/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(307);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {//! moment.js
	//! version : 2.11.1
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com
	
	;(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    global.moment = factory()
	}(this, function () { 'use strict';
	
	    var hookCallback;
	
	    function utils_hooks__hooks () {
	        return hookCallback.apply(null, arguments);
	    }
	
	    // This is done to register the method called with moment()
	    // without creating circular dependencies.
	    function setHookCallback (callback) {
	        hookCallback = callback;
	    }
	
	    function isArray(input) {
	        return Object.prototype.toString.call(input) === '[object Array]';
	    }
	
	    function isDate(input) {
	        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	    }
	
	    function map(arr, fn) {
	        var res = [], i;
	        for (i = 0; i < arr.length; ++i) {
	            res.push(fn(arr[i], i));
	        }
	        return res;
	    }
	
	    function hasOwnProp(a, b) {
	        return Object.prototype.hasOwnProperty.call(a, b);
	    }
	
	    function extend(a, b) {
	        for (var i in b) {
	            if (hasOwnProp(b, i)) {
	                a[i] = b[i];
	            }
	        }
	
	        if (hasOwnProp(b, 'toString')) {
	            a.toString = b.toString;
	        }
	
	        if (hasOwnProp(b, 'valueOf')) {
	            a.valueOf = b.valueOf;
	        }
	
	        return a;
	    }
	
	    function create_utc__createUTC (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, true).utc();
	    }
	
	    function defaultParsingFlags() {
	        // We need to deep clone this object.
	        return {
	            empty           : false,
	            unusedTokens    : [],
	            unusedInput     : [],
	            overflow        : -2,
	            charsLeftOver   : 0,
	            nullInput       : false,
	            invalidMonth    : null,
	            invalidFormat   : false,
	            userInvalidated : false,
	            iso             : false
	        };
	    }
	
	    function getParsingFlags(m) {
	        if (m._pf == null) {
	            m._pf = defaultParsingFlags();
	        }
	        return m._pf;
	    }
	
	    function valid__isValid(m) {
	        if (m._isValid == null) {
	            var flags = getParsingFlags(m);
	            m._isValid = !isNaN(m._d.getTime()) &&
	                flags.overflow < 0 &&
	                !flags.empty &&
	                !flags.invalidMonth &&
	                !flags.invalidWeekday &&
	                !flags.nullInput &&
	                !flags.invalidFormat &&
	                !flags.userInvalidated;
	
	            if (m._strict) {
	                m._isValid = m._isValid &&
	                    flags.charsLeftOver === 0 &&
	                    flags.unusedTokens.length === 0 &&
	                    flags.bigHour === undefined;
	            }
	        }
	        return m._isValid;
	    }
	
	    function valid__createInvalid (flags) {
	        var m = create_utc__createUTC(NaN);
	        if (flags != null) {
	            extend(getParsingFlags(m), flags);
	        }
	        else {
	            getParsingFlags(m).userInvalidated = true;
	        }
	
	        return m;
	    }
	
	    function isUndefined(input) {
	        return input === void 0;
	    }
	
	    // Plugins that add properties should also add the key here (null value),
	    // so we can properly clone ourselves.
	    var momentProperties = utils_hooks__hooks.momentProperties = [];
	
	    function copyConfig(to, from) {
	        var i, prop, val;
	
	        if (!isUndefined(from._isAMomentObject)) {
	            to._isAMomentObject = from._isAMomentObject;
	        }
	        if (!isUndefined(from._i)) {
	            to._i = from._i;
	        }
	        if (!isUndefined(from._f)) {
	            to._f = from._f;
	        }
	        if (!isUndefined(from._l)) {
	            to._l = from._l;
	        }
	        if (!isUndefined(from._strict)) {
	            to._strict = from._strict;
	        }
	        if (!isUndefined(from._tzm)) {
	            to._tzm = from._tzm;
	        }
	        if (!isUndefined(from._isUTC)) {
	            to._isUTC = from._isUTC;
	        }
	        if (!isUndefined(from._offset)) {
	            to._offset = from._offset;
	        }
	        if (!isUndefined(from._pf)) {
	            to._pf = getParsingFlags(from);
	        }
	        if (!isUndefined(from._locale)) {
	            to._locale = from._locale;
	        }
	
	        if (momentProperties.length > 0) {
	            for (i in momentProperties) {
	                prop = momentProperties[i];
	                val = from[prop];
	                if (!isUndefined(val)) {
	                    to[prop] = val;
	                }
	            }
	        }
	
	        return to;
	    }
	
	    var updateInProgress = false;
	
	    // Moment prototype object
	    function Moment(config) {
	        copyConfig(this, config);
	        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	        // Prevent infinite loop in case updateOffset creates new moment
	        // objects.
	        if (updateInProgress === false) {
	            updateInProgress = true;
	            utils_hooks__hooks.updateOffset(this);
	            updateInProgress = false;
	        }
	    }
	
	    function isMoment (obj) {
	        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
	    }
	
	    function absFloor (number) {
	        if (number < 0) {
	            return Math.ceil(number);
	        } else {
	            return Math.floor(number);
	        }
	    }
	
	    function toInt(argumentForCoercion) {
	        var coercedNumber = +argumentForCoercion,
	            value = 0;
	
	        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	            value = absFloor(coercedNumber);
	        }
	
	        return value;
	    }
	
	    // compare two arrays, return the number of differences
	    function compareArrays(array1, array2, dontConvert) {
	        var len = Math.min(array1.length, array2.length),
	            lengthDiff = Math.abs(array1.length - array2.length),
	            diffs = 0,
	            i;
	        for (i = 0; i < len; i++) {
	            if ((dontConvert && array1[i] !== array2[i]) ||
	                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	                diffs++;
	            }
	        }
	        return diffs + lengthDiff;
	    }
	
	    function Locale() {
	    }
	
	    // internal storage for locale config files
	    var locales = {};
	    var globalLocale;
	
	    function normalizeLocale(key) {
	        return key ? key.toLowerCase().replace('_', '-') : key;
	    }
	
	    // pick the locale from the array
	    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	    function chooseLocale(names) {
	        var i = 0, j, next, locale, split;
	
	        while (i < names.length) {
	            split = normalizeLocale(names[i]).split('-');
	            j = split.length;
	            next = normalizeLocale(names[i + 1]);
	            next = next ? next.split('-') : null;
	            while (j > 0) {
	                locale = loadLocale(split.slice(0, j).join('-'));
	                if (locale) {
	                    return locale;
	                }
	                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                    //the next array item is better than a shallower substring of this one
	                    break;
	                }
	                j--;
	            }
	            i++;
	        }
	        return null;
	    }
	
	    function loadLocale(name) {
	        var oldLocale = null;
	        // TODO: Find a better way to register and load all the locales in Node
	        if (!locales[name] && (typeof module !== 'undefined') &&
	                module && module.exports) {
	            try {
	                oldLocale = globalLocale._abbr;
	                __webpack_require__(330)("./" + name);
	                // because defineLocale currently also sets the global locale, we
	                // want to undo that for lazy loaded locales
	                locale_locales__getSetGlobalLocale(oldLocale);
	            } catch (e) { }
	        }
	        return locales[name];
	    }
	
	    // This function will load locale and then set the global locale.  If
	    // no arguments are passed in, it will simply return the current global
	    // locale key.
	    function locale_locales__getSetGlobalLocale (key, values) {
	        var data;
	        if (key) {
	            if (isUndefined(values)) {
	                data = locale_locales__getLocale(key);
	            }
	            else {
	                data = defineLocale(key, values);
	            }
	
	            if (data) {
	                // moment.duration._locale = moment._locale = data;
	                globalLocale = data;
	            }
	        }
	
	        return globalLocale._abbr;
	    }
	
	    function defineLocale (name, values) {
	        if (values !== null) {
	            values.abbr = name;
	            locales[name] = locales[name] || new Locale();
	            locales[name].set(values);
	
	            // backwards compat for now: also set the locale
	            locale_locales__getSetGlobalLocale(name);
	
	            return locales[name];
	        } else {
	            // useful for testing
	            delete locales[name];
	            return null;
	        }
	    }
	
	    // returns locale data
	    function locale_locales__getLocale (key) {
	        var locale;
	
	        if (key && key._locale && key._locale._abbr) {
	            key = key._locale._abbr;
	        }
	
	        if (!key) {
	            return globalLocale;
	        }
	
	        if (!isArray(key)) {
	            //short-circuit everything else
	            locale = loadLocale(key);
	            if (locale) {
	                return locale;
	            }
	            key = [key];
	        }
	
	        return chooseLocale(key);
	    }
	
	    var aliases = {};
	
	    function addUnitAlias (unit, shorthand) {
	        var lowerCase = unit.toLowerCase();
	        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	    }
	
	    function normalizeUnits(units) {
	        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	    }
	
	    function normalizeObjectUnits(inputObject) {
	        var normalizedInput = {},
	            normalizedProp,
	            prop;
	
	        for (prop in inputObject) {
	            if (hasOwnProp(inputObject, prop)) {
	                normalizedProp = normalizeUnits(prop);
	                if (normalizedProp) {
	                    normalizedInput[normalizedProp] = inputObject[prop];
	                }
	            }
	        }
	
	        return normalizedInput;
	    }
	
	    function isFunction(input) {
	        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	    }
	
	    function makeGetSet (unit, keepTime) {
	        return function (value) {
	            if (value != null) {
	                get_set__set(this, unit, value);
	                utils_hooks__hooks.updateOffset(this, keepTime);
	                return this;
	            } else {
	                return get_set__get(this, unit);
	            }
	        };
	    }
	
	    function get_set__get (mom, unit) {
	        return mom.isValid() ?
	            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
	    }
	
	    function get_set__set (mom, unit, value) {
	        if (mom.isValid()) {
	            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	        }
	    }
	
	    // MOMENTS
	
	    function getSet (units, value) {
	        var unit;
	        if (typeof units === 'object') {
	            for (unit in units) {
	                this.set(unit, units[unit]);
	            }
	        } else {
	            units = normalizeUnits(units);
	            if (isFunction(this[units])) {
	                return this[units](value);
	            }
	        }
	        return this;
	    }
	
	    function zeroFill(number, targetLength, forceSign) {
	        var absNumber = '' + Math.abs(number),
	            zerosToFill = targetLength - absNumber.length,
	            sign = number >= 0;
	        return (sign ? (forceSign ? '+' : '') : '-') +
	            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	    }
	
	    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
	
	    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
	
	    var formatFunctions = {};
	
	    var formatTokenFunctions = {};
	
	    // token:    'M'
	    // padded:   ['MM', 2]
	    // ordinal:  'Mo'
	    // callback: function () { this.month() + 1 }
	    function addFormatToken (token, padded, ordinal, callback) {
	        var func = callback;
	        if (typeof callback === 'string') {
	            func = function () {
	                return this[callback]();
	            };
	        }
	        if (token) {
	            formatTokenFunctions[token] = func;
	        }
	        if (padded) {
	            formatTokenFunctions[padded[0]] = function () {
	                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	            };
	        }
	        if (ordinal) {
	            formatTokenFunctions[ordinal] = function () {
	                return this.localeData().ordinal(func.apply(this, arguments), token);
	            };
	        }
	    }
	
	    function removeFormattingTokens(input) {
	        if (input.match(/\[[\s\S]/)) {
	            return input.replace(/^\[|\]$/g, '');
	        }
	        return input.replace(/\\/g, '');
	    }
	
	    function makeFormatFunction(format) {
	        var array = format.match(formattingTokens), i, length;
	
	        for (i = 0, length = array.length; i < length; i++) {
	            if (formatTokenFunctions[array[i]]) {
	                array[i] = formatTokenFunctions[array[i]];
	            } else {
	                array[i] = removeFormattingTokens(array[i]);
	            }
	        }
	
	        return function (mom) {
	            var output = '';
	            for (i = 0; i < length; i++) {
	                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
	            }
	            return output;
	        };
	    }
	
	    // format date using native date object
	    function formatMoment(m, format) {
	        if (!m.isValid()) {
	            return m.localeData().invalidDate();
	        }
	
	        format = expandFormat(format, m.localeData());
	        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
	
	        return formatFunctions[format](m);
	    }
	
	    function expandFormat(format, locale) {
	        var i = 5;
	
	        function replaceLongDateFormatTokens(input) {
	            return locale.longDateFormat(input) || input;
	        }
	
	        localFormattingTokens.lastIndex = 0;
	        while (i >= 0 && localFormattingTokens.test(format)) {
	            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	            localFormattingTokens.lastIndex = 0;
	            i -= 1;
	        }
	
	        return format;
	    }
	
	    var match1         = /\d/;            //       0 - 9
	    var match2         = /\d\d/;          //      00 - 99
	    var match3         = /\d{3}/;         //     000 - 999
	    var match4         = /\d{4}/;         //    0000 - 9999
	    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
	    var match1to2      = /\d\d?/;         //       0 - 99
	    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
	    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
	    var match1to3      = /\d{1,3}/;       //       0 - 999
	    var match1to4      = /\d{1,4}/;       //       0 - 9999
	    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999
	
	    var matchUnsigned  = /\d+/;           //       0 - inf
	    var matchSigned    = /[+-]?\d+/;      //    -inf - inf
	
	    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
	    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z
	
	    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
	
	    // any word (or two) characters or numbers including two/three word month in arabic.
	    // includes scottish gaelic two word and hyphenated months
	    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
	
	
	    var regexes = {};
	
	    function addRegexToken (token, regex, strictRegex) {
	        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
	            return (isStrict && strictRegex) ? strictRegex : regex;
	        };
	    }
	
	    function getParseRegexForToken (token, config) {
	        if (!hasOwnProp(regexes, token)) {
	            return new RegExp(unescapeFormat(token));
	        }
	
	        return regexes[token](config._strict, config._locale);
	    }
	
	    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	    function unescapeFormat(s) {
	        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	            return p1 || p2 || p3 || p4;
	        }));
	    }
	
	    function regexEscape(s) {
	        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }
	
	    var tokens = {};
	
	    function addParseToken (token, callback) {
	        var i, func = callback;
	        if (typeof token === 'string') {
	            token = [token];
	        }
	        if (typeof callback === 'number') {
	            func = function (input, array) {
	                array[callback] = toInt(input);
	            };
	        }
	        for (i = 0; i < token.length; i++) {
	            tokens[token[i]] = func;
	        }
	    }
	
	    function addWeekParseToken (token, callback) {
	        addParseToken(token, function (input, array, config, token) {
	            config._w = config._w || {};
	            callback(input, config._w, config, token);
	        });
	    }
	
	    function addTimeToArrayFromToken(token, input, config) {
	        if (input != null && hasOwnProp(tokens, token)) {
	            tokens[token](input, config._a, config, token);
	        }
	    }
	
	    var YEAR = 0;
	    var MONTH = 1;
	    var DATE = 2;
	    var HOUR = 3;
	    var MINUTE = 4;
	    var SECOND = 5;
	    var MILLISECOND = 6;
	    var WEEK = 7;
	    var WEEKDAY = 8;
	
	    function daysInMonth(year, month) {
	        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	    }
	
	    // FORMATTING
	
	    addFormatToken('M', ['MM', 2], 'Mo', function () {
	        return this.month() + 1;
	    });
	
	    addFormatToken('MMM', 0, 0, function (format) {
	        return this.localeData().monthsShort(this, format);
	    });
	
	    addFormatToken('MMMM', 0, 0, function (format) {
	        return this.localeData().months(this, format);
	    });
	
	    // ALIASES
	
	    addUnitAlias('month', 'M');
	
	    // PARSING
	
	    addRegexToken('M',    match1to2);
	    addRegexToken('MM',   match1to2, match2);
	    addRegexToken('MMM',  function (isStrict, locale) {
	        return locale.monthsShortRegex(isStrict);
	    });
	    addRegexToken('MMMM', function (isStrict, locale) {
	        return locale.monthsRegex(isStrict);
	    });
	
	    addParseToken(['M', 'MM'], function (input, array) {
	        array[MONTH] = toInt(input) - 1;
	    });
	
	    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	        var month = config._locale.monthsParse(input, token, config._strict);
	        // if we didn't find a month name, mark the date as invalid.
	        if (month != null) {
	            array[MONTH] = month;
	        } else {
	            getParsingFlags(config).invalidMonth = input;
	        }
	    });
	
	    // LOCALES
	
	    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
	    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
	    function localeMonths (m, format) {
	        return isArray(this._months) ? this._months[m.month()] :
	            this._months[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	    }
	
	    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
	    function localeMonthsShort (m, format) {
	        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
	            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	    }
	
	    function localeMonthsParse (monthName, format, strict) {
	        var i, mom, regex;
	
	        if (!this._monthsParse) {
	            this._monthsParse = [];
	            this._longMonthsParse = [];
	            this._shortMonthsParse = [];
	        }
	
	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = create_utc__createUTC([2000, i]);
	            if (strict && !this._longMonthsParse[i]) {
	                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	            }
	            if (!strict && !this._monthsParse[i]) {
	                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (!strict && this._monthsParse[i].test(monthName)) {
	                return i;
	            }
	        }
	    }
	
	    // MOMENTS
	
	    function setMonth (mom, value) {
	        var dayOfMonth;
	
	        if (!mom.isValid()) {
	            // No op
	            return mom;
	        }
	
	        // TODO: Move this out of here!
	        if (typeof value === 'string') {
	            value = mom.localeData().monthsParse(value);
	            // TODO: Another silent failure?
	            if (typeof value !== 'number') {
	                return mom;
	            }
	        }
	
	        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	        return mom;
	    }
	
	    function getSetMonth (value) {
	        if (value != null) {
	            setMonth(this, value);
	            utils_hooks__hooks.updateOffset(this, true);
	            return this;
	        } else {
	            return get_set__get(this, 'Month');
	        }
	    }
	
	    function getDaysInMonth () {
	        return daysInMonth(this.year(), this.month());
	    }
	
	    var defaultMonthsShortRegex = matchWord;
	    function monthsShortRegex (isStrict) {
	        if (this._monthsParseExact) {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                computeMonthsParse.call(this);
	            }
	            if (isStrict) {
	                return this._monthsShortStrictRegex;
	            } else {
	                return this._monthsShortRegex;
	            }
	        } else {
	            return this._monthsShortStrictRegex && isStrict ?
	                this._monthsShortStrictRegex : this._monthsShortRegex;
	        }
	    }
	
	    var defaultMonthsRegex = matchWord;
	    function monthsRegex (isStrict) {
	        if (this._monthsParseExact) {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                computeMonthsParse.call(this);
	            }
	            if (isStrict) {
	                return this._monthsStrictRegex;
	            } else {
	                return this._monthsRegex;
	            }
	        } else {
	            return this._monthsStrictRegex && isStrict ?
	                this._monthsStrictRegex : this._monthsRegex;
	        }
	    }
	
	    function computeMonthsParse () {
	        function cmpLenRev(a, b) {
	            return b.length - a.length;
	        }
	
	        var shortPieces = [], longPieces = [], mixedPieces = [],
	            i, mom;
	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = create_utc__createUTC([2000, i]);
	            shortPieces.push(this.monthsShort(mom, ''));
	            longPieces.push(this.months(mom, ''));
	            mixedPieces.push(this.months(mom, ''));
	            mixedPieces.push(this.monthsShort(mom, ''));
	        }
	        // Sorting makes sure if one month (or abbr) is a prefix of another it
	        // will match the longer piece.
	        shortPieces.sort(cmpLenRev);
	        longPieces.sort(cmpLenRev);
	        mixedPieces.sort(cmpLenRev);
	        for (i = 0; i < 12; i++) {
	            shortPieces[i] = regexEscape(shortPieces[i]);
	            longPieces[i] = regexEscape(longPieces[i]);
	            mixedPieces[i] = regexEscape(mixedPieces[i]);
	        }
	
	        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	        this._monthsShortRegex = this._monthsRegex;
	        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')$', 'i');
	        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')$', 'i');
	    }
	
	    function checkOverflow (m) {
	        var overflow;
	        var a = m._a;
	
	        if (a && getParsingFlags(m).overflow === -2) {
	            overflow =
	                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
	                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
	                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
	                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
	                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
	                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
	                -1;
	
	            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	                overflow = DATE;
	            }
	            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
	                overflow = WEEK;
	            }
	            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
	                overflow = WEEKDAY;
	            }
	
	            getParsingFlags(m).overflow = overflow;
	        }
	
	        return m;
	    }
	
	    function warn(msg) {
	        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
	                (typeof console !==  'undefined') && console.warn) {
	            console.warn('Deprecation warning: ' + msg);
	        }
	    }
	
	    function deprecate(msg, fn) {
	        var firstTime = true;
	
	        return extend(function () {
	            if (firstTime) {
	                warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
	                firstTime = false;
	            }
	            return fn.apply(this, arguments);
	        }, fn);
	    }
	
	    var deprecations = {};
	
	    function deprecateSimple(name, msg) {
	        if (!deprecations[name]) {
	            warn(msg);
	            deprecations[name] = true;
	        }
	    }
	
	    utils_hooks__hooks.suppressDeprecationWarnings = false;
	
	    // iso 8601 regex
	    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
	    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
	
	    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
	
	    var isoDates = [
	        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
	        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
	        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
	        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
	        ['YYYY-DDD', /\d{4}-\d{3}/],
	        ['YYYY-MM', /\d{4}-\d\d/, false],
	        ['YYYYYYMMDD', /[+-]\d{10}/],
	        ['YYYYMMDD', /\d{8}/],
	        // YYYYMM is NOT allowed by the standard
	        ['GGGG[W]WWE', /\d{4}W\d{3}/],
	        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
	        ['YYYYDDD', /\d{7}/]
	    ];
	
	    // iso time formats and regexes
	    var isoTimes = [
	        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
	        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
	        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
	        ['HH:mm', /\d\d:\d\d/],
	        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
	        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
	        ['HHmmss', /\d\d\d\d\d\d/],
	        ['HHmm', /\d\d\d\d/],
	        ['HH', /\d\d/]
	    ];
	
	    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
	
	    // date from iso format
	    function configFromISO(config) {
	        var i, l,
	            string = config._i,
	            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	            allowTime, dateFormat, timeFormat, tzFormat;
	
	        if (match) {
	            getParsingFlags(config).iso = true;
	
	            for (i = 0, l = isoDates.length; i < l; i++) {
	                if (isoDates[i][1].exec(match[1])) {
	                    dateFormat = isoDates[i][0];
	                    allowTime = isoDates[i][2] !== false;
	                    break;
	                }
	            }
	            if (dateFormat == null) {
	                config._isValid = false;
	                return;
	            }
	            if (match[3]) {
	                for (i = 0, l = isoTimes.length; i < l; i++) {
	                    if (isoTimes[i][1].exec(match[3])) {
	                        // match[2] should be 'T' or space
	                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
	                        break;
	                    }
	                }
	                if (timeFormat == null) {
	                    config._isValid = false;
	                    return;
	                }
	            }
	            if (!allowTime && timeFormat != null) {
	                config._isValid = false;
	                return;
	            }
	            if (match[4]) {
	                if (tzRegex.exec(match[4])) {
	                    tzFormat = 'Z';
	                } else {
	                    config._isValid = false;
	                    return;
	                }
	            }
	            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
	            configFromStringAndFormat(config);
	        } else {
	            config._isValid = false;
	        }
	    }
	
	    // date from iso format or fallback
	    function configFromString(config) {
	        var matched = aspNetJsonRegex.exec(config._i);
	
	        if (matched !== null) {
	            config._d = new Date(+matched[1]);
	            return;
	        }
	
	        configFromISO(config);
	        if (config._isValid === false) {
	            delete config._isValid;
	            utils_hooks__hooks.createFromInputFallback(config);
	        }
	    }
	
	    utils_hooks__hooks.createFromInputFallback = deprecate(
	        'moment construction falls back to js Date. This is ' +
	        'discouraged and will be removed in upcoming major ' +
	        'release. Please refer to ' +
	        'https://github.com/moment/moment/issues/1407 for more info.',
	        function (config) {
	            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	        }
	    );
	
	    function createDate (y, m, d, h, M, s, ms) {
	        //can't just apply() to create a date:
	        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
	        var date = new Date(y, m, d, h, M, s, ms);
	
	        //the date constructor remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
	            date.setFullYear(y);
	        }
	        return date;
	    }
	
	    function createUTCDate (y) {
	        var date = new Date(Date.UTC.apply(null, arguments));
	
	        //the Date.UTC function remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
	            date.setUTCFullYear(y);
	        }
	        return date;
	    }
	
	    // FORMATTING
	
	    addFormatToken('Y', 0, 0, function () {
	        var y = this.year();
	        return y <= 9999 ? '' + y : '+' + y;
	    });
	
	    addFormatToken(0, ['YY', 2], 0, function () {
	        return this.year() % 100;
	    });
	
	    addFormatToken(0, ['YYYY',   4],       0, 'year');
	    addFormatToken(0, ['YYYYY',  5],       0, 'year');
	    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
	
	    // ALIASES
	
	    addUnitAlias('year', 'y');
	
	    // PARSING
	
	    addRegexToken('Y',      matchSigned);
	    addRegexToken('YY',     match1to2, match2);
	    addRegexToken('YYYY',   match1to4, match4);
	    addRegexToken('YYYYY',  match1to6, match6);
	    addRegexToken('YYYYYY', match1to6, match6);
	
	    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	    addParseToken('YYYY', function (input, array) {
	        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
	    });
	    addParseToken('YY', function (input, array) {
	        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
	    });
	    addParseToken('Y', function (input, array) {
	        array[YEAR] = parseInt(input, 10);
	    });
	
	    // HELPERS
	
	    function daysInYear(year) {
	        return isLeapYear(year) ? 366 : 365;
	    }
	
	    function isLeapYear(year) {
	        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	    }
	
	    // HOOKS
	
	    utils_hooks__hooks.parseTwoDigitYear = function (input) {
	        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	    };
	
	    // MOMENTS
	
	    var getSetYear = makeGetSet('FullYear', false);
	
	    function getIsLeapYear () {
	        return isLeapYear(this.year());
	    }
	
	    // start-of-first-week - start-of-year
	    function firstWeekOffset(year, dow, doy) {
	        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	            fwd = 7 + dow - doy,
	            // first-week day local weekday -- which local weekday is fwd
	            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
	
	        return -fwdlw + fwd - 1;
	    }
	
	    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	        var localWeekday = (7 + weekday - dow) % 7,
	            weekOffset = firstWeekOffset(year, dow, doy),
	            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
	            resYear, resDayOfYear;
	
	        if (dayOfYear <= 0) {
	            resYear = year - 1;
	            resDayOfYear = daysInYear(resYear) + dayOfYear;
	        } else if (dayOfYear > daysInYear(year)) {
	            resYear = year + 1;
	            resDayOfYear = dayOfYear - daysInYear(year);
	        } else {
	            resYear = year;
	            resDayOfYear = dayOfYear;
	        }
	
	        return {
	            year: resYear,
	            dayOfYear: resDayOfYear
	        };
	    }
	
	    function weekOfYear(mom, dow, doy) {
	        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
	            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	            resWeek, resYear;
	
	        if (week < 1) {
	            resYear = mom.year() - 1;
	            resWeek = week + weeksInYear(resYear, dow, doy);
	        } else if (week > weeksInYear(mom.year(), dow, doy)) {
	            resWeek = week - weeksInYear(mom.year(), dow, doy);
	            resYear = mom.year() + 1;
	        } else {
	            resYear = mom.year();
	            resWeek = week;
	        }
	
	        return {
	            week: resWeek,
	            year: resYear
	        };
	    }
	
	    function weeksInYear(year, dow, doy) {
	        var weekOffset = firstWeekOffset(year, dow, doy),
	            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
	        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	    }
	
	    // Pick the first defined of two or three arguments.
	    function defaults(a, b, c) {
	        if (a != null) {
	            return a;
	        }
	        if (b != null) {
	            return b;
	        }
	        return c;
	    }
	
	    function currentDateArray(config) {
	        // hooks is actually the exported moment object
	        var nowValue = new Date(utils_hooks__hooks.now());
	        if (config._useUTC) {
	            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
	        }
	        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	    }
	
	    // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]
	    function configFromArray (config) {
	        var i, date, input = [], currentDate, yearToUse;
	
	        if (config._d) {
	            return;
	        }
	
	        currentDate = currentDateArray(config);
	
	        //compute day of the year from weeks and weekdays
	        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	            dayOfYearFromWeekInfo(config);
	        }
	
	        //if the day of the year is set, figure out what it is
	        if (config._dayOfYear) {
	            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
	
	            if (config._dayOfYear > daysInYear(yearToUse)) {
	                getParsingFlags(config)._overflowDayOfYear = true;
	            }
	
	            date = createUTCDate(yearToUse, 0, config._dayOfYear);
	            config._a[MONTH] = date.getUTCMonth();
	            config._a[DATE] = date.getUTCDate();
	        }
	
	        // Default to current date.
	        // * if no year, month, day of month are given, default to today
	        // * if day of month is given, default month and year
	        // * if month is given, default only year
	        // * if year is given, don't default anything
	        for (i = 0; i < 3 && config._a[i] == null; ++i) {
	            config._a[i] = input[i] = currentDate[i];
	        }
	
	        // Zero out whatever was not defaulted, including time
	        for (; i < 7; i++) {
	            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	        }
	
	        // Check for 24:00:00.000
	        if (config._a[HOUR] === 24 &&
	                config._a[MINUTE] === 0 &&
	                config._a[SECOND] === 0 &&
	                config._a[MILLISECOND] === 0) {
	            config._nextDay = true;
	            config._a[HOUR] = 0;
	        }
	
	        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	        // Apply timezone offset from input. The actual utcOffset can be changed
	        // with parseZone.
	        if (config._tzm != null) {
	            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	        }
	
	        if (config._nextDay) {
	            config._a[HOUR] = 24;
	        }
	    }
	
	    function dayOfYearFromWeekInfo(config) {
	        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
	
	        w = config._w;
	        if (w.GG != null || w.W != null || w.E != null) {
	            dow = 1;
	            doy = 4;
	
	            // TODO: We need to take the current isoWeekYear, but that depends on
	            // how we interpret now (local, utc, fixed offset). So create
	            // a now version of current config (take local/utc/offset flags, and
	            // create now).
	            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
	            week = defaults(w.W, 1);
	            weekday = defaults(w.E, 1);
	            if (weekday < 1 || weekday > 7) {
	                weekdayOverflow = true;
	            }
	        } else {
	            dow = config._locale._week.dow;
	            doy = config._locale._week.doy;
	
	            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
	            week = defaults(w.w, 1);
	
	            if (w.d != null) {
	                // weekday -- low day numbers are considered next week
	                weekday = w.d;
	                if (weekday < 0 || weekday > 6) {
	                    weekdayOverflow = true;
	                }
	            } else if (w.e != null) {
	                // local weekday -- counting starts from begining of week
	                weekday = w.e + dow;
	                if (w.e < 0 || w.e > 6) {
	                    weekdayOverflow = true;
	                }
	            } else {
	                // default to begining of week
	                weekday = dow;
	            }
	        }
	        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
	            getParsingFlags(config)._overflowWeeks = true;
	        } else if (weekdayOverflow != null) {
	            getParsingFlags(config)._overflowWeekday = true;
	        } else {
	            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	            config._a[YEAR] = temp.year;
	            config._dayOfYear = temp.dayOfYear;
	        }
	    }
	
	    // constant that refers to the ISO standard
	    utils_hooks__hooks.ISO_8601 = function () {};
	
	    // date from string and format string
	    function configFromStringAndFormat(config) {
	        // TODO: Move this to another part of the creation flow to prevent circular deps
	        if (config._f === utils_hooks__hooks.ISO_8601) {
	            configFromISO(config);
	            return;
	        }
	
	        config._a = [];
	        getParsingFlags(config).empty = true;
	
	        // This array is used to make a Date, either with `new Date` or `Date.UTC`
	        var string = '' + config._i,
	            i, parsedInput, tokens, token, skipped,
	            stringLength = string.length,
	            totalParsedInputLength = 0;
	
	        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
	
	        for (i = 0; i < tokens.length; i++) {
	            token = tokens[i];
	            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	            // console.log('token', token, 'parsedInput', parsedInput,
	            //         'regex', getParseRegexForToken(token, config));
	            if (parsedInput) {
	                skipped = string.substr(0, string.indexOf(parsedInput));
	                if (skipped.length > 0) {
	                    getParsingFlags(config).unusedInput.push(skipped);
	                }
	                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	                totalParsedInputLength += parsedInput.length;
	            }
	            // don't parse if it's not a known token
	            if (formatTokenFunctions[token]) {
	                if (parsedInput) {
	                    getParsingFlags(config).empty = false;
	                }
	                else {
	                    getParsingFlags(config).unusedTokens.push(token);
	                }
	                addTimeToArrayFromToken(token, parsedInput, config);
	            }
	            else if (config._strict && !parsedInput) {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	        }
	
	        // add remaining unparsed input length to the string
	        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
	        if (string.length > 0) {
	            getParsingFlags(config).unusedInput.push(string);
	        }
	
	        // clear _12h flag if hour is <= 12
	        if (getParsingFlags(config).bigHour === true &&
	                config._a[HOUR] <= 12 &&
	                config._a[HOUR] > 0) {
	            getParsingFlags(config).bigHour = undefined;
	        }
	        // handle meridiem
	        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
	
	        configFromArray(config);
	        checkOverflow(config);
	    }
	
	
	    function meridiemFixWrap (locale, hour, meridiem) {
	        var isPm;
	
	        if (meridiem == null) {
	            // nothing to do
	            return hour;
	        }
	        if (locale.meridiemHour != null) {
	            return locale.meridiemHour(hour, meridiem);
	        } else if (locale.isPM != null) {
	            // Fallback
	            isPm = locale.isPM(meridiem);
	            if (isPm && hour < 12) {
	                hour += 12;
	            }
	            if (!isPm && hour === 12) {
	                hour = 0;
	            }
	            return hour;
	        } else {
	            // this is not supposed to happen
	            return hour;
	        }
	    }
	
	    // date from string and array of format strings
	    function configFromStringAndArray(config) {
	        var tempConfig,
	            bestMoment,
	
	            scoreToBeat,
	            i,
	            currentScore;
	
	        if (config._f.length === 0) {
	            getParsingFlags(config).invalidFormat = true;
	            config._d = new Date(NaN);
	            return;
	        }
	
	        for (i = 0; i < config._f.length; i++) {
	            currentScore = 0;
	            tempConfig = copyConfig({}, config);
	            if (config._useUTC != null) {
	                tempConfig._useUTC = config._useUTC;
	            }
	            tempConfig._f = config._f[i];
	            configFromStringAndFormat(tempConfig);
	
	            if (!valid__isValid(tempConfig)) {
	                continue;
	            }
	
	            // if there is any input that was not parsed add a penalty for that format
	            currentScore += getParsingFlags(tempConfig).charsLeftOver;
	
	            //or tokens
	            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
	
	            getParsingFlags(tempConfig).score = currentScore;
	
	            if (scoreToBeat == null || currentScore < scoreToBeat) {
	                scoreToBeat = currentScore;
	                bestMoment = tempConfig;
	            }
	        }
	
	        extend(config, bestMoment || tempConfig);
	    }
	
	    function configFromObject(config) {
	        if (config._d) {
	            return;
	        }
	
	        var i = normalizeObjectUnits(config._i);
	        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
	            return obj && parseInt(obj, 10);
	        });
	
	        configFromArray(config);
	    }
	
	    function createFromConfig (config) {
	        var res = new Moment(checkOverflow(prepareConfig(config)));
	        if (res._nextDay) {
	            // Adding is smart enough around DST
	            res.add(1, 'd');
	            res._nextDay = undefined;
	        }
	
	        return res;
	    }
	
	    function prepareConfig (config) {
	        var input = config._i,
	            format = config._f;
	
	        config._locale = config._locale || locale_locales__getLocale(config._l);
	
	        if (input === null || (format === undefined && input === '')) {
	            return valid__createInvalid({nullInput: true});
	        }
	
	        if (typeof input === 'string') {
	            config._i = input = config._locale.preparse(input);
	        }
	
	        if (isMoment(input)) {
	            return new Moment(checkOverflow(input));
	        } else if (isArray(format)) {
	            configFromStringAndArray(config);
	        } else if (format) {
	            configFromStringAndFormat(config);
	        } else if (isDate(input)) {
	            config._d = input;
	        } else {
	            configFromInput(config);
	        }
	
	        if (!valid__isValid(config)) {
	            config._d = null;
	        }
	
	        return config;
	    }
	
	    function configFromInput(config) {
	        var input = config._i;
	        if (input === undefined) {
	            config._d = new Date(utils_hooks__hooks.now());
	        } else if (isDate(input)) {
	            config._d = new Date(+input);
	        } else if (typeof input === 'string') {
	            configFromString(config);
	        } else if (isArray(input)) {
	            config._a = map(input.slice(0), function (obj) {
	                return parseInt(obj, 10);
	            });
	            configFromArray(config);
	        } else if (typeof(input) === 'object') {
	            configFromObject(config);
	        } else if (typeof(input) === 'number') {
	            // from milliseconds
	            config._d = new Date(input);
	        } else {
	            utils_hooks__hooks.createFromInputFallback(config);
	        }
	    }
	
	    function createLocalOrUTC (input, format, locale, strict, isUTC) {
	        var c = {};
	
	        if (typeof(locale) === 'boolean') {
	            strict = locale;
	            locale = undefined;
	        }
	        // object construction must be done this way.
	        // https://github.com/moment/moment/issues/1423
	        c._isAMomentObject = true;
	        c._useUTC = c._isUTC = isUTC;
	        c._l = locale;
	        c._i = input;
	        c._f = format;
	        c._strict = strict;
	
	        return createFromConfig(c);
	    }
	
	    function local__createLocal (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, false);
	    }
	
	    var prototypeMin = deprecate(
	         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
	         function () {
	             var other = local__createLocal.apply(null, arguments);
	             if (this.isValid() && other.isValid()) {
	                 return other < this ? this : other;
	             } else {
	                 return valid__createInvalid();
	             }
	         }
	     );
	
	    var prototypeMax = deprecate(
	        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
	        function () {
	            var other = local__createLocal.apply(null, arguments);
	            if (this.isValid() && other.isValid()) {
	                return other > this ? this : other;
	            } else {
	                return valid__createInvalid();
	            }
	        }
	    );
	
	    // Pick a moment m from moments so that m[fn](other) is true for all
	    // other. This relies on the function fn to be transitive.
	    //
	    // moments should either be an array of moment objects or an array, whose
	    // first element is an array of moment objects.
	    function pickBy(fn, moments) {
	        var res, i;
	        if (moments.length === 1 && isArray(moments[0])) {
	            moments = moments[0];
	        }
	        if (!moments.length) {
	            return local__createLocal();
	        }
	        res = moments[0];
	        for (i = 1; i < moments.length; ++i) {
	            if (!moments[i].isValid() || moments[i][fn](res)) {
	                res = moments[i];
	            }
	        }
	        return res;
	    }
	
	    // TODO: Use [].sort instead?
	    function min () {
	        var args = [].slice.call(arguments, 0);
	
	        return pickBy('isBefore', args);
	    }
	
	    function max () {
	        var args = [].slice.call(arguments, 0);
	
	        return pickBy('isAfter', args);
	    }
	
	    var now = function () {
	        return Date.now ? Date.now() : +(new Date());
	    };
	
	    function Duration (duration) {
	        var normalizedInput = normalizeObjectUnits(duration),
	            years = normalizedInput.year || 0,
	            quarters = normalizedInput.quarter || 0,
	            months = normalizedInput.month || 0,
	            weeks = normalizedInput.week || 0,
	            days = normalizedInput.day || 0,
	            hours = normalizedInput.hour || 0,
	            minutes = normalizedInput.minute || 0,
	            seconds = normalizedInput.second || 0,
	            milliseconds = normalizedInput.millisecond || 0;
	
	        // representation for dateAddRemove
	        this._milliseconds = +milliseconds +
	            seconds * 1e3 + // 1000
	            minutes * 6e4 + // 1000 * 60
	            hours * 36e5; // 1000 * 60 * 60
	        // Because of dateAddRemove treats 24 hours as different from a
	        // day when working around DST, we need to store them separately
	        this._days = +days +
	            weeks * 7;
	        // It is impossible translate months into days without knowing
	        // which months you are are talking about, so we have to store
	        // it separately.
	        this._months = +months +
	            quarters * 3 +
	            years * 12;
	
	        this._data = {};
	
	        this._locale = locale_locales__getLocale();
	
	        this._bubble();
	    }
	
	    function isDuration (obj) {
	        return obj instanceof Duration;
	    }
	
	    // FORMATTING
	
	    function offset (token, separator) {
	        addFormatToken(token, 0, 0, function () {
	            var offset = this.utcOffset();
	            var sign = '+';
	            if (offset < 0) {
	                offset = -offset;
	                sign = '-';
	            }
	            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
	        });
	    }
	
	    offset('Z', ':');
	    offset('ZZ', '');
	
	    // PARSING
	
	    addRegexToken('Z',  matchShortOffset);
	    addRegexToken('ZZ', matchShortOffset);
	    addParseToken(['Z', 'ZZ'], function (input, array, config) {
	        config._useUTC = true;
	        config._tzm = offsetFromString(matchShortOffset, input);
	    });
	
	    // HELPERS
	
	    // timezone chunker
	    // '+10:00' > ['10',  '00']
	    // '-1530'  > ['-15', '30']
	    var chunkOffset = /([\+\-]|\d\d)/gi;
	
	    function offsetFromString(matcher, string) {
	        var matches = ((string || '').match(matcher) || []);
	        var chunk   = matches[matches.length - 1] || [];
	        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	        var minutes = +(parts[1] * 60) + toInt(parts[2]);
	
	        return parts[0] === '+' ? minutes : -minutes;
	    }
	
	    // Return a moment from input, that is local/utc/zone equivalent to model.
	    function cloneWithOffset(input, model) {
	        var res, diff;
	        if (model._isUTC) {
	            res = model.clone();
	            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
	            // Use low-level api, because this fn is low-level api.
	            res._d.setTime(+res._d + diff);
	            utils_hooks__hooks.updateOffset(res, false);
	            return res;
	        } else {
	            return local__createLocal(input).local();
	        }
	    }
	
	    function getDateOffset (m) {
	        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	        // https://github.com/moment/moment/pull/1871
	        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	    }
	
	    // HOOKS
	
	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.
	    utils_hooks__hooks.updateOffset = function () {};
	
	    // MOMENTS
	
	    // keepLocalTime = true means only change the timezone, without
	    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	    // +0200, so we adjust the time as needed, to be valid.
	    //
	    // Keeping the time actually adds/subtracts (one hour)
	    // from the actual represented time. That is why we call updateOffset
	    // a second time. In case it wants us to change the offset again
	    // _changeInProgress == true case, then we have to adjust, because
	    // there is no such time in the given timezone.
	    function getSetOffset (input, keepLocalTime) {
	        var offset = this._offset || 0,
	            localAdjust;
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        if (input != null) {
	            if (typeof input === 'string') {
	                input = offsetFromString(matchShortOffset, input);
	            } else if (Math.abs(input) < 16) {
	                input = input * 60;
	            }
	            if (!this._isUTC && keepLocalTime) {
	                localAdjust = getDateOffset(this);
	            }
	            this._offset = input;
	            this._isUTC = true;
	            if (localAdjust != null) {
	                this.add(localAdjust, 'm');
	            }
	            if (offset !== input) {
	                if (!keepLocalTime || this._changeInProgress) {
	                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
	                } else if (!this._changeInProgress) {
	                    this._changeInProgress = true;
	                    utils_hooks__hooks.updateOffset(this, true);
	                    this._changeInProgress = null;
	                }
	            }
	            return this;
	        } else {
	            return this._isUTC ? offset : getDateOffset(this);
	        }
	    }
	
	    function getSetZone (input, keepLocalTime) {
	        if (input != null) {
	            if (typeof input !== 'string') {
	                input = -input;
	            }
	
	            this.utcOffset(input, keepLocalTime);
	
	            return this;
	        } else {
	            return -this.utcOffset();
	        }
	    }
	
	    function setOffsetToUTC (keepLocalTime) {
	        return this.utcOffset(0, keepLocalTime);
	    }
	
	    function setOffsetToLocal (keepLocalTime) {
	        if (this._isUTC) {
	            this.utcOffset(0, keepLocalTime);
	            this._isUTC = false;
	
	            if (keepLocalTime) {
	                this.subtract(getDateOffset(this), 'm');
	            }
	        }
	        return this;
	    }
	
	    function setOffsetToParsedOffset () {
	        if (this._tzm) {
	            this.utcOffset(this._tzm);
	        } else if (typeof this._i === 'string') {
	            this.utcOffset(offsetFromString(matchOffset, this._i));
	        }
	        return this;
	    }
	
	    function hasAlignedHourOffset (input) {
	        if (!this.isValid()) {
	            return false;
	        }
	        input = input ? local__createLocal(input).utcOffset() : 0;
	
	        return (this.utcOffset() - input) % 60 === 0;
	    }
	
	    function isDaylightSavingTime () {
	        return (
	            this.utcOffset() > this.clone().month(0).utcOffset() ||
	            this.utcOffset() > this.clone().month(5).utcOffset()
	        );
	    }
	
	    function isDaylightSavingTimeShifted () {
	        if (!isUndefined(this._isDSTShifted)) {
	            return this._isDSTShifted;
	        }
	
	        var c = {};
	
	        copyConfig(c, this);
	        c = prepareConfig(c);
	
	        if (c._a) {
	            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
	            this._isDSTShifted = this.isValid() &&
	                compareArrays(c._a, other.toArray()) > 0;
	        } else {
	            this._isDSTShifted = false;
	        }
	
	        return this._isDSTShifted;
	    }
	
	    function isLocal () {
	        return this.isValid() ? !this._isUTC : false;
	    }
	
	    function isUtcOffset () {
	        return this.isValid() ? this._isUTC : false;
	    }
	
	    function isUtc () {
	        return this.isValid() ? this._isUTC && this._offset === 0 : false;
	    }
	
	    // ASP.NET json date format regex
	    var aspNetRegex = /(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;
	
	    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	    var isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;
	
	    function create__createDuration (input, key) {
	        var duration = input,
	            // matching against regexp is expensive, do it on demand
	            match = null,
	            sign,
	            ret,
	            diffRes;
	
	        if (isDuration(input)) {
	            duration = {
	                ms : input._milliseconds,
	                d  : input._days,
	                M  : input._months
	            };
	        } else if (typeof input === 'number') {
	            duration = {};
	            if (key) {
	                duration[key] = input;
	            } else {
	                duration.milliseconds = input;
	            }
	        } else if (!!(match = aspNetRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y  : 0,
	                d  : toInt(match[DATE])        * sign,
	                h  : toInt(match[HOUR])        * sign,
	                m  : toInt(match[MINUTE])      * sign,
	                s  : toInt(match[SECOND])      * sign,
	                ms : toInt(match[MILLISECOND]) * sign
	            };
	        } else if (!!(match = isoRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y : parseIso(match[2], sign),
	                M : parseIso(match[3], sign),
	                d : parseIso(match[4], sign),
	                h : parseIso(match[5], sign),
	                m : parseIso(match[6], sign),
	                s : parseIso(match[7], sign),
	                w : parseIso(match[8], sign)
	            };
	        } else if (duration == null) {// checks for null or undefined
	            duration = {};
	        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
	            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
	
	            duration = {};
	            duration.ms = diffRes.milliseconds;
	            duration.M = diffRes.months;
	        }
	
	        ret = new Duration(duration);
	
	        if (isDuration(input) && hasOwnProp(input, '_locale')) {
	            ret._locale = input._locale;
	        }
	
	        return ret;
	    }
	
	    create__createDuration.fn = Duration.prototype;
	
	    function parseIso (inp, sign) {
	        // We'd normally use ~~inp for this, but unfortunately it also
	        // converts floats to ints.
	        // inp may be undefined, so careful calling replace on it.
	        var res = inp && parseFloat(inp.replace(',', '.'));
	        // apply sign while we're at it
	        return (isNaN(res) ? 0 : res) * sign;
	    }
	
	    function positiveMomentsDifference(base, other) {
	        var res = {milliseconds: 0, months: 0};
	
	        res.months = other.month() - base.month() +
	            (other.year() - base.year()) * 12;
	        if (base.clone().add(res.months, 'M').isAfter(other)) {
	            --res.months;
	        }
	
	        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
	
	        return res;
	    }
	
	    function momentsDifference(base, other) {
	        var res;
	        if (!(base.isValid() && other.isValid())) {
	            return {milliseconds: 0, months: 0};
	        }
	
	        other = cloneWithOffset(other, base);
	        if (base.isBefore(other)) {
	            res = positiveMomentsDifference(base, other);
	        } else {
	            res = positiveMomentsDifference(other, base);
	            res.milliseconds = -res.milliseconds;
	            res.months = -res.months;
	        }
	
	        return res;
	    }
	
	    // TODO: remove 'name' arg after deprecation is removed
	    function createAdder(direction, name) {
	        return function (val, period) {
	            var dur, tmp;
	            //invert the arguments, but complain about it
	            if (period !== null && !isNaN(+period)) {
	                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
	                tmp = val; val = period; period = tmp;
	            }
	
	            val = typeof val === 'string' ? +val : val;
	            dur = create__createDuration(val, period);
	            add_subtract__addSubtract(this, dur, direction);
	            return this;
	        };
	    }
	
	    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
	        var milliseconds = duration._milliseconds,
	            days = duration._days,
	            months = duration._months;
	
	        if (!mom.isValid()) {
	            // No op
	            return;
	        }
	
	        updateOffset = updateOffset == null ? true : updateOffset;
	
	        if (milliseconds) {
	            mom._d.setTime(+mom._d + milliseconds * isAdding);
	        }
	        if (days) {
	            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
	        }
	        if (months) {
	            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
	        }
	        if (updateOffset) {
	            utils_hooks__hooks.updateOffset(mom, days || months);
	        }
	    }
	
	    var add_subtract__add      = createAdder(1, 'add');
	    var add_subtract__subtract = createAdder(-1, 'subtract');
	
	    function moment_calendar__calendar (time, formats) {
	        // We want to compare the start of today, vs this.
	        // Getting start-of-today depends on whether we're local/utc/offset or not.
	        var now = time || local__createLocal(),
	            sod = cloneWithOffset(now, this).startOf('day'),
	            diff = this.diff(sod, 'days', true),
	            format = diff < -6 ? 'sameElse' :
	                diff < -1 ? 'lastWeek' :
	                diff < 0 ? 'lastDay' :
	                diff < 1 ? 'sameDay' :
	                diff < 2 ? 'nextDay' :
	                diff < 7 ? 'nextWeek' : 'sameElse';
	
	        var output = formats && (isFunction(formats[format]) ? formats[format]() : formats[format]);
	
	        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
	    }
	
	    function clone () {
	        return new Moment(this);
	    }
	
	    function isAfter (input, units) {
	        var localInput = isMoment(input) ? input : local__createLocal(input);
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	        if (units === 'millisecond') {
	            return +this > +localInput;
	        } else {
	            return +localInput < +this.clone().startOf(units);
	        }
	    }
	
	    function isBefore (input, units) {
	        var localInput = isMoment(input) ? input : local__createLocal(input);
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	        if (units === 'millisecond') {
	            return +this < +localInput;
	        } else {
	            return +this.clone().endOf(units) < +localInput;
	        }
	    }
	
	    function isBetween (from, to, units) {
	        return this.isAfter(from, units) && this.isBefore(to, units);
	    }
	
	    function isSame (input, units) {
	        var localInput = isMoment(input) ? input : local__createLocal(input),
	            inputMs;
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(units || 'millisecond');
	        if (units === 'millisecond') {
	            return +this === +localInput;
	        } else {
	            inputMs = +localInput;
	            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
	        }
	    }
	
	    function isSameOrAfter (input, units) {
	        return this.isSame(input, units) || this.isAfter(input,units);
	    }
	
	    function isSameOrBefore (input, units) {
	        return this.isSame(input, units) || this.isBefore(input,units);
	    }
	
	    function diff (input, units, asFloat) {
	        var that,
	            zoneDelta,
	            delta, output;
	
	        if (!this.isValid()) {
	            return NaN;
	        }
	
	        that = cloneWithOffset(input, this);
	
	        if (!that.isValid()) {
	            return NaN;
	        }
	
	        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
	
	        units = normalizeUnits(units);
	
	        if (units === 'year' || units === 'month' || units === 'quarter') {
	            output = monthDiff(this, that);
	            if (units === 'quarter') {
	                output = output / 3;
	            } else if (units === 'year') {
	                output = output / 12;
	            }
	        } else {
	            delta = this - that;
	            output = units === 'second' ? delta / 1e3 : // 1000
	                units === 'minute' ? delta / 6e4 : // 1000 * 60
	                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
	                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	                delta;
	        }
	        return asFloat ? output : absFloor(output);
	    }
	
	    function monthDiff (a, b) {
	        // difference in months
	        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	            // b is in (anchor - 1 month, anchor + 1 month)
	            anchor = a.clone().add(wholeMonthDiff, 'months'),
	            anchor2, adjust;
	
	        if (b - anchor < 0) {
	            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor - anchor2);
	        } else {
	            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor2 - anchor);
	        }
	
	        return -(wholeMonthDiff + adjust);
	    }
	
	    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
	
	    function toString () {
	        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	    }
	
	    function moment_format__toISOString () {
	        var m = this.clone().utc();
	        if (0 < m.year() && m.year() <= 9999) {
	            if (isFunction(Date.prototype.toISOString)) {
	                // native implementation is ~50x faster, use it when we can
	                return this.toDate().toISOString();
	            } else {
	                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	            }
	        } else {
	            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	        }
	    }
	
	    function format (inputString) {
	        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
	        return this.localeData().postformat(output);
	    }
	
	    function from (time, withoutSuffix) {
	        if (this.isValid() &&
	                ((isMoment(time) && time.isValid()) ||
	                 local__createLocal(time).isValid())) {
	            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	        } else {
	            return this.localeData().invalidDate();
	        }
	    }
	
	    function fromNow (withoutSuffix) {
	        return this.from(local__createLocal(), withoutSuffix);
	    }
	
	    function to (time, withoutSuffix) {
	        if (this.isValid() &&
	                ((isMoment(time) && time.isValid()) ||
	                 local__createLocal(time).isValid())) {
	            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
	        } else {
	            return this.localeData().invalidDate();
	        }
	    }
	
	    function toNow (withoutSuffix) {
	        return this.to(local__createLocal(), withoutSuffix);
	    }
	
	    // If passed a locale key, it will set the locale for this
	    // instance.  Otherwise, it will return the locale configuration
	    // variables for this instance.
	    function locale (key) {
	        var newLocaleData;
	
	        if (key === undefined) {
	            return this._locale._abbr;
	        } else {
	            newLocaleData = locale_locales__getLocale(key);
	            if (newLocaleData != null) {
	                this._locale = newLocaleData;
	            }
	            return this;
	        }
	    }
	
	    var lang = deprecate(
	        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	        function (key) {
	            if (key === undefined) {
	                return this.localeData();
	            } else {
	                return this.locale(key);
	            }
	        }
	    );
	
	    function localeData () {
	        return this._locale;
	    }
	
	    function startOf (units) {
	        units = normalizeUnits(units);
	        // the following switch intentionally omits break keywords
	        // to utilize falling through the cases.
	        switch (units) {
	        case 'year':
	            this.month(0);
	            /* falls through */
	        case 'quarter':
	        case 'month':
	            this.date(1);
	            /* falls through */
	        case 'week':
	        case 'isoWeek':
	        case 'day':
	            this.hours(0);
	            /* falls through */
	        case 'hour':
	            this.minutes(0);
	            /* falls through */
	        case 'minute':
	            this.seconds(0);
	            /* falls through */
	        case 'second':
	            this.milliseconds(0);
	        }
	
	        // weeks are a special case
	        if (units === 'week') {
	            this.weekday(0);
	        }
	        if (units === 'isoWeek') {
	            this.isoWeekday(1);
	        }
	
	        // quarters are also special
	        if (units === 'quarter') {
	            this.month(Math.floor(this.month() / 3) * 3);
	        }
	
	        return this;
	    }
	
	    function endOf (units) {
	        units = normalizeUnits(units);
	        if (units === undefined || units === 'millisecond') {
	            return this;
	        }
	        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
	    }
	
	    function to_type__valueOf () {
	        return +this._d - ((this._offset || 0) * 60000);
	    }
	
	    function unix () {
	        return Math.floor(+this / 1000);
	    }
	
	    function toDate () {
	        return this._offset ? new Date(+this) : this._d;
	    }
	
	    function toArray () {
	        var m = this;
	        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	    }
	
	    function toObject () {
	        var m = this;
	        return {
	            years: m.year(),
	            months: m.month(),
	            date: m.date(),
	            hours: m.hours(),
	            minutes: m.minutes(),
	            seconds: m.seconds(),
	            milliseconds: m.milliseconds()
	        };
	    }
	
	    function toJSON () {
	        // JSON.stringify(new Date(NaN)) === 'null'
	        return this.isValid() ? this.toISOString() : 'null';
	    }
	
	    function moment_valid__isValid () {
	        return valid__isValid(this);
	    }
	
	    function parsingFlags () {
	        return extend({}, getParsingFlags(this));
	    }
	
	    function invalidAt () {
	        return getParsingFlags(this).overflow;
	    }
	
	    function creationData() {
	        return {
	            input: this._i,
	            format: this._f,
	            locale: this._locale,
	            isUTC: this._isUTC,
	            strict: this._strict
	        };
	    }
	
	    // FORMATTING
	
	    addFormatToken(0, ['gg', 2], 0, function () {
	        return this.weekYear() % 100;
	    });
	
	    addFormatToken(0, ['GG', 2], 0, function () {
	        return this.isoWeekYear() % 100;
	    });
	
	    function addWeekYearFormatToken (token, getter) {
	        addFormatToken(0, [token, token.length], 0, getter);
	    }
	
	    addWeekYearFormatToken('gggg',     'weekYear');
	    addWeekYearFormatToken('ggggg',    'weekYear');
	    addWeekYearFormatToken('GGGG',  'isoWeekYear');
	    addWeekYearFormatToken('GGGGG', 'isoWeekYear');
	
	    // ALIASES
	
	    addUnitAlias('weekYear', 'gg');
	    addUnitAlias('isoWeekYear', 'GG');
	
	    // PARSING
	
	    addRegexToken('G',      matchSigned);
	    addRegexToken('g',      matchSigned);
	    addRegexToken('GG',     match1to2, match2);
	    addRegexToken('gg',     match1to2, match2);
	    addRegexToken('GGGG',   match1to4, match4);
	    addRegexToken('gggg',   match1to4, match4);
	    addRegexToken('GGGGG',  match1to6, match6);
	    addRegexToken('ggggg',  match1to6, match6);
	
	    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
	        week[token.substr(0, 2)] = toInt(input);
	    });
	
	    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
	    });
	
	    // MOMENTS
	
	    function getSetWeekYear (input) {
	        return getSetWeekYearHelper.call(this,
	                input,
	                this.week(),
	                this.weekday(),
	                this.localeData()._week.dow,
	                this.localeData()._week.doy);
	    }
	
	    function getSetISOWeekYear (input) {
	        return getSetWeekYearHelper.call(this,
	                input, this.isoWeek(), this.isoWeekday(), 1, 4);
	    }
	
	    function getISOWeeksInYear () {
	        return weeksInYear(this.year(), 1, 4);
	    }
	
	    function getWeeksInYear () {
	        var weekInfo = this.localeData()._week;
	        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	    }
	
	    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	        var weeksTarget;
	        if (input == null) {
	            return weekOfYear(this, dow, doy).year;
	        } else {
	            weeksTarget = weeksInYear(input, dow, doy);
	            if (week > weeksTarget) {
	                week = weeksTarget;
	            }
	            return setWeekAll.call(this, input, week, weekday, dow, doy);
	        }
	    }
	
	    function setWeekAll(weekYear, week, weekday, dow, doy) {
	        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
	
	        // console.log("got", weekYear, week, weekday, "set", date.toISOString());
	        this.year(date.getUTCFullYear());
	        this.month(date.getUTCMonth());
	        this.date(date.getUTCDate());
	        return this;
	    }
	
	    // FORMATTING
	
	    addFormatToken('Q', 0, 'Qo', 'quarter');
	
	    // ALIASES
	
	    addUnitAlias('quarter', 'Q');
	
	    // PARSING
	
	    addRegexToken('Q', match1);
	    addParseToken('Q', function (input, array) {
	        array[MONTH] = (toInt(input) - 1) * 3;
	    });
	
	    // MOMENTS
	
	    function getSetQuarter (input) {
	        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	    }
	
	    // FORMATTING
	
	    addFormatToken('w', ['ww', 2], 'wo', 'week');
	    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
	
	    // ALIASES
	
	    addUnitAlias('week', 'w');
	    addUnitAlias('isoWeek', 'W');
	
	    // PARSING
	
	    addRegexToken('w',  match1to2);
	    addRegexToken('ww', match1to2, match2);
	    addRegexToken('W',  match1to2);
	    addRegexToken('WW', match1to2, match2);
	
	    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
	        week[token.substr(0, 1)] = toInt(input);
	    });
	
	    // HELPERS
	
	    // LOCALES
	
	    function localeWeek (mom) {
	        return weekOfYear(mom, this._week.dow, this._week.doy).week;
	    }
	
	    var defaultLocaleWeek = {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    };
	
	    function localeFirstDayOfWeek () {
	        return this._week.dow;
	    }
	
	    function localeFirstDayOfYear () {
	        return this._week.doy;
	    }
	
	    // MOMENTS
	
	    function getSetWeek (input) {
	        var week = this.localeData().week(this);
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }
	
	    function getSetISOWeek (input) {
	        var week = weekOfYear(this, 1, 4).week;
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }
	
	    // FORMATTING
	
	    addFormatToken('D', ['DD', 2], 'Do', 'date');
	
	    // ALIASES
	
	    addUnitAlias('date', 'D');
	
	    // PARSING
	
	    addRegexToken('D',  match1to2);
	    addRegexToken('DD', match1to2, match2);
	    addRegexToken('Do', function (isStrict, locale) {
	        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
	    });
	
	    addParseToken(['D', 'DD'], DATE);
	    addParseToken('Do', function (input, array) {
	        array[DATE] = toInt(input.match(match1to2)[0], 10);
	    });
	
	    // MOMENTS
	
	    var getSetDayOfMonth = makeGetSet('Date', true);
	
	    // FORMATTING
	
	    addFormatToken('d', 0, 'do', 'day');
	
	    addFormatToken('dd', 0, 0, function (format) {
	        return this.localeData().weekdaysMin(this, format);
	    });
	
	    addFormatToken('ddd', 0, 0, function (format) {
	        return this.localeData().weekdaysShort(this, format);
	    });
	
	    addFormatToken('dddd', 0, 0, function (format) {
	        return this.localeData().weekdays(this, format);
	    });
	
	    addFormatToken('e', 0, 0, 'weekday');
	    addFormatToken('E', 0, 0, 'isoWeekday');
	
	    // ALIASES
	
	    addUnitAlias('day', 'd');
	    addUnitAlias('weekday', 'e');
	    addUnitAlias('isoWeekday', 'E');
	
	    // PARSING
	
	    addRegexToken('d',    match1to2);
	    addRegexToken('e',    match1to2);
	    addRegexToken('E',    match1to2);
	    addRegexToken('dd',   matchWord);
	    addRegexToken('ddd',  matchWord);
	    addRegexToken('dddd', matchWord);
	
	    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
	        var weekday = config._locale.weekdaysParse(input, token, config._strict);
	        // if we didn't get a weekday name, mark the date as invalid
	        if (weekday != null) {
	            week.d = weekday;
	        } else {
	            getParsingFlags(config).invalidWeekday = input;
	        }
	    });
	
	    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	        week[token] = toInt(input);
	    });
	
	    // HELPERS
	
	    function parseWeekday(input, locale) {
	        if (typeof input !== 'string') {
	            return input;
	        }
	
	        if (!isNaN(input)) {
	            return parseInt(input, 10);
	        }
	
	        input = locale.weekdaysParse(input);
	        if (typeof input === 'number') {
	            return input;
	        }
	
	        return null;
	    }
	
	    // LOCALES
	
	    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
	    function localeWeekdays (m, format) {
	        return isArray(this._weekdays) ? this._weekdays[m.day()] :
	            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
	    }
	
	    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
	    function localeWeekdaysShort (m) {
	        return this._weekdaysShort[m.day()];
	    }
	
	    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
	    function localeWeekdaysMin (m) {
	        return this._weekdaysMin[m.day()];
	    }
	
	    function localeWeekdaysParse (weekdayName, format, strict) {
	        var i, mom, regex;
	
	        if (!this._weekdaysParse) {
	            this._weekdaysParse = [];
	            this._minWeekdaysParse = [];
	            this._shortWeekdaysParse = [];
	            this._fullWeekdaysParse = [];
	        }
	
	        for (i = 0; i < 7; i++) {
	            // make the regex if we don't have it already
	
	            mom = local__createLocal([2000, 1]).day(i);
	            if (strict && !this._fullWeekdaysParse[i]) {
	                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
	                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
	                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
	            }
	            if (!this._weekdaysParse[i]) {
	                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
	                return i;
	            }
	        }
	    }
	
	    // MOMENTS
	
	    function getSetDayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	        if (input != null) {
	            input = parseWeekday(input, this.localeData());
	            return this.add(input - day, 'd');
	        } else {
	            return day;
	        }
	    }
	
	    function getSetLocaleDayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	        return input == null ? weekday : this.add(input - weekday, 'd');
	    }
	
	    function getSetISODayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        // behaves the same as moment#day except
	        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	        // as a setter, sunday should belong to the previous week.
	        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
	    }
	
	    // FORMATTING
	
	    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
	
	    // ALIASES
	
	    addUnitAlias('dayOfYear', 'DDD');
	
	    // PARSING
	
	    addRegexToken('DDD',  match1to3);
	    addRegexToken('DDDD', match3);
	    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	        config._dayOfYear = toInt(input);
	    });
	
	    // HELPERS
	
	    // MOMENTS
	
	    function getSetDayOfYear (input) {
	        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
	        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	    }
	
	    // FORMATTING
	
	    function hFormat() {
	        return this.hours() % 12 || 12;
	    }
	
	    addFormatToken('H', ['HH', 2], 0, 'hour');
	    addFormatToken('h', ['hh', 2], 0, hFormat);
	
	    addFormatToken('hmm', 0, 0, function () {
	        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	    });
	
	    addFormatToken('hmmss', 0, 0, function () {
	        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
	            zeroFill(this.seconds(), 2);
	    });
	
	    addFormatToken('Hmm', 0, 0, function () {
	        return '' + this.hours() + zeroFill(this.minutes(), 2);
	    });
	
	    addFormatToken('Hmmss', 0, 0, function () {
	        return '' + this.hours() + zeroFill(this.minutes(), 2) +
	            zeroFill(this.seconds(), 2);
	    });
	
	    function meridiem (token, lowercase) {
	        addFormatToken(token, 0, 0, function () {
	            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	        });
	    }
	
	    meridiem('a', true);
	    meridiem('A', false);
	
	    // ALIASES
	
	    addUnitAlias('hour', 'h');
	
	    // PARSING
	
	    function matchMeridiem (isStrict, locale) {
	        return locale._meridiemParse;
	    }
	
	    addRegexToken('a',  matchMeridiem);
	    addRegexToken('A',  matchMeridiem);
	    addRegexToken('H',  match1to2);
	    addRegexToken('h',  match1to2);
	    addRegexToken('HH', match1to2, match2);
	    addRegexToken('hh', match1to2, match2);
	
	    addRegexToken('hmm', match3to4);
	    addRegexToken('hmmss', match5to6);
	    addRegexToken('Hmm', match3to4);
	    addRegexToken('Hmmss', match5to6);
	
	    addParseToken(['H', 'HH'], HOUR);
	    addParseToken(['a', 'A'], function (input, array, config) {
	        config._isPm = config._locale.isPM(input);
	        config._meridiem = input;
	    });
	    addParseToken(['h', 'hh'], function (input, array, config) {
	        array[HOUR] = toInt(input);
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmm', function (input, array, config) {
	        var pos = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos));
	        array[MINUTE] = toInt(input.substr(pos));
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmmss', function (input, array, config) {
	        var pos1 = input.length - 4;
	        var pos2 = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos1));
	        array[MINUTE] = toInt(input.substr(pos1, 2));
	        array[SECOND] = toInt(input.substr(pos2));
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('Hmm', function (input, array, config) {
	        var pos = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos));
	        array[MINUTE] = toInt(input.substr(pos));
	    });
	    addParseToken('Hmmss', function (input, array, config) {
	        var pos1 = input.length - 4;
	        var pos2 = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos1));
	        array[MINUTE] = toInt(input.substr(pos1, 2));
	        array[SECOND] = toInt(input.substr(pos2));
	    });
	
	    // LOCALES
	
	    function localeIsPM (input) {
	        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	        // Using charAt should be more compatible.
	        return ((input + '').toLowerCase().charAt(0) === 'p');
	    }
	
	    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	    function localeMeridiem (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'pm' : 'PM';
	        } else {
	            return isLower ? 'am' : 'AM';
	        }
	    }
	
	
	    // MOMENTS
	
	    // Setting the hour should keep the time, because the user explicitly
	    // specified which hour he wants. So trying to maintain the same hour (in
	    // a new timezone) makes sense. Adding/subtracting hours does not follow
	    // this rule.
	    var getSetHour = makeGetSet('Hours', true);
	
	    // FORMATTING
	
	    addFormatToken('m', ['mm', 2], 0, 'minute');
	
	    // ALIASES
	
	    addUnitAlias('minute', 'm');
	
	    // PARSING
	
	    addRegexToken('m',  match1to2);
	    addRegexToken('mm', match1to2, match2);
	    addParseToken(['m', 'mm'], MINUTE);
	
	    // MOMENTS
	
	    var getSetMinute = makeGetSet('Minutes', false);
	
	    // FORMATTING
	
	    addFormatToken('s', ['ss', 2], 0, 'second');
	
	    // ALIASES
	
	    addUnitAlias('second', 's');
	
	    // PARSING
	
	    addRegexToken('s',  match1to2);
	    addRegexToken('ss', match1to2, match2);
	    addParseToken(['s', 'ss'], SECOND);
	
	    // MOMENTS
	
	    var getSetSecond = makeGetSet('Seconds', false);
	
	    // FORMATTING
	
	    addFormatToken('S', 0, 0, function () {
	        return ~~(this.millisecond() / 100);
	    });
	
	    addFormatToken(0, ['SS', 2], 0, function () {
	        return ~~(this.millisecond() / 10);
	    });
	
	    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	    addFormatToken(0, ['SSSS', 4], 0, function () {
	        return this.millisecond() * 10;
	    });
	    addFormatToken(0, ['SSSSS', 5], 0, function () {
	        return this.millisecond() * 100;
	    });
	    addFormatToken(0, ['SSSSSS', 6], 0, function () {
	        return this.millisecond() * 1000;
	    });
	    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	        return this.millisecond() * 10000;
	    });
	    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	        return this.millisecond() * 100000;
	    });
	    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	        return this.millisecond() * 1000000;
	    });
	
	
	    // ALIASES
	
	    addUnitAlias('millisecond', 'ms');
	
	    // PARSING
	
	    addRegexToken('S',    match1to3, match1);
	    addRegexToken('SS',   match1to3, match2);
	    addRegexToken('SSS',  match1to3, match3);
	
	    var token;
	    for (token = 'SSSS'; token.length <= 9; token += 'S') {
	        addRegexToken(token, matchUnsigned);
	    }
	
	    function parseMs(input, array) {
	        array[MILLISECOND] = toInt(('0.' + input) * 1000);
	    }
	
	    for (token = 'S'; token.length <= 9; token += 'S') {
	        addParseToken(token, parseMs);
	    }
	    // MOMENTS
	
	    var getSetMillisecond = makeGetSet('Milliseconds', false);
	
	    // FORMATTING
	
	    addFormatToken('z',  0, 0, 'zoneAbbr');
	    addFormatToken('zz', 0, 0, 'zoneName');
	
	    // MOMENTS
	
	    function getZoneAbbr () {
	        return this._isUTC ? 'UTC' : '';
	    }
	
	    function getZoneName () {
	        return this._isUTC ? 'Coordinated Universal Time' : '';
	    }
	
	    var momentPrototype__proto = Moment.prototype;
	
	    momentPrototype__proto.add               = add_subtract__add;
	    momentPrototype__proto.calendar          = moment_calendar__calendar;
	    momentPrototype__proto.clone             = clone;
	    momentPrototype__proto.diff              = diff;
	    momentPrototype__proto.endOf             = endOf;
	    momentPrototype__proto.format            = format;
	    momentPrototype__proto.from              = from;
	    momentPrototype__proto.fromNow           = fromNow;
	    momentPrototype__proto.to                = to;
	    momentPrototype__proto.toNow             = toNow;
	    momentPrototype__proto.get               = getSet;
	    momentPrototype__proto.invalidAt         = invalidAt;
	    momentPrototype__proto.isAfter           = isAfter;
	    momentPrototype__proto.isBefore          = isBefore;
	    momentPrototype__proto.isBetween         = isBetween;
	    momentPrototype__proto.isSame            = isSame;
	    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
	    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
	    momentPrototype__proto.isValid           = moment_valid__isValid;
	    momentPrototype__proto.lang              = lang;
	    momentPrototype__proto.locale            = locale;
	    momentPrototype__proto.localeData        = localeData;
	    momentPrototype__proto.max               = prototypeMax;
	    momentPrototype__proto.min               = prototypeMin;
	    momentPrototype__proto.parsingFlags      = parsingFlags;
	    momentPrototype__proto.set               = getSet;
	    momentPrototype__proto.startOf           = startOf;
	    momentPrototype__proto.subtract          = add_subtract__subtract;
	    momentPrototype__proto.toArray           = toArray;
	    momentPrototype__proto.toObject          = toObject;
	    momentPrototype__proto.toDate            = toDate;
	    momentPrototype__proto.toISOString       = moment_format__toISOString;
	    momentPrototype__proto.toJSON            = toJSON;
	    momentPrototype__proto.toString          = toString;
	    momentPrototype__proto.unix              = unix;
	    momentPrototype__proto.valueOf           = to_type__valueOf;
	    momentPrototype__proto.creationData      = creationData;
	
	    // Year
	    momentPrototype__proto.year       = getSetYear;
	    momentPrototype__proto.isLeapYear = getIsLeapYear;
	
	    // Week Year
	    momentPrototype__proto.weekYear    = getSetWeekYear;
	    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
	
	    // Quarter
	    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
	
	    // Month
	    momentPrototype__proto.month       = getSetMonth;
	    momentPrototype__proto.daysInMonth = getDaysInMonth;
	
	    // Week
	    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
	    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
	    momentPrototype__proto.weeksInYear    = getWeeksInYear;
	    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
	
	    // Day
	    momentPrototype__proto.date       = getSetDayOfMonth;
	    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
	    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
	    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
	    momentPrototype__proto.dayOfYear  = getSetDayOfYear;
	
	    // Hour
	    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
	
	    // Minute
	    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
	
	    // Second
	    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
	
	    // Millisecond
	    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
	
	    // Offset
	    momentPrototype__proto.utcOffset            = getSetOffset;
	    momentPrototype__proto.utc                  = setOffsetToUTC;
	    momentPrototype__proto.local                = setOffsetToLocal;
	    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
	    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
	    momentPrototype__proto.isDST                = isDaylightSavingTime;
	    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
	    momentPrototype__proto.isLocal              = isLocal;
	    momentPrototype__proto.isUtcOffset          = isUtcOffset;
	    momentPrototype__proto.isUtc                = isUtc;
	    momentPrototype__proto.isUTC                = isUtc;
	
	    // Timezone
	    momentPrototype__proto.zoneAbbr = getZoneAbbr;
	    momentPrototype__proto.zoneName = getZoneName;
	
	    // Deprecations
	    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);
	
	    var momentPrototype = momentPrototype__proto;
	
	    function moment__createUnix (input) {
	        return local__createLocal(input * 1000);
	    }
	
	    function moment__createInZone () {
	        return local__createLocal.apply(null, arguments).parseZone();
	    }
	
	    var defaultCalendar = {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    };
	
	    function locale_calendar__calendar (key, mom, now) {
	        var output = this._calendar[key];
	        return isFunction(output) ? output.call(mom, now) : output;
	    }
	
	    var defaultLongDateFormat = {
	        LTS  : 'h:mm:ss A',
	        LT   : 'h:mm A',
	        L    : 'MM/DD/YYYY',
	        LL   : 'MMMM D, YYYY',
	        LLL  : 'MMMM D, YYYY h:mm A',
	        LLLL : 'dddd, MMMM D, YYYY h:mm A'
	    };
	
	    function longDateFormat (key) {
	        var format = this._longDateFormat[key],
	            formatUpper = this._longDateFormat[key.toUpperCase()];
	
	        if (format || !formatUpper) {
	            return format;
	        }
	
	        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	            return val.slice(1);
	        });
	
	        return this._longDateFormat[key];
	    }
	
	    var defaultInvalidDate = 'Invalid date';
	
	    function invalidDate () {
	        return this._invalidDate;
	    }
	
	    var defaultOrdinal = '%d';
	    var defaultOrdinalParse = /\d{1,2}/;
	
	    function ordinal (number) {
	        return this._ordinal.replace('%d', number);
	    }
	
	    function preParsePostFormat (string) {
	        return string;
	    }
	
	    var defaultRelativeTime = {
	        future : 'in %s',
	        past   : '%s ago',
	        s  : 'a few seconds',
	        m  : 'a minute',
	        mm : '%d minutes',
	        h  : 'an hour',
	        hh : '%d hours',
	        d  : 'a day',
	        dd : '%d days',
	        M  : 'a month',
	        MM : '%d months',
	        y  : 'a year',
	        yy : '%d years'
	    };
	
	    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
	        var output = this._relativeTime[string];
	        return (isFunction(output)) ?
	            output(number, withoutSuffix, string, isFuture) :
	            output.replace(/%d/i, number);
	    }
	
	    function pastFuture (diff, output) {
	        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	    }
	
	    function locale_set__set (config) {
	        var prop, i;
	        for (i in config) {
	            prop = config[i];
	            if (isFunction(prop)) {
	                this[i] = prop;
	            } else {
	                this['_' + i] = prop;
	            }
	        }
	        // Lenient ordinal parsing accepts just a number in addition to
	        // number + (possibly) stuff coming from _ordinalParseLenient.
	        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
	    }
	
	    var prototype__proto = Locale.prototype;
	
	    prototype__proto._calendar       = defaultCalendar;
	    prototype__proto.calendar        = locale_calendar__calendar;
	    prototype__proto._longDateFormat = defaultLongDateFormat;
	    prototype__proto.longDateFormat  = longDateFormat;
	    prototype__proto._invalidDate    = defaultInvalidDate;
	    prototype__proto.invalidDate     = invalidDate;
	    prototype__proto._ordinal        = defaultOrdinal;
	    prototype__proto.ordinal         = ordinal;
	    prototype__proto._ordinalParse   = defaultOrdinalParse;
	    prototype__proto.preparse        = preParsePostFormat;
	    prototype__proto.postformat      = preParsePostFormat;
	    prototype__proto._relativeTime   = defaultRelativeTime;
	    prototype__proto.relativeTime    = relative__relativeTime;
	    prototype__proto.pastFuture      = pastFuture;
	    prototype__proto.set             = locale_set__set;
	
	    // Month
	    prototype__proto.months            =        localeMonths;
	    prototype__proto._months           = defaultLocaleMonths;
	    prototype__proto.monthsShort       =        localeMonthsShort;
	    prototype__proto._monthsShort      = defaultLocaleMonthsShort;
	    prototype__proto.monthsParse       =        localeMonthsParse;
	    prototype__proto._monthsRegex      = defaultMonthsRegex;
	    prototype__proto.monthsRegex       = monthsRegex;
	    prototype__proto._monthsShortRegex = defaultMonthsShortRegex;
	    prototype__proto.monthsShortRegex  = monthsShortRegex;
	
	    // Week
	    prototype__proto.week = localeWeek;
	    prototype__proto._week = defaultLocaleWeek;
	    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
	    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
	
	    // Day of Week
	    prototype__proto.weekdays       =        localeWeekdays;
	    prototype__proto._weekdays      = defaultLocaleWeekdays;
	    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
	    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
	    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
	    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
	    prototype__proto.weekdaysParse  =        localeWeekdaysParse;
	
	    // Hours
	    prototype__proto.isPM = localeIsPM;
	    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
	    prototype__proto.meridiem = localeMeridiem;
	
	    function lists__get (format, index, field, setter) {
	        var locale = locale_locales__getLocale();
	        var utc = create_utc__createUTC().set(setter, index);
	        return locale[field](utc, format);
	    }
	
	    function list (format, index, field, count, setter) {
	        if (typeof format === 'number') {
	            index = format;
	            format = undefined;
	        }
	
	        format = format || '';
	
	        if (index != null) {
	            return lists__get(format, index, field, setter);
	        }
	
	        var i;
	        var out = [];
	        for (i = 0; i < count; i++) {
	            out[i] = lists__get(format, i, field, setter);
	        }
	        return out;
	    }
	
	    function lists__listMonths (format, index) {
	        return list(format, index, 'months', 12, 'month');
	    }
	
	    function lists__listMonthsShort (format, index) {
	        return list(format, index, 'monthsShort', 12, 'month');
	    }
	
	    function lists__listWeekdays (format, index) {
	        return list(format, index, 'weekdays', 7, 'day');
	    }
	
	    function lists__listWeekdaysShort (format, index) {
	        return list(format, index, 'weekdaysShort', 7, 'day');
	    }
	
	    function lists__listWeekdaysMin (format, index) {
	        return list(format, index, 'weekdaysMin', 7, 'day');
	    }
	
	    locale_locales__getSetGlobalLocale('en', {
	        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (toInt(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });
	
	    // Side effect imports
	    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
	    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);
	
	    var mathAbs = Math.abs;
	
	    function duration_abs__abs () {
	        var data           = this._data;
	
	        this._milliseconds = mathAbs(this._milliseconds);
	        this._days         = mathAbs(this._days);
	        this._months       = mathAbs(this._months);
	
	        data.milliseconds  = mathAbs(data.milliseconds);
	        data.seconds       = mathAbs(data.seconds);
	        data.minutes       = mathAbs(data.minutes);
	        data.hours         = mathAbs(data.hours);
	        data.months        = mathAbs(data.months);
	        data.years         = mathAbs(data.years);
	
	        return this;
	    }
	
	    function duration_add_subtract__addSubtract (duration, input, value, direction) {
	        var other = create__createDuration(input, value);
	
	        duration._milliseconds += direction * other._milliseconds;
	        duration._days         += direction * other._days;
	        duration._months       += direction * other._months;
	
	        return duration._bubble();
	    }
	
	    // supports only 2.0-style add(1, 's') or add(duration)
	    function duration_add_subtract__add (input, value) {
	        return duration_add_subtract__addSubtract(this, input, value, 1);
	    }
	
	    // supports only 2.0-style subtract(1, 's') or subtract(duration)
	    function duration_add_subtract__subtract (input, value) {
	        return duration_add_subtract__addSubtract(this, input, value, -1);
	    }
	
	    function absCeil (number) {
	        if (number < 0) {
	            return Math.floor(number);
	        } else {
	            return Math.ceil(number);
	        }
	    }
	
	    function bubble () {
	        var milliseconds = this._milliseconds;
	        var days         = this._days;
	        var months       = this._months;
	        var data         = this._data;
	        var seconds, minutes, hours, years, monthsFromDays;
	
	        // if we have a mix of positive and negative values, bubble down first
	        // check: https://github.com/moment/moment/issues/2166
	        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
	                (milliseconds <= 0 && days <= 0 && months <= 0))) {
	            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	            days = 0;
	            months = 0;
	        }
	
	        // The following code bubbles up values, see the tests for
	        // examples of what that means.
	        data.milliseconds = milliseconds % 1000;
	
	        seconds           = absFloor(milliseconds / 1000);
	        data.seconds      = seconds % 60;
	
	        minutes           = absFloor(seconds / 60);
	        data.minutes      = minutes % 60;
	
	        hours             = absFloor(minutes / 60);
	        data.hours        = hours % 24;
	
	        days += absFloor(hours / 24);
	
	        // convert days to months
	        monthsFromDays = absFloor(daysToMonths(days));
	        months += monthsFromDays;
	        days -= absCeil(monthsToDays(monthsFromDays));
	
	        // 12 months -> 1 year
	        years = absFloor(months / 12);
	        months %= 12;
	
	        data.days   = days;
	        data.months = months;
	        data.years  = years;
	
	        return this;
	    }
	
	    function daysToMonths (days) {
	        // 400 years have 146097 days (taking into account leap year rules)
	        // 400 years have 12 months === 4800
	        return days * 4800 / 146097;
	    }
	
	    function monthsToDays (months) {
	        // the reverse of daysToMonths
	        return months * 146097 / 4800;
	    }
	
	    function as (units) {
	        var days;
	        var months;
	        var milliseconds = this._milliseconds;
	
	        units = normalizeUnits(units);
	
	        if (units === 'month' || units === 'year') {
	            days   = this._days   + milliseconds / 864e5;
	            months = this._months + daysToMonths(days);
	            return units === 'month' ? months : months / 12;
	        } else {
	            // handle milliseconds separately because of floating point math errors (issue #1867)
	            days = this._days + Math.round(monthsToDays(this._months));
	            switch (units) {
	                case 'week'   : return days / 7     + milliseconds / 6048e5;
	                case 'day'    : return days         + milliseconds / 864e5;
	                case 'hour'   : return days * 24    + milliseconds / 36e5;
	                case 'minute' : return days * 1440  + milliseconds / 6e4;
	                case 'second' : return days * 86400 + milliseconds / 1000;
	                // Math.floor prevents floating point math errors here
	                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
	                default: throw new Error('Unknown unit ' + units);
	            }
	        }
	    }
	
	    // TODO: Use this.as('ms')?
	    function duration_as__valueOf () {
	        return (
	            this._milliseconds +
	            this._days * 864e5 +
	            (this._months % 12) * 2592e6 +
	            toInt(this._months / 12) * 31536e6
	        );
	    }
	
	    function makeAs (alias) {
	        return function () {
	            return this.as(alias);
	        };
	    }
	
	    var asMilliseconds = makeAs('ms');
	    var asSeconds      = makeAs('s');
	    var asMinutes      = makeAs('m');
	    var asHours        = makeAs('h');
	    var asDays         = makeAs('d');
	    var asWeeks        = makeAs('w');
	    var asMonths       = makeAs('M');
	    var asYears        = makeAs('y');
	
	    function duration_get__get (units) {
	        units = normalizeUnits(units);
	        return this[units + 's']();
	    }
	
	    function makeGetter(name) {
	        return function () {
	            return this._data[name];
	        };
	    }
	
	    var milliseconds = makeGetter('milliseconds');
	    var seconds      = makeGetter('seconds');
	    var minutes      = makeGetter('minutes');
	    var hours        = makeGetter('hours');
	    var days         = makeGetter('days');
	    var months       = makeGetter('months');
	    var years        = makeGetter('years');
	
	    function weeks () {
	        return absFloor(this.days() / 7);
	    }
	
	    var round = Math.round;
	    var thresholds = {
	        s: 45,  // seconds to minute
	        m: 45,  // minutes to hour
	        h: 22,  // hours to day
	        d: 26,  // days to month
	        M: 11   // months to year
	    };
	
	    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }
	
	    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
	        var duration = create__createDuration(posNegDuration).abs();
	        var seconds  = round(duration.as('s'));
	        var minutes  = round(duration.as('m'));
	        var hours    = round(duration.as('h'));
	        var days     = round(duration.as('d'));
	        var months   = round(duration.as('M'));
	        var years    = round(duration.as('y'));
	
	        var a = seconds < thresholds.s && ['s', seconds]  ||
	                minutes <= 1           && ['m']           ||
	                minutes < thresholds.m && ['mm', minutes] ||
	                hours   <= 1           && ['h']           ||
	                hours   < thresholds.h && ['hh', hours]   ||
	                days    <= 1           && ['d']           ||
	                days    < thresholds.d && ['dd', days]    ||
	                months  <= 1           && ['M']           ||
	                months  < thresholds.M && ['MM', months]  ||
	                years   <= 1           && ['y']           || ['yy', years];
	
	        a[2] = withoutSuffix;
	        a[3] = +posNegDuration > 0;
	        a[4] = locale;
	        return substituteTimeAgo.apply(null, a);
	    }
	
	    // This function allows you to set a threshold for relative time strings
	    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
	        if (thresholds[threshold] === undefined) {
	            return false;
	        }
	        if (limit === undefined) {
	            return thresholds[threshold];
	        }
	        thresholds[threshold] = limit;
	        return true;
	    }
	
	    function humanize (withSuffix) {
	        var locale = this.localeData();
	        var output = duration_humanize__relativeTime(this, !withSuffix, locale);
	
	        if (withSuffix) {
	            output = locale.pastFuture(+this, output);
	        }
	
	        return locale.postformat(output);
	    }
	
	    var iso_string__abs = Math.abs;
	
	    function iso_string__toISOString() {
	        // for ISO strings we do not use the normal bubbling rules:
	        //  * milliseconds bubble up until they become hours
	        //  * days do not bubble at all
	        //  * months bubble up until they become years
	        // This is because there is no context-free conversion between hours and days
	        // (think of clock changes)
	        // and also not between days and months (28-31 days per month)
	        var seconds = iso_string__abs(this._milliseconds) / 1000;
	        var days         = iso_string__abs(this._days);
	        var months       = iso_string__abs(this._months);
	        var minutes, hours, years;
	
	        // 3600 seconds -> 60 minutes -> 1 hour
	        minutes           = absFloor(seconds / 60);
	        hours             = absFloor(minutes / 60);
	        seconds %= 60;
	        minutes %= 60;
	
	        // 12 months -> 1 year
	        years  = absFloor(months / 12);
	        months %= 12;
	
	
	        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	        var Y = years;
	        var M = months;
	        var D = days;
	        var h = hours;
	        var m = minutes;
	        var s = seconds;
	        var total = this.asSeconds();
	
	        if (!total) {
	            // this is the same as C#'s (Noda) and python (isodate)...
	            // but not other JS (goog.date)
	            return 'P0D';
	        }
	
	        return (total < 0 ? '-' : '') +
	            'P' +
	            (Y ? Y + 'Y' : '') +
	            (M ? M + 'M' : '') +
	            (D ? D + 'D' : '') +
	            ((h || m || s) ? 'T' : '') +
	            (h ? h + 'H' : '') +
	            (m ? m + 'M' : '') +
	            (s ? s + 'S' : '');
	    }
	
	    var duration_prototype__proto = Duration.prototype;
	
	    duration_prototype__proto.abs            = duration_abs__abs;
	    duration_prototype__proto.add            = duration_add_subtract__add;
	    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
	    duration_prototype__proto.as             = as;
	    duration_prototype__proto.asMilliseconds = asMilliseconds;
	    duration_prototype__proto.asSeconds      = asSeconds;
	    duration_prototype__proto.asMinutes      = asMinutes;
	    duration_prototype__proto.asHours        = asHours;
	    duration_prototype__proto.asDays         = asDays;
	    duration_prototype__proto.asWeeks        = asWeeks;
	    duration_prototype__proto.asMonths       = asMonths;
	    duration_prototype__proto.asYears        = asYears;
	    duration_prototype__proto.valueOf        = duration_as__valueOf;
	    duration_prototype__proto._bubble        = bubble;
	    duration_prototype__proto.get            = duration_get__get;
	    duration_prototype__proto.milliseconds   = milliseconds;
	    duration_prototype__proto.seconds        = seconds;
	    duration_prototype__proto.minutes        = minutes;
	    duration_prototype__proto.hours          = hours;
	    duration_prototype__proto.days           = days;
	    duration_prototype__proto.weeks          = weeks;
	    duration_prototype__proto.months         = months;
	    duration_prototype__proto.years          = years;
	    duration_prototype__proto.humanize       = humanize;
	    duration_prototype__proto.toISOString    = iso_string__toISOString;
	    duration_prototype__proto.toString       = iso_string__toISOString;
	    duration_prototype__proto.toJSON         = iso_string__toISOString;
	    duration_prototype__proto.locale         = locale;
	    duration_prototype__proto.localeData     = localeData;
	
	    // Deprecations
	    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
	    duration_prototype__proto.lang = lang;
	
	    // Side effect imports
	
	    // FORMATTING
	
	    addFormatToken('X', 0, 0, 'unix');
	    addFormatToken('x', 0, 0, 'valueOf');
	
	    // PARSING
	
	    addRegexToken('x', matchSigned);
	    addRegexToken('X', matchTimestamp);
	    addParseToken('X', function (input, array, config) {
	        config._d = new Date(parseFloat(input, 10) * 1000);
	    });
	    addParseToken('x', function (input, array, config) {
	        config._d = new Date(toInt(input));
	    });
	
	    // Side effect imports
	
	
	    utils_hooks__hooks.version = '2.11.1';
	
	    setHookCallback(local__createLocal);
	
	    utils_hooks__hooks.fn                    = momentPrototype;
	    utils_hooks__hooks.min                   = min;
	    utils_hooks__hooks.max                   = max;
	    utils_hooks__hooks.now                   = now;
	    utils_hooks__hooks.utc                   = create_utc__createUTC;
	    utils_hooks__hooks.unix                  = moment__createUnix;
	    utils_hooks__hooks.months                = lists__listMonths;
	    utils_hooks__hooks.isDate                = isDate;
	    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
	    utils_hooks__hooks.invalid               = valid__createInvalid;
	    utils_hooks__hooks.duration              = create__createDuration;
	    utils_hooks__hooks.isMoment              = isMoment;
	    utils_hooks__hooks.weekdays              = lists__listWeekdays;
	    utils_hooks__hooks.parseZone             = moment__createInZone;
	    utils_hooks__hooks.localeData            = locale_locales__getLocale;
	    utils_hooks__hooks.isDuration            = isDuration;
	    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
	    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
	    utils_hooks__hooks.defineLocale          = defineLocale;
	    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
	    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
	    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
	    utils_hooks__hooks.prototype             = momentPrototype;
	
	    var _moment = utils_hooks__hooks;
	
	    return _moment;
	
	}));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(491)(module)))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var self = self || {};// File:src/Three.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	var THREE = { REVISION: '73' };
	
	//
	
	if ( true ) {
	
			!(__WEBPACK_AMD_DEFINE_FACTORY__ = (THREE), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {
	
			module.exports = THREE;
	
	}
	
	
	// polyfills
	
	if ( self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined ) {
	
		// Missing in Android stock browser.
	
		( function () {
	
			var lastTime = 0;
			var vendors = [ 'ms', 'moz', 'webkit', 'o' ];
	
			for ( var x = 0; x < vendors.length && ! self.requestAnimationFrame; ++ x ) {
	
				self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
				self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];
	
			}
	
			if ( self.requestAnimationFrame === undefined && self.setTimeout !== undefined ) {
	
				self.requestAnimationFrame = function ( callback ) {
	
					var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
					var id = self.setTimeout( function () {
	
						callback( currTime + timeToCall );
	
					}, timeToCall );
					lastTime = currTime + timeToCall;
					return id;
	
				};
	
			}
	
			if ( self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined ) {
	
				self.cancelAnimationFrame = function ( id ) {
	
					self.clearTimeout( id );
	
				};
	
			}
	
		} )();
	
	}
	
	//
	
	if ( self.performance === undefined ) {
	
		self.performance = {};
	
	}
	
	if ( self.performance.now === undefined ) {
	
		( function () {
	
			var start = Date.now();
	
			self.performance.now = function () {
	
				return Date.now() - start;
	
			}
	
		} )();
	
	}
	
	//
	
	if ( Number.EPSILON === undefined ) {
	
		Number.EPSILON = Math.pow( 2, -52 );
	
	}
	
	//
	
	if ( Math.sign === undefined ) {
	
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
	
		Math.sign = function ( x ) {
	
			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;
	
		};
	
	}
	
	if ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {
	
		// Missing in IE9-11.
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
	
		Object.defineProperty( Function.prototype, 'name', {
	
			get: function () {
	
				return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];
	
			}
	
		} );
	
	}
	
	// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button
	
	THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
	
	// GL STATE CONSTANTS
	
	THREE.CullFaceNone = 0;
	THREE.CullFaceBack = 1;
	THREE.CullFaceFront = 2;
	THREE.CullFaceFrontBack = 3;
	
	THREE.FrontFaceDirectionCW = 0;
	THREE.FrontFaceDirectionCCW = 1;
	
	// SHADOWING TYPES
	
	THREE.BasicShadowMap = 0;
	THREE.PCFShadowMap = 1;
	THREE.PCFSoftShadowMap = 2;
	
	// MATERIAL CONSTANTS
	
	// side
	
	THREE.FrontSide = 0;
	THREE.BackSide = 1;
	THREE.DoubleSide = 2;
	
	// shading
	
	THREE.FlatShading = 1;
	THREE.SmoothShading = 2;
	
	// colors
	
	THREE.NoColors = 0;
	THREE.FaceColors = 1;
	THREE.VertexColors = 2;
	
	// blending modes
	
	THREE.NoBlending = 0;
	THREE.NormalBlending = 1;
	THREE.AdditiveBlending = 2;
	THREE.SubtractiveBlending = 3;
	THREE.MultiplyBlending = 4;
	THREE.CustomBlending = 5;
	
	// custom blending equations
	// (numbers start from 100 not to clash with other
	// mappings to OpenGL constants defined in Texture.js)
	
	THREE.AddEquation = 100;
	THREE.SubtractEquation = 101;
	THREE.ReverseSubtractEquation = 102;
	THREE.MinEquation = 103;
	THREE.MaxEquation = 104;
	
	// custom blending destination factors
	
	THREE.ZeroFactor = 200;
	THREE.OneFactor = 201;
	THREE.SrcColorFactor = 202;
	THREE.OneMinusSrcColorFactor = 203;
	THREE.SrcAlphaFactor = 204;
	THREE.OneMinusSrcAlphaFactor = 205;
	THREE.DstAlphaFactor = 206;
	THREE.OneMinusDstAlphaFactor = 207;
	
	// custom blending source factors
	
	//THREE.ZeroFactor = 200;
	//THREE.OneFactor = 201;
	//THREE.SrcAlphaFactor = 204;
	//THREE.OneMinusSrcAlphaFactor = 205;
	//THREE.DstAlphaFactor = 206;
	//THREE.OneMinusDstAlphaFactor = 207;
	THREE.DstColorFactor = 208;
	THREE.OneMinusDstColorFactor = 209;
	THREE.SrcAlphaSaturateFactor = 210;
	
	// depth modes
	
	THREE.NeverDepth = 0;
	THREE.AlwaysDepth = 1;
	THREE.LessDepth = 2;
	THREE.LessEqualDepth = 3;
	THREE.EqualDepth = 4;
	THREE.GreaterEqualDepth = 5;
	THREE.GreaterDepth = 6;
	THREE.NotEqualDepth = 7;
	
	
	// TEXTURE CONSTANTS
	
	THREE.MultiplyOperation = 0;
	THREE.MixOperation = 1;
	THREE.AddOperation = 2;
	
	// Mapping modes
	
	THREE.UVMapping = 300;
	
	THREE.CubeReflectionMapping = 301;
	THREE.CubeRefractionMapping = 302;
	
	THREE.EquirectangularReflectionMapping = 303;
	THREE.EquirectangularRefractionMapping = 304;
	
	THREE.SphericalReflectionMapping = 305;
	
	// Wrapping modes
	
	THREE.RepeatWrapping = 1000;
	THREE.ClampToEdgeWrapping = 1001;
	THREE.MirroredRepeatWrapping = 1002;
	
	// Filters
	
	THREE.NearestFilter = 1003;
	THREE.NearestMipMapNearestFilter = 1004;
	THREE.NearestMipMapLinearFilter = 1005;
	THREE.LinearFilter = 1006;
	THREE.LinearMipMapNearestFilter = 1007;
	THREE.LinearMipMapLinearFilter = 1008;
	
	// Data types
	
	THREE.UnsignedByteType = 1009;
	THREE.ByteType = 1010;
	THREE.ShortType = 1011;
	THREE.UnsignedShortType = 1012;
	THREE.IntType = 1013;
	THREE.UnsignedIntType = 1014;
	THREE.FloatType = 1015;
	THREE.HalfFloatType = 1025;
	
	// Pixel types
	
	//THREE.UnsignedByteType = 1009;
	THREE.UnsignedShort4444Type = 1016;
	THREE.UnsignedShort5551Type = 1017;
	THREE.UnsignedShort565Type = 1018;
	
	// Pixel formats
	
	THREE.AlphaFormat = 1019;
	THREE.RGBFormat = 1020;
	THREE.RGBAFormat = 1021;
	THREE.LuminanceFormat = 1022;
	THREE.LuminanceAlphaFormat = 1023;
	// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
	THREE.RGBEFormat = THREE.RGBAFormat; //1024;
	
	// DDS / ST3C Compressed texture formats
	
	THREE.RGB_S3TC_DXT1_Format = 2001;
	THREE.RGBA_S3TC_DXT1_Format = 2002;
	THREE.RGBA_S3TC_DXT3_Format = 2003;
	THREE.RGBA_S3TC_DXT5_Format = 2004;
	
	
	// PVRTC compressed texture formats
	
	THREE.RGB_PVRTC_4BPPV1_Format = 2100;
	THREE.RGB_PVRTC_2BPPV1_Format = 2101;
	THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
	THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
	
	// Loop styles for AnimationAction
	
	THREE.LoopOnce = 2200;
	THREE.LoopRepeat = 2201;
	THREE.LoopPingPong = 2202;
	
	// DEPRECATED
	
	THREE.Projector = function () {
	
		console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );
	
		this.projectVector = function ( vector, camera ) {
	
			console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );
	
		};
	
		this.unprojectVector = function ( vector, camera ) {
	
			console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );
	
		};
	
		this.pickingRay = function ( vector, camera ) {
	
			console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );
	
		};
	
	};
	
	THREE.CanvasRenderer = function () {
	
		console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );
	
		this.domElement = document.createElement( 'canvas' );
		this.clear = function () {};
		this.render = function () {};
		this.setClearColor = function () {};
		this.setSize = function () {};
	
	};
	
	// File:src/math/Color.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Color = function ( color ) {
	
		if ( arguments.length === 3 ) {
	
			return this.fromArray( arguments );
	
		}
	
		return this.set( color );
	
	};
	
	THREE.Color.prototype = {
	
		constructor: THREE.Color,
	
		r: 1, g: 1, b: 1,
	
		set: function ( value ) {
	
			if ( value instanceof THREE.Color ) {
	
				this.copy( value );
	
			} else if ( typeof value === 'number' ) {
	
				this.setHex( value );
	
			} else if ( typeof value === 'string' ) {
	
				this.setStyle( value );
	
			}
	
			return this;
	
		},
	
		setHex: function ( hex ) {
	
			hex = Math.floor( hex );
	
			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;
	
			return this;
	
		},
	
		setRGB: function ( r, g, b ) {
	
			this.r = r;
			this.g = g;
			this.b = b;
	
			return this;
	
		},
	
		setHSL: function () {
	
			function hue2rgb( p, q, t ) {
	
				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;
	
			}
	
			return function ( h, s, l ) {
	
				// h,s,l ranges are in 0.0 - 1.0
				h = THREE.Math.euclideanModulo( h, 1 );
				s = THREE.Math.clamp( s, 0, 1 );
				l = THREE.Math.clamp( l, 0, 1 );
	
				if ( s === 0 ) {
	
					this.r = this.g = this.b = l;
	
				} else {
	
					var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
					var q = ( 2 * l ) - p;
	
					this.r = hue2rgb( q, p, h + 1 / 3 );
					this.g = hue2rgb( q, p, h );
					this.b = hue2rgb( q, p, h - 1 / 3 );
	
				}
	
				return this;
	
			};
	
		}(),
	
		setStyle: function ( style ) {
	
			function handleAlpha( string ) {
	
				if ( string === undefined ) return;
	
				if ( parseFloat( string ) < 1 ) {
	
					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );
	
				}
	
			}
	
	
			var m;
	
			if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {
	
				// rgb / hsl
	
				var color;
				var name = m[ 1 ];
				var components = m[ 2 ];
	
				switch ( name ) {
	
					case 'rgb':
					case 'rgba':
	
						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
	
							handleAlpha( color[ 5 ] );
	
							return this;
	
						}
	
						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
	
							handleAlpha( color[ 5 ] );
	
							return this;
	
						}
	
						break;
	
					case 'hsl':
					case 'hsla':
	
						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							var h = parseFloat( color[ 1 ] ) / 360;
							var s = parseInt( color[ 2 ], 10 ) / 100;
							var l = parseInt( color[ 3 ], 10 ) / 100;
	
							handleAlpha( color[ 5 ] );
	
							return this.setHSL( h, s, l );
	
						}
	
						break;
	
				}
	
			} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {
	
				// hex color
	
				var hex = m[ 1 ];
				var size = hex.length;
	
				if ( size === 3 ) {
	
					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;
	
					return this;
	
				} else if ( size === 6 ) {
	
					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;
	
					return this;
	
				}
	
			}
	
			if ( style && style.length > 0 ) {
	
				// color keywords
				var hex = THREE.ColorKeywords[ style ];
	
				if ( hex !== undefined ) {
	
					// red
					this.setHex( hex );
	
				} else {
	
					// unknown color
					console.warn( 'THREE.Color: Unknown color ' + style );
	
				}
	
			}
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor( this.r, this.g, this.b );
	
		},
	
		copy: function ( color ) {
	
			this.r = color.r;
			this.g = color.g;
			this.b = color.b;
	
			return this;
	
		},
	
		copyGammaToLinear: function ( color, gammaFactor ) {
	
			if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );
	
			return this;
	
		},
	
		copyLinearToGamma: function ( color, gammaFactor ) {
	
			if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;
	
			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );
	
			return this;
	
		},
	
		convertGammaToLinear: function () {
	
			var r = this.r, g = this.g, b = this.b;
	
			this.r = r * r;
			this.g = g * g;
			this.b = b * b;
	
			return this;
	
		},
	
		convertLinearToGamma: function () {
	
			this.r = Math.sqrt( this.r );
			this.g = Math.sqrt( this.g );
			this.b = Math.sqrt( this.b );
	
			return this;
	
		},
	
		getHex: function () {
	
			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;
	
		},
	
		getHexString: function () {
	
			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );
	
		},
	
		getHSL: function ( optionalTarget ) {
	
			// h,s,l ranges are in 0.0 - 1.0
	
			var hsl = optionalTarget || { h: 0, s: 0, l: 0 };
	
			var r = this.r, g = this.g, b = this.b;
	
			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );
	
			var hue, saturation;
			var lightness = ( min + max ) / 2.0;
	
			if ( min === max ) {
	
				hue = 0;
				saturation = 0;
	
			} else {
	
				var delta = max - min;
	
				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );
	
				switch ( max ) {
	
					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;
	
				}
	
				hue /= 6;
	
			}
	
			hsl.h = hue;
			hsl.s = saturation;
			hsl.l = lightness;
	
			return hsl;
	
		},
	
		getStyle: function () {
	
			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';
	
		},
	
		offsetHSL: function ( h, s, l ) {
	
			var hsl = this.getHSL();
	
			hsl.h += h; hsl.s += s; hsl.l += l;
	
			this.setHSL( hsl.h, hsl.s, hsl.l );
	
			return this;
	
		},
	
		add: function ( color ) {
	
			this.r += color.r;
			this.g += color.g;
			this.b += color.b;
	
			return this;
	
		},
	
		addColors: function ( color1, color2 ) {
	
			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.r += s;
			this.g += s;
			this.b += s;
	
			return this;
	
		},
	
		multiply: function ( color ) {
	
			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			this.r *= s;
			this.g *= s;
			this.b *= s;
	
			return this;
	
		},
	
		lerp: function ( color, alpha ) {
	
			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;
	
			return this;
	
		},
	
		equals: function ( c ) {
	
			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;
	
			return array;
	
		}
	
	};
	
	THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };
	
	// File:src/math/Quaternion.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Quaternion = function ( x, y, z, w ) {
	
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;
	
	};
	
	THREE.Quaternion.prototype = {
	
		constructor: THREE.Quaternion,
	
		get x () {
	
			return this._x;
	
		},
	
		set x ( value ) {
	
			this._x = value;
			this.onChangeCallback();
	
		},
	
		get y () {
	
			return this._y;
	
		},
	
		set y ( value ) {
	
			this._y = value;
			this.onChangeCallback();
	
		},
	
		get z () {
	
			return this._z;
	
		},
	
		set z ( value ) {
	
			this._z = value;
			this.onChangeCallback();
	
		},
	
		get w () {
	
			return this._w;
	
		},
	
		set w ( value ) {
	
			this._w = value;
			this.onChangeCallback();
	
		},
	
		set: function ( x, y, z, w ) {
	
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor( this._x, this._y, this._z, this._w );
	
		},
	
		copy: function ( quaternion ) {
	
			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromEuler: function ( euler, update ) {
	
			if ( euler instanceof THREE.Euler === false ) {
	
				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
	
			}
	
			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m
	
			var c1 = Math.cos( euler._x / 2 );
			var c2 = Math.cos( euler._y / 2 );
			var c3 = Math.cos( euler._z / 2 );
			var s1 = Math.sin( euler._x / 2 );
			var s2 = Math.sin( euler._y / 2 );
			var s3 = Math.sin( euler._z / 2 );
	
			var order = euler.order;
	
			if ( order === 'XYZ' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'YXZ' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( order === 'ZXY' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'ZYX' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( order === 'YZX' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'XZY' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			}
	
			if ( update !== false ) this.onChangeCallback();
	
			return this;
	
		},
	
		setFromAxisAngle: function ( axis, angle ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	
			// assumes axis is normalized
	
			var halfAngle = angle / 2, s = Math.sin( halfAngle );
	
			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var te = m.elements,
	
				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],
	
				trace = m11 + m22 + m33,
				s;
	
			if ( trace > 0 ) {
	
				s = 0.5 / Math.sqrt( trace + 1.0 );
	
				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;
	
			} else if ( m11 > m22 && m11 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
	
				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;
	
			} else if ( m22 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
	
				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;
	
			} else {
	
				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
	
				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;
	
			}
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromUnitVectors: function () {
	
			// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
	
			// assumes direction vectors vFrom and vTo are normalized
	
			var v1, r;
	
			var EPS = 0.000001;
	
			return function ( vFrom, vTo ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				r = vFrom.dot( vTo ) + 1;
	
				if ( r < EPS ) {
	
					r = 0;
	
					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
	
						v1.set( - vFrom.y, vFrom.x, 0 );
	
					} else {
	
						v1.set( 0, - vFrom.z, vFrom.y );
	
					}
	
				} else {
	
					v1.crossVectors( vFrom, vTo );
	
				}
	
				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;
	
				this.normalize();
	
				return this;
	
			}
	
		}(),
	
		inverse: function () {
	
			this.conjugate().normalize();
	
			return this;
	
		},
	
		conjugate: function () {
	
			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	
		},
	
		lengthSq: function () {
	
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	
		},
	
		length: function () {
	
			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );
	
		},
	
		normalize: function () {
	
			var l = this.length();
	
			if ( l === 0 ) {
	
				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;
	
			} else {
	
				l = 1 / l;
	
				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;
	
			}
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		multiply: function ( q, p ) {
	
			if ( p !== undefined ) {
	
				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );
	
			}
	
			return this.multiplyQuaternions( this, q );
	
		},
	
		multiplyQuaternions: function ( a, b ) {
	
			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	
			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
	
			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		multiplyVector3: function ( vector ) {
	
			console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion( this );
	
		},
	
		slerp: function ( qb, t ) {
	
			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );
	
			var x = this._x, y = this._y, z = this._z, w = this._w;
	
			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	
			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
	
			if ( cosHalfTheta < 0 ) {
	
				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;
	
				cosHalfTheta = - cosHalfTheta;
	
			} else {
	
				this.copy( qb );
	
			}
	
			if ( cosHalfTheta >= 1.0 ) {
	
				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;
	
				return this;
	
			}
	
			var halfTheta = Math.acos( cosHalfTheta );
			var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );
	
			if ( Math.abs( sinHalfTheta ) < 0.001 ) {
	
				this._w = 0.5 * ( w + this._w );
				this._x = 0.5 * ( x + this._x );
				this._y = 0.5 * ( y + this._y );
				this._z = 0.5 * ( z + this._z );
	
				return this;
	
			}
	
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
	
			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		equals: function ( quaternion ) {
	
			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;
	
			return array;
	
		},
	
		onChange: function ( callback ) {
	
			this.onChangeCallback = callback;
	
			return this;
	
		},
	
		onChangeCallback: function () {}
	
	};
	
	THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {
	
		return qm.copy( qa ).slerp( qb, t );
	
	};
	
	// File:src/math/Vector2.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.Vector2 = function ( x, y ) {
	
		this.x = x || 0;
		this.y = y || 0;
	
	};
	
	THREE.Vector2.prototype = {
	
		constructor: THREE.Vector2,
	
		get width() { return this.x },
		set width( value ) { this.x = value },
	
		get height() { return this.y },
		set height( value ) { this.y = value },
	
		//
	
		set: function ( x, y ) {
	
			this.x = x;
			this.y = y;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		clone: function () {
	
			return new this.constructor( this.x, this.y );
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
	
			return this;
	
		},
	
		addScaledVector: function ( v, s ) {
	
			this.x += v.x * s;
			this.y += v.y * s;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
	
			return this;
	
		},
	
		subScalar: function ( s ) {
	
			this.x -= s;
			this.y -= s;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
	
			return this;
	
		},
	
		multiply: function ( v ) {
	
			this.x *= v.x;
			this.y *= v.y;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			if ( isFinite( scalar ) ) {
				this.x *= scalar;
				this.y *= scalar;
			} else {
				this.x = 0;
				this.y = 0;
			}
	
			return this;
	
		},
	
		divide: function ( v ) {
	
			this.x /= v.x;
			this.y /= v.y;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			return this.multiplyScalar( 1 / scalar );
	
		},
	
		min: function ( v ) {
	
			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
	
			return this;
	
		},
	
		max: function ( v ) {
	
			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
	
			return this;
	
		},
	
		clampScalar: function () {
	
			var min, max;
	
			return function clampScalar( minVal, maxVal ) {
	
				if ( min === undefined ) {
	
					min = new THREE.Vector2();
					max = new THREE.Vector2();
	
				}
	
				min.set( minVal, minVal );
				max.set( maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		}(),
	
		clampLength: function ( min, max ) {
	
			var length = this.length();
	
			this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );
	
			return this;
	
		},
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y );
	
		},
	
		lengthManhattan: function() {
	
			return Math.abs( this.x ) + Math.abs( this.y );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		distanceTo: function ( v ) {
	
			return Math.sqrt( this.distanceToSquared( v ) );
	
		},
	
		distanceToSquared: function ( v ) {
	
			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;
	
		},
	
		setLength: function ( length ) {
	
			return this.multiplyScalar( length / this.length() );
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
	
			return this;
	
		},
	
		lerpVectors: function ( v1, v2, alpha ) {
	
			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			return this;
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
	
			return array;
	
		},
	
		fromAttribute: function ( attribute, index, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			index = index * attribute.itemSize + offset;
	
			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
	
			return this;
	
		},
	
		rotateAround: function ( center, angle ) {
	
			var c = Math.cos( angle ), s = Math.sin( angle );
	
			var x = this.x - center.x;
			var y = this.y - center.y;
	
			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;
	
			return this;
	
		}
	
	};
	
	// File:src/math/Vector3.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author *kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Vector3 = function ( x, y, z ) {
	
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
	
	};
	
	THREE.Vector3.prototype = {
	
		constructor: THREE.Vector3,
	
		set: function ( x, y, z ) {
	
			this.x = x;
			this.y = y;
			this.z = z;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setZ: function ( z ) {
	
			this.z = z;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		clone: function () {
	
			return new this.constructor( this.x, this.y, this.z );
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
			this.z += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
	
			return this;
	
		},
	
		addScaledVector: function ( v, s ) {
	
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
	
			return this;
	
		},
	
		subScalar: function ( s ) {
	
			this.x -= s;
			this.y -= s;
			this.z -= s;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
	
			return this;
	
		},
	
		multiply: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );
	
			}
	
			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			if ( isFinite( scalar ) ) {
				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;
			} else {
				this.x = 0;
				this.y = 0;
				this.z = 0;
			}
	
			return this;
	
		},
	
		multiplyVectors: function ( a, b ) {
	
			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;
	
			return this;
	
		},
	
		applyEuler: function () {
	
			var quaternion;
	
			return function applyEuler( euler ) {
	
				if ( euler instanceof THREE.Euler === false ) {
	
					console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );
	
				}
	
				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();
	
				this.applyQuaternion( quaternion.setFromEuler( euler ) );
	
				return this;
	
			};
	
		}(),
	
		applyAxisAngle: function () {
	
			var quaternion;
	
			return function applyAxisAngle( axis, angle ) {
	
				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();
	
				this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );
	
				return this;
	
			};
	
		}(),
	
		applyMatrix3: function ( m ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;
	
			return this;
	
		},
	
		applyMatrix4: function ( m ) {
	
			// input: THREE.Matrix4 affine matrix
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];
	
			return this;
	
		},
	
		applyProjection: function ( m ) {
	
			// input: THREE.Matrix4 projection matrix
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
			var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide
	
			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;
	
			return this;
	
		},
	
		applyQuaternion: function ( q ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
	
			var qx = q.x;
			var qy = q.y;
			var qz = q.z;
			var qw = q.w;
	
			// calculate quat * vector
	
			var ix =  qw * x + qy * z - qz * y;
			var iy =  qw * y + qz * x - qx * z;
			var iz =  qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;
	
			// calculate result * inverse quat
	
			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;
	
			return this;
	
		},
	
		project: function () {
	
			var matrix;
	
			return function project( camera ) {
	
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
	
				matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
				return this.applyProjection( matrix );
	
			};
	
		}(),
	
		unproject: function () {
	
			var matrix;
	
			return function unproject( camera ) {
	
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
	
				matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
				return this.applyProjection( matrix );
	
			};
	
		}(),
	
		transformDirection: function ( m ) {
	
			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;
	
			this.normalize();
	
			return this;
	
		},
	
		divide: function ( v ) {
	
			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			return this.multiplyScalar( 1 / scalar );
	
		},
	
		min: function ( v ) {
	
			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
	
			return this;
	
		},
	
		max: function ( v ) {
	
			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
	
			return this;
	
		},
	
		clampScalar: function () {
	
			var min, max;
	
			return function clampScalar( minVal, maxVal ) {
	
				if ( min === undefined ) {
	
					min = new THREE.Vector3();
					max = new THREE.Vector3();
	
				}
	
				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		}(),
	
		clampLength: function ( min, max ) {
	
			var length = this.length();
	
			this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );
	
			return this;
	
		},
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y + this.z * v.z;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y + this.z * this.z;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
	
		},
	
		lengthManhattan: function () {
	
			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		setLength: function ( length ) {
	
			return this.multiplyScalar( length / this.length() );
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
	
			return this;
	
		},
	
		lerpVectors: function ( v1, v2, alpha ) {
	
			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			return this;
	
		},
	
		cross: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );
	
			}
	
			var x = this.x, y = this.y, z = this.z;
	
			this.x = y * v.z - z * v.y;
			this.y = z * v.x - x * v.z;
			this.z = x * v.y - y * v.x;
	
			return this;
	
		},
	
		crossVectors: function ( a, b ) {
	
			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;
	
			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;
	
			return this;
	
		},
	
		projectOnVector: function () {
	
			var v1, dot;
	
			return function projectOnVector( vector ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				v1.copy( vector ).normalize();
	
				dot = this.dot( v1 );
	
				return this.copy( v1 ).multiplyScalar( dot );
	
			};
	
		}(),
	
		projectOnPlane: function () {
	
			var v1;
	
			return function projectOnPlane( planeNormal ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				v1.copy( this ).projectOnVector( planeNormal );
	
				return this.sub( v1 );
	
			}
	
		}(),
	
		reflect: function () {
	
			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length
	
			var v1;
	
			return function reflect( normal ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );
	
			}
	
		}(),
	
		angleTo: function ( v ) {
	
			var theta = this.dot( v ) / ( this.length() * v.length() );
	
			// clamp, to handle numerical problems
	
			return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );
	
		},
	
		distanceTo: function ( v ) {
	
			return Math.sqrt( this.distanceToSquared( v ) );
	
		},
	
		distanceToSquared: function ( v ) {
	
			var dx = this.x - v.x;
			var dy = this.y - v.y;
			var dz = this.z - v.z;
	
			return dx * dx + dy * dy + dz * dz;
	
		},
	
		setEulerFromRotationMatrix: function ( m, order ) {
	
			console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
	
		},
	
		setEulerFromQuaternion: function ( q, order ) {
	
			console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
	
		},
	
		getPositionFromMatrix: function ( m ) {
	
			console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
	
			return this.setFromMatrixPosition( m );
	
		},
	
		getScaleFromMatrix: function ( m ) {
	
			console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
	
			return this.setFromMatrixScale( m );
	
		},
	
		getColumnFromMatrix: function ( index, matrix ) {
	
			console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
	
			return this.setFromMatrixColumn( index, matrix );
	
		},
	
		setFromMatrixPosition: function ( m ) {
	
			this.x = m.elements[ 12 ];
			this.y = m.elements[ 13 ];
			this.z = m.elements[ 14 ];
	
			return this;
	
		},
	
		setFromMatrixScale: function ( m ) {
	
			var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[ 2 ] ).length();
			var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[ 6 ] ).length();
			var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();
	
			this.x = sx;
			this.y = sy;
			this.z = sz;
	
			return this;
	
		},
	
		setFromMatrixColumn: function ( index, matrix ) {
	
			var offset = index * 4;
	
			var me = matrix.elements;
	
			this.x = me[ offset ];
			this.y = me[ offset + 1 ];
			this.z = me[ offset + 2 ];
	
			return this;
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
	
			return array;
	
		},
	
		fromAttribute: function ( attribute, index, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			index = index * attribute.itemSize + offset;
	
			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];
	
			return this;
	
		}
	
	};
	
	// File:src/math/Vector4.js
	
	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Vector4 = function ( x, y, z, w ) {
	
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;
	
	};
	
	THREE.Vector4.prototype = {
	
		constructor: THREE.Vector4,
	
		set: function ( x, y, z, w ) {
	
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setZ: function ( z ) {
	
			this.z = z;
	
			return this;
	
		},
	
		setW: function ( w ) {
	
			this.w = w;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		clone: function () {
	
			return new this.constructor( this.x, this.y, this.z, this.w );
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;
	
			return this;
	
		},
	
		addScaledVector: function ( v, s ) {
	
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;
	
			return this;
	
		},
	
		subScalar: function ( s ) {
	
			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			if ( isFinite( scalar ) ) {
				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;
				this.w *= scalar;
			} else {
				this.x = 0;
				this.y = 0;
				this.z = 0;
				this.w = 0;
			}
	
			return this;
	
		},
	
		applyMatrix4: function ( m ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
			var w = this.w;
	
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			return this.multiplyScalar( 1 / scalar );
	
		},
	
		setAxisAngleFromQuaternion: function ( q ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	
			// q is assumed to be normalized
	
			this.w = 2 * Math.acos( q.w );
	
			var s = Math.sqrt( 1 - q.w * q.w );
	
			if ( s < 0.0001 ) {
	
				 this.x = 1;
				 this.y = 0;
				 this.z = 0;
	
			} else {
	
				 this.x = q.x / s;
				 this.y = q.y / s;
				 this.z = q.z / s;
	
			}
	
			return this;
	
		},
	
		setAxisAngleFromRotationMatrix: function ( m ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees
	
				te = m.elements,
	
				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
			if ( ( Math.abs( m12 - m21 ) < epsilon )
			   && ( Math.abs( m13 - m31 ) < epsilon )
			   && ( Math.abs( m23 - m32 ) < epsilon ) ) {
	
				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms
	
				if ( ( Math.abs( m12 + m21 ) < epsilon2 )
				   && ( Math.abs( m13 + m31 ) < epsilon2 )
				   && ( Math.abs( m23 + m32 ) < epsilon2 )
				   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {
	
					// this singularity is identity matrix so angle = 0
	
					this.set( 1, 0, 0, 0 );
	
					return this; // zero angle, arbitrary axis
	
				}
	
				// otherwise this singularity is angle = 180
	
				angle = Math.PI;
	
				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;
	
				if ( ( xx > yy ) && ( xx > zz ) ) {
	
					// m11 is the largest diagonal term
	
					if ( xx < epsilon ) {
	
						x = 0;
						y = 0.707106781;
						z = 0.707106781;
	
					} else {
	
						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;
	
					}
	
				} else if ( yy > zz ) {
	
					// m22 is the largest diagonal term
	
					if ( yy < epsilon ) {
	
						x = 0.707106781;
						y = 0;
						z = 0.707106781;
	
					} else {
	
						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;
	
					}
	
				} else {
	
					// m33 is the largest diagonal term so base result on this
	
					if ( zz < epsilon ) {
	
						x = 0.707106781;
						y = 0.707106781;
						z = 0;
	
					} else {
	
						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;
	
					}
	
				}
	
				this.set( x, y, z, angle );
	
				return this; // return 180 deg rotation
	
			}
	
			// as we have reached here there are no singularities so we can handle normally
	
			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
							  + ( m13 - m31 ) * ( m13 - m31 )
							  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize
	
			if ( Math.abs( s ) < 0.001 ) s = 1;
	
			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case
	
			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );
	
			return this;
	
		},
	
		min: function ( v ) {
	
			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );
	
			return this;
	
		},
	
		max: function ( v ) {
	
			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );
	
			return this;
	
		},
	
		clampScalar: function () {
	
			var min, max;
	
			return function clampScalar( minVal, maxVal ) {
	
				if ( min === undefined ) {
	
					min = new THREE.Vector4();
					max = new THREE.Vector4();
	
				}
	
				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		}(),
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
	
		},
	
		lengthManhattan: function () {
	
			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		setLength: function ( length ) {
	
			return this.multiplyScalar( length / this.length() );
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;
	
			return this;
	
		},
	
		lerpVectors: function ( v1, v2, alpha ) {
	
			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			return this;
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;
	
			return array;
	
		},
	
		fromAttribute: function ( attribute, index, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			index = index * attribute.itemSize + offset;
	
			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];
			this.w = attribute.array[ index + 3 ];
	
			return this;
	
		}
	
	};
	
	// File:src/math/Euler.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Euler = function ( x, y, z, order ) {
	
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || THREE.Euler.DefaultOrder;
	
	};
	
	THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];
	
	THREE.Euler.DefaultOrder = 'XYZ';
	
	THREE.Euler.prototype = {
	
		constructor: THREE.Euler,
	
		get x () {
	
			return this._x;
	
		},
	
		set x ( value ) {
	
			this._x = value;
			this.onChangeCallback();
	
		},
	
		get y () {
	
			return this._y;
	
		},
	
		set y ( value ) {
	
			this._y = value;
			this.onChangeCallback();
	
		},
	
		get z () {
	
			return this._z;
	
		},
	
		set z ( value ) {
	
			this._z = value;
			this.onChangeCallback();
	
		},
	
		get order () {
	
			return this._order;
	
		},
	
		set order ( value ) {
	
			this._order = value;
			this.onChangeCallback();
	
		},
	
		set: function ( x, y, z, order ) {
	
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor( this._x, this._y, this._z, this._order);
	
		},
	
		copy: function ( euler ) {
	
			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m, order, update ) {
	
			var clamp = THREE.Math.clamp;
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
			order = order || this._order;
	
			if ( order === 'XYZ' ) {
	
				this._y = Math.asin( clamp( m13, - 1, 1 ) );
	
				if ( Math.abs( m13 ) < 0.99999 ) {
	
					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );
	
				} else {
	
					this._x = Math.atan2( m32, m22 );
					this._z = 0;
	
				}
	
			} else if ( order === 'YXZ' ) {
	
				this._x = Math.asin( - clamp( m23, - 1, 1 ) );
	
				if ( Math.abs( m23 ) < 0.99999 ) {
	
					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );
	
				} else {
	
					this._y = Math.atan2( - m31, m11 );
					this._z = 0;
	
				}
	
			} else if ( order === 'ZXY' ) {
	
				this._x = Math.asin( clamp( m32, - 1, 1 ) );
	
				if ( Math.abs( m32 ) < 0.99999 ) {
	
					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );
	
				} else {
	
					this._y = 0;
					this._z = Math.atan2( m21, m11 );
	
				}
	
			} else if ( order === 'ZYX' ) {
	
				this._y = Math.asin( - clamp( m31, - 1, 1 ) );
	
				if ( Math.abs( m31 ) < 0.99999 ) {
	
					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );
	
				} else {
	
					this._x = 0;
					this._z = Math.atan2( - m12, m22 );
	
				}
	
			} else if ( order === 'YZX' ) {
	
				this._z = Math.asin( clamp( m21, - 1, 1 ) );
	
				if ( Math.abs( m21 ) < 0.99999 ) {
	
					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );
	
				} else {
	
					this._x = 0;
					this._y = Math.atan2( m13, m33 );
	
				}
	
			} else if ( order === 'XZY' ) {
	
				this._z = Math.asin( - clamp( m12, - 1, 1 ) );
	
				if ( Math.abs( m12 ) < 0.99999 ) {
	
					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );
	
				} else {
	
					this._x = Math.atan2( - m23, m33 );
					this._y = 0;
	
				}
	
			} else {
	
				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )
	
			}
	
			this._order = order;
	
			if ( update !== false ) this.onChangeCallback();
	
			return this;
	
		},
	
		setFromQuaternion: function () {
	
			var matrix;
	
			return function ( q, order, update ) {
	
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
				matrix.makeRotationFromQuaternion( q );
				this.setFromRotationMatrix( matrix, order, update );
	
				return this;
	
			};
	
		}(),
	
		setFromVector3: function ( v, order ) {
	
			return this.set( v.x, v.y, v.z, order || this._order );
	
		},
	
		reorder: function () {
	
			// WARNING: this discards revolution information -bhouston
	
			var q = new THREE.Quaternion();
	
			return function ( newOrder ) {
	
				q.setFromEuler( this );
				this.setFromQuaternion( q, newOrder );
	
			};
	
		}(),
	
		equals: function ( euler ) {
	
			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );
	
		},
	
		fromArray: function ( array ) {
	
			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;
	
			return array;
	
		},
	
		toVector3: function ( optionalResult ) {
	
			if ( optionalResult ) {
	
				return optionalResult.set( this._x, this._y, this._z );
	
			} else {
	
				return new THREE.Vector3( this._x, this._y, this._z );
	
			}
	
		},
	
		onChange: function ( callback ) {
	
			this.onChangeCallback = callback;
	
			return this;
	
		},
	
		onChangeCallback: function () {}
	
	};
	
	// File:src/math/Line3.js
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Line3 = function ( start, end ) {
	
		this.start = ( start !== undefined ) ? start : new THREE.Vector3();
		this.end = ( end !== undefined ) ? end : new THREE.Vector3();
	
	};
	
	THREE.Line3.prototype = {
	
		constructor: THREE.Line3,
	
		set: function ( start, end ) {
	
			this.start.copy( start );
			this.end.copy( end );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( line ) {
	
			this.start.copy( line.start );
			this.end.copy( line.end );
	
			return this;
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );
	
		},
	
		delta: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.end, this.start );
	
		},
	
		distanceSq: function () {
	
			return this.start.distanceToSquared( this.end );
	
		},
	
		distance: function () {
	
			return this.start.distanceTo( this.end );
	
		},
	
		at: function ( t, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			return this.delta( result ).multiplyScalar( t ).add( this.start );
	
		},
	
		closestPointToPointParameter: function () {
	
			var startP = new THREE.Vector3();
			var startEnd = new THREE.Vector3();
	
			return function ( point, clampToLine ) {
	
				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );
	
				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );
	
				var t = startEnd_startP / startEnd2;
	
				if ( clampToLine ) {
	
					t = THREE.Math.clamp( t, 0, 1 );
	
				}
	
				return t;
	
			};
	
		}(),
	
		closestPointToPoint: function ( point, clampToLine, optionalTarget ) {
	
			var t = this.closestPointToPointParameter( point, clampToLine );
	
			var result = optionalTarget || new THREE.Vector3();
	
			return this.delta( result ).multiplyScalar( t ).add( this.start );
	
		},
	
		applyMatrix4: function ( matrix ) {
	
			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );
	
			return this;
	
		},
	
		equals: function ( line ) {
	
			return line.start.equals( this.start ) && line.end.equals( this.end );
	
		}
	
	};
	
	// File:src/math/Box2.js
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Box2 = function ( min, max ) {
	
		this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );
	
	};
	
	THREE.Box2.prototype = {
	
		constructor: THREE.Box2,
	
		set: function ( min, max ) {
	
			this.min.copy( min );
			this.max.copy( max );
	
			return this;
	
		},
	
		setFromPoints: function ( points ) {
	
			this.makeEmpty();
	
			for ( var i = 0, il = points.length; i < il; i ++ ) {
	
				this.expandByPoint( points[ i ] )
	
			}
	
			return this;
	
		},
	
		setFromCenterAndSize: function () {
	
			var v1 = new THREE.Vector2();
	
			return function ( center, size ) {
	
				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );
	
				return this;
	
			};
	
		}(),
		
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( box ) {
	
			this.min.copy( box.min );
			this.max.copy( box.max );
	
			return this;
	
		},
	
		makeEmpty: function () {
	
			this.min.x = this.min.y = Infinity;
			this.max.x = this.max.y = - Infinity;
	
			return this;
	
		},
	
		empty: function () {
	
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
		},
	
		size: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.subVectors( this.max, this.min );
	
		},
	
		expandByPoint: function ( point ) {
	
			this.min.min( point );
			this.max.max( point );
	
			return this;
	
		},
	
		expandByVector: function ( vector ) {
	
			this.min.sub( vector );
			this.max.add( vector );
	
			return this;
	
		},
	
		expandByScalar: function ( scalar ) {
	
			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );
	
			return this;
	
		},
	
		containsPoint: function ( point ) {
	
			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		containsBox: function ( box ) {
	
			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		getParameter: function ( point, optionalTarget ) {
	
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
	
			var result = optionalTarget || new THREE.Vector2();
	
			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);
	
		},
	
		isIntersectionBox: function ( box ) {
	
			// using 6 splitting planes to rule out intersections.
	
			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.copy( point ).clamp( this.min, this.max );
	
		},
	
		distanceToPoint: function () {
	
			var v1 = new THREE.Vector2();
	
			return function ( point ) {
	
				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();
	
			};
	
		}(),
	
		intersect: function ( box ) {
	
			this.min.max( box.min );
			this.max.min( box.max );
	
			return this;
	
		},
	
		union: function ( box ) {
	
			this.min.min( box.min );
			this.max.max( box.max );
	
			return this;
	
		},
	
		translate: function ( offset ) {
	
			this.min.add( offset );
			this.max.add( offset );
	
			return this;
	
		},
	
		equals: function ( box ) {
	
			return box.min.equals( this.min ) && box.max.equals( this.max );
	
		}
	
	};
	
	// File:src/math/Box3.js
	
	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Box3 = function ( min, max ) {
	
		this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );
	
	};
	
	THREE.Box3.prototype = {
	
		constructor: THREE.Box3,
	
		set: function ( min, max ) {
	
			this.min.copy( min );
			this.max.copy( max );
	
			return this;
	
		},
	
		setFromPoints: function ( points ) {
	
			this.makeEmpty();
	
			for ( var i = 0, il = points.length; i < il; i ++ ) {
	
				this.expandByPoint( points[ i ] );
	
			}
	
			return this;
	
		},
	
		setFromCenterAndSize: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( center, size ) {
	
				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
	
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );
	
				return this;
	
			};
	
		}(),
	
		setFromObject: function () {
	
			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms
	
			var v1 = new THREE.Vector3();
	
			return function ( object ) {
	
				var scope = this;
	
				object.updateMatrixWorld( true );
	
				this.makeEmpty();
	
				object.traverse( function ( node ) {
	
					var geometry = node.geometry;
	
					if ( geometry !== undefined ) {
	
						if ( geometry instanceof THREE.Geometry ) {
	
							var vertices = geometry.vertices;
	
							for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
								v1.copy( vertices[ i ] );
	
								v1.applyMatrix4( node.matrixWorld );
	
								scope.expandByPoint( v1 );
	
							}
	
						} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {
	
							var positions = geometry.attributes[ 'position' ].array;
	
							for ( var i = 0, il = positions.length; i < il; i += 3 ) {
	
								v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
	
								v1.applyMatrix4( node.matrixWorld );
	
								scope.expandByPoint( v1 );
	
							}
	
						}
	
					}
	
				} );
	
				return this;
	
			};
	
		}(),
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( box ) {
	
			this.min.copy( box.min );
			this.max.copy( box.max );
	
			return this;
	
		},
	
		makeEmpty: function () {
	
			this.min.x = this.min.y = this.min.z = Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;
	
			return this;
	
		},
	
		empty: function () {
	
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
		},
	
		size: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.max, this.min );
	
		},
	
		expandByPoint: function ( point ) {
	
			this.min.min( point );
			this.max.max( point );
	
			return this;
	
		},
	
		expandByVector: function ( vector ) {
	
			this.min.sub( vector );
			this.max.add( vector );
	
			return this;
	
		},
	
		expandByScalar: function ( scalar ) {
	
			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );
	
			return this;
	
		},
	
		containsPoint: function ( point ) {
	
			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ||
			     point.z < this.min.z || point.z > this.max.z ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		containsBox: function ( box ) {
	
			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
				 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
				 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		getParameter: function ( point, optionalTarget ) {
	
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
	
			var result = optionalTarget || new THREE.Vector3();
	
			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);
	
		},
	
		isIntersectionBox: function ( box ) {
	
			// using 6 splitting planes to rule out intersections.
	
			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ||
			     box.max.z < this.min.z || box.min.z > this.max.z ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( point ).clamp( this.min, this.max );
	
		},
	
		distanceToPoint: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( point ) {
	
				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();
	
			};
	
		}(),
	
		getBoundingSphere: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Sphere();
	
				result.center = this.center();
				result.radius = this.size( v1 ).length() * 0.5;
	
				return result;
	
			};
	
		}(),
	
		intersect: function ( box ) {
	
			this.min.max( box.min );
			this.max.min( box.max );
	
			return this;
	
		},
	
		union: function ( box ) {
	
			this.min.min( box.min );
			this.max.max( box.max );
	
			return this;
	
		},
	
		applyMatrix4: function () {
	
			var points = [
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3()
			];
	
			return function ( matrix ) {
	
				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111
	
				this.makeEmpty();
				this.setFromPoints( points );
	
				return this;
	
			};
	
		}(),
	
		translate: function ( offset ) {
	
			this.min.add( offset );
			this.max.add( offset );
	
			return this;
	
		},
	
		equals: function ( box ) {
	
			return box.min.equals( this.min ) && box.max.equals( this.max );
	
		}
	
	};
	
	// File:src/math/Matrix3.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Matrix3 = function () {
	
		this.elements = new Float32Array( [
	
			1, 0, 0,
			0, 1, 0,
			0, 0, 1
	
		] );
	
		if ( arguments.length > 0 ) {
	
			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );
	
		}
	
	};
	
	THREE.Matrix3.prototype = {
	
		constructor: THREE.Matrix3,
	
		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
	
			var te = this.elements;
	
			te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
			te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
			te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;
	
			return this;
	
		},
	
		identity: function () {
	
			this.set(
	
				1, 0, 0,
				0, 1, 0,
				0, 0, 1
	
			);
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().fromArray( this.elements );
	
		},
	
		copy: function ( m ) {
	
			var me = m.elements;
	
			this.set(
	
				me[ 0 ], me[ 3 ], me[ 6 ],
				me[ 1 ], me[ 4 ], me[ 7 ],
				me[ 2 ], me[ 5 ], me[ 8 ]
	
			);
	
			return this;
	
		},
	
		multiplyVector3: function ( vector ) {
	
			console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );
	
		},
	
		multiplyVector3Array: function ( a ) {
	
			console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );
	
		},
	
		applyToVector3Array: function () {
	
			var v1;
	
			return function ( array, offset, length ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;
	
				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {
	
					v1.fromArray( array, j );
					v1.applyMatrix3( this );
					v1.toArray( array, j );
	
				}
	
				return array;
	
			};
	
		}(),
	
		applyToBuffer: function () {
	
			var v1;
	
			return function applyToBuffer( buffer, offset, length ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = buffer.length / buffer.itemSize;
	
				for ( var i = 0, j = offset; i < length; i ++, j ++ ) {
	
					v1.x = buffer.getX( j );
					v1.y = buffer.getY( j );
					v1.z = buffer.getZ( j );
	
					v1.applyMatrix3( this );
	
					buffer.setXYZ( v1.x, v1.y, v1.z );
	
				}
	
				return buffer;
	
			};
	
		}(),
	
		multiplyScalar: function ( s ) {
	
			var te = this.elements;
	
			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;
	
			return this;
	
		},
	
		determinant: function () {
	
			var te = this.elements;
	
			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];
	
			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	
		},
	
		getInverse: function ( matrix, throwOnInvertible ) {
	
			// input: THREE.Matrix4
			// ( based on http://code.google.com/p/webgl-mjs/ )
	
			var me = matrix.elements;
			var te = this.elements;
	
			te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
			te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
			te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
			te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
			te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
			te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
			te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
			te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
			te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];
	
			var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];
	
			// no inverse
	
			if ( det === 0 ) {
	
				var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";
	
				if ( throwOnInvertible || false ) {
	
					throw new Error( msg );
	
				} else {
	
					console.warn( msg );
	
				}
	
				this.identity();
	
				return this;
	
			}
	
			this.multiplyScalar( 1.0 / det );
	
			return this;
	
		},
	
		transpose: function () {
	
			var tmp, m = this.elements;
	
			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;
	
			return this;
	
		},
	
		flattenToArrayOffset: function ( array, offset ) {
	
			var te = this.elements;
	
			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
	
			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
	
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ]  = te[ 8 ];
	
			return array;
	
		},
	
		getNormalMatrix: function ( m ) {
	
			// input: THREE.Matrix4
	
			this.getInverse( m ).transpose();
	
			return this;
	
		},
	
		transposeIntoArray: function ( r ) {
	
			var m = this.elements;
	
			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];
	
			return this;
	
		},
	
		fromArray: function ( array ) {
	
			this.elements.set( array );
	
			return this;
	
		},
	
		toArray: function () {
	
			var te = this.elements;
	
			return [
				te[ 0 ], te[ 1 ], te[ 2 ],
				te[ 3 ], te[ 4 ], te[ 5 ],
				te[ 6 ], te[ 7 ], te[ 8 ]
			];
	
		}
	
	};
	
	// File:src/math/Matrix4.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Matrix4 = function () {
	
		this.elements = new Float32Array( [
	
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
	
		] );
	
		if ( arguments.length > 0 ) {
	
			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );
	
		}
	
	};
	
	THREE.Matrix4.prototype = {
	
		constructor: THREE.Matrix4,
	
		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
	
			var te = this.elements;
	
			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;
	
			return this;
	
		},
	
		identity: function () {
	
			this.set(
	
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		clone: function () {
	
			return new THREE.Matrix4().fromArray( this.elements );
	
		},
	
		copy: function ( m ) {
	
			this.elements.set( m.elements );
	
			return this;
	
		},
	
		extractPosition: function ( m ) {
	
			console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );
	
		},
	
		copyPosition: function ( m ) {
	
			var te = this.elements;
			var me = m.elements;
	
			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];
	
			return this;
	
		},
	
		extractBasis: function ( xAxis, yAxis, zAxis ) {
	
			var te = this.elements;
	
			xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
			yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
			zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );
	
			return this;
	
		},
	
		makeBasis: function ( xAxis, yAxis, zAxis ) {
	
			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0,       0,       0,       1
			);
	
			return this;
	
		},
	
		extractRotation: function () {
	
			var v1;
	
			return function ( m ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
	
				var te = this.elements;
				var me = m.elements;
	
				var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
				var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
				var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();
	
				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;
	
				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;
	
				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;
	
				return this;
	
			};
	
		}(),
	
		makeRotationFromEuler: function ( euler ) {
	
			if ( euler instanceof THREE.Euler === false ) {
	
				console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
	
			}
	
			var te = this.elements;
	
			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );
	
			if ( euler.order === 'XYZ' ) {
	
				var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;
	
				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;
	
				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'YXZ' ) {
	
				var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;
	
				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;
	
				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'ZXY' ) {
	
				var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;
	
				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;
	
				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'ZYX' ) {
	
				var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;
	
				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;
	
				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'YZX' ) {
	
				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;
	
				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;
	
				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;
	
			} else if ( euler.order === 'XZY' ) {
	
				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;
	
				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;
	
				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;
	
			}
	
			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;
	
			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;
	
			return this;
	
		},
	
		setRotationFromQuaternion: function ( q ) {
	
			console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
	
			return this.makeRotationFromQuaternion( q );
	
		},
	
		makeRotationFromQuaternion: function ( q ) {
	
			var te = this.elements;
	
			var x = q.x, y = q.y, z = q.z, w = q.w;
			var x2 = x + x, y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;
	
			te[ 0 ] = 1 - ( yy + zz );
			te[ 4 ] = xy - wz;
			te[ 8 ] = xz + wy;
	
			te[ 1 ] = xy + wz;
			te[ 5 ] = 1 - ( xx + zz );
			te[ 9 ] = yz - wx;
	
			te[ 2 ] = xz - wy;
			te[ 6 ] = yz + wx;
			te[ 10 ] = 1 - ( xx + yy );
	
			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;
	
			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;
	
			return this;
	
		},
	
		lookAt: function () {
	
			var x, y, z;
	
			return function ( eye, target, up ) {
	
				if ( x === undefined ) x = new THREE.Vector3();
				if ( y === undefined ) y = new THREE.Vector3();
				if ( z === undefined ) z = new THREE.Vector3();
	
				var te = this.elements;
	
				z.subVectors( eye, target ).normalize();
	
				if ( z.lengthSq() === 0 ) {
	
					z.z = 1;
	
				}
	
				x.crossVectors( up, z ).normalize();
	
				if ( x.lengthSq() === 0 ) {
	
					z.x += 0.0001;
					x.crossVectors( up, z ).normalize();
	
				}
	
				y.crossVectors( z, x );
	
	
				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;
	
				return this;
	
			};
	
		}(),
	
		multiply: function ( m, n ) {
	
			if ( n !== undefined ) {
	
				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );
	
			}
	
			return this.multiplyMatrices( this, m );
	
		},
	
		multiplyMatrices: function ( a, b ) {
	
			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;
	
			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];
	
			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];
	
			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	
			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	
			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	
			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	
			return this;
	
		},
	
		multiplyToArray: function ( a, b, r ) {
	
			var te = this.elements;
	
			this.multiplyMatrices( a, b );
	
			r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
			r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
			r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
			r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			var te = this.elements;
	
			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;
	
			return this;
	
		},
	
		multiplyVector3: function ( vector ) {
	
			console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
			return vector.applyProjection( this );
	
		},
	
		multiplyVector4: function ( vector ) {
	
			console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );
	
		},
	
		multiplyVector3Array: function ( a ) {
	
			console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );
	
		},
	
		applyToVector3Array: function () {
	
			var v1;
	
			return function ( array, offset, length ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;
	
				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {
	
					v1.fromArray( array, j );
					v1.applyMatrix4( this );
					v1.toArray( array, j );
	
				}
	
				return array;
	
			};
	
		}(),
	
		applyToBuffer: function () {
	
			var v1;
	
			return function applyToBuffer( buffer, offset, length ) {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = buffer.length / buffer.itemSize;
	
				for ( var i = 0, j = offset; i < length; i ++, j ++ ) {
	
					v1.x = buffer.getX( j );
					v1.y = buffer.getY( j );
					v1.z = buffer.getZ( j );
	
					v1.applyMatrix4( this );
	
					buffer.setXYZ( v1.x, v1.y, v1.z );
	
				}
	
				return buffer;
	
			};
	
		}(),
	
		rotateAxis: function ( v ) {
	
			console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
	
			v.transformDirection( this );
	
		},
	
		crossVector: function ( vector ) {
	
			console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );
	
		},
	
		determinant: function () {
	
			var te = this.elements;
	
			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];
	
			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
	
			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)
	
			);
	
		},
	
		transpose: function () {
	
			var te = this.elements;
			var tmp;
	
			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;
	
			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;
	
			return this;
	
		},
	
		flattenToArrayOffset: function ( array, offset ) {
	
			var te = this.elements;
	
			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];
	
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
	
			array[ offset + 8 ]  = te[ 8 ];
			array[ offset + 9 ]  = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];
	
			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];
	
			return array;
	
		},
	
		getPosition: function () {
	
			var v1;
	
			return function () {
	
				if ( v1 === undefined ) v1 = new THREE.Vector3();
				console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
	
				var te = this.elements;
				return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );
	
			};
	
		}(),
	
		setPosition: function ( v ) {
	
			var te = this.elements;
	
			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;
	
			return this;
	
		},
	
		getInverse: function ( m, throwOnInvertible ) {
	
			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements;
			var me = m.elements;
	
			var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
			var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
			var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
			var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];
	
			te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
			te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
			te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
			te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
			te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
			te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
			te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
			te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
			te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
			te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
			te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
			te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
			te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
			te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
			te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
			te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
	
			var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];
	
			if ( det === 0 ) {
	
				var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
	
				if ( throwOnInvertible || false ) {
	
					throw new Error( msg );
	
				} else {
	
					console.warn( msg );
	
				}
	
				this.identity();
	
				return this;
	
			}
	
			this.multiplyScalar( 1 / det );
	
			return this;
	
		},
	
		translate: function ( v ) {
	
			console.error( 'THREE.Matrix4: .translate() has been removed.' );
	
		},
	
		rotateX: function ( angle ) {
	
			console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
	
		},
	
		rotateY: function ( angle ) {
	
			console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
	
		},
	
		rotateZ: function ( angle ) {
	
			console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
	
		},
	
		rotateByAxis: function ( axis, angle ) {
	
			console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
	
		},
	
		scale: function ( v ) {
	
			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;
	
			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;
	
			return this;
	
		},
	
		getMaxScaleOnAxis: function () {
	
			var te = this.elements;
	
			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];
	
			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );
	
		},
	
		makeTranslation: function ( x, y, z ) {
	
			this.set(
	
				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationX: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				1, 0,  0, 0,
				0, c, - s, 0,
				0, s,  c, 0,
				0, 0,  0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationY: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationZ: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				c, - s, 0, 0,
				s,  c, 0, 0,
				0,  0, 1, 0,
				0,  0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationAxis: function ( axis, angle ) {
	
			// Based on http://www.gamedev.net/reference/articles/article1199.asp
	
			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;
	
			this.set(
	
				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1
	
			);
	
			 return this;
	
		},
	
		makeScale: function ( x, y, z ) {
	
			this.set(
	
				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		compose: function ( position, quaternion, scale ) {
	
			this.makeRotationFromQuaternion( quaternion );
			this.scale( scale );
			this.setPosition( position );
	
			return this;
	
		},
	
		decompose: function () {
	
			var vector, matrix;
	
			return function ( position, quaternion, scale ) {
	
				if ( vector === undefined ) vector = new THREE.Vector3();
				if ( matrix === undefined ) matrix = new THREE.Matrix4();
	
				var te = this.elements;
	
				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();
	
				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) {
	
					sx = - sx;
	
				}
	
				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];
	
				// scale the rotation part
	
				matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()
	
				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;
	
				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;
	
				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;
	
				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;
	
				quaternion.setFromRotationMatrix( matrix );
	
				scale.x = sx;
				scale.y = sy;
				scale.z = sz;
	
				return this;
	
			};
	
		}(),
	
		makeFrustum: function ( left, right, bottom, top, near, far ) {
	
			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );
	
			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );
	
			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;
	
			return this;
	
		},
	
		makePerspective: function ( fov, aspect, near, far ) {
	
			var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
			var ymin = - ymax;
			var xmin = ymin * aspect;
			var xmax = ymax * aspect;
	
			return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );
	
		},
	
		makeOrthographic: function ( left, right, top, bottom, near, far ) {
	
			var te = this.elements;
			var w = right - left;
			var h = top - bottom;
			var p = far - near;
	
			var x = ( right + left ) / w;
			var y = ( top + bottom ) / h;
			var z = ( far + near ) / p;
	
			te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;
	
			return this;
	
		},
	
		equals: function ( matrix ) {
	
			var te = this.elements;
			var me = matrix.elements;
	
			for ( var i = 0; i < 16; i ++ ) {
	
				if ( te[ i ] !== me[ i ] ) return false;
	
			}
	
			return true;
	
		},
	
		fromArray: function ( array ) {
	
			this.elements.set( array );
	
			return this;
	
		},
	
		toArray: function () {
	
			var te = this.elements;
	
			return [
				te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
				te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
				te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
				te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
			];
	
		}
	
	};
	
	// File:src/math/Ray.js
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Ray = function ( origin, direction ) {
	
		this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
		this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();
	
	};
	
	THREE.Ray.prototype = {
	
		constructor: THREE.Ray,
	
		set: function ( origin, direction ) {
	
			this.origin.copy( origin );
			this.direction.copy( direction );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( ray ) {
	
			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );
	
			return this;
	
		},
	
		at: function ( t, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );
	
		},
	
		recast: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( t ) {
	
				this.origin.copy( this.at( t, v1 ) );
	
				return this;
	
			};
	
		}(),
	
		closestPointToPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			result.subVectors( point, this.origin );
			var directionDistance = result.dot( this.direction );
	
			if ( directionDistance < 0 ) {
	
				return result.copy( this.origin );
	
			}
	
			return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
		},
	
		distanceToPoint: function ( point ) {
	
			return Math.sqrt( this.distanceSqToPoint( point ) );
	
		},
	
		distanceSqToPoint: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( point ) {
	
				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );
	
				// point behind the ray
	
				if ( directionDistance < 0 ) {
	
					return this.origin.distanceToSquared( point );
	
				}
	
				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
				return v1.distanceToSquared( point );
	
			};
	
		}(),
	
		distanceSqToSegment: function () {
	
			var segCenter = new THREE.Vector3();
			var segDir = new THREE.Vector3();
			var diff = new THREE.Vector3();
	
			return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {
	
				// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment
	
				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				segDir.copy( v1 ).sub( v0 ).normalize();
				diff.copy( this.origin ).sub( segCenter );
	
				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( segDir );
				var b0 = diff.dot( this.direction );
				var b1 = - diff.dot( segDir );
				var c = diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;
	
				if ( det > 0 ) {
	
					// The ray and segment are not parallel.
	
					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;
	
					if ( s0 >= 0 ) {
	
						if ( s1 >= - extDet ) {
	
							if ( s1 <= extDet ) {
	
								// region 0
								// Minimum at interior points of ray and segment.
	
								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;
	
							} else {
	
								// region 1
	
								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
							}
	
						} else {
	
							// region 5
	
							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						}
	
					} else {
	
						if ( s1 <= - extDet ) {
	
							// region 4
	
							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						} else if ( s1 <= extDet ) {
	
							// region 3
	
							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;
	
						} else {
	
							// region 2
	
							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						}
	
					}
	
				} else {
	
					// Ray and segment are parallel.
	
					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
				}
	
				if ( optionalPointOnRay ) {
	
					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );
	
				}
	
				if ( optionalPointOnSegment ) {
	
					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );
	
				}
	
				return sqrDist;
	
			};
	
		}(),
	
	
		isIntersectionSphere: function ( sphere ) {
	
			return this.distanceToPoint( sphere.center ) <= sphere.radius;
	
		},
	
		intersectSphere: function () {
	
			// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/
	
			var v1 = new THREE.Vector3();
	
			return function ( sphere, optionalTarget ) {
	
				v1.subVectors( sphere.center, this.origin );
	
				var tca = v1.dot( this.direction );
	
				var d2 = v1.dot( v1 ) - tca * tca;
	
				var radius2 = sphere.radius * sphere.radius;
	
				if ( d2 > radius2 ) return null;
	
				var thc = Math.sqrt( radius2 - d2 );
	
				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;
	
				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;
	
				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) return null;
	
				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) return this.at( t1, optionalTarget );
	
				// else t0 is in front of the ray, so return the first collision point scaled by t0
				return this.at( t0, optionalTarget );
	
			}
	
		}(),
	
		isIntersectionPlane: function ( plane ) {
	
			// check if the ray lies on the plane first
	
			var distToPoint = plane.distanceToPoint( this.origin );
	
			if ( distToPoint === 0 ) {
	
				return true;
	
			}
	
			var denominator = plane.normal.dot( this.direction );
	
			if ( denominator * distToPoint < 0 ) {
	
				return true;
	
			}
	
			// ray origin is behind the plane (and is pointing behind it)
	
			return false;
	
		},
	
		distanceToPlane: function ( plane ) {
	
			var denominator = plane.normal.dot( this.direction );
			if ( denominator === 0 ) {
	
				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {
	
					return 0;
	
				}
	
				// Null is preferable to undefined since undefined means.... it is undefined
	
				return null;
	
			}
	
			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;
	
			// Return if the ray never intersects the plane
	
			return t >= 0 ? t :  null;
	
		},
	
		intersectPlane: function ( plane, optionalTarget ) {
	
			var t = this.distanceToPlane( plane );
	
			if ( t === null ) {
	
				return null;
	
			}
	
			return this.at( t, optionalTarget );
	
		},
	
		isIntersectionBox: function () {
	
			var v = new THREE.Vector3();
	
			return function ( box ) {
	
				return this.intersectBox( box, v ) !== null;
	
			};
	
		}(),
	
		intersectBox: function ( box, optionalTarget ) {
	
			// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/
	
			var tmin, tmax, tymin, tymax, tzmin, tzmax;
	
			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;
	
			var origin = this.origin;
	
			if ( invdirx >= 0 ) {
	
				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;
	
			} else {
	
				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;
	
			}
	
			if ( invdiry >= 0 ) {
	
				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;
	
			} else {
	
				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;
	
			}
	
			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;
	
			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN
	
			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;
	
			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;
	
			if ( invdirz >= 0 ) {
	
				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;
	
			} else {
	
				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;
	
			}
	
			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;
	
			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;
	
			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;
	
			//return point closest to the ray (positive side)
	
			if ( tmax < 0 ) return null;
	
			return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );
	
		},
	
		intersectTriangle: function () {
	
			// Compute the offset origin, edges, and normal.
			var diff = new THREE.Vector3();
			var edge1 = new THREE.Vector3();
			var edge2 = new THREE.Vector3();
			var normal = new THREE.Vector3();
	
			return function ( a, b, c, backfaceCulling, optionalTarget ) {
	
				// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp
	
				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );
	
				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;
	
				if ( DdN > 0 ) {
	
					if ( backfaceCulling ) return null;
					sign = 1;
	
				} else if ( DdN < 0 ) {
	
					sign = - 1;
					DdN = - DdN;
	
				} else {
	
					return null;
	
				}
	
				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );
	
				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {
	
					return null;
	
				}
	
				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );
	
				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {
	
					return null;
	
				}
	
				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {
	
					return null;
	
				}
	
				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );
	
				// t < 0, no intersection
				if ( QdN < 0 ) {
	
					return null;
	
				}
	
				// Ray intersects triangle.
				return this.at( QdN / DdN, optionalTarget );
	
			};
	
		}(),
	
		applyMatrix4: function ( matrix4 ) {
	
			this.direction.add( this.origin ).applyMatrix4( matrix4 );
			this.origin.applyMatrix4( matrix4 );
			this.direction.sub( this.origin );
			this.direction.normalize();
	
			return this;
	
		},
	
		equals: function ( ray ) {
	
			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );
	
		}
	
	};
	
	// File:src/math/Sphere.js
	
	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Sphere = function ( center, radius ) {
	
		this.center = ( center !== undefined ) ? center : new THREE.Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;
	
	};
	
	THREE.Sphere.prototype = {
	
		constructor: THREE.Sphere,
	
		set: function ( center, radius ) {
	
			this.center.copy( center );
			this.radius = radius;
	
			return this;
	
		},
	
		setFromPoints: function () {
	
			var box = new THREE.Box3();
	
			return function ( points, optionalCenter ) {
	
				var center = this.center;
	
				if ( optionalCenter !== undefined ) {
	
					center.copy( optionalCenter );
	
				} else {
	
					box.setFromPoints( points ).center( center );
	
				}
	
				var maxRadiusSq = 0;
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );
	
				}
	
				this.radius = Math.sqrt( maxRadiusSq );
	
				return this;
	
			};
	
		}(),
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( sphere ) {
	
			this.center.copy( sphere.center );
			this.radius = sphere.radius;
	
			return this;
	
		},
	
		empty: function () {
	
			return ( this.radius <= 0 );
	
		},
	
		containsPoint: function ( point ) {
	
			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );
	
		},
	
		distanceToPoint: function ( point ) {
	
			return ( point.distanceTo( this.center ) - this.radius );
	
		},
	
		intersectsSphere: function ( sphere ) {
	
			var radiusSum = this.radius + sphere.radius;
	
			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var deltaLengthSq = this.center.distanceToSquared( point );
	
			var result = optionalTarget || new THREE.Vector3();
			result.copy( point );
	
			if ( deltaLengthSq > ( this.radius * this.radius ) ) {
	
				result.sub( this.center ).normalize();
				result.multiplyScalar( this.radius ).add( this.center );
	
			}
	
			return result;
	
		},
	
		getBoundingBox: function ( optionalTarget ) {
	
			var box = optionalTarget || new THREE.Box3();
	
			box.set( this.center, this.center );
			box.expandByScalar( this.radius );
	
			return box;
	
		},
	
		applyMatrix4: function ( matrix ) {
	
			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();
	
			return this;
	
		},
	
		translate: function ( offset ) {
	
			this.center.add( offset );
	
			return this;
	
		},
	
		equals: function ( sphere ) {
	
			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );
	
		}
	
	};
	
	// File:src/math/Frustum.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {
	
		this.planes = [
	
			( p0 !== undefined ) ? p0 : new THREE.Plane(),
			( p1 !== undefined ) ? p1 : new THREE.Plane(),
			( p2 !== undefined ) ? p2 : new THREE.Plane(),
			( p3 !== undefined ) ? p3 : new THREE.Plane(),
			( p4 !== undefined ) ? p4 : new THREE.Plane(),
			( p5 !== undefined ) ? p5 : new THREE.Plane()
	
		];
	
	};
	
	THREE.Frustum.prototype = {
	
		constructor: THREE.Frustum,
	
		set: function ( p0, p1, p2, p3, p4, p5 ) {
	
			var planes = this.planes;
	
			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( frustum ) {
	
			var planes = this.planes;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				planes[ i ].copy( frustum.planes[ i ] );
	
			}
	
			return this;
	
		},
	
		setFromMatrix: function ( m ) {
	
			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];
	
			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();
	
			return this;
	
		},
	
		intersectsObject: function () {
	
			var sphere = new THREE.Sphere();
	
			return function ( object ) {
	
				var geometry = object.geometry;
	
				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( object.matrixWorld );
	
				return this.intersectsSphere( sphere );
	
			};
	
		}(),
	
		intersectsSphere: function ( sphere ) {
	
			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				var distance = planes[ i ].distanceToPoint( center );
	
				if ( distance < negRadius ) {
	
					return false;
	
				}
	
			}
	
			return true;
	
		},
	
		intersectsBox: function () {
	
			var p1 = new THREE.Vector3(),
				p2 = new THREE.Vector3();
	
			return function ( box ) {
	
				var planes = this.planes;
	
				for ( var i = 0; i < 6 ; i ++ ) {
	
					var plane = planes[ i ];
	
					p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
					p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
					p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
					p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
	
					var d1 = plane.distanceToPoint( p1 );
					var d2 = plane.distanceToPoint( p2 );
	
					// if both outside plane, no intersection
	
					if ( d1 < 0 && d2 < 0 ) {
	
						return false;
	
					}
	
				}
	
				return true;
	
			};
	
		}(),
	
	
		containsPoint: function ( point ) {
	
			var planes = this.planes;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				if ( planes[ i ].distanceToPoint( point ) < 0 ) {
	
					return false;
	
				}
	
			}
	
			return true;
	
		}
	
	};
	
	// File:src/math/Plane.js
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Plane = function ( normal, constant ) {
	
		this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;
	
	};
	
	THREE.Plane.prototype = {
	
		constructor: THREE.Plane,
	
		set: function ( normal, constant ) {
	
			this.normal.copy( normal );
			this.constant = constant;
	
			return this;
	
		},
	
		setComponents: function ( x, y, z, w ) {
	
			this.normal.set( x, y, z );
			this.constant = w;
	
			return this;
	
		},
	
		setFromNormalAndCoplanarPoint: function ( normal, point ) {
	
			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized
	
			return this;
	
		},
	
		setFromCoplanarPoints: function () {
	
			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
	
			return function ( a, b, c ) {
	
				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();
	
				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
	
				this.setFromNormalAndCoplanarPoint( normal, a );
	
				return this;
	
			};
	
		}(),
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( plane ) {
	
			this.normal.copy( plane.normal );
			this.constant = plane.constant;
	
			return this;
	
		},
	
		normalize: function () {
	
			// Note: will lead to a divide by zero if the plane is invalid.
	
			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;
	
			return this;
	
		},
	
		negate: function () {
	
			this.constant *= - 1;
			this.normal.negate();
	
			return this;
	
		},
	
		distanceToPoint: function ( point ) {
	
			return this.normal.dot( point ) + this.constant;
	
		},
	
		distanceToSphere: function ( sphere ) {
	
			return this.distanceToPoint( sphere.center ) - sphere.radius;
	
		},
	
		projectPoint: function ( point, optionalTarget ) {
	
			return this.orthoPoint( point, optionalTarget ).sub( point ).negate();
	
		},
	
		orthoPoint: function ( point, optionalTarget ) {
	
			var perpendicularMagnitude = this.distanceToPoint( point );
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );
	
		},
	
		isIntersectionLine: function ( line ) {
	
			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
	
			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );
	
			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );
	
		},
	
		intersectLine: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( line, optionalTarget ) {
	
				var result = optionalTarget || new THREE.Vector3();
	
				var direction = line.delta( v1 );
	
				var denominator = this.normal.dot( direction );
	
				if ( denominator === 0 ) {
	
					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) === 0 ) {
	
						return result.copy( line.start );
	
					}
	
					// Unsure if this is the correct method to handle this case.
					return undefined;
	
				}
	
				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;
	
				if ( t < 0 || t > 1 ) {
	
					return undefined;
	
				}
	
				return result.copy( direction ).multiplyScalar( t ).add( line.start );
	
			};
	
		}(),
	
	
		coplanarPoint: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( - this.constant );
	
		},
	
		applyMatrix4: function () {
	
			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
			var m1 = new THREE.Matrix3();
	
			return function ( matrix, optionalNormalMatrix ) {
	
				// compute new normal based on theory here:
				// http://www.songho.ca/opengl/gl_normaltransform.html
				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
				var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );
	
				var newCoplanarPoint = this.coplanarPoint( v2 );
				newCoplanarPoint.applyMatrix4( matrix );
	
				this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );
	
				return this;
	
			};
	
		}(),
	
		translate: function ( offset ) {
	
			this.constant = this.constant - offset.dot( this.normal );
	
			return this;
	
		},
	
		equals: function ( plane ) {
	
			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );
	
		}
	
	};
	
	// File:src/math/Math.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Math = {
	
		generateUUID: function () {
	
			// http://www.broofa.com/Tools/Math.uuid.htm
	
			var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
			var uuid = new Array( 36 );
			var rnd = 0, r;
	
			return function () {
	
				for ( var i = 0; i < 36; i ++ ) {
	
					if ( i === 8 || i === 13 || i === 18 || i === 23 ) {
	
						uuid[ i ] = '-';
	
					} else if ( i === 14 ) {
	
						uuid[ i ] = '4';
	
					} else {
	
						if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
						r = rnd & 0xf;
						rnd = rnd >> 4;
						uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];
	
					}
	
				}
	
				return uuid.join( '' );
	
			};
	
		}(),
	
		clamp: function ( value, min, max ) {
	
			return Math.max( min, Math.min( max, value ) );
	
		},
	
		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation
	
		euclideanModulo: function ( n, m ) {
	
			return ( ( n % m ) + m ) % m;
	
		},
	
		// Linear mapping from range <a1, a2> to range <b1, b2>
	
		mapLinear: function ( x, a1, a2, b1, b2 ) {
	
			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );
	
		},
	
		// http://en.wikipedia.org/wiki/Smoothstep
	
		smoothstep: function ( x, min, max ) {
	
			if ( x <= min ) return 0;
			if ( x >= max ) return 1;
	
			x = ( x - min ) / ( max - min );
	
			return x * x * ( 3 - 2 * x );
	
		},
	
		smootherstep: function ( x, min, max ) {
	
			if ( x <= min ) return 0;
			if ( x >= max ) return 1;
	
			x = ( x - min ) / ( max - min );
	
			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );
	
		},
	
		// Random float from <0, 1> with 16 bits of randomness
		// (standard Math.random() creates repetitive patterns when applied over larger space)
	
		random16: function () {
	
			return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;
	
		},
	
		// Random integer from <low, high> interval
	
		randInt: function ( low, high ) {
	
			return low + Math.floor( Math.random() * ( high - low + 1 ) );
	
		},
	
		// Random float from <low, high> interval
	
		randFloat: function ( low, high ) {
	
			return low + Math.random() * ( high - low );
	
		},
	
		// Random float from <-range/2, range/2> interval
	
		randFloatSpread: function ( range ) {
	
			return range * ( 0.5 - Math.random() );
	
		},
	
		degToRad: function () {
	
			var degreeToRadiansFactor = Math.PI / 180;
	
			return function ( degrees ) {
	
				return degrees * degreeToRadiansFactor;
	
			};
	
		}(),
	
		radToDeg: function () {
	
			var radianToDegreesFactor = 180 / Math.PI;
	
			return function ( radians ) {
	
				return radians * radianToDegreesFactor;
	
			};
	
		}(),
	
		isPowerOfTwo: function ( value ) {
	
			return ( value & ( value - 1 ) ) === 0 && value !== 0;
	
		},
	
		nearestPowerOfTwo: function ( value ) {
	
			return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );
	
		},
	
		nextPowerOfTwo: function ( value ) {
	
			value --;
			value |= value >> 1;
			value |= value >> 2;
			value |= value >> 4;
			value |= value >> 8;
			value |= value >> 16;
			value ++;
	
			return value;
	
		}
	
	};
	
	// File:src/math/Spline.js
	
	/**
	 * Spline from Tween.js, slightly optimized (and trashed)
	 * http://sole.github.com/tween.js/examples/05_spline.html
	 *
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Spline = function ( points ) {
	
		this.points = points;
	
		var c = [], v3 = { x: 0, y: 0, z: 0 },
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;
	
		this.initFromArray = function ( a ) {
	
			this.points = [];
	
			for ( var i = 0; i < a.length; i ++ ) {
	
				this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };
	
			}
	
		};
	
		this.getPoint = function ( k ) {
	
			point = ( this.points.length - 1 ) * k;
			intPoint = Math.floor( point );
			weight = point - intPoint;
	
			c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
			c[ 1 ] = intPoint;
			c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
			c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
	
			pa = this.points[ c[ 0 ] ];
			pb = this.points[ c[ 1 ] ];
			pc = this.points[ c[ 2 ] ];
			pd = this.points[ c[ 3 ] ];
	
			w2 = weight * weight;
			w3 = weight * w2;
	
			v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
			v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
			v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );
	
			return v3;
	
		};
	
		this.getControlPointsArray = function () {
	
			var i, p, l = this.points.length,
				coords = [];
	
			for ( i = 0; i < l; i ++ ) {
	
				p = this.points[ i ];
				coords[ i ] = [ p.x, p.y, p.z ];
	
			}
	
			return coords;
	
		};
	
		// approximate length by summing linear segments
	
		this.getLength = function ( nSubDivisions ) {
	
			var i, index, nSamples, position,
				point = 0, intPoint = 0, oldIntPoint = 0,
				oldPosition = new THREE.Vector3(),
				tmpVec = new THREE.Vector3(),
				chunkLengths = [],
				totalLength = 0;
	
			// first point has 0 length
	
			chunkLengths[ 0 ] = 0;
	
			if ( ! nSubDivisions ) nSubDivisions = 100;
	
			nSamples = this.points.length * nSubDivisions;
	
			oldPosition.copy( this.points[ 0 ] );
	
			for ( i = 1; i < nSamples; i ++ ) {
	
				index = i / nSamples;
	
				position = this.getPoint( index );
				tmpVec.copy( position );
	
				totalLength += tmpVec.distanceTo( oldPosition );
	
				oldPosition.copy( position );
	
				point = ( this.points.length - 1 ) * index;
				intPoint = Math.floor( point );
	
				if ( intPoint !== oldIntPoint ) {
	
					chunkLengths[ intPoint ] = totalLength;
					oldIntPoint = intPoint;
	
				}
	
			}
	
			// last point ends with total length
	
			chunkLengths[ chunkLengths.length ] = totalLength;
	
			return { chunks: chunkLengths, total: totalLength };
	
		};
	
		this.reparametrizeByArcLength = function ( samplingCoef ) {
	
			var i, j,
				index, indexCurrent, indexNext,
				realDistance,
				sampling, position,
				newpoints = [],
				tmpVec = new THREE.Vector3(),
				sl = this.getLength();
	
			newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );
	
			for ( i = 1; i < this.points.length; i ++ ) {
	
				//tmpVec.copy( this.points[ i - 1 ] );
				//linearDistance = tmpVec.distanceTo( this.points[ i ] );
	
				realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];
	
				sampling = Math.ceil( samplingCoef * realDistance / sl.total );
	
				indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
				indexNext = i / ( this.points.length - 1 );
	
				for ( j = 1; j < sampling - 1; j ++ ) {
	
					index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );
	
					position = this.getPoint( index );
					newpoints.push( tmpVec.copy( position ).clone() );
	
				}
	
				newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );
	
			}
	
			this.points = newpoints;
	
		};
	
		// Catmull-Rom
	
		function interpolate( p0, p1, p2, p3, t, t2, t3 ) {
	
			var v0 = ( p2 - p0 ) * 0.5,
				v1 = ( p3 - p1 ) * 0.5;
	
			return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
		}
	
	};
	
	// File:src/math/Triangle.js
	
	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Triangle = function ( a, b, c ) {
	
		this.a = ( a !== undefined ) ? a : new THREE.Vector3();
		this.b = ( b !== undefined ) ? b : new THREE.Vector3();
		this.c = ( c !== undefined ) ? c : new THREE.Vector3();
	
	};
	
	THREE.Triangle.normal = function () {
	
		var v0 = new THREE.Vector3();
	
		return function ( a, b, c, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			result.subVectors( c, b );
			v0.subVectors( a, b );
			result.cross( v0 );
	
			var resultLengthSq = result.lengthSq();
			if ( resultLengthSq > 0 ) {
	
				return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );
	
			}
	
			return result.set( 0, 0, 0 );
	
		};
	
	}();
	
	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	THREE.Triangle.barycoordFromPoint = function () {
	
		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
	
		return function ( point, a, b, c, optionalTarget ) {
	
			v0.subVectors( c, a );
			v1.subVectors( b, a );
			v2.subVectors( point, a );
	
			var dot00 = v0.dot( v0 );
			var dot01 = v0.dot( v1 );
			var dot02 = v0.dot( v2 );
			var dot11 = v1.dot( v1 );
			var dot12 = v1.dot( v2 );
	
			var denom = ( dot00 * dot11 - dot01 * dot01 );
	
			var result = optionalTarget || new THREE.Vector3();
	
			// collinear or singular triangle
			if ( denom === 0 ) {
	
				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return result.set( - 2, - 1, - 1 );
	
			}
	
			var invDenom = 1 / denom;
			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;
	
			// barycentric coordinates must always sum to 1
			return result.set( 1 - u - v, v, u );
	
		};
	
	}();
	
	THREE.Triangle.containsPoint = function () {
	
		var v1 = new THREE.Vector3();
	
		return function ( point, a, b, c ) {
	
			var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );
	
			return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );
	
		};
	
	}();
	
	THREE.Triangle.prototype = {
	
		constructor: THREE.Triangle,
	
		set: function ( a, b, c ) {
	
			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );
	
			return this;
	
		},
	
		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {
	
			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( triangle ) {
	
			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );
	
			return this;
	
		},
	
		area: function () {
	
			var v0 = new THREE.Vector3();
			var v1 = new THREE.Vector3();
	
			return function () {
	
				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );
	
				return v0.cross( v1 ).length() * 0.5;
	
			};
	
		}(),
	
		midpoint: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );
	
		},
	
		normal: function ( optionalTarget ) {
	
			return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );
	
		},
	
		plane: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Plane();
	
			return result.setFromCoplanarPoints( this.a, this.b, this.c );
	
		},
	
		barycoordFromPoint: function ( point, optionalTarget ) {
	
			return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );
	
		},
	
		containsPoint: function ( point ) {
	
			return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );
	
		},
	
		equals: function ( triangle ) {
	
			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );
	
		}
	
	};
	
	// File:src/core/Channels.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Channels = function () {
	
		this.mask = 1;
	
	};
	
	THREE.Channels.prototype = {
	
		constructor: THREE.Channels,
	
		set: function ( channel ) {
	
			this.mask = 1 << channel;
	
		},
	
		enable: function ( channel ) {
	
			this.mask |= 1 << channel;
	
		},
	
		toggle: function ( channel ) {
	
			this.mask ^= 1 << channel;
	
		},
	
		disable: function ( channel ) {
	
			this.mask &= ~ ( 1 << channel );
	
		}
	
	};
	
	// File:src/core/Clock.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Clock = function ( autoStart ) {
	
		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;
	
		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;
	
		this.running = false;
	
	};
	
	THREE.Clock.prototype = {
	
		constructor: THREE.Clock,
	
		start: function () {
	
			this.startTime = self.performance.now();
	
			this.oldTime = this.startTime;
			this.running = true;
	
		},
	
		stop: function () {
	
			this.getElapsedTime();
			this.running = false;
	
		},
	
		getElapsedTime: function () {
	
			this.getDelta();
			return this.elapsedTime;
	
		},
	
		getDelta: function () {
	
			var diff = 0;
	
			if ( this.autoStart && ! this.running ) {
	
				this.start();
	
			}
	
			if ( this.running ) {
	
				var newTime = self.performance.now();
	
				diff = 0.001 * ( newTime - this.oldTime );
				this.oldTime = newTime;
	
				this.elapsedTime += diff;
	
			}
	
			return diff;
	
		}
	
	};
	
	// File:src/core/EventDispatcher.js
	
	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */
	
	THREE.EventDispatcher = function () {};
	
	THREE.EventDispatcher.prototype = {
	
		constructor: THREE.EventDispatcher,
	
		apply: function ( object ) {
	
			object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
			object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
			object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
			object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
	
		},
	
		addEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) this._listeners = {};
	
			var listeners = this._listeners;
	
			if ( listeners[ type ] === undefined ) {
	
				listeners[ type ] = [];
	
			}
	
			if ( listeners[ type ].indexOf( listener ) === - 1 ) {
	
				listeners[ type ].push( listener );
	
			}
	
		},
	
		hasEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) return false;
	
			var listeners = this._listeners;
	
			if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		removeEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) return;
	
			var listeners = this._listeners;
			var listenerArray = listeners[ type ];
	
			if ( listenerArray !== undefined ) {
	
				var index = listenerArray.indexOf( listener );
	
				if ( index !== - 1 ) {
	
					listenerArray.splice( index, 1 );
	
				}
	
			}
	
		},
	
		dispatchEvent: function ( event ) {
	
			if ( this._listeners === undefined ) return;
	
			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];
	
			if ( listenerArray !== undefined ) {
	
				event.target = this;
	
				var array = [];
				var length = listenerArray.length;
	
				for ( var i = 0; i < length; i ++ ) {
	
					array[ i ] = listenerArray[ i ];
	
				}
	
				for ( var i = 0; i < length; i ++ ) {
	
					array[ i ].call( this, event );
	
				}
	
			}
	
		}
	
	};
	
	// File:src/core/Raycaster.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io/
	 * @author stephomi / http://stephaneginier.com/
	 */
	
	( function ( THREE ) {
	
		THREE.Raycaster = function ( origin, direction, near, far ) {
	
			this.ray = new THREE.Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)
	
			this.near = near || 0;
			this.far = far || Infinity;
	
			this.params = {
				Mesh: {},
				Line: {},
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};
	
			Object.defineProperties( this.params, {
				PointCloud: {
					get: function () {
						console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
						return this.Points;
					}
				}
			} );
	
		};
	
		function descSort( a, b ) {
	
			return a.distance - b.distance;
	
		}
	
		function intersectObject( object, raycaster, intersects, recursive ) {
	
			if ( object.visible === false ) return;
	
			object.raycast( raycaster, intersects );
	
			if ( recursive === true ) {
	
				var children = object.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					intersectObject( children[ i ], raycaster, intersects, true );
	
				}
	
			}
	
		}
	
		//
	
		THREE.Raycaster.prototype = {
	
			constructor: THREE.Raycaster,
	
			linePrecision: 1,
	
			set: function ( origin, direction ) {
	
				// direction is assumed to be normalized (for accurate distance calculations)
	
				this.ray.set( origin, direction );
	
			},
	
			setFromCamera: function ( coords, camera ) {
	
				if ( camera instanceof THREE.PerspectiveCamera ) {
	
					this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
					this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
	
				} else if ( camera instanceof THREE.OrthographicCamera ) {
	
					this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
					this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
	
				} else {
	
					console.error( 'THREE.Raycaster: Unsupported camera type.' );
	
				}
	
			},
	
			intersectObject: function ( object, recursive ) {
	
				var intersects = [];
	
				intersectObject( object, this, intersects, recursive );
	
				intersects.sort( descSort );
	
				return intersects;
	
			},
	
			intersectObjects: function ( objects, recursive ) {
	
				var intersects = [];
	
				if ( Array.isArray( objects ) === false ) {
	
					console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;
	
				}
	
				for ( var i = 0, l = objects.length; i < l; i ++ ) {
	
					intersectObject( objects[ i ], this, intersects, recursive );
	
				}
	
				intersects.sort( descSort );
	
				return intersects;
	
			}
	
		};
	
	}( THREE ) );
	
	// File:src/core/Object3D.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */
	
	THREE.Object3D = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'Object3D';
	
		this.parent = null;
		this.channels = new THREE.Channels();
		this.children = [];
	
		this.up = THREE.Object3D.DefaultUp.clone();
	
		var position = new THREE.Vector3();
		var rotation = new THREE.Euler();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3( 1, 1, 1 );
	
		function onRotationChange() {
	
			quaternion.setFromEuler( rotation, false );
	
		}
	
		function onQuaternionChange() {
	
			rotation.setFromQuaternion( quaternion, undefined, false );
	
		}
	
		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );
	
		Object.defineProperties( this, {
			position: {
				enumerable: true,
				value: position
			},
			rotation: {
				enumerable: true,
				value: rotation
			},
			quaternion: {
				enumerable: true,
				value: quaternion
			},
			scale: {
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new THREE.Matrix4()
			},
			normalMatrix: {
				value: new THREE.Matrix3()
			}
		} );
	
		this.rotationAutoUpdate = true;
	
		this.matrix = new THREE.Matrix4();
		this.matrixWorld = new THREE.Matrix4();
	
		this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;
	
		this.visible = true;
	
		this.castShadow = false;
		this.receiveShadow = false;
	
		this.frustumCulled = true;
		this.renderOrder = 0;
	
		this.userData = {};
	
	};
	
	THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
	THREE.Object3D.DefaultMatrixAutoUpdate = true;
	
	THREE.Object3D.prototype = {
	
		constructor: THREE.Object3D,
	
		get eulerOrder () {
	
			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
	
			return this.rotation.order;
	
		},
	
		set eulerOrder ( value ) {
	
			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
	
			this.rotation.order = value;
	
		},
	
		get useQuaternion () {
	
			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
	
		},
	
		set useQuaternion ( value ) {
	
			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
	
		},
	
		set renderDepth ( value ) {
	
			console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
	
		},
	
		//
	
		applyMatrix: function ( matrix ) {
	
			this.matrix.multiplyMatrices( matrix, this.matrix );
	
			this.matrix.decompose( this.position, this.quaternion, this.scale );
	
		},
	
		setRotationFromAxisAngle: function ( axis, angle ) {
	
			// assumes axis is normalized
	
			this.quaternion.setFromAxisAngle( axis, angle );
	
		},
	
		setRotationFromEuler: function ( euler ) {
	
			this.quaternion.setFromEuler( euler, true );
	
		},
	
		setRotationFromMatrix: function ( m ) {
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			this.quaternion.setFromRotationMatrix( m );
	
		},
	
		setRotationFromQuaternion: function ( q ) {
	
			// assumes q is normalized
	
			this.quaternion.copy( q );
	
		},
	
		rotateOnAxis: function () {
	
			// rotate object on axis in object space
			// axis is assumed to be normalized
	
			var q1 = new THREE.Quaternion();
	
			return function ( axis, angle ) {
	
				q1.setFromAxisAngle( axis, angle );
	
				this.quaternion.multiply( q1 );
	
				return this;
	
			};
	
		}(),
	
		rotateX: function () {
	
			var v1 = new THREE.Vector3( 1, 0, 0 );
	
			return function ( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		rotateY: function () {
	
			var v1 = new THREE.Vector3( 0, 1, 0 );
	
			return function ( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		rotateZ: function () {
	
			var v1 = new THREE.Vector3( 0, 0, 1 );
	
			return function ( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		translateOnAxis: function () {
	
			// translate object by distance along axis in object space
			// axis is assumed to be normalized
	
			var v1 = new THREE.Vector3();
	
			return function ( axis, distance ) {
	
				v1.copy( axis ).applyQuaternion( this.quaternion );
	
				this.position.add( v1.multiplyScalar( distance ) );
	
				return this;
	
			};
	
		}(),
	
		translate: function ( distance, axis ) {
	
			console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );
	
		},
	
		translateX: function () {
	
			var v1 = new THREE.Vector3( 1, 0, 0 );
	
			return function ( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		translateY: function () {
	
			var v1 = new THREE.Vector3( 0, 1, 0 );
	
			return function ( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		translateZ: function () {
	
			var v1 = new THREE.Vector3( 0, 0, 1 );
	
			return function ( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		localToWorld: function ( vector ) {
	
			return vector.applyMatrix4( this.matrixWorld );
	
		},
	
		worldToLocal: function () {
	
			var m1 = new THREE.Matrix4();
	
			return function ( vector ) {
	
				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );
	
			};
	
		}(),
	
		lookAt: function () {
	
			// This routine does not support objects with rotated and/or translated parent(s)
	
			var m1 = new THREE.Matrix4();
	
			return function ( vector ) {
	
				m1.lookAt( vector, this.position, this.up );
	
				this.quaternion.setFromRotationMatrix( m1 );
	
			};
	
		}(),
	
		add: function ( object ) {
	
			if ( arguments.length > 1 ) {
	
				for ( var i = 0; i < arguments.length; i ++ ) {
	
					this.add( arguments[ i ] );
	
				}
	
				return this;
	
			}
	
			if ( object === this ) {
	
				console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;
	
			}
	
			if ( object instanceof THREE.Object3D ) {
	
				if ( object.parent !== null ) {
	
					object.parent.remove( object );
	
				}
	
				object.parent = this;
				object.dispatchEvent( { type: 'added' } );
	
				this.children.push( object );
	
			} else {
	
				console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );
	
			}
	
			return this;
	
		},
	
		remove: function ( object ) {
	
			if ( arguments.length > 1 ) {
	
				for ( var i = 0; i < arguments.length; i ++ ) {
	
					this.remove( arguments[ i ] );
	
				}
	
			}
	
			var index = this.children.indexOf( object );
	
			if ( index !== - 1 ) {
	
				object.parent = null;
	
				object.dispatchEvent( { type: 'removed' } );
	
				this.children.splice( index, 1 );
	
			}
	
		},
	
		getChildByName: function ( name ) {
	
			console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name );
	
		},
	
		getObjectById: function ( id ) {
	
			return this.getObjectByProperty( 'id', id );
	
		},
	
		getObjectByName: function ( name ) {
	
			return this.getObjectByProperty( 'name', name );
	
		},
	
		getObjectByProperty: function ( name, value ) {
	
			if ( this[ name ] === value ) return this;
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );
	
				if ( object !== undefined ) {
	
					return object;
	
				}
	
			}
	
			return undefined;
	
		},
	
		getWorldPosition: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			this.updateMatrixWorld( true );
	
			return result.setFromMatrixPosition( this.matrixWorld );
	
		},
	
		getWorldQuaternion: function () {
	
			var position = new THREE.Vector3();
			var scale = new THREE.Vector3();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Quaternion();
	
				this.updateMatrixWorld( true );
	
				this.matrixWorld.decompose( position, result, scale );
	
				return result;
	
			};
	
		}(),
	
		getWorldRotation: function () {
	
			var quaternion = new THREE.Quaternion();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Euler();
	
				this.getWorldQuaternion( quaternion );
	
				return result.setFromQuaternion( quaternion, this.rotation.order, false );
	
			};
	
		}(),
	
		getWorldScale: function () {
	
			var position = new THREE.Vector3();
			var quaternion = new THREE.Quaternion();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Vector3();
	
				this.updateMatrixWorld( true );
	
				this.matrixWorld.decompose( position, quaternion, result );
	
				return result;
	
			};
	
		}(),
	
		getWorldDirection: function () {
	
			var quaternion = new THREE.Quaternion();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Vector3();
	
				this.getWorldQuaternion( quaternion );
	
				return result.set( 0, 0, 1 ).applyQuaternion( quaternion );
	
			};
	
		}(),
	
		raycast: function () {},
	
		traverse: function ( callback ) {
	
			callback( this );
	
			var children = this.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				children[ i ].traverse( callback );
	
			}
	
		},
	
		traverseVisible: function ( callback ) {
	
			if ( this.visible === false ) return;
	
			callback( this );
	
			var children = this.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				children[ i ].traverseVisible( callback );
	
			}
	
		},
	
		traverseAncestors: function ( callback ) {
	
			var parent = this.parent;
	
			if ( parent !== null ) {
	
				callback( parent );
	
				parent.traverseAncestors( callback );
	
			}
	
		},
	
		updateMatrix: function () {
	
			this.matrix.compose( this.position, this.quaternion, this.scale );
	
			this.matrixWorldNeedsUpdate = true;
	
		},
	
		updateMatrixWorld: function ( force ) {
	
			if ( this.matrixAutoUpdate === true ) this.updateMatrix();
	
			if ( this.matrixWorldNeedsUpdate === true || force === true ) {
	
				if ( this.parent === null ) {
	
					this.matrixWorld.copy( this.matrix );
	
				} else {
	
					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	
				}
	
				this.matrixWorldNeedsUpdate = false;
	
				force = true;
	
			}
	
			// update children
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				this.children[ i ].updateMatrixWorld( force );
	
			}
	
		},
	
		toJSON: function ( meta ) {
	
			var isRootObject = ( meta === undefined );
	
			var output = {};
	
			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {
	
				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {}
				};
	
				output.metadata = {
					version: 4.4,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};
	
			}
	
			// standard Object3D serialization
	
			var object = {};
	
			object.uuid = this.uuid;
			object.type = this.type;
	
			if ( this.name !== '' ) object.name = this.name;
			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
	
			object.matrix = this.matrix.toArray();
	
			//
	
			if ( this.geometry !== undefined ) {
	
				if ( meta.geometries[ this.geometry.uuid ] === undefined ) {
	
					meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );
	
				}
	
				object.geometry = this.geometry.uuid;
	
			}
	
			if ( this.material !== undefined ) {
	
				if ( meta.materials[ this.material.uuid ] === undefined ) {
	
					meta.materials[ this.material.uuid ] = this.material.toJSON( meta );
	
				}
	
				object.material = this.material.uuid;
	
			}
	
			//
	
			if ( this.children.length > 0 ) {
	
				object.children = [];
	
				for ( var i = 0; i < this.children.length; i ++ ) {
	
					object.children.push( this.children[ i ].toJSON( meta ).object );
	
				}
	
			}
	
			if ( isRootObject ) {
	
				var geometries = extractFromCache( meta.geometries );
				var materials = extractFromCache( meta.materials );
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
	
				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
	
			}
	
			output.object = object;
	
			return output;
	
			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache ( cache ) {
	
				var values = [];
				for ( var key in cache ) {
	
					var data = cache[ key ];
					delete data.metadata;
					values.push( data );
	
				}
				return values;
	
			}
	
		},
	
		clone: function ( recursive ) {
	
			return new this.constructor().copy( this, recursive );
	
		},
	
		copy: function ( source, recursive ) {
	
			if ( recursive === undefined ) recursive = true;
	
			this.name = source.name;
	
			this.up.copy( source.up );
	
			this.position.copy( source.position );
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );
	
			this.rotationAutoUpdate = source.rotationAutoUpdate;
	
			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );
	
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
	
			this.visible = source.visible;
	
			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;
	
			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;
	
			this.userData = JSON.parse( JSON.stringify( source.userData ) );
	
			if ( recursive === true ) {
	
				for ( var i = 0; i < source.children.length; i ++ ) {
	
					var child = source.children[ i ];
					this.add( child.clone() );
	
				}
	
			}
	
			return this;
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );
	
	THREE.Object3DIdCount = 0;
	
	// File:src/core/Face3.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {
	
		this.a = a;
		this.b = b;
		this.c = c;
	
		this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
		this.vertexNormals = Array.isArray( normal ) ? normal : [];
	
		this.color = color instanceof THREE.Color ? color : new THREE.Color();
		this.vertexColors = Array.isArray( color ) ? color : [];
	
		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
	
	};
	
	THREE.Face3.prototype = {
	
		constructor: THREE.Face3,
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.a = source.a;
			this.b = source.b;
			this.c = source.c;
	
			this.normal.copy( source.normal );
			this.color.copy( source.color );
	
			this.materialIndex = source.materialIndex;
	
			for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {
	
				this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();
	
			}
	
			for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {
	
				this.vertexColors[ i ] = source.vertexColors[ i ].clone();
	
			}
	
			return this;
	
		}
	
	};
	
	// File:src/core/Face4.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {
	
		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
		return new THREE.Face3( a, b, c, normal, color, materialIndex );
	
	};
	
	// File:src/core/BufferAttribute.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BufferAttribute = function ( array, itemSize ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.array = array;
		this.itemSize = itemSize;
	
		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };
	
		this.version = 0;
	
	};
	
	THREE.BufferAttribute.prototype = {
	
		constructor: THREE.BufferAttribute,
	
		get length() {
	
			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
			return this.array.length;
	
		},
	
		get count() {
	
			return this.array.length / this.itemSize;
	
		},
	
		set needsUpdate( value ) {
	
			if ( value === true ) this.version ++;
	
		},
	
		setDynamic: function ( value ) {
	
			this.dynamic = value;
	
			return this;
	
		},
	
		copy: function ( source ) {
	
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
	
			this.dynamic = source.dynamic;
	
			return this;
	
		},
	
		copyAt: function ( index1, attribute, index2 ) {
	
			index1 *= this.itemSize;
			index2 *= attribute.itemSize;
	
			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {
	
				this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
			}
	
			return this;
	
		},
	
		copyArray: function ( array ) {
	
			this.array.set( array );
	
			return this;
	
		},
	
		copyColorsArray: function ( colors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = colors.length; i < l; i ++ ) {
	
				var color = colors[ i ];
	
				if ( color === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new THREE.Color();
	
				}
	
				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;
	
			}
	
			return this;
	
		},
	
		copyIndicesArray: function ( indices ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = indices.length; i < l; i ++ ) {
	
				var index = indices[ i ];
	
				array[ offset ++ ] = index.a;
				array[ offset ++ ] = index.b;
				array[ offset ++ ] = index.c;
	
			}
	
			return this;
	
		},
	
		copyVector2sArray: function ( vectors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
				var vector = vectors[ i ];
	
				if ( vector === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new THREE.Vector2();
	
				}
	
				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
	
			}
	
			return this;
	
		},
	
		copyVector3sArray: function ( vectors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
				var vector = vectors[ i ];
	
				if ( vector === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new THREE.Vector3();
	
				}
	
				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
	
			}
	
			return this;
	
		},
	
		copyVector4sArray: function ( vectors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
				var vector = vectors[ i ];
	
				if ( vector === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new THREE.Vector4();
	
				}
	
				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;
	
			}
	
			return this;
	
		},
	
		set: function ( value, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.array.set( value, offset );
	
			return this;
	
		},
	
		getX: function ( index ) {
	
			return this.array[ index * this.itemSize ];
	
		},
	
		setX: function ( index, x ) {
	
			this.array[ index * this.itemSize ] = x;
	
			return this;
	
		},
	
		getY: function ( index ) {
	
			return this.array[ index * this.itemSize + 1 ];
	
		},
	
		setY: function ( index, y ) {
	
			this.array[ index * this.itemSize + 1 ] = y;
	
			return this;
	
		},
	
		getZ: function ( index ) {
	
			return this.array[ index * this.itemSize + 2 ];
	
		},
	
		setZ: function ( index, z ) {
	
			this.array[ index * this.itemSize + 2 ] = z;
	
			return this;
	
		},
	
		getW: function ( index ) {
	
			return this.array[ index * this.itemSize + 3 ];
	
		},
	
		setW: function ( index, w ) {
	
			this.array[ index * this.itemSize + 3 ] = w;
	
			return this;
	
		},
	
		setXY: function ( index, x, y ) {
	
			index *= this.itemSize;
	
			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
	
			return this;
	
		},
	
		setXYZ: function ( index, x, y, z ) {
	
			index *= this.itemSize;
	
			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
	
			return this;
	
		},
	
		setXYZW: function ( index, x, y, z, w ) {
	
			index *= this.itemSize;
	
			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		}
	
	};
	
	//
	
	THREE.Int8Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Int8Array( array ), itemSize );
	
	};
	
	THREE.Uint8Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );
	
	};
	
	THREE.Uint8ClampedAttribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );
	
	};
	
	THREE.Int16Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Int16Array( array ), itemSize );
	
	};
	
	THREE.Uint16Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );
	
	};
	
	THREE.Int32Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Int32Array( array ), itemSize );
	
	};
	
	THREE.Uint32Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );
	
	};
	
	THREE.Float32Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Float32Array( array ), itemSize );
	
	};
	
	THREE.Float64Attribute = function ( array, itemSize ) {
	
		return new THREE.BufferAttribute( new Float64Array( array ), itemSize );
	
	};
	
	
	// Deprecated
	
	THREE.DynamicBufferAttribute = function ( array, itemSize ) {
	
		console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
		return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );
	
	};
	
	// File:src/core/InstancedBufferAttribute.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {
	
		THREE.BufferAttribute.call( this, array, itemSize );
	
		this.meshPerAttribute = meshPerAttribute || 1;
	
	};
	
	THREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
	THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;
	
	THREE.InstancedBufferAttribute.prototype.copy = function ( source ) {
	
		THREE.BufferAttribute.prototype.copy.call( this, source );
	
		this.meshPerAttribute = source.meshPerAttribute;
	
		return this;
	
	};
	
	// File:src/core/InterleavedBuffer.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InterleavedBuffer = function ( array, stride ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.array = array;
		this.stride = stride;
	
		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };
	
		this.version = 0;
	
	};
	
	THREE.InterleavedBuffer.prototype = {
	
		constructor: THREE.InterleavedBuffer,
	
		get length () {
	
			return this.array.length;
	
		},
	
		get count () {
	
			return this.array.length / this.stride;
	
		},
	
		set needsUpdate( value ) {
	
			if ( value === true ) this.version ++;
	
		},
	
		setDynamic: function ( value ) {
	
			this.dynamic = value;
	
			return this;
	
		},
	
		copy: function ( source ) {
	
			this.array = new source.array.constructor( source.array );
			this.stride = source.stride;
			this.dynamic = source.dynamic;
	
		},
	
		copyAt: function ( index1, attribute, index2 ) {
	
			index1 *= this.stride;
			index2 *= attribute.stride;
	
			for ( var i = 0, l = this.stride; i < l; i ++ ) {
	
				this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
			}
	
			return this;
	
		},
	
		set: function ( value, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.array.set( value, offset );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		}
	
	};
	
	// File:src/core/InstancedInterleavedBuffer.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {
	
		THREE.InterleavedBuffer.call( this, array, stride );
	
		this.meshPerAttribute = meshPerAttribute || 1;
	
	};
	
	THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
	THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;
	
	THREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {
	
		THREE.InterleavedBuffer.prototype.copy.call( this, source );
	
		this.meshPerAttribute = source.meshPerAttribute;
	
		return this;
	
	};
	
	// File:src/core/InterleavedBufferAttribute.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;
	
	};
	
	
	THREE.InterleavedBufferAttribute.prototype = {
	
		constructor: THREE.InterleavedBufferAttribute,
	
		get length() {
	
			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
			return this.array.length;
	
		},
	
		get count() {
	
			return this.data.array.length / this.data.stride;
	
		},
	
		setX: function ( index, x ) {
	
			this.data.array[ index * this.data.stride + this.offset ] = x;
	
			return this;
	
		},
	
		setY: function ( index, y ) {
	
			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;
	
			return this;
	
		},
	
		setZ: function ( index, z ) {
	
			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;
	
			return this;
	
		},
	
		setW: function ( index, w ) {
	
			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;
	
			return this;
	
		},
	
		getX: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset ];
	
		},
	
		getY: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset + 1 ];
	
		},
	
		getZ: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset + 2 ];
	
		},
	
		getW: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset + 3 ];
	
		},
	
		setXY: function ( index, x, y ) {
	
			index = index * this.data.stride + this.offset;
	
			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
	
			return this;
	
		},
	
		setXYZ: function ( index, x, y, z ) {
	
			index = index * this.data.stride + this.offset;
	
			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
	
			return this;
	
		},
	
		setXYZW: function ( index, x, y, z, w ) {
	
			index = index * this.data.stride + this.offset;
	
			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;
	
			return this;
	
		}
	
	};
	
	// File:src/core/Geometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://clara.io
	 */
	
	THREE.Geometry = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'Geometry';
	
		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [ [] ];
	
		this.morphTargets = [];
		this.morphNormals = [];
	
		this.skinWeights = [];
		this.skinIndices = [];
	
		this.lineDistances = [];
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		// update flags
	
		this.verticesNeedUpdate = false;
		this.elementsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;
	
	};
	
	THREE.Geometry.prototype = {
	
		constructor: THREE.Geometry,
	
		applyMatrix: function ( matrix ) {
	
			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	
			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {
	
				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );
	
			}
	
			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {
	
				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();
	
				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();
	
				}
	
			}
	
			if ( this.boundingBox !== null ) {
	
				this.computeBoundingBox();
	
			}
	
			if ( this.boundingSphere !== null ) {
	
				this.computeBoundingSphere();
	
			}
	
			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;
	
		},
	
		rotateX: function () {
	
			// rotate geometry around world x-axis
	
			var m1;
	
			return function rotateX( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationX( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateY: function () {
	
			// rotate geometry around world y-axis
	
			var m1;
	
			return function rotateY( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationY( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateZ: function () {
	
			// rotate geometry around world z-axis
	
			var m1;
	
			return function rotateZ( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationZ( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		translate: function () {
	
			// translate geometry
	
			var m1;
	
			return function translate( x, y, z ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeTranslation( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		scale: function () {
	
			// scale geometry
	
			var m1;
	
			return function scale( x, y, z ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeScale( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		lookAt: function () {
	
			var obj;
	
			return function lookAt( vector ) {
	
				if ( obj === undefined ) obj = new THREE.Object3D();
	
				obj.lookAt( vector );
	
				obj.updateMatrix();
	
				this.applyMatrix( obj.matrix );
	
			};
	
		}(),
	
		fromBufferGeometry: function ( geometry ) {
	
			var scope = this;
	
			var indices = geometry.index !== null ? geometry.index.array : undefined;
			var attributes = geometry.attributes;
	
			var vertices = attributes.position.array;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
			var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
	
			if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];
	
			var tempNormals = [];
			var tempUVs = [];
			var tempUVs2 = [];
	
			for ( var i = 0, j = 0, k = 0; i < vertices.length; i += 3, j += 2, k += 4 ) {
	
				scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );
	
				if ( normals !== undefined ) {
	
					tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );
	
				}
	
				if ( colors !== undefined ) {
	
					scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );
	
				}
	
				if ( uvs !== undefined ) {
	
					tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );
	
				}
	
				if ( uvs2 !== undefined ) {
	
					tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );
	
				}
	
			}
	
			function addFace( a, b, c ) {
	
				var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
				var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];
	
				var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors );
	
				scope.faces.push( face );
	
				if ( uvs !== undefined ) {
	
					scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );
	
				}
	
				if ( uvs2 !== undefined ) {
	
					scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );
	
				}
	
			};
	
			if ( indices !== undefined ) {
	
				var groups = geometry.groups;
	
				if ( groups.length > 0 ) {
	
					for ( var i = 0; i < groups.length; i ++ ) {
	
						var group = groups[ i ];
	
						var start = group.start;
						var count = group.count;
	
						for ( var j = start, jl = start + count; j < jl; j += 3 ) {
	
							addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ] );
	
						}
	
					}
	
				} else {
	
					for ( var i = 0; i < indices.length; i += 3 ) {
	
						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );
	
					}
	
				}
	
			} else {
	
				for ( var i = 0; i < vertices.length / 3; i += 3 ) {
	
					addFace( i, i + 1, i + 2 );
	
				}
	
			}
	
			this.computeFaceNormals();
	
			if ( geometry.boundingBox !== null ) {
	
				this.boundingBox = geometry.boundingBox.clone();
	
			}
	
			if ( geometry.boundingSphere !== null ) {
	
				this.boundingSphere = geometry.boundingSphere.clone();
	
			}
	
			return this;
	
		},
	
		center: function () {
	
			this.computeBoundingBox();
	
			var offset = this.boundingBox.center().negate();
	
			this.translate( offset.x, offset.y, offset.z );
	
			return offset;
	
		},
	
		normalize: function () {
	
			this.computeBoundingSphere();
	
			var center = this.boundingSphere.center;
			var radius = this.boundingSphere.radius;
	
			var s = radius === 0 ? 1 : 1.0 / radius;
	
			var matrix = new THREE.Matrix4();
			matrix.set(
				s, 0, 0, - s * center.x,
				0, s, 0, - s * center.y,
				0, 0, s, - s * center.z,
				0, 0, 0, 1
			);
	
			this.applyMatrix( matrix );
	
			return this;
	
		},
	
		computeFaceNormals: function () {
	
			var cb = new THREE.Vector3(), ab = new THREE.Vector3();
	
			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				var face = this.faces[ f ];
	
				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];
	
				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );
	
				cb.normalize();
	
				face.normal.copy( cb );
	
			}
	
		},
	
		computeVertexNormals: function ( areaWeighted ) {
	
			var v, vl, f, fl, face, vertices;
	
			vertices = new Array( this.vertices.length );
	
			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
				vertices[ v ] = new THREE.Vector3();
	
			}
	
			if ( areaWeighted ) {
	
				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm
	
				var vA, vB, vC;
				var cb = new THREE.Vector3(), ab = new THREE.Vector3();
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];
	
					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );
	
					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );
	
				}
	
			} else {
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );
	
				}
	
			}
	
			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
				vertices[ v ].normalize();
	
			}
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				var vertexNormals = face.vertexNormals;
	
				if ( vertexNormals.length === 3 ) {
	
					vertexNormals[ 0 ].copy( vertices[ face.a ] );
					vertexNormals[ 1 ].copy( vertices[ face.b ] );
					vertexNormals[ 2 ].copy( vertices[ face.c ] );
	
				} else {
	
					vertexNormals[ 0 ] = vertices[ face.a ].clone();
					vertexNormals[ 1 ] = vertices[ face.b ].clone();
					vertexNormals[ 2 ] = vertices[ face.c ].clone();
	
				}
	
			}
	
		},
	
		computeMorphNormals: function () {
	
			var i, il, f, fl, face;
	
			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				if ( ! face.__originalFaceNormal ) {
	
					face.__originalFaceNormal = face.normal.clone();
	
				} else {
	
					face.__originalFaceNormal.copy( face.normal );
	
				}
	
				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];
	
				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {
	
					if ( ! face.__originalVertexNormals[ i ] ) {
	
						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();
	
					} else {
	
						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );
	
					}
	
				}
	
			}
	
			// use temp geometry to compute face and vertex normals for each morph
	
			var tmpGeo = new THREE.Geometry();
			tmpGeo.faces = this.faces;
	
			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {
	
				// create on first access
	
				if ( ! this.morphNormals[ i ] ) {
	
					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];
	
					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;
	
					var faceNormal, vertexNormals;
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						faceNormal = new THREE.Vector3();
						vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };
	
						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );
	
					}
	
				}
	
				var morphNormals = this.morphNormals[ i ];
	
				// set vertices to morph target
	
				tmpGeo.vertices = this.morphTargets[ i ].vertices;
	
				// compute morph normals
	
				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();
	
				// store morph normals
	
				var faceNormal, vertexNormals;
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];
	
					faceNormal.copy( face.normal );
	
					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );
	
				}
	
			}
	
			// restore original normals
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;
	
			}
	
		},
	
		computeTangents: function () {
	
			console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );
	
		},
	
		computeLineDistances: function () {
	
			var d = 0;
			var vertices = this.vertices;
	
			for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
				if ( i > 0 ) {
	
					d += vertices[ i ].distanceTo( vertices[ i - 1 ] );
	
				}
	
				this.lineDistances[ i ] = d;
	
			}
	
		},
	
		computeBoundingBox: function () {
	
			if ( this.boundingBox === null ) {
	
				this.boundingBox = new THREE.Box3();
	
			}
	
			this.boundingBox.setFromPoints( this.vertices );
	
		},
	
		computeBoundingSphere: function () {
	
			if ( this.boundingSphere === null ) {
	
				this.boundingSphere = new THREE.Sphere();
	
			}
	
			this.boundingSphere.setFromPoints( this.vertices );
	
		},
	
		merge: function ( geometry, matrix, materialIndexOffset ) {
	
			if ( geometry instanceof THREE.Geometry === false ) {
	
				console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;
	
			}
	
			var normalMatrix,
			vertexOffset = this.vertices.length,
			vertices1 = this.vertices,
			vertices2 = geometry.vertices,
			faces1 = this.faces,
			faces2 = geometry.faces,
			uvs1 = this.faceVertexUvs[ 0 ],
			uvs2 = geometry.faceVertexUvs[ 0 ];
	
			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;
	
			if ( matrix !== undefined ) {
	
				normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	
			}
	
			// vertices
	
			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {
	
				var vertex = vertices2[ i ];
	
				var vertexCopy = vertex.clone();
	
				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );
	
				vertices1.push( vertexCopy );
	
			}
	
			// faces
	
			for ( i = 0, il = faces2.length; i < il; i ++ ) {
	
				var face = faces2[ i ], faceCopy, normal, color,
				faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;
	
				faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );
	
				if ( normalMatrix !== undefined ) {
	
					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();
	
				}
	
				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {
	
					normal = faceVertexNormals[ j ].clone();
	
					if ( normalMatrix !== undefined ) {
	
						normal.applyMatrix3( normalMatrix ).normalize();
	
					}
	
					faceCopy.vertexNormals.push( normal );
	
				}
	
				faceCopy.color.copy( face.color );
	
				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {
	
					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );
	
				}
	
				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
	
				faces1.push( faceCopy );
	
			}
	
			// uvs
	
			for ( i = 0, il = uvs2.length; i < il; i ++ ) {
	
				var uv = uvs2[ i ], uvCopy = [];
	
				if ( uv === undefined ) {
	
					continue;
	
				}
	
				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {
	
					uvCopy.push( uv[ j ].clone() );
	
				}
	
				uvs1.push( uvCopy );
	
			}
	
		},
	
		mergeMesh: function ( mesh ) {
	
			if ( mesh instanceof THREE.Mesh === false ) {
	
				console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;
	
			}
	
			mesh.matrixAutoUpdate && mesh.updateMatrix();
	
			this.merge( mesh.geometry, mesh.matrix );
	
		},
	
		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */
	
		mergeVertices: function () {
	
			var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
			var unique = [], changes = [];
	
			var v, key;
			var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;
	
			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {
	
				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );
	
				if ( verticesMap[ key ] === undefined ) {
	
					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;
	
				} else {
	
					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];
	
				}
	
			}
	
	
			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];
	
			for ( i = 0, il = this.faces.length; i < il; i ++ ) {
	
				face = this.faces[ i ];
	
				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];
	
				indices = [ face.a, face.b, face.c ];
	
				var dupIndex = - 1;
	
				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {
	
					if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {
	
						dupIndex = n;
						faceIndicesToRemove.push( i );
						break;
	
					}
	
				}
	
			}
	
			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
	
				var idx = faceIndicesToRemove[ i ];
	
				this.faces.splice( idx, 1 );
	
				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {
	
					this.faceVertexUvs[ j ].splice( idx, 1 );
	
				}
	
			}
	
			// Use unique set of vertices
	
			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;
	
		},
	
		sortFacesByMaterialIndex: function () {
	
			var faces = this.faces;
			var length = faces.length;
	
			// tag faces
	
			for ( var i = 0; i < length; i ++ ) {
	
				faces[ i ]._id = i;
	
			}
	
			// sort faces
	
			function materialIndexSort( a, b ) {
	
				return a.materialIndex - b.materialIndex;
	
			}
	
			faces.sort( materialIndexSort );
	
			// sort uvs
	
			var uvs1 = this.faceVertexUvs[ 0 ];
			var uvs2 = this.faceVertexUvs[ 1 ];
	
			var newUvs1, newUvs2;
	
			if ( uvs1 && uvs1.length === length ) newUvs1 = [];
			if ( uvs2 && uvs2.length === length ) newUvs2 = [];
	
			for ( var i = 0; i < length; i ++ ) {
	
				var id = faces[ i ]._id;
	
				if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
				if ( newUvs2 ) newUvs2.push( uvs2[ id ] );
	
			}
	
			if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
			if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;
	
		},
	
		toJSON: function () {
	
			var data = {
				metadata: {
					version: 4.4,
					type: 'Geometry',
					generator: 'Geometry.toJSON'
				}
			};
	
			// standard Geometry serialization
	
			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
	
			if ( this.parameters !== undefined ) {
	
				var parameters = this.parameters;
	
				for ( var key in parameters ) {
	
					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
	
				}
	
				return data;
	
			}
	
			var vertices = [];
	
			for ( var i = 0; i < this.vertices.length; i ++ ) {
	
				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );
	
			}
	
			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};
	
			for ( var i = 0; i < this.faces.length; i ++ ) {
	
				var face = this.faces[ i ];
	
				var hasMaterial = false; // face.materialIndex !== undefined;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;
	
				var faceType = 0;
	
				faceType = setBit( faceType, 0, 0 );
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );
	
				faces.push( faceType );
				faces.push( face.a, face.b, face.c );
	
				if ( hasFaceVertexUv ) {
	
					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];
	
					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);
	
				}
	
				if ( hasFaceNormal ) {
	
					faces.push( getNormalIndex( face.normal ) );
	
				}
	
				if ( hasFaceVertexNormal ) {
	
					var vertexNormals = face.vertexNormals;
	
					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);
	
				}
	
				if ( hasFaceColor ) {
	
					faces.push( getColorIndex( face.color ) );
	
				}
	
				if ( hasFaceVertexColor ) {
	
					var vertexColors = face.vertexColors;
	
					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);
	
				}
	
			}
	
			function setBit( value, position, enabled ) {
	
				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );
	
			}
	
			function getNormalIndex( normal ) {
	
				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
	
				if ( normalsHash[ hash ] !== undefined ) {
	
					return normalsHash[ hash ];
	
				}
	
				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );
	
				return normalsHash[ hash ];
	
			}
	
			function getColorIndex( color ) {
	
				var hash = color.r.toString() + color.g.toString() + color.b.toString();
	
				if ( colorsHash[ hash ] !== undefined ) {
	
					return colorsHash[ hash ];
	
				}
	
				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );
	
				return colorsHash[ hash ];
	
			}
	
			function getUvIndex( uv ) {
	
				var hash = uv.x.toString() + uv.y.toString();
	
				if ( uvsHash[ hash ] !== undefined ) {
	
					return uvsHash[ hash ];
	
				}
	
				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );
	
				return uvsHash[ hash ];
	
			}
	
			data.data = {};
	
			data.data.vertices = vertices;
			data.data.normals = normals;
			if ( colors.length > 0 ) data.data.colors = colors;
			if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
			data.data.faces = faces;
	
			return data;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.vertices = [];
			this.faces = [];
			this.faceVertexUvs = [ [] ];
	
			var vertices = source.vertices;
	
			for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
				this.vertices.push( vertices[ i ].clone() );
	
			}
	
			var faces = source.faces;
	
			for ( var i = 0, il = faces.length; i < il; i ++ ) {
	
				this.faces.push( faces[ i ].clone() );
	
			}
	
			for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {
	
				var faceVertexUvs = source.faceVertexUvs[ i ];
	
				if ( this.faceVertexUvs[ i ] === undefined ) {
	
					this.faceVertexUvs[ i ] = [];
	
				}
	
				for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {
	
					var uvs = faceVertexUvs[ j ], uvsCopy = [];
	
					for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {
	
						var uv = uvs[ k ];
	
						uvsCopy.push( uv.clone() );
	
					}
	
					this.faceVertexUvs[ i ].push( uvsCopy );
	
				}
	
			}
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );
	
	THREE.GeometryIdCount = 0;
	
	// File:src/core/DirectGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.DirectGeometry = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'DirectGeometry';
	
		this.indices = [];
		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];
	
		this.groups = [];
	
		this.morphTargets = {};
	
		this.skinWeights = [];
		this.skinIndices = [];
	
		// this.lineDistances = [];
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		// update flags
	
		this.verticesNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.groupsNeedUpdate = false;
	
	};
	
	THREE.DirectGeometry.prototype = {
	
		constructor: THREE.DirectGeometry,
	
		computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
		computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,
	
		computeFaceNormals: function () {
	
			console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );
	
		},
	
		computeVertexNormals: function () {
	
			console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );
	
		},
	
		computeGroups: function ( geometry ) {
	
			var group;
			var groups = [];
			var materialIndex;
	
			var faces = geometry.faces;
	
			for ( var i = 0; i < faces.length; i ++ ) {
	
				var face = faces[ i ];
	
				// materials
	
				if ( face.materialIndex !== materialIndex ) {
	
					materialIndex = face.materialIndex;
	
					if ( group !== undefined ) {
	
						group.count = ( i * 3 ) - group.start;
						groups.push( group );
	
					}
	
					group = {
						start: i * 3,
						materialIndex: materialIndex
					};
	
				}
	
			}
	
			if ( group !== undefined ) {
	
				group.count = ( i * 3 ) - group.start;
				groups.push( group );
	
			}
	
			this.groups = groups;
	
		},
	
		fromGeometry: function ( geometry ) {
	
			var faces = geometry.faces;
			var vertices = geometry.vertices;
			var faceVertexUvs = geometry.faceVertexUvs;
	
			var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
			var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;
	
			// morphs
	
			var morphTargets = geometry.morphTargets;
			var morphTargetsLength = morphTargets.length;
	
			if ( morphTargetsLength > 0 ) {
	
				var morphTargetsPosition = [];
	
				for ( var i = 0; i < morphTargetsLength; i ++ ) {
	
					morphTargetsPosition[ i ] = [];
	
				}
	
				this.morphTargets.position = morphTargetsPosition;
	
			}
	
			var morphNormals = geometry.morphNormals;
			var morphNormalsLength = morphNormals.length;
	
			if ( morphNormalsLength > 0 ) {
	
				var morphTargetsNormal = [];
	
				for ( var i = 0; i < morphNormalsLength; i ++ ) {
	
					morphTargetsNormal[ i ] = [];
	
				}
	
				this.morphTargets.normal = morphTargetsNormal;
	
			}
	
			// skins
	
			var skinIndices = geometry.skinIndices;
			var skinWeights = geometry.skinWeights;
	
			var hasSkinIndices = skinIndices.length === vertices.length;
			var hasSkinWeights = skinWeights.length === vertices.length;
	
			//
	
			for ( var i = 0; i < faces.length; i ++ ) {
	
				var face = faces[ i ];
	
				this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );
	
				var vertexNormals = face.vertexNormals;
	
				if ( vertexNormals.length === 3 ) {
	
					this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );
	
				} else {
	
					var normal = face.normal;
	
					this.normals.push( normal, normal, normal );
	
				}
	
				var vertexColors = face.vertexColors;
	
				if ( vertexColors.length === 3 ) {
	
					this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );
	
				} else {
	
					var color = face.color;
	
					this.colors.push( color, color, color );
	
				}
	
				if ( hasFaceVertexUv === true ) {
	
					var vertexUvs = faceVertexUvs[ 0 ][ i ];
	
					if ( vertexUvs !== undefined ) {
	
						this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
	
					} else {
	
						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );
	
						this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );
	
					}
	
				}
	
				if ( hasFaceVertexUv2 === true ) {
	
					var vertexUvs = faceVertexUvs[ 1 ][ i ];
	
					if ( vertexUvs !== undefined ) {
	
						this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
	
					} else {
	
						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );
	
						this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );
	
					}
	
				}
	
				// morphs
	
				for ( var j = 0; j < morphTargetsLength; j ++ ) {
	
					var morphTarget = morphTargets[ j ].vertices;
	
					morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );
	
				}
	
				for ( var j = 0; j < morphNormalsLength; j ++ ) {
	
					var morphNormal = morphNormals[ j ].vertexNormals[ i ];
	
					morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );
	
				}
	
				// skins
	
				if ( hasSkinIndices ) {
	
					this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );
	
				}
	
				if ( hasSkinWeights ) {
	
					this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );
	
				}
	
			}
	
			this.computeGroups( geometry );
	
			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
			this.groupsNeedUpdate = geometry.groupsNeedUpdate;
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );
	
	// File:src/core/BufferGeometry.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BufferGeometry = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'BufferGeometry';
	
		this.index = null;
		this.attributes = {};
	
		this.morphAttributes = {};
	
		this.groups = [];
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		this.drawRange = { start: 0, count: Infinity };
	
	};
	
	THREE.BufferGeometry.prototype = {
	
		constructor: THREE.BufferGeometry,
	
		addIndex: function ( index ) {
	
			console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
			this.setIndex( index );
	
		},
	
		getIndex: function () {
	
			return this.index;
	
		},
	
		setIndex: function ( index ) {
	
			this.index = index;
	
		},
	
		addAttribute: function ( name, attribute ) {
	
			if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {
	
				console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );
	
				this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );
	
				return;
	
			}
	
			if ( name === 'index' ) {
	
				console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
				this.setIndex( attribute );
	
				return;
	
			}
	
			this.attributes[ name ] = attribute;
	
		},
	
		getAttribute: function ( name ) {
	
			return this.attributes[ name ];
	
		},
	
		removeAttribute: function ( name ) {
	
			delete this.attributes[ name ];
	
		},
	
		get drawcalls() {
	
			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			return this.groups;
	
		},
	
		get offsets() {
	
			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			return this.groups;
	
		},
	
		addDrawCall: function ( start, count, indexOffset ) {
	
			if ( indexOffset !== undefined ) {
	
				console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
	
			}
	
			console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
			this.addGroup( start, count );
	
		},
	
		clearDrawCalls: function () {
	
			console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
			this.clearGroups();
	
		},
	
		addGroup: function ( start, count, materialIndex ) {
	
			this.groups.push( {
	
				start: start,
				count: count,
				materialIndex: materialIndex !== undefined ? materialIndex : 0
	
			} );
	
		},
	
		clearGroups: function () {
	
			this.groups = [];
	
		},
	
		setDrawRange: function ( start, count ) {
	
			this.drawRange.start = start;
			this.drawRange.count = count;
	
		},
	
		applyMatrix: function ( matrix ) {
	
			var position = this.attributes.position;
	
			if ( position !== undefined ) {
	
				matrix.applyToVector3Array( position.array );
				position.needsUpdate = true;
	
			}
	
			var normal = this.attributes.normal;
	
			if ( normal !== undefined ) {
	
				var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	
				normalMatrix.applyToVector3Array( normal.array );
				normal.needsUpdate = true;
	
			}
	
			if ( this.boundingBox !== null ) {
	
				this.computeBoundingBox();
	
			}
	
			if ( this.boundingSphere !== null ) {
	
				this.computeBoundingSphere();
	
			}
	
		},
	
		rotateX: function () {
	
			// rotate geometry around world x-axis
	
			var m1;
	
			return function rotateX( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationX( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateY: function () {
	
			// rotate geometry around world y-axis
	
			var m1;
	
			return function rotateY( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationY( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateZ: function () {
	
			// rotate geometry around world z-axis
	
			var m1;
	
			return function rotateZ( angle ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeRotationZ( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		translate: function () {
	
			// translate geometry
	
			var m1;
	
			return function translate( x, y, z ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeTranslation( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		scale: function () {
	
			// scale geometry
	
			var m1;
	
			return function scale( x, y, z ) {
	
				if ( m1 === undefined ) m1 = new THREE.Matrix4();
	
				m1.makeScale( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		lookAt: function () {
	
			var obj;
	
			return function lookAt( vector ) {
	
				if ( obj === undefined ) obj = new THREE.Object3D();
	
				obj.lookAt( vector );
	
				obj.updateMatrix();
	
				this.applyMatrix( obj.matrix );
	
			};
	
		}(),
	
		center: function () {
	
			this.computeBoundingBox();
	
			var offset = this.boundingBox.center().negate();
	
			this.translate( offset.x, offset.y, offset.z );
	
			return offset;
	
		},
	
		setFromObject: function ( object ) {
	
			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
	
			var geometry = object.geometry;
	
			if ( object instanceof THREE.Points || object instanceof THREE.Line ) {
	
				var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
				var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );
	
				this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
				this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );
	
				if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {
	
					var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );
	
					this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );
	
				}
	
				if ( geometry.boundingSphere !== null ) {
	
					this.boundingSphere = geometry.boundingSphere.clone();
	
				}
	
				if ( geometry.boundingBox !== null ) {
	
					this.boundingBox = geometry.boundingBox.clone();
	
				}
	
			} else if ( object instanceof THREE.Mesh ) {
	
				if ( geometry instanceof THREE.Geometry ) {
	
					this.fromGeometry( geometry );
	
				}
	
			}
	
			return this;
	
		},
	
		updateFromObject: function ( object ) {
	
			var geometry = object.geometry;
	
			if ( object instanceof THREE.Mesh ) {
	
				var direct = geometry.__directGeometry;
	
				if ( direct === undefined ) {
	
					return this.fromGeometry( geometry );
	
				}
	
				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
	
				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;
	
				geometry = direct;
	
			}
	
			if ( geometry.verticesNeedUpdate === true ) {
	
				var attribute = this.attributes.position;
	
				if ( attribute !== undefined ) {
	
					attribute.copyVector3sArray( geometry.vertices );
					attribute.needsUpdate = true;
	
				}
	
				geometry.verticesNeedUpdate = false;
	
			}
	
			if ( geometry.normalsNeedUpdate === true ) {
	
				var attribute = this.attributes.normal;
	
				if ( attribute !== undefined ) {
	
					attribute.copyVector3sArray( geometry.normals );
					attribute.needsUpdate = true;
	
				}
	
				geometry.normalsNeedUpdate = false;
	
			}
	
			if ( geometry.colorsNeedUpdate === true ) {
	
				var attribute = this.attributes.color;
	
				if ( attribute !== undefined ) {
	
					attribute.copyColorsArray( geometry.colors );
					attribute.needsUpdate = true;
	
				}
	
				geometry.colorsNeedUpdate = false;
	
			}
	
			if ( geometry.uvsNeedUpdate ) {
	
					var attribute = this.attributes.uv;
	
					if ( attribute !== undefined ) {
	
							attribute.copyVector2sArray( geometry.uvs );
							attribute.needsUpdate = true;
	
					}
	
					geometry.uvsNeedUpdate = false;
	
			}
	
			if ( geometry.lineDistancesNeedUpdate ) {
	
				var attribute = this.attributes.lineDistance;
	
				if ( attribute !== undefined ) {
	
					attribute.copyArray( geometry.lineDistances );
					attribute.needsUpdate = true;
	
				}
	
				geometry.lineDistancesNeedUpdate = false;
	
			}
	
			if ( geometry.groupsNeedUpdate ) {
	
				geometry.computeGroups( object.geometry );
				this.groups = geometry.groups;
	
				geometry.groupsNeedUpdate = false;
	
			}
	
			return this;
	
		},
	
		fromGeometry: function ( geometry ) {
	
			geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );
	
			return this.fromDirectGeometry( geometry.__directGeometry );
	
		},
	
		fromDirectGeometry: function ( geometry ) {
	
			var positions = new Float32Array( geometry.vertices.length * 3 );
			this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );
	
			if ( geometry.normals.length > 0 ) {
	
				var normals = new Float32Array( geometry.normals.length * 3 );
				this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );
	
			}
	
			if ( geometry.colors.length > 0 ) {
	
				var colors = new Float32Array( geometry.colors.length * 3 );
				this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );
	
			}
	
			if ( geometry.uvs.length > 0 ) {
	
				var uvs = new Float32Array( geometry.uvs.length * 2 );
				this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );
	
			}
	
			if ( geometry.uvs2.length > 0 ) {
	
				var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
				this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );
	
			}
	
			if ( geometry.indices.length > 0 ) {
	
				var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
				var indices = new TypeArray( geometry.indices.length * 3 );
				this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );
	
			}
	
			// groups
	
			this.groups = geometry.groups;
	
			// morphs
	
			for ( var name in geometry.morphTargets ) {
	
				var array = [];
				var morphTargets = geometry.morphTargets[ name ];
	
				for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {
	
					var morphTarget = morphTargets[ i ];
	
					var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );
	
					array.push( attribute.copyVector3sArray( morphTarget ) );
	
				}
	
				this.morphAttributes[ name ] = array;
	
			}
	
			// skinning
	
			if ( geometry.skinIndices.length > 0 ) {
	
				var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
				this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );
	
			}
	
			if ( geometry.skinWeights.length > 0 ) {
	
				var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
				this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );
	
			}
	
			//
	
			if ( geometry.boundingSphere !== null ) {
	
				this.boundingSphere = geometry.boundingSphere.clone();
	
			}
	
			if ( geometry.boundingBox !== null ) {
	
				this.boundingBox = geometry.boundingBox.clone();
	
			}
	
			return this;
	
		},
	
		computeBoundingBox: function () {
	
			var vector = new THREE.Vector3();
	
			return function () {
	
				if ( this.boundingBox === null ) {
	
					this.boundingBox = new THREE.Box3();
	
				}
	
				var positions = this.attributes.position.array;
	
				if ( positions ) {
	
					var bb = this.boundingBox;
					bb.makeEmpty();
	
					for ( var i = 0, il = positions.length; i < il; i += 3 ) {
	
						vector.fromArray( positions, i );
						bb.expandByPoint( vector );
	
					}
	
				}
	
				if ( positions === undefined || positions.length === 0 ) {
	
					this.boundingBox.min.set( 0, 0, 0 );
					this.boundingBox.max.set( 0, 0, 0 );
	
				}
	
				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {
	
					console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );
	
				}
	
			};
	
		}(),
	
		computeBoundingSphere: function () {
	
			var box = new THREE.Box3();
			var vector = new THREE.Vector3();
	
			return function () {
	
				if ( this.boundingSphere === null ) {
	
					this.boundingSphere = new THREE.Sphere();
	
				}
	
				var positions = this.attributes.position.array;
	
				if ( positions ) {
	
					box.makeEmpty();
	
					var center = this.boundingSphere.center;
	
					for ( var i = 0, il = positions.length; i < il; i += 3 ) {
	
						vector.fromArray( positions, i );
						box.expandByPoint( vector );
	
					}
	
					box.center( center );
	
					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
	
					var maxRadiusSq = 0;
	
					for ( var i = 0, il = positions.length; i < il; i += 3 ) {
	
						vector.fromArray( positions, i );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );
	
					}
	
					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );
	
					if ( isNaN( this.boundingSphere.radius ) ) {
	
						console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );
	
					}
	
				}
	
			};
	
		}(),
	
		computeFaceNormals: function () {
	
			// backwards compatibility
	
		},
	
		computeVertexNormals: function () {
	
			var index = this.index;
			var attributes = this.attributes;
			var groups = this.groups;
	
			if ( attributes.position ) {
	
				var positions = attributes.position.array;
	
				if ( attributes.normal === undefined ) {
	
					this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );
	
				} else {
	
					// reset existing normals to zero
	
					var normals = attributes.normal.array;
	
					for ( var i = 0, il = normals.length; i < il; i ++ ) {
	
						normals[ i ] = 0;
	
					}
	
				}
	
				var normals = attributes.normal.array;
	
				var vA, vB, vC,
	
				pA = new THREE.Vector3(),
				pB = new THREE.Vector3(),
				pC = new THREE.Vector3(),
	
				cb = new THREE.Vector3(),
				ab = new THREE.Vector3();
	
				// indexed elements
	
				if ( index ) {
	
					var indices = index.array;
	
					if ( groups.length === 0 ) {
	
						this.addGroup( 0, indices.length );
	
					}
	
					for ( var j = 0, jl = groups.length; j < jl; ++ j ) {
	
						var group = groups[ j ];
	
						var start = group.start;
						var count = group.count;
	
						for ( var i = start, il = start + count; i < il; i += 3 ) {
	
							vA = indices[ i + 0 ] * 3;
							vB = indices[ i + 1 ] * 3;
							vC = indices[ i + 2 ] * 3;
	
							pA.fromArray( positions, vA );
							pB.fromArray( positions, vB );
							pC.fromArray( positions, vC );
	
							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );
	
							normals[ vA ] += cb.x;
							normals[ vA + 1 ] += cb.y;
							normals[ vA + 2 ] += cb.z;
	
							normals[ vB ] += cb.x;
							normals[ vB + 1 ] += cb.y;
							normals[ vB + 2 ] += cb.z;
	
							normals[ vC ] += cb.x;
							normals[ vC + 1 ] += cb.y;
							normals[ vC + 2 ] += cb.z;
	
						}
	
					}
	
				} else {
	
					// non-indexed elements (unconnected triangle soup)
	
					for ( var i = 0, il = positions.length; i < il; i += 9 ) {
	
						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );
	
						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );
	
						normals[ i ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;
	
						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;
	
						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;
	
					}
	
				}
	
				this.normalizeNormals();
	
				attributes.normal.needsUpdate = true;
	
			}
	
		},
	
		computeTangents: function () {
	
			console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
	
		},
	
		computeOffsets: function ( size ) {
	
			console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.')
	
		},
	
		merge: function ( geometry, offset ) {
	
			if ( geometry instanceof THREE.BufferGeometry === false ) {
	
				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;
	
			}
	
			if ( offset === undefined ) offset = 0;
	
			var attributes = this.attributes;
	
			for ( var key in attributes ) {
	
				if ( geometry.attributes[ key ] === undefined ) continue;
	
				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;
	
				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;
	
				var attributeSize = attribute2.itemSize;
	
				for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {
	
					attributeArray1[ j ] = attributeArray2[ i ];
	
				}
	
			}
	
			return this;
	
		},
	
		normalizeNormals: function () {
	
			var normals = this.attributes.normal.array;
	
			var x, y, z, n;
	
			for ( var i = 0, il = normals.length; i < il; i += 3 ) {
	
				x = normals[ i ];
				y = normals[ i + 1 ];
				z = normals[ i + 2 ];
	
				n = 1.0 / Math.sqrt( x * x + y * y + z * z );
	
				normals[ i ] *= n;
				normals[ i + 1 ] *= n;
				normals[ i + 2 ] *= n;
	
			}
	
		},
	
		toJSON: function () {
	
			var data = {
				metadata: {
					version: 4.4,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};
	
			// standard BufferGeometry serialization
	
			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
	
			if ( this.parameters !== undefined ) {
	
				var parameters = this.parameters;
	
				for ( var key in parameters ) {
	
					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
	
				}
	
				return data;
	
			}
	
			data.data = { attributes: {} };
	
			var index = this.index;
	
			if ( index !== null ) {
	
				var array = Array.prototype.slice.call( index.array );
	
				data.data.index = {
					type: index.array.constructor.name,
					array: array
				};
	
			}
	
			var attributes = this.attributes;
	
			for ( var key in attributes ) {
	
				var attribute = attributes[ key ];
	
				var array = Array.prototype.slice.call( attribute.array );
	
				data.data.attributes[ key ] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: array
				};
	
			}
	
			var groups = this.groups;
	
			if ( groups.length > 0 ) {
	
				data.data.groups = JSON.parse( JSON.stringify( groups ) );
	
			}
	
			var boundingSphere = this.boundingSphere;
	
			if ( boundingSphere !== null ) {
	
				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};
	
			}
	
			return data;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			var index = source.index;
	
			if ( index !== null ) {
	
				this.setIndex( index.clone() );
	
			}
	
			var attributes = source.attributes;
	
			for ( var name in attributes ) {
	
				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );
	
			}
	
			var groups = source.groups;
	
			for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
				var group = groups[ i ];
				this.addGroup( group.start, group.count );
	
			}
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );
	
	THREE.BufferGeometry.MaxIndex = 65535;
	
	// File:src/core/InstancedBufferGeometry.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.InstancedBufferGeometry = function () {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'InstancedBufferGeometry';
		this.maxInstancedCount = undefined;
	
	};
	
	THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;
	
	THREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {
	
		this.groups.push( {
	
			start: start,
			count: count,
			instances: instances
	
		} );
	
	};
	
	THREE.InstancedBufferGeometry.prototype.copy = function ( source ) {
	
		var index = source.index;
	
		if ( index !== null ) {
	
			this.setIndex( index.clone() );
	
		}
	
		var attributes = source.attributes;
	
		for ( var name in attributes ) {
	
			var attribute = attributes[ name ];
			this.addAttribute( name, attribute.clone() );
	
		}
	
		var groups = source.groups;
	
		for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
			var group = groups[ i ];
			this.addGroup( group.start, group.count, group.instances );
	
		}
	
		return this;
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );
	
	// File:src/animation/AnimationAction.js
	
	/**
	 *
	 * A clip that has been explicitly scheduled.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	THREE.AnimationAction = function ( clip, startTime, timeScale, weight, loop ) {
	
		if ( clip === undefined ) throw new Error( 'clip is null' );
		this.clip = clip;
		this.localRoot = null;
		this.startTime = startTime || 0;
		this.timeScale = timeScale || 1;
		this.weight = weight || 1;
		this.loop = loop || THREE.LoopRepeat;
		this.loopCount = 0;
		this.enabled = true;	// allow for easy disabling of the action.
	
		this.actionTime = - this.startTime;
		this.clipTime = 0;
	
		this.propertyBindings = [];
	};
	
	/*
	THREE.LoopOnce = 2200;
	THREE.LoopRepeat = 2201;
	THREE.LoopPingPing = 2202;
	*/
	
	THREE.AnimationAction.prototype = {
	
		constructor: THREE.AnimationAction,
	
		setLocalRoot: function( localRoot ) {
	
			this.localRoot = localRoot;
	
			return this;
	
		},
	
		updateTime: function( clipDeltaTime ) {
	
			var previousClipTime = this.clipTime;
	   		var previousLoopCount = this.loopCount;
	   		var previousActionTime = this.actionTime;
	
			var duration = this.clip.duration;
	
			this.actionTime = this.actionTime + clipDeltaTime;
	
			if ( this.loop === THREE.LoopOnce ) {
	
				this.loopCount = 0;
				this.clipTime = Math.min( Math.max( this.actionTime, 0 ), duration );
	
				// if time is changed since last time, see if we have hit a start/end limit
				if ( this.clipTime !== previousClipTime ) {
	
					if ( this.clipTime === duration ) {
	
						this.mixer.dispatchEvent( { type: 'finished', action: this, direction: 1 } );
	
					} else if ( this.clipTime === 0 ) {
	
						this.mixer.dispatchEvent( { type: 'finished', action: this, direction: -1 } );
	
					}
	
				}
	
	
				return this.clipTime;
	
			}
	
			this.loopCount = Math.floor( this.actionTime / duration );
	
			var newClipTime = this.actionTime - this.loopCount * duration;
			newClipTime = newClipTime % duration;
	
			// if we are ping pong looping, ensure that we go backwards when appropriate
			if ( this.loop == THREE.LoopPingPong ) {
	
				if ( Math.abs( this.loopCount % 2 ) === 1 ) {
	
					newClipTime = duration - newClipTime;
	
				}
	
			}
	
			this.clipTime = newClipTime;
	
			if ( this.loopCount !== previousLoopCount ) {
	
	   			this.mixer.dispatchEvent( { type: 'loop', action: this, loopDelta: ( this.loopCount - this.loopCount ) } );
	
	   		}
	
		   	return this.clipTime;
	
		},
	
		syncWith: function( action ) {
	
			this.actionTime = action.actionTime;
			this.timeScale = action.timeScale;
	
			return this;
		},
	
		warpToDuration: function( duration ) {
	
			this.timeScale = this.clip.duration / duration;
	
			return this;
		},
	
		init: function( time ) {
	
			this.clipTime = time - this.startTime;
	
			return this;
	
		},
	
		update: function( clipDeltaTime ) {
	
			this.updateTime( clipDeltaTime );
	
			var clipResults = this.clip.getAt( this.clipTime );
	
			return clipResults;
	
		},
	
		getTimeScaleAt: function( time ) {
	
			if ( this.timeScale.getAt ) {
				// pass in time, not clip time, allows for fadein/fadeout across multiple loops of the clip
				return this.timeScale.getAt( time );
	
			}
	
			return this.timeScale;
	
		},
	
		getWeightAt: function( time ) {
	
			if ( this.weight.getAt ) {
				// pass in time, not clip time, allows for fadein/fadeout across multiple loops of the clip
				return this.weight.getAt( time );
	
			}
	
			return this.weight;
	
		}
	
	};
	
	// File:src/animation/AnimationClip.js
	
	/**
	 *
	 * Reusable set of Tracks that represent an animation.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	THREE.AnimationClip = function ( name, duration, tracks ) {
	
		this.name = name;
		this.tracks = tracks;
		this.duration = ( duration !== undefined ) ? duration : -1;
	
		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {
			for ( var i = 0; i < this.tracks.length; i ++ ) {
				var track = this.tracks[i];
				this.duration = Math.max( track.keys[ track.keys.length - 1 ].time );
			}
		}
	
		// maybe only do these on demand, as doing them here could potentially slow down loading
		// but leaving these here during development as this ensures a lot of testing of these functions
		this.trim();
		this.optimize();
	
		this.results = [];
	
	};
	
	THREE.AnimationClip.prototype = {
	
		constructor: THREE.AnimationClip,
	
		getAt: function( clipTime ) {
	
			clipTime = Math.max( 0, Math.min( clipTime, this.duration ) );
	
			for ( var i = 0; i < this.tracks.length; i ++ ) {
	
				var track = this.tracks[ i ];
	
				this.results[ i ] = track.getAt( clipTime );
	
			}
	
			return this.results;
		},
	
		trim: function() {
	
			for ( var i = 0; i < this.tracks.length; i ++ ) {
	
				this.tracks[ i ].trim( 0, this.duration );
	
			}
	
			return this;
	
		},
	
		optimize: function() {
	
			for ( var i = 0; i < this.tracks.length; i ++ ) {
	
				this.tracks[ i ].optimize();
	
			}
	
			return this;
	
		}
	
	};
	
	
	THREE.AnimationClip.CreateFromMorphTargetSequence = function( name, morphTargetSequence, fps ) {
	
	
		var numMorphTargets = morphTargetSequence.length;
		var tracks = [];
	
		for ( var i = 0; i < numMorphTargets; i ++ ) {
	
			var keys = [];
	
			keys.push( { time: ( i + numMorphTargets - 1 ) % numMorphTargets, value: 0 } );
			keys.push( { time: i, value: 1 } );
			keys.push( { time: ( i + 1 ) % numMorphTargets, value: 0 } );
	
			keys.sort( THREE.KeyframeTrack.keyComparer );
	
			// if there is a key at the first frame, duplicate it as the last frame as well for perfect loop.
			if ( keys[0].time === 0 ) {
				keys.push( {
					time: numMorphTargets,
					value: keys[0].value
				});
			}
	
			tracks.push( new THREE.NumberKeyframeTrack( '.morphTargetInfluences[' + morphTargetSequence[i].name + ']', keys ).scale( 1.0 / fps ) );
		}
	
		return new THREE.AnimationClip( name, -1, tracks );
	
	};
	
	THREE.AnimationClip.findByName = function( clipArray, name ) {
	
		for ( var i = 0; i < clipArray.length; i ++ ) {
	
			if ( clipArray[i].name === name ) {
	
				return clipArray[i];
	
			}
		}
	
		return null;
	
	};
	
	THREE.AnimationClip.CreateClipsFromMorphTargetSequences = function( morphTargets, fps ) {
	
		var animationToMorphTargets = {};
	
		// tested with https://regex101.com/ on trick sequences such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		var pattern = /^([\w-]*?)([\d]+)$/;
	
		// sort morph target names into animation groups based patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {
	
			var morphTarget = morphTargets[ i ];
			var parts = morphTarget.name.match( pattern );
	
			if ( parts && parts.length > 1 ) {
	
				var name = parts[ 1 ];
	
				var animationMorphTargets = animationToMorphTargets[ name ];
				if ( ! animationMorphTargets ) {
					animationToMorphTargets[ name ] = animationMorphTargets = [];
				}
	
				animationMorphTargets.push( morphTarget );
	
			}
	
		}
	
		var clips = [];
	
		for ( var name in animationToMorphTargets ) {
	
			clips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps ) );
		}
	
		return clips;
	
	};
	
	// parse the standard JSON format for clips
	THREE.AnimationClip.parse = function( json ) {
	
		var tracks = [];
	
		for ( var i = 0; i < json.tracks.length; i ++ ) {
	
			tracks.push( THREE.KeyframeTrack.parse( json.tracks[i] ).scale( 1.0 / json.fps ) );
	
		}
	
		return new THREE.AnimationClip( json.name, json.duration, tracks );
	
	};
	
	
	// parse the animation.hierarchy format
	THREE.AnimationClip.parseAnimation = function( animation, bones, nodeName ) {
	
		if ( ! animation ) {
			console.error( "  no animation in JSONLoader data" );
			return null;
		}
	
		var convertTrack = function( trackName, animationKeys, propertyName, trackType, animationKeyToValueFunc ) {
	
			var keys = [];
	
			for ( var k = 0; k < animationKeys.length; k ++ ) {
	
				var animationKey = animationKeys[k];
	
				if ( animationKey[propertyName] !== undefined ) {
	
					keys.push( { time: animationKey.time, value: animationKeyToValueFunc( animationKey ) } );
				}
	
			}
	
			// only return track if there are actually keys.
			if ( keys.length > 0 ) {
	
				return new trackType( trackName, keys );
	
			}
	
			return null;
	
		};
	
		var tracks = [];
	
		var clipName = animation.name || 'default';
		var duration = animation.length || -1; // automatic length determination in AnimationClip.
		var fps = animation.fps || 30;
	
		var hierarchyTracks = animation.hierarchy || [];
	
		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {
	
			var animationKeys = hierarchyTracks[ h ].keys;
	
			// skip empty tracks
			if ( ! animationKeys || animationKeys.length == 0 ) {
				continue;
			}
	
			// process morph targets in a way exactly compatible with AnimationHandler.init( animation )
			if ( animationKeys[0].morphTargets ) {
	
				// figure out all morph targets used in this track
				var morphTargetNames = {};
				for ( var k = 0; k < animationKeys.length; k ++ ) {
	
					if ( animationKeys[k].morphTargets ) {
						for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {
	
							morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
						}
					}
	
				}
	
				// create a track for each morph target with all zero morphTargetInfluences except for the keys in which the morphTarget is named.
				for ( var morphTargetName in morphTargetNames ) {
	
					var keys = [];
	
					for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {
	
						var animationKey = animationKeys[k];
	
						keys.push( {
								time: animationKey.time,
								value: (( animationKey.morphTarget === morphTargetName ) ? 1 : 0 )
							});
	
					}
	
					tracks.push( new THREE.NumberKeyframeTrack( nodeName + '.morphTargetInfluence[' + morphTargetName + ']', keys ) );
	
				}
	
				duration = morphTargetNames.length * ( fps || 1.0 );
	
			} else {
	
				var boneName = nodeName + '.bones[' + bones[ h ].name + ']';
	
				// track contains positions...
				var positionTrack = convertTrack( boneName + '.position', animationKeys, 'pos', THREE.VectorKeyframeTrack, function( animationKey ) {
						return new THREE.Vector3().fromArray( animationKey.pos )
					} );
	
				if ( positionTrack ) tracks.push( positionTrack );
	
				// track contains quaternions...
				var quaternionTrack = convertTrack( boneName + '.quaternion', animationKeys, 'rot', THREE.QuaternionKeyframeTrack, function( animationKey ) {
						if ( animationKey.rot.slerp ) {
							return animationKey.rot.clone();
						} else {
							return new THREE.Quaternion().fromArray( animationKey.rot );
						}
					} );
	
				if ( quaternionTrack ) tracks.push( quaternionTrack );
	
				// track contains quaternions...
				var scaleTrack = convertTrack( boneName + '.scale', animationKeys, 'scl', THREE.VectorKeyframeTrack, function( animationKey ) {
						return new THREE.Vector3().fromArray( animationKey.scl )
					} );
	
				if ( scaleTrack ) tracks.push( scaleTrack );
	
			}
		}
	
		if ( tracks.length === 0 ) {
	
			return null;
	
		}
	
		var clip = new THREE.AnimationClip( clipName, duration, tracks );
	
		return clip;
	
	};
	
	// File:src/animation/AnimationMixer.js
	
	/**
	 *
	 * Mixes together the AnimationClips scheduled by AnimationActions and applies them to the root and subtree
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	THREE.AnimationMixer = function( root ) {
	
		this.root = root;
		this.time = 0;
		this.timeScale = 1.0;
		this.actions = [];
		this.propertyBindingMap = {};
	
	};
	
	THREE.AnimationMixer.prototype = {
	
		constructor: THREE.AnimationMixer,
	
		addAction: function( action ) {
	
			// TODO: check for duplicate action names?  Or provide each action with a UUID?
	
			this.actions.push( action );
			action.init( this.time );
			action.mixer = this;
	
			var tracks = action.clip.tracks;
	
			var root = action.localRoot || this.root;
	
			for ( var i = 0; i < tracks.length; i ++ ) {
	
				var track = tracks[ i ];
	
				var propertyBindingKey = root.uuid + '-' + track.name;
				var propertyBinding = this.propertyBindingMap[ propertyBindingKey ];
	
				if ( propertyBinding === undefined ) {
	
					propertyBinding = new THREE.PropertyBinding( root, track.name );
					this.propertyBindingMap[ propertyBindingKey ] = propertyBinding;
	
				}
	
				// push in the same order as the tracks.
				action.propertyBindings.push( propertyBinding );
	
				// track usages of shared property bindings, because if we leave too many around, the mixer can get slow
				propertyBinding.referenceCount += 1;
	
			}
	
		},
	
		removeAllActions: function() {
	
			for ( var i = 0; i < this.actions.length; i ++ ) {
	
				this.actions[i].mixer = null;
	
			}
	
			// unbind all property bindings
			for ( var properyBindingKey in this.propertyBindingMap ) {
	
				this.propertyBindingMap[ properyBindingKey ].unbind();
	
			}
	
			this.actions = [];
			this.propertyBindingMap = {};
	
			return this;
	
		},
	
		removeAction: function( action ) {
	
			var index = this.actions.indexOf( action );
	
			if ( index !== - 1 ) {
	
				this.actions.splice( index, 1 );
				action.mixer = null;
	
			}
	
	
			// remove unused property bindings because if we leave them around the mixer can get slow
			var root = action.localRoot || this.root;
			var tracks = action.clip.tracks;
	
			for ( var i = 0; i < tracks.length; i ++ ) {
	
				var track = tracks[ i ];
	
				var propertyBindingKey = root.uuid + '-' + track.name;
				var propertyBinding = this.propertyBindingMap[ propertyBindingKey ];
	
				propertyBinding.referenceCount -= 1;
	
				if ( propertyBinding.referenceCount <= 0 ) {
	
					propertyBinding.unbind();
	
					delete this.propertyBindingMap[ propertyBindingKey ];
	
				}
			}
	
			return this;
	
		},
	
		// can be optimized if needed
		findActionByName: function( name ) {
	
			for ( var i = 0; i < this.actions.length; i ++ ) {
	
				if ( this.actions[i].name === name ) return this.actions[i];
	
			}
	
			return null;
	
		},
	
		play: function( action, optionalFadeInDuration ) {
	
			action.startTime = this.time;
			this.addAction( action );
	
			return this;
	
		},
	
		fadeOut: function( action, duration ) {
	
			var keys = [];
	
			keys.push( { time: this.time, value: 1 } );
			keys.push( { time: this.time + duration, value: 0 } );
	
			action.weight = new THREE.NumberKeyframeTrack( "weight", keys );
	
			return this;
	
		},
	
		fadeIn: function( action, duration ) {
	
			var keys = [];
	
			keys.push( { time: this.time, value: 0 } );
			keys.push( { time: this.time + duration, value: 1 } );
	
			action.weight = new THREE.NumberKeyframeTrack( "weight", keys );
	
			return this;
	
		},
	
		warp: function( action, startTimeScale, endTimeScale, duration ) {
	
			var keys = [];
	
			keys.push( { time: this.time, value: startTimeScale } );
			keys.push( { time: this.time + duration, value: endTimeScale } );
	
			action.timeScale = new THREE.NumberKeyframeTrack( "timeScale", keys );
	
			return this;
	
		},
	
		crossFade: function( fadeOutAction, fadeInAction, duration, warp ) {
	
			this.fadeOut( fadeOutAction, duration );
			this.fadeIn( fadeInAction, duration );
	
			if ( warp ) {
	
				var startEndRatio = fadeOutAction.clip.duration / fadeInAction.clip.duration;
				var endStartRatio = 1.0 / startEndRatio;
	
				this.warp( fadeOutAction, 1.0, startEndRatio, duration );
				this.warp( fadeInAction, endStartRatio, 1.0, duration );
	
			}
	
			return this;
	
		},
	
		update: function( deltaTime ) {
	
			var mixerDeltaTime = deltaTime * this.timeScale;
			this.time += mixerDeltaTime;
	
			for ( var i = 0; i < this.actions.length; i ++ ) {
	
				var action = this.actions[i];
	
				var weight = action.getWeightAt( this.time );
	
				var actionTimeScale = action.getTimeScaleAt( this.time );
				var actionDeltaTime = mixerDeltaTime * actionTimeScale;
	
				var actionResults = action.update( actionDeltaTime );
	
				if ( action.weight <= 0 || ! action.enabled ) continue;
	
				for ( var j = 0; j < actionResults.length; j ++ ) {
	
					var name = action.clip.tracks[j].name;
	
					action.propertyBindings[ j ].accumulate( actionResults[j], weight );
	
				}
	
			}
	
			// apply to nodes
			for ( var propertyBindingKey in this.propertyBindingMap ) {
	
				this.propertyBindingMap[ propertyBindingKey ].apply();
	
			}
	
			return this;
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.AnimationMixer.prototype );
	
	// File:src/animation/AnimationUtils.js
	
	/**
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	THREE.AnimationUtils = {
	
		getEqualsFunc: function( exemplarValue ) {
	
			if ( exemplarValue.equals ) {
				return function equals_object( a, b ) {
					return a.equals( b );
				}
			}
	
			return function equals_primitive( a, b ) {
				return ( a === b );
			};
	
		},
	
		clone: function( exemplarValue ) {
	
			var typeName = typeof exemplarValue;
			if ( typeName === "object" ) {
				if ( exemplarValue.clone ) {
					return exemplarValue.clone();
				}
				console.error( "can not figure out how to copy exemplarValue", exemplarValue );
			}
	
			return exemplarValue;
	
		},
	
		lerp: function( a, b, alpha, interTrack ) {
	
			var lerpFunc = THREE.AnimationUtils.getLerpFunc( a, interTrack );
	
			return lerpFunc( a, b, alpha );
	
		},
	
		lerp_object: function( a, b, alpha ) {
			return a.lerp( b, alpha );
		},
	
		slerp_object: function( a, b, alpha ) {
			return a.slerp( b, alpha );
		},
	
		lerp_number: function( a, b, alpha ) {
			return a * ( 1 - alpha ) + b * alpha;
		},
	
		lerp_boolean: function( a, b, alpha ) {
			return ( alpha < 0.5 ) ? a : b;
		},
	
		lerp_boolean_immediate: function( a, b, alpha ) {
			return a;
		},
	
		lerp_string: function( a, b, alpha ) {
			return ( alpha < 0.5 ) ? a : b;
		},
	
		lerp_string_immediate: function( a, b, alpha ) {
	 		return a;
	 	},
	
		// NOTE: this is an accumulator function that modifies the first argument (e.g. a).	This is to minimize memory alocations.
		getLerpFunc: function( exemplarValue, interTrack ) {
	
			if ( exemplarValue === undefined || exemplarValue === null ) throw new Error( "examplarValue is null" );
	
			var typeName = typeof exemplarValue;
	
			switch( typeName ) {
	
				case "object":
					if ( exemplarValue.lerp ) {
						return THREE.AnimationUtils.lerp_object;
					}
	
					if ( exemplarValue.slerp ) {
						return THREE.AnimationUtils.slerp_object;
					}
					break;
	
				case "number":
					return THREE.AnimationUtils.lerp_number;
	
				case "boolean":
					if ( interTrack ) {
						return THREE.AnimationUtils.lerp_boolean;
					} else {
						return THREE.AnimationUtils.lerp_boolean_immediate;
					}
	
				case "string":
					if ( interTrack ) {
						return THREE.AnimationUtils.lerp_string;
					} else {
						return THREE.AnimationUtils.lerp_string_immediate;
					}
	
			}
	
		}
	
	};
	
	// File:src/animation/KeyframeTrack.js
	
	/**
	 *
	 * A Track that returns a keyframe interpolated value, currently linearly interpolated
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	THREE.KeyframeTrack = function ( name, keys ) {
	
		if ( name === undefined ) throw new Error( "track name is undefined" );
		if ( keys === undefined || keys.length === 0 ) throw new Error( "no keys in track named " + name );
	
		this.name = name;
		this.keys = keys;	// time in seconds, value as value
	
		// the index of the last result, used as a starting point for local search.
		this.lastIndex = 0;
	
		this.validate();
		this.optimize();
	
	};
	
	THREE.KeyframeTrack.prototype = {
	
		constructor: THREE.KeyframeTrack,
	
		getAt: function( time ) {
	
	
			// this can not go higher than this.keys.length.
			while( ( this.lastIndex < this.keys.length ) && ( time >= this.keys[this.lastIndex].time ) ) {
				this.lastIndex ++;
			};
	
			// this can not go lower than 0.
			while( ( this.lastIndex > 0 ) && ( time < this.keys[this.lastIndex - 1].time ) ) {
				this.lastIndex --;
			}
	
			if ( this.lastIndex >= this.keys.length ) {
	
				this.setResult( this.keys[ this.keys.length - 1 ].value );
	
				return this.result;
	
			}
	
			if ( this.lastIndex === 0 ) {
	
				this.setResult( this.keys[ 0 ].value );
	
				return this.result;
	
			}
	
			var prevKey = this.keys[ this.lastIndex - 1 ];
			this.setResult( prevKey.value );
	
			// if true, means that prev/current keys are identical, thus no interpolation required.
			if ( prevKey.constantToNext ) {
	
				return this.result;
	
			}
	
			// linear interpolation to start with
			var currentKey = this.keys[ this.lastIndex ];
			var alpha = ( time - prevKey.time ) / ( currentKey.time - prevKey.time );
			this.result = this.lerpValues( this.result, currentKey.value, alpha );
	
			return this.result;
	
		},
	
		// move all keyframes either forwards or backwards in time
		shift: function( timeOffset ) {
	
			if ( timeOffset !== 0.0 ) {
	
				for ( var i = 0; i < this.keys.length; i ++ ) {
					this.keys[i].time += timeOffset;
				}
	
			}
	
			return this;
	
		},
	
		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale: function( timeScale ) {
	
			if ( timeScale !== 1.0 ) {
	
				for ( var i = 0; i < this.keys.length; i ++ ) {
					this.keys[i].time *= timeScale;
				}
	
			}
	
			return this;
	
		},
	
		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	 	trim: function( startTime, endTime ) {
	
			var firstKeysToRemove = 0;
			for ( var i = 1; i < this.keys.length; i ++ ) {
				if ( this.keys[i] <= startTime ) {
					firstKeysToRemove ++;
				}
			}
	
			var lastKeysToRemove = 0;
			for ( var i = this.keys.length - 2; i > 0; i ++ ) {
				if ( this.keys[i] >= endTime ) {
					lastKeysToRemove ++;
				} else {
					break;
				}
			}
	
			// remove last keys first because it doesn't affect the position of the first keys (the otherway around doesn't work as easily)
			if ( ( firstKeysToRemove + lastKeysToRemove ) > 0 ) {
				this.keys = this.keys.splice( firstKeysToRemove, this.keys.length - lastKeysToRemove - firstKeysToRemove );;
			}
	
			return this;
	
		},
	
		/* NOTE: This is commented out because we really shouldn't have to handle unsorted key lists
		         Tracks with out of order keys should be considered to be invalid.  - bhouston
		sort: function() {
	
			this.keys.sort( THREE.KeyframeTrack.keyComparer );
	
			return this;
	
		},*/
	
		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		// One could eventually ensure that all key.values in a track are all of the same type (otherwise interpolation makes no sense.)
		validate: function() {
	
			var prevKey = null;
	
			if ( this.keys.length === 0 ) {
				console.error( "  track is empty, no keys", this );
				return;
			}
	
			for ( var i = 0; i < this.keys.length; i ++ ) {
	
				var currKey = this.keys[i];
	
				if ( ! currKey ) {
					console.error( "  key is null in track", this, i );
					return;
				}
	
				if ( ( typeof currKey.time ) !== 'number' || isNaN( currKey.time ) ) {
					console.error( "  key.time is not a valid number", this, i, currKey );
					return;
				}
	
				if ( currKey.value === undefined || currKey.value === null) {
					console.error( "  key.value is null in track", this, i, currKey );
					return;
				}
	
				if ( prevKey && prevKey.time > currKey.time ) {
					console.error( "  key.time is less than previous key time, out of order keys", this, i, currKey, prevKey );
					return;
				}
	
				prevKey = currKey;
	
			}
	
			return this;
	
		},
	
		// currently only removes equivalent sequential keys (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0), which are common in morph target animations
		optimize: function() {
	
			var newKeys = [];
			var prevKey = this.keys[0];
			newKeys.push( prevKey );
	
			var equalsFunc = THREE.AnimationUtils.getEqualsFunc( prevKey.value );
	
			for ( var i = 1; i < this.keys.length - 1; i ++ ) {
				var currKey = this.keys[i];
				var nextKey = this.keys[i+1];
	
				// if prevKey & currKey are the same time, remove currKey.  If you want immediate adjacent keys, use an epsilon offset
				// it is not possible to have two keys at the same time as we sort them.  The sort is not stable on keys with the same time.
				if ( ( prevKey.time === currKey.time ) ) {
	
					continue;
	
				}
	
				// remove completely unnecessary keyframes that are the same as their prev and next keys
				if ( this.compareValues( prevKey.value, currKey.value ) && this.compareValues( currKey.value, nextKey.value ) ) {
	
					continue;
	
				}
	
				// determine if interpolation is required
				prevKey.constantToNext = this.compareValues( prevKey.value, currKey.value );
	
				newKeys.push( currKey );
				prevKey = currKey;
			}
			newKeys.push( this.keys[ this.keys.length - 1 ] );
	
			this.keys = newKeys;
	
			return this;
	
		}
	
	};
	
	THREE.KeyframeTrack.keyComparer = function keyComparator(key0, key1) {
		return key0.time - key1.time;
	};
	
	THREE.KeyframeTrack.parse = function( json ) {
	
		if ( json.type === undefined ) throw new Error( "track type undefined, can not parse" );
	
		var trackType = THREE.KeyframeTrack.GetTrackTypeForTypeName( json.type );
	
		return trackType.parse( json );
	
	};
	
	THREE.KeyframeTrack.GetTrackTypeForTypeName = function( typeName ) {
		switch( typeName.toLowerCase() ) {
		 	case "vector":
		 	case "vector2":
		 	case "vector3":
		 	case "vector4":
				return THREE.VectorKeyframeTrack;
	
		 	case "quaternion":
				return THREE.QuaternionKeyframeTrack;
	
		 	case "integer":
		 	case "scalar":
		 	case "double":
		 	case "float":
		 	case "number":
				return THREE.NumberKeyframeTrack;
	
		 	case "bool":
		 	case "boolean":
				return THREE.BooleanKeyframeTrack;
	
		 	case "string":
		 		return THREE.StringKeyframeTrack;
		};
	
		throw new Error( "Unsupported typeName: " + typeName );
	};
	
	// File:src/animation/PropertyBinding.js
	
	/**
	 *
	 * A track bound to a real value in the scene graph.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	THREE.PropertyBinding = function ( rootNode, trackName ) {
	
		this.rootNode = rootNode;
		this.trackName = trackName;
		this.referenceCount = 0;
		this.originalValue = null; // the value of the property before it was controlled by this binding
	
		var parseResults = THREE.PropertyBinding.parseTrackName( trackName );
	
		this.directoryName = parseResults.directoryName;
		this.nodeName = parseResults.nodeName;
		this.objectName = parseResults.objectName;
		this.objectIndex = parseResults.objectIndex;
		this.propertyName = parseResults.propertyName;
		this.propertyIndex = parseResults.propertyIndex;
	
		this.node = THREE.PropertyBinding.findNode( rootNode, this.nodeName ) || rootNode;
	
		this.cumulativeValue = null;
		this.cumulativeWeight = 0;
	};
	
	THREE.PropertyBinding.prototype = {
	
		constructor: THREE.PropertyBinding,
	
		reset: function() {
	
			this.cumulativeValue = null;
			this.cumulativeWeight = 0;
	
		},
	
		accumulate: function( value, weight ) {
	
			if ( ! this.isBound ) this.bind();
	
			if ( this.cumulativeWeight === 0 ) {
	
				if ( weight > 0 ) {
	
					if ( this.cumulativeValue === null ) {
						this.cumulativeValue = THREE.AnimationUtils.clone( value );
					}
					this.cumulativeWeight = weight;
	
				}
	
			} else {
	
				var lerpAlpha = weight / ( this.cumulativeWeight + weight );
				this.cumulativeValue = this.lerpValue( this.cumulativeValue, value, lerpAlpha );
				this.cumulativeWeight += weight;
	
			}
	
		},
	
		unbind: function() {
	
			if ( ! this.isBound ) return;
	
			this.setValue( this.originalValue );
	
			this.setValue = null;
			this.getValue = null;
			this.lerpValue = null;
			this.equalsValue = null;
			this.triggerDirty = null;
			this.isBound = false;
	
		},
	
		// bind to the real property in the scene graph, remember original value, memorize various accessors for speed/inefficiency
		bind: function() {
	
			if ( this.isBound ) return;
	
			var targetObject = this.node;
	
	 		// ensure there is a value node
			if ( ! targetObject ) {
				console.error( "  trying to update node for track: " + this.trackName + " but it wasn't found." );
				return;
			}
	
			if ( this.objectName ) {
				// special case were we need to reach deeper into the hierarchy to get the face materials....
				if ( this.objectName === "materials" ) {
					if ( ! targetObject.material ) {
						console.error( '  can not bind to material as node does not have a material', this );
						return;
					}
					if ( ! targetObject.material.materials ) {
						console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
						return;
					}
					targetObject = targetObject.material.materials;
				} else if ( this.objectName === "bones" ) {
					if ( ! targetObject.skeleton ) {
						console.error( '  can not bind to bones as node does not have a skeleton', this );
						return;
					}
					// potential future optimization: skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
	
					targetObject = targetObject.skeleton.bones;
	
					// support resolving morphTarget names into indices.
					for ( var i = 0; i < targetObject.length; i ++ ) {
						if ( targetObject[i].name === this.objectIndex ) {
							this.objectIndex = i;
							break;
						}
					}
				} else {
	
					if ( targetObject[ this.objectName ] === undefined ) {
						console.error( '  can not bind to objectName of node, undefined', this );
						return;
					}
					targetObject = targetObject[ this.objectName ];
				}
	
				if ( this.objectIndex !== undefined ) {
					if ( targetObject[ this.objectIndex ] === undefined ) {
						console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
						return;
					}
	
					targetObject = targetObject[ this.objectIndex ];
				}
	
			}
	
	 		// special case mappings
	 		var nodeProperty = targetObject[ this.propertyName ];
			if ( ! nodeProperty ) {
				console.error( "  trying to update property for track: " + this.nodeName + '.' + this.propertyName + " but it wasn't found.", targetObject );
				return;
			}
	
			// access a sub element of the property array (only primitives are supported right now)
			if ( this.propertyIndex !== undefined ) {
	
				if ( this.propertyName === "morphTargetInfluences" ) {
					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
	
					// support resolving morphTarget names into indices.
					if ( ! targetObject.geometry ) {
						console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
					}
					if ( ! targetObject.geometry.morphTargets ) {
						console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
					}
	
					for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {
						if ( targetObject.geometry.morphTargets[i].name === this.propertyIndex ) {
							this.propertyIndex = i;
							break;
						}
					}
				}
	
				this.setValue = function setValue_propertyIndexed( value ) {
					if ( ! this.equalsValue( nodeProperty[ this.propertyIndex ], value ) ) {
						nodeProperty[ this.propertyIndex ] = value;
						return true;
					}
					return false;
				};
	
				this.getValue = function getValue_propertyIndexed() {
					return nodeProperty[ this.propertyIndex ];
				};
	
			}
			// must use copy for Object3D.Euler/Quaternion
			else if ( nodeProperty.copy ) {
	
				this.setValue = function setValue_propertyObject( value ) {
					if ( ! this.equalsValue( nodeProperty, value ) ) {
						nodeProperty.copy( value );
						return true;
					}
					return false;
				}
	
				this.getValue = function getValue_propertyObject() {
					return nodeProperty;
				};
	
			}
			// otherwise just set the property directly on the node (do not use nodeProperty as it may not be a reference object)
			else {
	
				this.setValue = function setValue_property( value ) {
					if ( ! this.equalsValue( targetObject[ this.propertyName ], value ) ) {
						targetObject[ this.propertyName ] = value;
						return true;
					}
					return false;
				}
	
				this.getValue = function getValue_property() {
					return targetObject[ this.propertyName ];
				};
	
			}
	
			// trigger node dirty
			if ( targetObject.needsUpdate !== undefined ) { // material
	
				this.triggerDirty = function triggerDirty_needsUpdate() {
					this.node.needsUpdate = true;
				}
	
			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform
	
				this.triggerDirty = function triggerDirty_matrixWorldNeedsUpdate() {
					targetObject.matrixWorldNeedsUpdate = true;
				}
	
			}
	
			this.originalValue = this.getValue();
	
			this.equalsValue = THREE.AnimationUtils.getEqualsFunc( this.originalValue );
			this.lerpValue = THREE.AnimationUtils.getLerpFunc( this.originalValue, true );
	
			this.isBound = true;
	
		},
	
		apply: function() {
	
			// for speed capture the setter pattern as a closure (sort of a memoization pattern: https://en.wikipedia.org/wiki/Memoization)
			if ( ! this.isBound ) this.bind();
	
			// early exit if there is nothing to apply.
			if ( this.cumulativeWeight > 0 ) {
	
				// blend with original value
				if ( this.cumulativeWeight < 1 ) {
	
					var remainingWeight = 1 - this.cumulativeWeight;
					var lerpAlpha = remainingWeight / ( this.cumulativeWeight + remainingWeight );
					this.cumulativeValue = this.lerpValue( this.cumulativeValue, this.originalValue, lerpAlpha );
	
				}
	
				var valueChanged = this.setValue( this.cumulativeValue );
	
				if ( valueChanged && this.triggerDirty ) {
					this.triggerDirty();
				}
	
				// reset accumulator
				this.cumulativeValue = null;
				this.cumulativeWeight = 0;
	
			}
		}
	
	};
	
	
	THREE.PropertyBinding.parseTrackName = function( trackName ) {
	
		// matches strings in the form of:
		//    nodeName.property
		//    nodeName.property[accessor]
		//    nodeName.material.property[accessor]
		//    uuid.property[accessor]
		//    uuid.objectName[objectIndex].propertyName[propertyIndex]
		//    parentName/nodeName.property
		//    parentName/parentName/nodeName.property[index]
		//	  .bone[Armature.DEF_cog].position
		// created and tested via https://regex101.com/#javascript
	
		var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_. ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/;
		var matches = re.exec(trackName);
	
		if ( ! matches ) {
			throw new Error( "cannot parse trackName at all: " + trackName );
		}
	
	    if (matches.index === re.lastIndex) {
	        re.lastIndex++;
	    }
	
		var results = {
			directoryName: matches[1],
			nodeName: matches[3], 	// allowed to be null, specified root node.
			objectName: matches[5],
			objectIndex: matches[7],
			propertyName: matches[9],
			propertyIndex: matches[11]	// allowed to be null, specifies that the whole property is set.
		};
	
		if ( results.propertyName === null || results.propertyName.length === 0 ) {
			throw new Error( "can not parse propertyName from trackName: " + trackName );
		}
	
		return results;
	
	};
	
	THREE.PropertyBinding.findNode = function( root, nodeName ) {
	
		function searchSkeleton( skeleton ) {
	
			for ( var i = 0; i < skeleton.bones.length; i ++ ) {
	
				var bone = skeleton.bones[i];
	
				if ( bone.name === nodeName ) {
	
					return bone;
	
				}
			}
	
			return null;
	
		}
	
		function searchNodeSubtree( children ) {
	
			for ( var i = 0; i < children.length; i ++ ) {
	
				var childNode = children[i];
	
				if ( childNode.name === nodeName || childNode.uuid === nodeName ) {
	
					return childNode;
	
				}
	
				var result = searchNodeSubtree( childNode.children );
	
				if ( result ) return result;
	
			}
	
			return null;
	
		}
	
		//
	
		if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {
	
			return root;
	
		}
	
		// search into skeleton bones.
		if ( root.skeleton ) {
	
			var bone = searchSkeleton( root.skeleton );
	
			if ( bone ) {
	
				return bone;
	
			}
		}
	
		// search into node subtree.
		if ( root.children ) {
	
			var subTreeNode = searchNodeSubtree( root.children );
	
			if ( subTreeNode ) {
	
				return subTreeNode;
	
			}
	
		}
	
		return null;
	}
	
	// File:src/animation/tracks/VectorKeyframeTrack.js
	
	/**
	 *
	 * A Track that interpolates Vectors
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	THREE.VectorKeyframeTrack = function ( name, keys ) {
	
		THREE.KeyframeTrack.call( this, name, keys );
	
		// local cache of value type to avoid allocations during runtime.
		this.result = this.keys[0].value.clone();
	
	};
	
	THREE.VectorKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );
	
	THREE.VectorKeyframeTrack.prototype.constructor = THREE.VectorKeyframeTrack;
	
	THREE.VectorKeyframeTrack.prototype.setResult = function( value ) {
	
		this.result.copy( value );
	
	};
	
	// memoization of the lerp function for speed.
	// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
	THREE.VectorKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {
	
		return value0.lerp( value1, alpha );
	
	};
	
	THREE.VectorKeyframeTrack.prototype.compareValues = function( value0, value1 ) {
	
		return value0.equals( value1 );
	
	};
	
	THREE.VectorKeyframeTrack.prototype.clone = function() {
	
		var clonedKeys = [];
	
		for ( var i = 0; i < this.keys.length; i ++ ) {
	
			var key = this.keys[i];
			clonedKeys.push( {
				time: key.time,
				value: key.value.clone()
			} );
		}
	
		return new THREE.VectorKeyframeTrack( this.name, clonedKeys );
	
	};
	
	THREE.VectorKeyframeTrack.parse = function( json ) {
	
		var elementCount = json.keys[0].value.length;
		var valueType = THREE[ 'Vector' + elementCount ];
	
		var keys = [];
	
		for ( var i = 0; i < json.keys.length; i ++ ) {
			var jsonKey = json.keys[i];
			keys.push( {
				value: new valueType().fromArray( jsonKey.value ),
				time: jsonKey.time
			} );
		}
	
		return new THREE.VectorKeyframeTrack( json.name, keys );
	
	};
	
	// File:src/animation/tracks/QuaternionKeyframeTrack.js
	
	/**
	 *
	 * A Track that interpolates Quaternion
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	THREE.QuaternionKeyframeTrack = function ( name, keys ) {
	
		THREE.KeyframeTrack.call( this, name, keys );
	
		// local cache of value type to avoid allocations during runtime.
		this.result = this.keys[0].value.clone();
	
	};
	
	THREE.QuaternionKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );
	
	THREE.QuaternionKeyframeTrack.prototype.constructor = THREE.QuaternionKeyframeTrack;
	
	THREE.QuaternionKeyframeTrack.prototype.setResult = function( value ) {
	
		this.result.copy( value );
	
	};
	
	// memoization of the lerp function for speed.
	// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
	THREE.QuaternionKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {
	
		return value0.slerp( value1, alpha );
	
	};
	
	THREE.QuaternionKeyframeTrack.prototype.compareValues = function( value0, value1 ) {
	
		return value0.equals( value1 );
	
	};
	
	THREE.QuaternionKeyframeTrack.prototype.multiply = function( quat ) {
	
		for ( var i = 0; i < this.keys.length; i ++ ) {
	
			this.keys[i].value.multiply( quat );
	
		}
	
		return this;
	
	};
	
	THREE.QuaternionKeyframeTrack.prototype.clone = function() {
	
		var clonedKeys = [];
	
		for ( var i = 0; i < this.keys.length; i ++ ) {
	
			var key = this.keys[i];
			clonedKeys.push( {
				time: key.time,
				value: key.value.clone()
			} );
		}
	
		return new THREE.QuaternionKeyframeTrack( this.name, clonedKeys );
	
	};
	
	THREE.QuaternionKeyframeTrack.parse = function( json ) {
	
		var keys = [];
	
		for ( var i = 0; i < json.keys.length; i ++ ) {
			var jsonKey = json.keys[i];
			keys.push( {
				value: new THREE.Quaternion().fromArray( jsonKey.value ),
				time: jsonKey.time
			} );
		}
	
		return new THREE.QuaternionKeyframeTrack( json.name, keys );
	
	};
	
	// File:src/animation/tracks/StringKeyframeTrack.js
	
	/**
	 *
	 * A Track that interpolates Strings
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	THREE.StringKeyframeTrack = function ( name, keys ) {
	
		THREE.KeyframeTrack.call( this, name, keys );
	
		// local cache of value type to avoid allocations during runtime.
		this.result = this.keys[0].value;
	
	};
	
	THREE.StringKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );
	
	THREE.StringKeyframeTrack.prototype.constructor = THREE.StringKeyframeTrack;
	
	THREE.StringKeyframeTrack.prototype.setResult = function( value ) {
	
		this.result = value;
	
	};
	
	// memoization of the lerp function for speed.
	// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
	THREE.StringKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {
	
		return ( alpha < 1.0 ) ? value0 : value1;
	
	};
	
	THREE.StringKeyframeTrack.prototype.compareValues = function( value0, value1 ) {
	
		return ( value0 === value1 );
	
	};
	
	THREE.StringKeyframeTrack.prototype.clone = function() {
	
		var clonedKeys = [];
	
		for ( var i = 0; i < this.keys.length; i ++ ) {
	
			var key = this.keys[i];
			clonedKeys.push( {
				time: key.time,
				value: key.value
			} );
		}
	
		return new THREE.StringKeyframeTrack( this.name, clonedKeys );
	
	};
	
	THREE.StringKeyframeTrack.parse = function( json ) {
	
		return new THREE.StringKeyframeTrack( json.name, json.keys );
	
	};
	
	// File:src/animation/tracks/BooleanKeyframeTrack.js
	
	/**
	 *
	 * A Track that interpolates Boolean
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	THREE.BooleanKeyframeTrack = function ( name, keys ) {
	
		THREE.KeyframeTrack.call( this, name, keys );
	
		// local cache of value type to avoid allocations during runtime.
		this.result = this.keys[0].value;
	
	};
	
	THREE.BooleanKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );
	
	THREE.BooleanKeyframeTrack.prototype.constructor = THREE.BooleanKeyframeTrack;
	
	THREE.BooleanKeyframeTrack.prototype.setResult = function( value ) {
	
		this.result = value;
	
	};
	
	// memoization of the lerp function for speed.
	// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
	THREE.BooleanKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {
	
		return ( alpha < 1.0 ) ? value0 : value1;
	
	};
	
	THREE.BooleanKeyframeTrack.prototype.compareValues = function( value0, value1 ) {
	
		return ( value0 === value1 );
	
	};
	
	THREE.BooleanKeyframeTrack.prototype.clone = function() {
	
		var clonedKeys = [];
	
		for ( var i = 0; i < this.keys.length; i ++ ) {
	
			var key = this.keys[i];
			clonedKeys.push( {
				time: key.time,
				value: key.value
			} );
		}
	
		return new THREE.BooleanKeyframeTrack( this.name, clonedKeys );
	
	};
	
	THREE.BooleanKeyframeTrack.parse = function( json ) {
	
		return new THREE.BooleanKeyframeTrack( json.name, json.keys );
	
	};
	
	// File:src/animation/tracks/NumberKeyframeTrack.js
	
	/**
	 *
	 * A Track that interpolates Numbers
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	THREE.NumberKeyframeTrack = function ( name, keys ) {
	
		THREE.KeyframeTrack.call( this, name, keys );
	
		// local cache of value type to avoid allocations during runtime.
		this.result = this.keys[0].value;
	
	};
	
	THREE.NumberKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );
	
	THREE.NumberKeyframeTrack.prototype.constructor = THREE.NumberKeyframeTrack;
	
	THREE.NumberKeyframeTrack.prototype.setResult = function( value ) {
	
		this.result = value;
	
	};
	
	// memoization of the lerp function for speed.
	// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
	THREE.NumberKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {
	
		return value0 * ( 1 - alpha ) + value1 * alpha;
	
	};
	
	THREE.NumberKeyframeTrack.prototype.compareValues = function( value0, value1 ) {
	
		return ( value0 === value1 );
	
	};
	
	THREE.NumberKeyframeTrack.prototype.clone = function() {
	
		var clonedKeys = [];
	
		for ( var i = 0; i < this.keys.length; i ++ ) {
	
			var key = this.keys[i];
			clonedKeys.push( {
				time: key.time,
				value: key.value
			} );
		}
	
		return new THREE.NumberKeyframeTrack( this.name, clonedKeys );
	
	};
	
	THREE.NumberKeyframeTrack.parse = function( json ) {
	
		return new THREE.NumberKeyframeTrack( json.name, json.keys );
	
	};
	
	// File:src/cameras/Camera.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.Camera = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'Camera';
	
		this.matrixWorldInverse = new THREE.Matrix4();
		this.projectionMatrix = new THREE.Matrix4();
	
	};
	
	THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Camera.prototype.constructor = THREE.Camera;
	
	THREE.Camera.prototype.getWorldDirection = function () {
	
		var quaternion = new THREE.Quaternion();
	
		return function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			this.getWorldQuaternion( quaternion );
	
			return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	
		};
	
	}();
	
	THREE.Camera.prototype.lookAt = function () {
	
		// This routine does not support cameras with rotated and/or translated parent(s)
	
		var m1 = new THREE.Matrix4();
	
		return function ( vector ) {
	
			m1.lookAt( this.position, vector, this.up );
	
			this.quaternion.setFromRotationMatrix( m1 );
	
		};
	
	}();
	
	THREE.Camera.prototype.clone = function () {
	
		return new this.constructor().copy( this );
	
	};
	
	THREE.Camera.prototype.copy = function ( source ) {
	
		THREE.Object3D.prototype.copy.call( this, source );
	
		this.matrixWorldInverse.copy( source.matrixWorldInverse );
		this.projectionMatrix.copy( source.projectionMatrix );
	
		return this;
	
	};
	
	// File:src/cameras/CubeCamera.js
	
	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.CubeCamera = function ( near, far, cubeResolution ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'CubeCamera';
	
		var fov = 90, aspect = 1;
	
		var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
		this.add( cameraPX );
	
		var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );
	
		var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
		this.add( cameraPY );
	
		var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );
	
		var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );
	
		var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );
	
		this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );
	
		this.updateCubeMap = function ( renderer, scene ) {
	
			if ( this.parent === null ) this.updateMatrixWorld();
	
			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.texture.generateMipmaps;
	
			renderTarget.texture.generateMipmaps = false;
	
			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );
	
			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );
	
			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );
	
			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );
	
			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );
	
			renderTarget.texture.generateMipmaps = generateMipmaps;
	
			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );
	
			renderer.setRenderTarget( null );
	
		};
	
	};
	
	THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;
	
	// File:src/cameras/OrthographicCamera.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {
	
		THREE.Camera.call( this );
	
		this.type = 'OrthographicCamera';
	
		this.zoom = 1;
	
		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;
	
		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;
	
		this.updateProjectionMatrix();
	
	};
	
	THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;
	
	THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
	
		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		var cx = ( this.right + this.left ) / 2;
		var cy = ( this.top + this.bottom ) / 2;
	
		this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );
	
	};
	
	THREE.OrthographicCamera.prototype.copy = function ( source ) {
		
		THREE.Camera.prototype.copy.call( this, source );
		
		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;
		
		this.zoom = source.zoom;
		
		return this;
			
	};
	
	THREE.OrthographicCamera.prototype.toJSON = function ( meta ) {
	
		var data = THREE.Object3D.prototype.toJSON.call( this, meta );
	
		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;
	
		return data;
	
	};
	
	// File:src/cameras/PerspectiveCamera.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {
	
		THREE.Camera.call( this );
	
		this.type = 'PerspectiveCamera';
	
		this.zoom = 1;
	
		this.fov = fov !== undefined ? fov : 50;
		this.aspect = aspect !== undefined ? aspect : 1;
		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
	
		this.updateProjectionMatrix();
	
	};
	
	THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;
	
	
	/**
	 * Uses Focal Length (in mm) to estimate and set FOV
	 * 35mm (full-frame) camera is used if frame size is not specified;
	 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
	 */
	
	THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {
	
		if ( frameHeight === undefined ) frameHeight = 24;
	
		this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
		this.updateProjectionMatrix();
	
	};
	
	
	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	
	THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {
	
		this.fullWidth = fullWidth;
		this.fullHeight = fullHeight;
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
	
		this.updateProjectionMatrix();
	
	};
	
	
	THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
	
		var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );
	
		if ( this.fullWidth ) {
	
			var aspect = this.fullWidth / this.fullHeight;
			var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
			var bottom = - top;
			var left = aspect * bottom;
			var right = aspect * top;
			var width = Math.abs( right - left );
			var height = Math.abs( top - bottom );
	
			this.projectionMatrix.makeFrustum(
				left + this.x * width / this.fullWidth,
				left + ( this.x + this.width ) * width / this.fullWidth,
				top - ( this.y + this.height ) * height / this.fullHeight,
				top - this.y * height / this.fullHeight,
				this.near,
				this.far
			);
	
		} else {
	
			this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );
	
		}
	
	};
	
	THREE.PerspectiveCamera.prototype.copy = function ( source ) {
		
		THREE.Camera.prototype.copy.call( this, source );
		
		this.fov = source.fov;
		this.aspect = source.aspect;
		this.near = source.near;
		this.far = source.far;
		
		this.zoom = source.zoom;
		
		return this;
			
	};
	
	THREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {
	
		var data = THREE.Object3D.prototype.toJSON.call( this, meta );
	
		data.object.zoom = this.zoom;
		data.object.fov = this.fov;
		data.object.aspect = this.aspect;
		data.object.near = this.near;
		data.object.far = this.far;
	
		return data;
	
	};
	
	// File:src/lights/Light.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Light = function ( color ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Light';
	
		this.color = new THREE.Color( color );
	
		this.receiveShadow = undefined;
	
	};
	
	THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Light.prototype.constructor = THREE.Light;
	
	Object.defineProperties( THREE.Light.prototype, {
		onlyShadow: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .onlyShadow has been removed.' );
			}
		},
		shadowCameraFov: {
			set: function ( value ) {
				this.shadow.camera.fov = value;
			}
		},
		shadowCameraLeft: {
			set: function ( value ) {
				this.shadow.camera.left = value;
			}
		},
		shadowCameraRight: {
			set: function ( value ) {
				this.shadow.camera.right = value;
			}
		},
		shadowCameraTop: {
			set: function ( value ) {
				this.shadow.camera.top = value;
			}
		},
		shadowCameraBottom: {
			set: function ( value ) {
				this.shadow.camera.bottom = value;
			}
		},
		shadowCameraNear: {
			set: function ( value ) {
				this.shadow.camera.near = value;
			}
		},
		shadowCameraFar: {
			set: function ( value ) {
				this.shadow.camera.far = value;
			}
		},
		shadowCameraVisible: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow ) instead.' );
			}
		},
		shadowBias: {
			set: function ( value ) {
				this.shadow.bias = value;
			}
		},
		shadowDarkness: {
			set: function ( value ) {
				this.shadow.darkness = value;
			}
		},
		shadowMapWidth: {
			set: function ( value ) {
				this.shadow.mapSize.width = value;
			}
		},
		shadowMapHeight: {
			set: function ( value ) {
				this.shadow.mapSize.height = value;
			}
		}
	} );
	
	THREE.Light.prototype.copy = function ( source ) {
	
		THREE.Object3D.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		return this;
	
	};
	
	THREE.Light.prototype.toJSON = function ( meta ) {
	
		var data = THREE.Object3D.prototype.toJSON.call( this, meta );
	
		data.object.color = this.color.getHex();
		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();
	
		if ( this.intensity !== undefined ) data.object.intensity = this.intensity;
		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.exponent !== undefined ) data.object.exponent = this.exponent;
	
		return data;
	
	};
	
	// File:src/lights/LightShadow.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LightShadow = function ( camera ) {
	
		this.camera = camera;
	
		this.bias = 0;
		this.darkness = 1;
	
		this.mapSize = new THREE.Vector2( 512, 512 );
	
		this.map = null;
		this.matrix = null;
	
	};
	
	THREE.LightShadow.prototype = {
	
		constructor: THREE.LightShadow,
	
		copy: function ( source ) {
	
			this.camera = source.camera.clone();
	
			this.bias = source.bias;
			this.darkness = source.darkness;
	
			this.mapSize.copy( source.mapSize );
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		}
	
	};
	
	// File:src/lights/AmbientLight.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AmbientLight = function ( color ) {
	
		THREE.Light.call( this, color );
	
		this.type = 'AmbientLight';
	
		this.castShadow = undefined;
	
	};
	
	THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
	THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;
	
	// File:src/lights/DirectionalLight.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.DirectionalLight = function ( color, intensity ) {
	
		THREE.Light.call( this, color );
	
		this.type = 'DirectionalLight';
	
		this.position.set( 0, 1, 0 );
		this.updateMatrix();
	
		this.target = new THREE.Object3D();
	
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
	
		this.shadow = new THREE.LightShadow( new THREE.OrthographicCamera( - 500, 500, 500, - 500, 50, 5000 ) );
	
	};
	
	THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
	THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;
	
	THREE.DirectionalLight.prototype.copy = function ( source ) {
	
		THREE.Light.prototype.copy.call( this, source );
	
		this.intensity = source.intensity;
		this.target = source.target.clone();
	
		this.shadow = source.shadow.clone();
	
		return this;
	
	};
	
	// File:src/lights/HemisphereLight.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {
	
		THREE.Light.call( this, skyColor );
	
		this.type = 'HemisphereLight';
	
		this.castShadow = undefined;
	
		this.position.set( 0, 1, 0 );
		this.updateMatrix();
	
		this.groundColor = new THREE.Color( groundColor );
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
	
	};
	
	THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
	THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;
	
	THREE.HemisphereLight.prototype.copy = function ( source ) {
	
		THREE.Light.prototype.copy.call( this, source );
	
		this.groundColor.copy( source.groundColor );
		this.intensity = source.intensity;
	
		return this;
	
	};
	
	// File:src/lights/PointLight.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	
	THREE.PointLight = function ( color, intensity, distance, decay ) {
	
		THREE.Light.call( this, color );
	
		this.type = 'PointLight';
	
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
		this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 1, 500 ) );
	
	};
	
	THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
	THREE.PointLight.prototype.constructor = THREE.PointLight;
	
	THREE.PointLight.prototype.copy = function ( source ) {
	
		THREE.Light.prototype.copy.call( this, source );
	
		this.intensity = source.intensity;
		this.distance = source.distance;
		this.decay = source.decay;
	
		this.shadow = source.shadow.clone();
	
		return this;
	
	};
	
	// File:src/lights/SpotLight.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {
	
		THREE.Light.call( this, color );
	
		this.type = 'SpotLight';
	
		this.position.set( 0, 1, 0 );
		this.updateMatrix();
	
		this.target = new THREE.Object3D();
	
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.exponent = ( exponent !== undefined ) ? exponent : 10;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
		this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 50, 5000 ) );
	
	};
	
	THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
	THREE.SpotLight.prototype.constructor = THREE.SpotLight;
	
	THREE.SpotLight.prototype.copy = function ( source ) {
	
		THREE.Light.prototype.copy.call( this, source );
	
		this.intensity = source.intensity;
		this.distance = source.distance;
		this.angle = source.angle;
		this.exponent = source.exponent;
		this.decay = source.decay;
	
		this.target = source.target.clone();
	
		this.shadow = source.shadow.clone();
	
		return this;
	
	};
	
	// File:src/loaders/Cache.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Cache = {
	
		enabled: false,
	
		files: {},
	
		add: function ( key, file ) {
	
			if ( this.enabled === false ) return;
	
			// console.log( 'THREE.Cache', 'Adding key:', key );
	
			this.files[ key ] = file;
	
		},
	
		get: function ( key ) {
	
			if ( this.enabled === false ) return;
	
			// console.log( 'THREE.Cache', 'Checking key:', key );
	
			return this.files[ key ];
	
		},
	
		remove: function ( key ) {
	
			delete this.files[ key ];
	
		},
	
		clear: function () {
	
			this.files = {};
	
		}
	
	};
	
	// File:src/loaders/Loader.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Loader = function () {
	
		this.onLoadStart = function () {};
		this.onLoadProgress = function () {};
		this.onLoadComplete = function () {};
	
	};
	
	THREE.Loader.prototype = {
	
		constructor: THREE.Loader,
	
		crossOrigin: undefined,
	
		extractUrlBase: function ( url ) {
	
			var parts = url.split( '/' );
	
			if ( parts.length === 1 ) return './';
	
			parts.pop();
	
			return parts.join( '/' ) + '/';
	
		},
	
		initMaterials: function ( materials, texturePath, crossOrigin ) {
	
			var array = [];
	
			for ( var i = 0; i < materials.length; ++ i ) {
	
				array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );
	
			}
	
			return array;
	
		},
	
		createMaterial: ( function () {
	
			var color, textureLoader, materialLoader;
	
			return function ( m, texturePath, crossOrigin ) {
	
				if ( color === undefined ) color = new THREE.Color();
				if ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();
				if ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();
	
				// convert from old material format
	
				var textures = {};
	
				function loadTexture( path, repeat, offset, wrap, anisotropy ) {
	
					var fullPath = texturePath + path;
					var loader = THREE.Loader.Handlers.get( fullPath );
	
					var texture;
	
					if ( loader !== null ) {
	
						texture = loader.load( fullPath );
	
					} else {
	
						textureLoader.setCrossOrigin( crossOrigin );
						texture = textureLoader.load( fullPath );
	
					}
	
					if ( repeat !== undefined ) {
	
						texture.repeat.fromArray( repeat );
	
						if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
						if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;
	
					}
	
					if ( offset !== undefined ) {
	
						texture.offset.fromArray( offset );
	
					}
	
					if ( wrap !== undefined ) {
	
						if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;
						if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;
	
						if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;
						if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;
	
					}
	
					if ( anisotropy !== undefined ) {
	
						texture.anisotropy = anisotropy;
	
					}
	
					var uuid = THREE.Math.generateUUID();
	
					textures[ uuid ] = texture;
	
					return uuid;
	
				}
	
				//
	
				var json = {
					uuid: THREE.Math.generateUUID(),
					type: 'MeshLambertMaterial'
				};
	
				for ( var name in m ) {
	
					var value = m[ name ];
	
					switch ( name ) {
						case 'DbgColor':
							json.color = value;
							break;
						case 'DbgIndex':
						case 'opticalDensity':
						case 'illumination':
							// These were never supported
							break;
						case 'DbgName':
							json.name = value;
							break;
						case 'blending':
							json.blending = THREE[ value ];
							break;
						case 'colorDiffuse':
							json.color = color.fromArray( value ).getHex();
							break;
						case 'colorSpecular':
							json.specular = color.fromArray( value ).getHex();
							break;
						case 'colorEmissive':
							json.emissive = color.fromArray( value ).getHex();
							break;
						case 'specularCoef':
							json.shininess = value;
							break;
						case 'shading':
							if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
							if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
							break;
						case 'mapDiffuse':
							json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
							break;
						case 'mapDiffuseRepeat':
						case 'mapDiffuseOffset':
						case 'mapDiffuseWrap':
						case 'mapDiffuseAnisotropy':
							break;
						case 'mapLight':
							json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
							break;
						case 'mapLightRepeat':
						case 'mapLightOffset':
						case 'mapLightWrap':
						case 'mapLightAnisotropy':
							break;
						case 'mapAO':
							json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
							break;
						case 'mapAORepeat':
						case 'mapAOOffset':
						case 'mapAOWrap':
						case 'mapAOAnisotropy':
							break;
						case 'mapBump':
							json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
							break;
						case 'mapBumpScale':
							json.bumpScale = value;
							break;
						case 'mapBumpRepeat':
						case 'mapBumpOffset':
						case 'mapBumpWrap':
						case 'mapBumpAnisotropy':
							break;
						case 'mapNormal':
							json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
							break;
						case 'mapNormalFactor':
							json.normalScale = [ value, value ];
							break;
						case 'mapNormalRepeat':
						case 'mapNormalOffset':
						case 'mapNormalWrap':
						case 'mapNormalAnisotropy':
							break;
						case 'mapSpecular':
							json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
							break;
						case 'mapSpecularRepeat':
						case 'mapSpecularOffset':
						case 'mapSpecularWrap':
						case 'mapSpecularAnisotropy':
							break;
						case 'mapAlpha':
							json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
							break;
						case 'mapAlphaRepeat':
						case 'mapAlphaOffset':
						case 'mapAlphaWrap':
						case 'mapAlphaAnisotropy':
							break;
						case 'flipSided':
							json.side = THREE.BackSide;
							break;
						case 'doubleSided':
							json.side = THREE.DoubleSide;
							break;
						case 'transparency':
							console.warn( 'THREE.Loader: transparency has been renamed to opacity' );
							json.opacity = value;
							break;
						case 'opacity':
						case 'transparent':
						case 'depthTest':
						case 'depthWrite':
						case 'transparent':
						case 'visible':
						case 'wireframe':
							json[ name ] = value;
							break;
						case 'vertexColors':
							if ( value === true ) json.vertexColors = THREE.VertexColors;
							if ( value === 'face' ) json.vertexColors = THREE.FaceColors;
							break;
						default:
							console.error( 'Loader.createMaterial: Unsupported', name, value );
							break;
					}
	
				}
	
				if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;
				if ( json.opacity < 1 ) json.transparent = true;
	
				materialLoader.setTextures( textures );
	
				return materialLoader.parse( json );
	
			};
	
		} )()
	
	};
	
	THREE.Loader.Handlers = {
	
		handlers: [],
	
		add: function ( regex, loader ) {
	
			this.handlers.push( regex, loader );
	
		},
	
		get: function ( file ) {
	
			var handlers = this.handlers;
	
			for ( var i = 0, l = handlers.length; i < l; i += 2 ) {
	
				var regex = handlers[ i ];
				var loader  = handlers[ i + 1 ];
	
				if ( regex.test( file ) ) {
	
					return loader;
	
				}
	
			}
	
			return null;
	
		}
	
	};
	
	// File:src/loaders/XHRLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.XHRLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.XHRLoader.prototype = {
	
		constructor: THREE.XHRLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var cached = THREE.Cache.get( url );
	
			if ( cached !== undefined ) {
	
				if ( onLoad ) {
	
					setTimeout( function () {
	
						onLoad( cached );
	
					}, 0 );
	
				}
	
				return cached;
	
			}
	
			var request = new XMLHttpRequest();
			request.open( 'GET', url, true );
	
			request.addEventListener( 'load', function ( event ) {
	
				var response = event.target.response;
	
				THREE.Cache.add( url, response );
	
				if ( onLoad ) onLoad( response );
	
				scope.manager.itemEnd( url );
	
			}, false );
	
			if ( onProgress !== undefined ) {
	
				request.addEventListener( 'progress', function ( event ) {
	
					onProgress( event );
	
				}, false );
	
			}
	
			request.addEventListener( 'error', function ( event ) {
	
				if ( onError ) onError( event );
	
				scope.manager.itemError( url );
	
			}, false );
	
			if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
			if ( this.responseType !== undefined ) request.responseType = this.responseType;
			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;
	
			request.send( null );
	
			scope.manager.itemStart( url );
	
			return request;
	
		},
	
		setResponseType: function ( value ) {
	
			this.responseType = value;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		setWithCredentials: function ( value ) {
	
			this.withCredentials = value;
	
		}
	
	};
	
	// File:src/loaders/ImageLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.ImageLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.ImageLoader.prototype = {
	
		constructor: THREE.ImageLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var cached = THREE.Cache.get( url );
	
			if ( cached !== undefined ) {
	
				scope.manager.itemStart( url );
	
				if ( onLoad ) {
	
					setTimeout( function () {
	
						onLoad( cached );
	
						scope.manager.itemEnd( url );
	
					}, 0 );
	
				} else {
	
					scope.manager.itemEnd( url );
	
				}
	
				return cached;
	
			}
	
			var image = document.createElement( 'img' );
	
			image.addEventListener( 'load', function ( event ) {
	
				THREE.Cache.add( url, this );
	
				if ( onLoad ) onLoad( this );
	
				scope.manager.itemEnd( url );
	
			}, false );
	
			if ( onProgress !== undefined ) {
	
				image.addEventListener( 'progress', function ( event ) {
	
					onProgress( event );
	
				}, false );
	
			}
	
			image.addEventListener( 'error', function ( event ) {
	
				if ( onError ) onError( event );
	
				scope.manager.itemError( url );
	
			}, false );
	
			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;
	
			scope.manager.itemStart( url );
	
			image.src = url;
	
			return image;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		}
	
	};
	
	// File:src/loaders/JSONLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.JSONLoader = function ( manager ) {
	
		if ( typeof manager === 'boolean' ) {
	
			console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
			manager = undefined;
	
		}
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
		this.withCredentials = false;
	
	};
	
	THREE.JSONLoader.prototype = {
	
		constructor: THREE.JSONLoader,
	
		// Deprecated
	
		get statusDomElement () {
	
			if ( this._statusDomElement === undefined ) {
	
				this._statusDomElement = document.createElement( 'div' );
	
			}
	
			console.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );
			return this._statusDomElement;
	
		},
	
		load: function( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );
	
			var loader = new THREE.XHRLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( text ) {
	
				var json = JSON.parse( text );
				var metadata = json.metadata;
	
				if ( metadata !== undefined ) {
	
					if ( metadata.type === 'object' ) {
	
						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
						return;
	
					}
	
					if ( metadata.type === 'scene' ) {
	
						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
						return;
	
					}
	
				}
	
				var object = scope.parse( json, texturePath );
				onLoad( object.geometry, object.materials );
	
			} );
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		setTexturePath: function ( value ) {
	
			this.texturePath = value;
	
		},
	
		parse: function ( json, texturePath ) {
	
			var geometry = new THREE.Geometry(),
			scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;
	
			parseModel( scale );
	
			parseSkin();
			parseMorphing( scale );
			parseAnimations();
	
			geometry.computeFaceNormals();
			geometry.computeBoundingSphere();
	
			function parseModel( scale ) {
	
				function isBitSet( value, position ) {
	
					return value & ( 1 << position );
	
				}
	
				var i, j, fi,
	
				offset, zLength,
	
			colorIndex, normalIndex, uvIndex, materialIndex,
	
				type,
				isQuad,
				hasMaterial,
				hasFaceVertexUv,
				hasFaceNormal, hasFaceVertexNormal,
				hasFaceColor, hasFaceVertexColor,
	
			vertex, face, faceA, faceB, hex, normal,
	
				uvLayer, uv, u, v,
	
				faces = json.faces,
				vertices = json.vertices,
				normals = json.normals,
				colors = json.colors,
	
				nUvLayers = 0;
	
				if ( json.uvs !== undefined ) {
	
					// disregard empty arrays
	
					for ( i = 0; i < json.uvs.length; i ++ ) {
	
						if ( json.uvs[ i ].length ) nUvLayers ++;
	
					}
	
					for ( i = 0; i < nUvLayers; i ++ ) {
	
						geometry.faceVertexUvs[ i ] = [];
	
					}
	
				}
	
				offset = 0;
				zLength = vertices.length;
	
				while ( offset < zLength ) {
	
					vertex = new THREE.Vector3();
	
					vertex.x = vertices[ offset ++ ] * scale;
					vertex.y = vertices[ offset ++ ] * scale;
					vertex.z = vertices[ offset ++ ] * scale;
	
					geometry.vertices.push( vertex );
	
				}
	
				offset = 0;
				zLength = faces.length;
	
				while ( offset < zLength ) {
	
					type = faces[ offset ++ ];
	
	
					isQuad              = isBitSet( type, 0 );
					hasMaterial         = isBitSet( type, 1 );
					hasFaceVertexUv     = isBitSet( type, 3 );
					hasFaceNormal       = isBitSet( type, 4 );
					hasFaceVertexNormal = isBitSet( type, 5 );
					hasFaceColor	     = isBitSet( type, 6 );
					hasFaceVertexColor  = isBitSet( type, 7 );
	
					// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
	
					if ( isQuad ) {
	
						faceA = new THREE.Face3();
						faceA.a = faces[ offset ];
						faceA.b = faces[ offset + 1 ];
						faceA.c = faces[ offset + 3 ];
	
						faceB = new THREE.Face3();
						faceB.a = faces[ offset + 1 ];
						faceB.b = faces[ offset + 2 ];
						faceB.c = faces[ offset + 3 ];
	
						offset += 4;
	
						if ( hasMaterial ) {
	
							materialIndex = faces[ offset ++ ];
							faceA.materialIndex = materialIndex;
							faceB.materialIndex = materialIndex;
	
						}
	
						// to get face <=> uv index correspondence
	
						fi = geometry.faces.length;
	
						if ( hasFaceVertexUv ) {
	
							for ( i = 0; i < nUvLayers; i ++ ) {
	
								uvLayer = json.uvs[ i ];
	
								geometry.faceVertexUvs[ i ][ fi ] = [];
								geometry.faceVertexUvs[ i ][ fi + 1 ] = [];
	
								for ( j = 0; j < 4; j ++ ) {
	
									uvIndex = faces[ offset ++ ];
	
									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];
	
									uv = new THREE.Vector2( u, v );
	
									if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
									if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );
	
								}
	
							}
	
						}
	
						if ( hasFaceNormal ) {
	
							normalIndex = faces[ offset ++ ] * 3;
	
							faceA.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);
	
							faceB.normal.copy( faceA.normal );
	
						}
	
						if ( hasFaceVertexNormal ) {
	
							for ( i = 0; i < 4; i ++ ) {
	
								normalIndex = faces[ offset ++ ] * 3;
	
								normal = new THREE.Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);
	
	
								if ( i !== 2 ) faceA.vertexNormals.push( normal );
								if ( i !== 0 ) faceB.vertexNormals.push( normal );
	
							}
	
						}
	
	
						if ( hasFaceColor ) {
	
							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];
	
							faceA.color.setHex( hex );
							faceB.color.setHex( hex );
	
						}
	
	
						if ( hasFaceVertexColor ) {
	
							for ( i = 0; i < 4; i ++ ) {
	
								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];
	
								if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
								if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );
	
							}
	
						}
	
						geometry.faces.push( faceA );
						geometry.faces.push( faceB );
	
					} else {
	
						face = new THREE.Face3();
						face.a = faces[ offset ++ ];
						face.b = faces[ offset ++ ];
						face.c = faces[ offset ++ ];
	
						if ( hasMaterial ) {
	
							materialIndex = faces[ offset ++ ];
							face.materialIndex = materialIndex;
	
						}
	
						// to get face <=> uv index correspondence
	
						fi = geometry.faces.length;
	
						if ( hasFaceVertexUv ) {
	
							for ( i = 0; i < nUvLayers; i ++ ) {
	
								uvLayer = json.uvs[ i ];
	
								geometry.faceVertexUvs[ i ][ fi ] = [];
	
								for ( j = 0; j < 3; j ++ ) {
	
									uvIndex = faces[ offset ++ ];
	
									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];
	
									uv = new THREE.Vector2( u, v );
	
									geometry.faceVertexUvs[ i ][ fi ].push( uv );
	
								}
	
							}
	
						}
	
						if ( hasFaceNormal ) {
	
							normalIndex = faces[ offset ++ ] * 3;
	
							face.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);
	
						}
	
						if ( hasFaceVertexNormal ) {
	
							for ( i = 0; i < 3; i ++ ) {
	
								normalIndex = faces[ offset ++ ] * 3;
	
								normal = new THREE.Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);
	
								face.vertexNormals.push( normal );
	
							}
	
						}
	
	
						if ( hasFaceColor ) {
	
							colorIndex = faces[ offset ++ ];
							face.color.setHex( colors[ colorIndex ] );
	
						}
	
	
						if ( hasFaceVertexColor ) {
	
							for ( i = 0; i < 3; i ++ ) {
	
								colorIndex = faces[ offset ++ ];
								face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );
	
							}
	
						}
	
						geometry.faces.push( face );
	
					}
	
				}
	
			};
	
			function parseSkin() {
	
				var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;
	
				if ( json.skinWeights ) {
	
					for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {
	
						var x =                               json.skinWeights[ i ];
						var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
						var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
						var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;
	
						geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );
	
					}
	
				}
	
				if ( json.skinIndices ) {
	
					for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {
	
						var a =                               json.skinIndices[ i ];
						var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
						var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
						var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;
	
						geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );
	
					}
	
				}
	
				geometry.bones = json.bones;
	
				if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {
	
					console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
						geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );
	
				}
	
			};
	
			function parseMorphing( scale ) {
	
				if ( json.morphTargets !== undefined ) {
	
					for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {
	
						geometry.morphTargets[ i ] = {};
						geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
						geometry.morphTargets[ i ].vertices = [];
	
						var dstVertices = geometry.morphTargets[ i ].vertices;
						var srcVertices = json.morphTargets[ i ].vertices;
	
						for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {
	
							var vertex = new THREE.Vector3();
							vertex.x = srcVertices[ v ] * scale;
							vertex.y = srcVertices[ v + 1 ] * scale;
							vertex.z = srcVertices[ v + 2 ] * scale;
	
							dstVertices.push( vertex );
	
						}
	
					}
	
				}
	
				if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {
	
					console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );
	
					var faces = geometry.faces;
					var morphColors = json.morphColors[ 0 ].colors;
	
					for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
						faces[ i ].color.fromArray( morphColors, i * 3 );
	
					}
	
				}
	
			}
	
			function parseAnimations() {
	
				var outputAnimations = [];
	
				// parse old style Bone/Hierarchy animations
				var animations = [];
				if ( json.animation !== undefined ) {
					animations.push( json.animation );
				}
				if ( json.animations !== undefined ) {
					if ( json.animations.length ) {
						animations = animations.concat( json.animations );
					} else {
						animations.push( json.animations );
					}
				}
	
				for ( var i = 0; i < animations.length; i ++ ) {
	
					var clip = THREE.AnimationClip.parseAnimation( animations[i], geometry.bones );
					if ( clip ) outputAnimations.push( clip );
	
				}
	
				// parse implicit morph animations
				if ( geometry.morphTargets ) {
	
					// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
					var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
					outputAnimations = outputAnimations.concat( morphAnimationClips );
	
				}
	
				if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;
	
			};
	
			if ( json.materials === undefined || json.materials.length === 0 ) {
	
				return { geometry: geometry };
	
			} else {
	
				var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );
	
				return { geometry: geometry, materials: materials };
	
			}
	
		}
	
	};
	
	// File:src/loaders/LoadingManager.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LoadingManager = function ( onLoad, onProgress, onError ) {
	
		var scope = this;
	
		var isLoading = false, itemsLoaded = 0, itemsTotal = 0;
	
		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;
	
		this.itemStart = function ( url ) {
	
			itemsTotal ++;
	
			if ( isLoading === false ) {
	
				if ( scope.onStart !== undefined ) {
	
					scope.onStart( url, itemsLoaded, itemsTotal );
	
				}
	
			}
	
			isLoading = true;
	
		};
	
		this.itemEnd = function ( url ) {
	
			itemsLoaded ++;
	
			if ( scope.onProgress !== undefined ) {
	
				scope.onProgress( url, itemsLoaded, itemsTotal );
	
			}
	
			if ( itemsLoaded === itemsTotal ) {
	
				isLoading = false;
	
				if ( scope.onLoad !== undefined ) {
	
					scope.onLoad();
	
				}
	
			}
	
		};
	
		this.itemError = function ( url ) {
	
			if ( scope.onError !== undefined ) {
	
				scope.onError( url );
	
			}
	
		};
	
	};
	
	THREE.DefaultLoadingManager = new THREE.LoadingManager();
	
	// File:src/loaders/BufferGeometryLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BufferGeometryLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.BufferGeometryLoader.prototype = {
	
		constructor: THREE.BufferGeometryLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( JSON.parse( text ) ) );
	
			}, onProgress, onError );
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		parse: function ( json ) {
	
			var geometry = new THREE.BufferGeometry();
	
			var index = json.data.index;
	
			if ( index !== undefined ) {
	
				var typedArray = new self[ index.type ]( index.array );
				geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );
	
			}
	
			var attributes = json.data.attributes;
	
			for ( var key in attributes ) {
	
				var attribute = attributes[ key ];
				var typedArray = new self[ attribute.type ]( attribute.array );
	
				geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );
	
			}
	
			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
	
			if ( groups !== undefined ) {
	
				for ( var i = 0, n = groups.length; i !== n; ++ i ) {
	
					var group = groups[ i ];
	
					geometry.addGroup( group.start, group.count );
	
				}
	
			}
	
			var boundingSphere = json.data.boundingSphere;
	
			if ( boundingSphere !== undefined ) {
	
				var center = new THREE.Vector3();
	
				if ( boundingSphere.center !== undefined ) {
	
					center.fromArray( boundingSphere.center );
	
				}
	
				geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );
	
			}
	
			return geometry;
	
		}
	
	};
	
	// File:src/loaders/MaterialLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.MaterialLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
		this.textures = {};
	
	};
	
	THREE.MaterialLoader.prototype = {
	
		constructor: THREE.MaterialLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( JSON.parse( text ) ) );
	
			}, onProgress, onError );
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		setTextures: function ( value ) {
	
			this.textures = value;
	
		},
	
		getTexture: function ( name ) {
	
			var textures = this.textures;
	
			if ( textures[ name ] === undefined ) {
	
				console.warn( 'THREE.MaterialLoader: Undefined texture', name );
	
			}
	
			return textures[ name ];
	
		},
	
		parse: function ( json ) {
	
			var material = new THREE[ json.type ];
			material.uuid = json.uuid;
	
			if ( json.name !== undefined ) material.name = json.name;
			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.shading !== undefined ) material.shading = json.shading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
			if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
			if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
			if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
	
			// for PointsMaterial
			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;
	
			// maps
	
			if ( json.map !== undefined ) material.map = this.getTexture( json.map );
	
			if ( json.alphaMap !== undefined ) {
	
				material.alphaMap = this.getTexture( json.alphaMap );
				material.transparent = true;
	
			}
	
			if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );
			if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;
	
			if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );
			if ( json.normalScale )	material.normalScale = new THREE.Vector2( json.normalScale, json.normalScale );
	
			if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );
			if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
			if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;
	
			if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );
	
			if ( json.envMap !== undefined ) {
	
				material.envMap = this.getTexture( json.envMap );
				material.combine = THREE.MultiplyOperation;
	
			}
	
			if ( json.reflectivity ) material.reflectivity = json.reflectivity;
	
			if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );
			if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;
	
			if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );
			if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;
	
			// MeshFaceMaterial
	
			if ( json.materials !== undefined ) {
	
				for ( var i = 0, l = json.materials.length; i < l; i ++ ) {
	
					material.materials.push( this.parse( json.materials[ i ] ) );
	
				}
	
			}
	
			return material;
	
		}
	
	};
	
	// File:src/loaders/ObjectLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.ObjectLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
		this.texturePath = '';
	
	};
	
	THREE.ObjectLoader.prototype = {
	
		constructor: THREE.ObjectLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			if ( this.texturePath === '' ) {
	
				this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );
	
			}
	
			var scope = this;
	
			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {
	
				scope.parse( JSON.parse( text ), onLoad );
	
			}, onProgress, onError );
	
		},
	
		setTexturePath: function ( value ) {
	
			this.texturePath = value;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		},
	
		parse: function ( json, onLoad ) {
	
			var geometries = this.parseGeometries( json.geometries );
	
			var images = this.parseImages( json.images, function () {
	
				if ( onLoad !== undefined ) onLoad( object );
	
			} );
	
			var textures  = this.parseTextures( json.textures, images );
			var materials = this.parseMaterials( json.materials, textures );
	
			var object = this.parseObject( json.object, geometries, materials );
	
			if ( json.animations ) {
	
				object.animations = this.parseAnimations( json.animations );
	
			}
	
			if ( json.images === undefined || json.images.length === 0 ) {
	
				if ( onLoad !== undefined ) onLoad( object );
	
			}
	
			return object;
	
		},
	
		parseGeometries: function ( json ) {
	
			var geometries = {};
	
			if ( json !== undefined ) {
	
				var geometryLoader = new THREE.JSONLoader();
				var bufferGeometryLoader = new THREE.BufferGeometryLoader();
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var geometry;
					var data = json[ i ];
	
					switch ( data.type ) {
	
						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':
	
							geometry = new THREE[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);
	
							break;
	
						case 'BoxGeometry':
						case 'CubeGeometry': // backwards compatible
	
							geometry = new THREE.BoxGeometry(
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);
	
							break;
	
						case 'CircleBufferGeometry':
	
							geometry = new THREE.CircleBufferGeometry(
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'CircleGeometry':
	
							geometry = new THREE.CircleGeometry(
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'CylinderGeometry':
	
							geometry = new THREE.CylinderGeometry(
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'SphereGeometry':
	
							geometry = new THREE.SphereGeometry(
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'SphereBufferGeometry':
	
							geometry = new THREE.SphereBufferGeometry(
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'DodecahedronGeometry':
	
							geometry = new THREE.DodecahedronGeometry(
								data.radius,
								data.detail
							);
	
							break;
	
						case 'IcosahedronGeometry':
	
							geometry = new THREE.IcosahedronGeometry(
								data.radius,
								data.detail
							);
	
							break;
	
						case 'OctahedronGeometry':
	
							geometry = new THREE.OctahedronGeometry(
								data.radius,
								data.detail
							);
	
							break;
	
						case 'TetrahedronGeometry':
	
							geometry = new THREE.TetrahedronGeometry(
								data.radius,
								data.detail
							);
	
							break;
	
						case 'RingGeometry':
	
							geometry = new THREE.RingGeometry(
								data.innerRadius,
								data.outerRadius,
								data.thetaSegments,
								data.phiSegments,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'TorusGeometry':
	
							geometry = new THREE.TorusGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);
	
							break;
	
						case 'TorusKnotGeometry':
	
							geometry = new THREE.TorusKnotGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.p,
								data.q,
								data.heightScale
							);
	
							break;
	
						case 'BufferGeometry':
	
							geometry = bufferGeometryLoader.parse( data );
	
							break;
	
						case 'Geometry':
	
							geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;
	
							break;
	
						default:
	
							console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );
	
							continue;
	
					}
	
					geometry.uuid = data.uuid;
	
					if ( data.name !== undefined ) geometry.name = data.name;
	
					geometries[ data.uuid ] = geometry;
	
				}
	
			}
	
			return geometries;
	
		},
	
		parseMaterials: function ( json, textures ) {
	
			var materials = {};
	
			if ( json !== undefined ) {
	
				var loader = new THREE.MaterialLoader();
				loader.setTextures( textures );
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var material = loader.parse( json[ i ] );
					materials[ material.uuid ] = material;
	
				}
	
			}
	
			return materials;
	
		},
	
		parseAnimations: function ( json ) {
	
			var animations = [];
	
			for ( var i = 0; i < json.length; i ++ ) {
	
				var clip = THREE.AnimationClip.parse( json[i] );
	
				animations.push( clip );
	
			}
	
			return animations;
	
		},
	
		parseImages: function ( json, onLoad ) {
	
			var scope = this;
			var images = {};
	
			function loadImage( url ) {
	
				scope.manager.itemStart( url );
	
				return loader.load( url, function () {
	
					scope.manager.itemEnd( url );
	
				} );
	
			}
	
			if ( json !== undefined && json.length > 0 ) {
	
				var manager = new THREE.LoadingManager( onLoad );
	
				var loader = new THREE.ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var image = json[ i ];
					var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;
	
					images[ image.uuid ] = loadImage( path );
	
				}
	
			}
	
			return images;
	
		},
	
		parseTextures: function ( json, images ) {
	
			function parseConstant( value ) {
	
				if ( typeof( value ) === 'number' ) return value;
	
				console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );
	
				return THREE[ value ];
	
			}
	
			var textures = {};
	
			if ( json !== undefined ) {
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var data = json[ i ];
	
					if ( data.image === undefined ) {
	
						console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );
	
					}
	
					if ( images[ data.image ] === undefined ) {
	
						console.warn( 'THREE.ObjectLoader: Undefined image', data.image );
	
					}
	
					var texture = new THREE.Texture( images[ data.image ] );
					texture.needsUpdate = true;
	
					texture.uuid = data.uuid;
	
					if ( data.name !== undefined ) texture.name = data.name;
					if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
					if ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );
					if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
					if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
					if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
					if ( Array.isArray( data.wrap ) ) {
	
						texture.wrapS = parseConstant( data.wrap[ 0 ] );
						texture.wrapT = parseConstant( data.wrap[ 1 ] );
	
					}
	
					textures[ data.uuid ] = texture;
	
				}
	
			}
	
			return textures;
	
		},
	
		parseObject: function () {
	
			var matrix = new THREE.Matrix4();
	
			return function ( data, geometries, materials ) {
	
				var object;
	
				function getGeometry( name ) {
	
					if ( geometries[ name ] === undefined ) {
	
						console.warn( 'THREE.ObjectLoader: Undefined geometry', name );
	
					}
	
					return geometries[ name ];
	
				}
	
				function getMaterial( name ) {
	
					if ( name === undefined ) return undefined;
	
					if ( materials[ name ] === undefined ) {
	
						console.warn( 'THREE.ObjectLoader: Undefined material', name );
	
					}
	
					return materials[ name ];
	
				}
	
				switch ( data.type ) {
	
					case 'Scene':
	
						object = new THREE.Scene();
	
						break;
	
					case 'PerspectiveCamera':
	
						object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );
	
						break;
	
					case 'OrthographicCamera':
	
						object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );
	
						break;
	
					case 'AmbientLight':
	
						object = new THREE.AmbientLight( data.color );
	
						break;
	
					case 'DirectionalLight':
	
						object = new THREE.DirectionalLight( data.color, data.intensity );
	
						break;
	
					case 'PointLight':
	
						object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );
	
						break;
	
					case 'SpotLight':
	
						object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );
	
						break;
	
					case 'HemisphereLight':
	
						object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );
	
						break;
	
					case 'Mesh':
	
						object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );
	
						break;
	
					case 'LOD':
	
						object = new THREE.LOD();
	
						break;
	
					case 'Line':
	
						object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );
	
						break;
	
					case 'PointCloud':
					case 'Points':
	
						object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );
	
						break;
	
					case 'Sprite':
	
						object = new THREE.Sprite( getMaterial( data.material ) );
	
						break;
	
					case 'Group':
	
						object = new THREE.Group();
	
						break;
	
					default:
	
						object = new THREE.Object3D();
	
				}
	
				object.uuid = data.uuid;
	
				if ( data.name !== undefined ) object.name = data.name;
				if ( data.matrix !== undefined ) {
	
					matrix.fromArray( data.matrix );
					matrix.decompose( object.position, object.quaternion, object.scale );
	
				} else {
	
					if ( data.position !== undefined ) object.position.fromArray( data.position );
					if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
					if ( data.scale !== undefined ) object.scale.fromArray( data.scale );
	
				}
	
				if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
				if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;
	
				if ( data.visible !== undefined ) object.visible = data.visible;
				if ( data.userData !== undefined ) object.userData = data.userData;
	
				if ( data.children !== undefined ) {
	
					for ( var child in data.children ) {
	
						object.add( this.parseObject( data.children[ child ], geometries, materials ) );
	
					}
	
				}
	
				if ( data.type === 'LOD' ) {
	
					var levels = data.levels;
	
					for ( var l = 0; l < levels.length; l ++ ) {
	
						var level = levels[ l ];
						var child = object.getObjectByProperty( 'uuid', level.object );
	
						if ( child !== undefined ) {
	
							object.addLevel( child, level.distance );
	
						}
	
					}
	
				}
	
				return object;
	
			}
	
		}()
	
	};
	
	// File:src/loaders/TextureLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.TextureLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.TextureLoader.prototype = {
	
		constructor: THREE.TextureLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var texture = new THREE.Texture();
	
			var loader = new THREE.ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( image ) {
	
				texture.image = image;
				texture.needsUpdate = true;
	
				if ( onLoad !== undefined ) {
	
					onLoad( texture );
	
				}
	
			}, onProgress, onError );
	
			return texture;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		}
	
	};
	
	// File:src/loaders/CubeTextureLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CubeTextureLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	};
	
	THREE.CubeTextureLoader.prototype = {
	
		constructor: THREE.CubeTextureLoader,
	
		load: function ( urls, onLoad, onProgress, onError ) {
	
			var texture = new THREE.CubeTexture( [] );
	
			var loader = new THREE.ImageLoader();
			loader.setCrossOrigin( this.crossOrigin );
	
			var loaded = 0;
	
			function loadTexture( i ) {
	
				loader.load( urls[ i ], function ( image ) {
	
					texture.images[ i ] = image;
	
					loaded ++;
	
					if ( loaded === 6 ) {
	
						texture.needsUpdate = true;
	
						if ( onLoad ) onLoad( texture );
	
					}
	
				}, undefined, onError );
	
			}
	
			for ( var i = 0; i < urls.length; ++ i ) {
	
				loadTexture( i );
	
			}
	
			return texture;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		}
	
	};
	
	// File:src/loaders/BinaryTextureLoader.js
	
	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */
	
	THREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
		// override in sub classes
		this._parser = null;
	
	};
	
	THREE.BinaryTextureLoader.prototype = {
	
		constructor: THREE.BinaryTextureLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var texture = new THREE.DataTexture();
	
			var loader = new THREE.XHRLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setResponseType( 'arraybuffer' );
	
			loader.load( url, function ( buffer ) {
	
				var texData = scope._parser( buffer );
	
				if ( ! texData ) return;
	
				if ( undefined !== texData.image ) {
	
					texture.image = texData.image;
	
				} else if ( undefined !== texData.data ) {
	
					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;
	
				}
	
				texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
				texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;
	
				texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
				texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;
	
				texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
	
				if ( undefined !== texData.format ) {
	
					texture.format = texData.format;
	
				}
				if ( undefined !== texData.type ) {
	
					texture.type = texData.type;
	
				}
	
				if ( undefined !== texData.mipmaps ) {
	
					texture.mipmaps = texData.mipmaps;
	
				}
	
				if ( 1 === texData.mipmapCount ) {
	
					texture.minFilter = THREE.LinearFilter;
	
				}
	
				texture.needsUpdate = true;
	
				if ( onLoad ) onLoad( texture, texData );
	
			}, onProgress, onError );
	
	
			return texture;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		}
	
	};
	
	// File:src/loaders/CompressedTextureLoader.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */
	
	THREE.CompressedTextureLoader = function ( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
		// override in sub classes
		this._parser = null;
	
	};
	
	
	THREE.CompressedTextureLoader.prototype = {
	
		constructor: THREE.CompressedTextureLoader,
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var images = [];
	
			var texture = new THREE.CompressedTexture();
			texture.image = images;
	
			var loader = new THREE.XHRLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setResponseType( 'arraybuffer' );
	
			if ( Array.isArray( url ) ) {
	
				var loaded = 0;
	
				var loadTexture = function ( i ) {
	
					loader.load( url[ i ], function ( buffer ) {
	
						var texDatas = scope._parser( buffer, true );
	
						images[ i ] = {
							width: texDatas.width,
							height: texDatas.height,
							format: texDatas.format,
							mipmaps: texDatas.mipmaps
						};
	
						loaded += 1;
	
						if ( loaded === 6 ) {
	
							if ( texDatas.mipmapCount === 1 )
	 							texture.minFilter = THREE.LinearFilter;
	
							texture.format = texDatas.format;
							texture.needsUpdate = true;
	
							if ( onLoad ) onLoad( texture );
	
						}
	
					}, onProgress, onError );
	
				};
	
				for ( var i = 0, il = url.length; i < il; ++ i ) {
	
					loadTexture( i );
	
				}
	
			} else {
	
				// compressed cubemap texture stored in a single DDS file
	
				loader.load( url, function ( buffer ) {
	
					var texDatas = scope._parser( buffer, true );
	
					if ( texDatas.isCubemap ) {
	
						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
	
						for ( var f = 0; f < faces; f ++ ) {
	
							images[ f ] = { mipmaps : [] };
	
							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {
	
								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;
	
							}
	
						}
	
					} else {
	
						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;
	
					}
	
					if ( texDatas.mipmapCount === 1 ) {
	
						texture.minFilter = THREE.LinearFilter;
	
					}
	
					texture.format = texDatas.format;
					texture.needsUpdate = true;
	
					if ( onLoad ) onLoad( texture );
	
				}, onProgress, onError );
	
			}
	
			return texture;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
	
		}
	
	};
	
	// File:src/materials/Material.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Material = function () {
	
		Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.type = 'Material';
	
		this.side = THREE.FrontSide;
	
		this.opacity = 1;
		this.transparent = false;
	
		this.blending = THREE.NormalBlending;
	
		this.blendSrc = THREE.SrcAlphaFactor;
		this.blendDst = THREE.OneMinusSrcAlphaFactor;
		this.blendEquation = THREE.AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;
	
		this.depthFunc = THREE.LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;
	
		this.colorWrite = true;
	
		this.precision = null; // override the renderer's default precision for this material
	
		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;
	
		this.alphaTest = 0;
	
		this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
	
		this.visible = true;
	
		this._needsUpdate = true;
	
	};
	
	THREE.Material.prototype = {
	
		constructor: THREE.Material,
	
		get needsUpdate () {
	
			return this._needsUpdate;
	
		},
	
		set needsUpdate ( value ) {
	
			if ( value === true ) this.update();
	
			this._needsUpdate = value;
	
		},
	
		setValues: function ( values ) {
	
			if ( values === undefined ) return;
	
			for ( var key in values ) {
	
				var newValue = values[ key ];
	
				if ( newValue === undefined ) {
	
					console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;
	
				}
	
				var currentValue = this[ key ];
	
				if ( currentValue === undefined ) {
	
					console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
					continue;
	
				}
	
				if ( currentValue instanceof THREE.Color ) {
	
					currentValue.set( newValue );
	
				} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {
	
					currentValue.copy( newValue );
	
				} else if ( key === 'overdraw' ) {
	
					// ensure overdraw is backwards-compatible with legacy boolean type
					this[ key ] = Number( newValue );
	
				} else {
	
					this[ key ] = newValue;
	
				}
	
			}
	
		},
	
		toJSON: function ( meta ) {
	
			var data = {
				metadata: {
					version: 4.4,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};
	
			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
	
			if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();
			if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
			if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
	
			if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
			if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
			if ( this.bumpMap instanceof THREE.Texture ) {
	
				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;
	
			}
			if ( this.normalMap instanceof THREE.Texture ) {
	
				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalScale = this.normalScale; // Removed for now, causes issue in editor ui.js
	
			}
			if ( this.displacementMap instanceof THREE.Texture ) {
	
				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;
	
			}
			if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
			if ( this.envMap instanceof THREE.Texture ) {
	
				data.envMap = this.envMap.toJSON( meta ).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap
	
			}
	
			if ( this.size !== undefined ) data.size = this.size;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;
	
			if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
			if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;
			if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;
			if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;
	
			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;
			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
	
			return data;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.name = source.name;
	
			this.side = source.side;
	
			this.opacity = source.opacity;
			this.transparent = source.transparent;
	
			this.blending = source.blending;
	
			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;
	
			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;
	
			this.precision = source.precision;
	
			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;
	
			this.alphaTest = source.alphaTest;
	
			this.overdraw = source.overdraw;
	
			this.visible = source.visible;
	
			return this;
	
		},
	
		update: function () {
	
			this.dispatchEvent( { type: 'update' } );
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		},
	
		// Deprecated
	
		get wrapAround () {
	
			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
	
		},
	
		set wrapAround ( boolean ) {
	
			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
	
		},
	
		get wrapRGB () {
	
			console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
			return new THREE.Color();
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );
	
	THREE.MaterialIdCount = 0;
	
	// File:src/materials/LineBasicMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round",
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.LineBasicMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'LineBasicMaterial';
	
		this.color = new THREE.Color( 0xffffff );
	
		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.fog = true;
	
		this.setValues( parameters );
	
	};
	
	THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;
	
	THREE.LineBasicMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;
	
		this.vertexColors = source.vertexColors;
	
		this.fog = source.fog;
	
		return this;
	
	};
	
	// File:src/materials/LineDashedMaterial.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>,
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.LineDashedMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'LineDashedMaterial';
	
		this.color = new THREE.Color( 0xffffff );
	
		this.linewidth = 1;
	
		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;
	
		this.vertexColors = false;
	
		this.fog = true;
	
		this.setValues( parameters );
	
	};
	
	THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;
	
	THREE.LineDashedMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
		
		this.linewidth = source.linewidth;
	
		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;
	
		this.vertexColors = source.vertexColors;
	
		this.fog = source.fog;
	
		return this;
	
	};
	
	// File:src/materials/MeshBasicMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.MeshBasicMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshBasicMaterial';
	
		this.color = new THREE.Color( 0xffffff ); // emissive
	
		this.map = null;
	
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
	
		this.specularMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.shading = THREE.SmoothShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;
	
	THREE.MeshBasicMaterial.prototype.copy = function ( source ) {
		
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.map = source.map;
	
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
	
		this.specularMap = source.specularMap;
	
		this.alphaMap = source.alphaMap;
	
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
	
		this.fog = source.fog;
	
		this.shading = source.shading;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.vertexColors = source.vertexColors;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		
		return this;
	
	};
	
	// File:src/materials/MeshLambertMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  emissive: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.MeshLambertMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshLambertMaterial';
	
		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.emissive = new THREE.Color( 0x000000 );
	
		this.map = null;
	
		this.specularMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;
	
	THREE.MeshLambertMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
		this.emissive.copy( source.emissive );
	
		this.map = source.map;
	
		this.specularMap = source.specularMap;
	
		this.alphaMap = source.alphaMap;
	
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
	
		this.fog = source.fog;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.vertexColors = source.vertexColors;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		return this;
	
	};
	
	// File:src/materials/MeshPhongMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  emissive: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.MeshPhongMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshPhongMaterial';
	
		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.emissive = new THREE.Color( 0x000000 );
		this.specular = new THREE.Color( 0x111111 );
		this.shininess = 30;
	
		this.metal = false;
	
		this.map = null;
	
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
	
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
	
		this.emissiveMap = null;
	
		this.bumpMap = null;
		this.bumpScale = 1;
	
		this.normalMap = null;
		this.normalScale = new THREE.Vector2( 1, 1 );
	
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
	
		this.specularMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.shading = THREE.SmoothShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;
	
	THREE.MeshPhongMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
		this.emissive.copy( source.emissive );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;
	
		this.metal = source.metal;
	
		this.map = source.map;
	
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
	
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
	
		this.emissiveMap = source.emissiveMap;
	
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
	
		this.normalMap = source.normalMap;
		this.normalScale.copy( source.normalScale );
	
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
	
		this.specularMap = source.specularMap;
	
		this.alphaMap = source.alphaMap;
	
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
	
		this.fog = source.fog;
	
		this.shading = source.shading;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.vertexColors = source.vertexColors;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		return this;
	
	};
	
	// File:src/materials/MeshDepthMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */
	
	THREE.MeshDepthMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'MeshDepthMaterial';
	
		this.morphTargets = false;
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;
	
	THREE.MeshDepthMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
	
		return this;
	
	};
	
	// File:src/materials/MeshNormalMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  shading: THREE.FlatShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */
	
	THREE.MeshNormalMaterial = function ( parameters ) {
	
		THREE.Material.call( this, parameters );
	
		this.type = 'MeshNormalMaterial';
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.morphTargets = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;
	
	THREE.MeshNormalMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
	
		return this;
	
	};
	
	// File:src/materials/MultiMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.MultiMaterial = function ( materials ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.type = 'MultiMaterial';
	
		this.materials = materials instanceof Array ? materials : [];
	
		this.visible = true;
	
	};
	
	THREE.MultiMaterial.prototype = {
	
		constructor: THREE.MultiMaterial,
	
		toJSON: function () {
	
			var output = {
				metadata: {
					version: 4.2,
					type: 'material',
					generator: 'MaterialExporter'
				},
				uuid: this.uuid,
				type: this.type,
				materials: []
			};
	
			for ( var i = 0, l = this.materials.length; i < l; i ++ ) {
	
				output.materials.push( this.materials[ i ].toJSON() );
	
			}
	
			output.visible = this.visible;
	
			return output;
	
		},
	
		clone: function () {
	
			var material = new this.constructor();
	
			for ( var i = 0; i < this.materials.length; i ++ ) {
	
				material.materials.push( this.materials[ i ].clone() );
	
			}
	
			material.visible = this.visible;
	
			return material;
	
		}
	
	};
	
	// backwards compatibility
	
	THREE.MeshFaceMaterial = THREE.MultiMaterial;
	
	// File:src/materials/PointsMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  vertexColors: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.PointsMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'PointsMaterial';
	
		this.color = new THREE.Color( 0xffffff );
	
		this.map = null;
	
		this.size = 1;
		this.sizeAttenuation = true;
	
		this.vertexColors = THREE.NoColors;
	
		this.fog = true;
	
		this.setValues( parameters );
	
	};
	
	THREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;
	
	THREE.PointsMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.map = source.map;
	
		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;
	
		this.vertexColors = source.vertexColors;
	
		this.fog = source.fog;
	
		return this;
	
	};
	
	// backwards compatibility
	
	THREE.PointCloudMaterial = function ( parameters ) {
	
		console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
		return new THREE.PointsMaterial( parameters );
	
	};
	
	THREE.ParticleBasicMaterial = function ( parameters ) {
	
		console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
		return new THREE.PointsMaterial( parameters );
	
	};
	
	THREE.ParticleSystemMaterial = function ( parameters ) {
	
		console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
		return new THREE.PointsMaterial( parameters );
	
	};
	
	// File:src/materials/ShaderMaterial.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.ShaderMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'ShaderMaterial';
	
		this.defines = {};
		this.uniforms = {};
	
		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
	
		this.shading = THREE.SmoothShading;
	
		this.linewidth = 1;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.fog = false; // set to use scene fog
	
		this.lights = false; // set to use scene lights
	
		this.vertexColors = THREE.NoColors; // set to use "color" attribute stream
	
		this.skinning = false; // set to use skinning attribute streams
	
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals
	
		this.derivatives = false; // set to use derivatives
	
		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};
	
		this.index0AttributeName = undefined;
	
		if ( parameters !== undefined ) {
	
			if ( parameters.attributes !== undefined ) {
	
				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );
	
			}
	
			this.setValues( parameters );
	
		}
	
	};
	
	THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;
	
	THREE.ShaderMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;
	
		this.uniforms = THREE.UniformsUtils.clone( source.uniforms );
	
		this.attributes = source.attributes;
		this.defines = source.defines;
	
		this.shading = source.shading;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
	
		this.fog = source.fog;
	
		this.lights = source.lights;
	
		this.vertexColors = source.vertexColors;
	
		this.skinning = source.skinning;
	
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		this.derivatives = source.derivatives;
	
		return this;
	
	};
	
	THREE.ShaderMaterial.prototype.toJSON = function ( meta ) {
	
		var data = THREE.Material.prototype.toJSON.call( this, meta );
	
		data.uniforms = this.uniforms;
		data.attributes = this.attributes;
		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;
	
		return data;
	
	};
	
	// File:src/materials/RawShaderMaterial.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.RawShaderMaterial = function ( parameters ) {
	
		THREE.ShaderMaterial.call( this, parameters );
	
		this.type = 'RawShaderMaterial';
	
	};
	
	THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
	THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
	// File:src/materials/SpriteMaterial.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2(),
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.SpriteMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.type = 'SpriteMaterial';
	
		this.color = new THREE.Color( 0xffffff );
		this.map = null;
	
		this.rotation = 0;
	
		this.fog = false;
	
		// set parameters
	
		this.setValues( parameters );
	
	};
	
	THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;
	
	THREE.SpriteMaterial.prototype.copy = function ( source ) {
	
		THREE.Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
		this.map = source.map;
	
		this.rotation = source.rotation;
	
		this.fog = source.fog;
	
		return this;
	
	};
	
	// File:src/textures/Texture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */
	
	THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );
	
		this.uuid = THREE.Math.generateUUID();
	
		this.name = '';
		this.sourceFile = '';
	
		this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
		this.mipmaps = [];
	
		this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;
	
		this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
	
		this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;
	
		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
	
		this.format = format !== undefined ? format : THREE.RGBAFormat;
		this.type = type !== undefined ? type : THREE.UnsignedByteType;
	
		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );
	
		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
	
		this.version = 0;
		this.onUpdate = null;
	
	};
	
	THREE.Texture.DEFAULT_IMAGE = undefined;
	THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;
	
	THREE.Texture.prototype = {
	
		constructor: THREE.Texture,
	
		set needsUpdate ( value ) {
	
			if ( value === true ) this.version ++;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );
	
			this.mapping = source.mapping;
	
			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;
	
			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;
	
			this.anisotropy = source.anisotropy;
	
			this.format = source.format;
			this.type = source.type;
	
			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
	
			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
	
			return this;
	
		},
	
		toJSON: function ( meta ) {
	
			if ( meta.textures[ this.uuid ] !== undefined ) {
	
				return meta.textures[ this.uuid ];
	
			}
	
			function getDataURL( image ) {
	
				var canvas;
	
				if ( image.toDataURL !== undefined ) {
	
					canvas = image;
	
				} else {
	
					canvas = document.createElement( 'canvas' );
					canvas.width = image.width;
					canvas.height = image.height;
	
					canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );
	
				}
	
				if ( canvas.width > 2048 || canvas.height > 2048 ) {
	
					return canvas.toDataURL( 'image/jpeg', 0.6 );
	
				} else {
	
					return canvas.toDataURL( 'image/png' );
	
				}
	
			}
	
			var output = {
				metadata: {
					version: 4.4,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},
	
				uuid: this.uuid,
				name: this.name,
	
				mapping: this.mapping,
	
				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				wrap: [ this.wrapS, this.wrapT ],
	
				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy
			};
	
			if ( this.image !== undefined ) {
	
				// TODO: Move to THREE.Image
	
				var image = this.image;
	
				if ( image.uuid === undefined ) {
	
					image.uuid = THREE.Math.generateUUID(); // UGH
	
				}
	
				if ( meta.images[ image.uuid ] === undefined ) {
	
					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: getDataURL( image )
					};
	
				}
	
				output.image = image.uuid;
	
			}
	
			meta.textures[ this.uuid ] = output;
	
			return output;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		},
	
		transformUv: function ( uv ) {
	
			if ( this.mapping !== THREE.UVMapping )  return;
	
			uv.multiply( this.repeat );
			uv.add( this.offset );
	
			if ( uv.x < 0 || uv.x > 1 ) {
	
				switch ( this.wrapS ) {
	
					case THREE.RepeatWrapping:
	
						uv.x = uv.x - Math.floor( uv.x );
						break;
	
					case THREE.ClampToEdgeWrapping:
	
						uv.x = uv.x < 0 ? 0 : 1;
						break;
	
					case THREE.MirroredRepeatWrapping:
	
						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {
	
							uv.x = Math.ceil( uv.x ) - uv.x;
	
						} else {
	
							uv.x = uv.x - Math.floor( uv.x );
	
						}
						break;
	
				}
	
			}
	
			if ( uv.y < 0 || uv.y > 1 ) {
	
				switch ( this.wrapT ) {
	
					case THREE.RepeatWrapping:
	
						uv.y = uv.y - Math.floor( uv.y );
						break;
	
					case THREE.ClampToEdgeWrapping:
	
						uv.y = uv.y < 0 ? 0 : 1;
						break;
	
					case THREE.MirroredRepeatWrapping:
	
						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {
	
							uv.y = Math.ceil( uv.y ) - uv.y;
	
						} else {
	
							uv.y = uv.y - Math.floor( uv.y );
	
						}
						break;
	
				}
	
			}
	
			if ( this.flipY ) {
	
				uv.y = 1 - uv.y;
	
			}
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );
	
	THREE.TextureIdCount = 0;
	
	// File:src/textures/CanvasTexture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.needsUpdate = true;
	
	};
	
	THREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;
	
	// File:src/textures/CubeTexture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;
	
		THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.images = images;
		this.flipY = false;
	
	};
	
	THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;
	
	THREE.CubeTexture.prototype.copy = function ( source ) {
	
		THREE.Texture.prototype.copy.call( this, source );
		
		this.images = source.images;
		
		return this;
	
	};
	// File:src/textures/CompressedTexture.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {
	
		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;
	
		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )
	
		this.flipY = false;
	
		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files
	
		this.generateMipmaps = false;
	
	};
	
	THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;
	
	// File:src/textures/DataTexture.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {
	
		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.image = { data: data, width: width, height: height };
	
		this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;
		
		this.flipY = false;
		this.generateMipmaps  = false;
	
	};
	
	THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.DataTexture.prototype.constructor = THREE.DataTexture;
	
	// File:src/textures/VideoTexture.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.generateMipmaps = false;
	
		var scope = this;
	
		function update() {
	
			requestAnimationFrame( update );
	
			if ( video.readyState === video.HAVE_ENOUGH_DATA ) {
	
				scope.needsUpdate = true;
	
			}
	
		}
	
		update();
	
	};
	
	THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;
	
	// File:src/objects/Group.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Group = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'Group';
	
	};
	
	THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Group.prototype.constructor = THREE.Group;
	// File:src/objects/Points.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Points = function ( geometry, material ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Points';
	
		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );
	
	};
	
	THREE.Points.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Points.prototype.constructor = THREE.Points;
	
	THREE.Points.prototype.raycast = ( function () {
	
		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
	
		return function raycast( raycaster, intersects ) {
	
			var object = this;
			var geometry = object.geometry;
			var threshold = raycaster.params.Points.threshold;
	
			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
			if ( geometry.boundingBox !== null ) {
	
				if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {
	
					return;
	
				}
	
			}
	
			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var localThresholdSq = localThreshold * localThreshold;
			var position = new THREE.Vector3();
	
			function testPoint( point, index ) {
	
				var rayPointDistanceSq = ray.distanceSqToPoint( point );
	
				if ( rayPointDistanceSq < localThresholdSq ) {
	
					var intersectPoint = ray.closestPointToPoint( point );
					intersectPoint.applyMatrix4( object.matrixWorld );
	
					var distance = raycaster.ray.origin.distanceTo( intersectPoint );
	
					if ( distance < raycaster.near || distance > raycaster.far ) return;
	
					intersects.push( {
	
						distance: distance,
						distanceToRay: Math.sqrt( rayPointDistanceSq ),
						point: intersectPoint.clone(),
						index: index,
						face: null,
						object: object
	
					} );
	
				}
	
			}
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;
	
				if ( index !== null ) {
	
					var indices = index.array;
	
					for ( var i = 0, il = indices.length; i < il; i ++ ) {
	
						var a = indices[ i ];
	
						position.fromArray( positions, a * 3 );
	
						testPoint( position, a );
	
					}
	
				} else {
	
					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {
	
						position.fromArray( positions, i * 3 );
	
						testPoint( position, i );
	
					}
	
				}
	
			} else {
	
				var vertices = geometry.vertices;
	
				for ( var i = 0, l = vertices.length; i < l; i ++ ) {
	
					testPoint( vertices[ i ], i );
	
				}
	
			}
	
		};
	
	}() );
	
	THREE.Points.prototype.clone = function () {
	
		return new this.constructor( this.geometry, this.material ).copy( this );
	
	};
	
	// Backwards compatibility
	
	THREE.PointCloud = function ( geometry, material ) {
	
		console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
		return new THREE.Points( geometry, material );
	
	};
	
	THREE.ParticleSystem = function ( geometry, material ) {
	
		console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
		return new THREE.Points( geometry, material );
	
	};
	
	// File:src/objects/Line.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Line = function ( geometry, material, mode ) {
	
		if ( mode === 1 ) {
	
			console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
			return new THREE.LineSegments( geometry, material );
	
		}
	
		THREE.Object3D.call( this );
	
		this.type = 'Line';
	
		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );
	
	};
	
	THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Line.prototype.constructor = THREE.Line;
	
	THREE.Line.prototype.raycast = ( function () {
	
		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();
	
		return function raycast( raycaster, intersects ) {
	
			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;
	
			var geometry = this.geometry;
	
			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
			// Checking boundingSphere distance to ray
	
			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( this.matrixWorld );
	
			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {
	
				return;
	
			}
	
			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
			var vStart = new THREE.Vector3();
			var vEnd = new THREE.Vector3();
			var interSegment = new THREE.Vector3();
			var interRay = new THREE.Vector3();
			var step = this instanceof THREE.LineSegments ? 2 : 1;
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				var index = geometry.index;
				var attributes = geometry.attributes;
	
				if ( index !== null ) {
	
					var indices = index.array;
					var positions = attributes.position.array;
	
					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {
	
						var a = indices[ i ];
						var b = indices[ i + 1 ];
	
						vStart.fromArray( positions, a * 3 );
						vEnd.fromArray( positions, b * 3 );
	
						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
						if ( distSq > precisionSq ) continue;
	
						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
						var distance = raycaster.ray.origin.distanceTo( interRay );
	
						if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
						intersects.push( {
	
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this
	
						} );
	
					}
	
				} else {
	
					var positions = attributes.position.array;
	
					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {
	
						vStart.fromArray( positions, 3 * i );
						vEnd.fromArray( positions, 3 * i + 3 );
	
						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
						if ( distSq > precisionSq ) continue;
	
						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
						var distance = raycaster.ray.origin.distanceTo( interRay );
	
						if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
						intersects.push( {
	
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this
	
						} );
	
					}
	
				}
	
			} else if ( geometry instanceof THREE.Geometry ) {
	
				var vertices = geometry.vertices;
				var nbVertices = vertices.length;
	
				for ( var i = 0; i < nbVertices - 1; i += step ) {
	
					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );
	
					if ( distSq > precisionSq ) continue;
	
					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
					var distance = raycaster.ray.origin.distanceTo( interRay );
	
					if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
					intersects.push( {
	
						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this
	
					} );
	
				}
	
			}
	
		};
	
	}() );
	
	THREE.Line.prototype.clone = function () {
	
		return new this.constructor( this.geometry, this.material ).copy( this );
	
	};
	
	// DEPRECATED
	
	THREE.LineStrip = 0;
	THREE.LinePieces = 1;
	
	// File:src/objects/LineSegments.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LineSegments = function ( geometry, material ) {
	
		THREE.Line.call( this, geometry, material );
	
		this.type = 'LineSegments';
	
	};
	
	THREE.LineSegments.prototype = Object.create( THREE.Line.prototype );
	THREE.LineSegments.prototype.constructor = THREE.LineSegments;
	
	// File:src/objects/Mesh.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */
	
	THREE.Mesh = function ( geometry, material ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Mesh';
	
		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );
	
		this.updateMorphTargets();
	
	};
	
	THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Mesh.prototype.constructor = THREE.Mesh;
	
	THREE.Mesh.prototype.updateMorphTargets = function () {
	
		if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {
	
			this.morphTargetBase = - 1;
			this.morphTargetInfluences = [];
			this.morphTargetDictionary = {};
	
			for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {
	
				this.morphTargetInfluences.push( 0 );
				this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;
	
			}
	
		}
	
	};
	
	THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {
	
		if ( this.morphTargetDictionary[ name ] !== undefined ) {
	
			return this.morphTargetDictionary[ name ];
	
		}
	
		console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );
	
		return 0;
	
	};
	
	
	THREE.Mesh.prototype.raycast = ( function () {
	
		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();
	
		var vA = new THREE.Vector3();
		var vB = new THREE.Vector3();
		var vC = new THREE.Vector3();
	
		var tempA = new THREE.Vector3();
		var tempB = new THREE.Vector3();
		var tempC = new THREE.Vector3();
	
		var uvA = new THREE.Vector2();
		var uvB = new THREE.Vector2();
		var uvC = new THREE.Vector2();
	
		var barycoord = new THREE.Vector3();
	
		var intersectionPoint = new THREE.Vector3();
		var intersectionPointWorld = new THREE.Vector3();
	
		function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {
	
			THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );
	
			uv1.multiplyScalar( barycoord.x );
			uv2.multiplyScalar( barycoord.y );
			uv3.multiplyScalar( barycoord.z );
	
			uv1.add( uv2 ).add( uv3 );
	
			return uv1.clone();
	
		}
	
		function checkIntersection( object, raycaster, ray, pA, pB, pC, point ){
	
			var intersect;
			var material = object.material;
	
			if ( material.side === THREE.BackSide ) {
	
				intersect = ray.intersectTriangle( pC, pB, pA, true, point );
	
			} else {
	
				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );
	
			}
	
			if ( intersect === null ) return null;
	
			intersectionPointWorld.copy( point );
			intersectionPointWorld.applyMatrix4( object.matrixWorld );
	
			var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );
	
			if ( distance < raycaster.near || distance > raycaster.far ) return null;
	
			return {
				distance: distance,
				point: intersectionPointWorld.clone(),
				object: object
			};
	
		}
	
		function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {
	
			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );
	
			var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );
	
			if ( intersection ) {
	
				if ( uvs ) {
	
					uvA.fromArray( uvs, a * 2 );
					uvB.fromArray( uvs, b * 2 );
					uvC.fromArray( uvs, c * 2 );
	
					intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );
	
				}
	
				intersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );
				intersection.faceIndex = a;
	
			}
	
			return intersection;
	
		}
	
		return function raycast( raycaster, intersects ) {
	
			var geometry = this.geometry;
			var material = this.material;
	
			if ( material === undefined ) return;
	
			// Checking boundingSphere distance to ray
	
			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
			var matrixWorld = this.matrixWorld;
	
			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );
	
			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) return;
	
			// Check boundingBox before continuing
	
			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
			if ( geometry.boundingBox !== null ) {
	
				if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) return;
	
			}
	
			var uvs, intersection;
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				var a, b, c;
				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;
	
				if ( attributes.uv !== undefined ){
	
					uvs = attributes.uv.array;
	
				}
	
				if ( index !== null ) {
	
					var indices = index.array;
	
					for ( var i = 0, l = indices.length; i < l; i += 3 ) {
	
						a = indices[ i ];
						b = indices[ i + 1 ];
						c = indices[ i + 2 ];
	
						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );
	
						if ( intersection ) {
	
							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
							intersects.push( intersection );
	
						}
	
					}
	
				} else {
	
	
					for ( var i = 0, l = positions.length; i < l; i += 9 ) {
	
						a = i / 3;
						b = a + 1;
						c = a + 2;
	
						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );
	
						if ( intersection ) {
	
							intersection.index = a; // triangle number in positions buffer semantics
							intersects.push( intersection );
	
						}
	
					}
	
				}
	
			} else if ( geometry instanceof THREE.Geometry ) {
	
				var fvA, fvB, fvC;
				var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;
				var materials = isFaceMaterial === true ? material.materials : null;
	
				var vertices = geometry.vertices;
				var faces = geometry.faces;
				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
				if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;
	
				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {
	
					var face = faces[ f ];
					var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;
	
					if ( faceMaterial === undefined ) continue;
	
					fvA = vertices[ face.a ];
					fvB = vertices[ face.b ];
					fvC = vertices[ face.c ];
	
					if ( faceMaterial.morphTargets === true ) {
	
						var morphTargets = geometry.morphTargets;
						var morphInfluences = this.morphTargetInfluences;
	
						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );
	
						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {
	
							var influence = morphInfluences[ t ];
	
							if ( influence === 0 ) continue;
	
							var targets = morphTargets[ t ].vertices;
	
							vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
							vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
							vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );
	
						}
	
						vA.add( fvA );
						vB.add( fvB );
						vC.add( fvC );
	
						fvA = vA;
						fvB = vB;
						fvC = vC;
	
					}
	
					intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );
	
					if ( intersection ) {
	
						if ( uvs ) {
	
							var uvs_f = uvs[ f ];
							uvA.copy( uvs_f[ 0 ] );
							uvB.copy( uvs_f[ 1 ] );
							uvC.copy( uvs_f[ 2 ] );
	
							intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );
	
						}
	
						intersection.face = face;
						intersection.faceIndex = f;
						intersects.push( intersection );
	
					}
	
				}
	
			}
	
		};
	
	}() );
	
	THREE.Mesh.prototype.clone = function () {
	
		return new this.constructor( this.geometry, this.material ).copy( this );
	
	};
	
	// File:src/objects/Bone.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */
	
	THREE.Bone = function ( skin ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Bone';
	
		this.skin = skin;
	
	};
	
	THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Bone.prototype.constructor = THREE.Bone;
	
	THREE.Bone.prototype.copy = function ( source ) {
		
		THREE.Object3D.prototype.copy.call( this, source );
		
		this.skin = source.skin;
		
		return this;
	
	};
	
	// File:src/objects/Skeleton.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */
	
	THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {
	
		this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
	
		this.identityMatrix = new THREE.Matrix4();
	
		// copy the bone array
	
		bones = bones || [];
	
		this.bones = bones.slice( 0 );
	
		// create a bone texture or an array of floats
	
		if ( this.useVertexTexture ) {
	
			// layout (1 matrix = 4 pixels)
			//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
			//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
			//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
			//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
	
			
			var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
			size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );
			size = Math.max( size, 4 );
	
			this.boneTextureWidth = size;
			this.boneTextureHeight = size;
	
			this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
			this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
	
		} else {
	
			this.boneMatrices = new Float32Array( 16 * this.bones.length );
	
		}
	
		// use the supplied bone inverses or calculate the inverses
	
		if ( boneInverses === undefined ) {
	
			this.calculateInverses();
	
		} else {
	
			if ( this.bones.length === boneInverses.length ) {
	
				this.boneInverses = boneInverses.slice( 0 );
	
			} else {
	
				console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );
	
				this.boneInverses = [];
	
				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
					this.boneInverses.push( new THREE.Matrix4() );
	
				}
	
			}
	
		}
	
	};
	
	THREE.Skeleton.prototype.calculateInverses = function () {
	
		this.boneInverses = [];
	
		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
			var inverse = new THREE.Matrix4();
	
			if ( this.bones[ b ] ) {
	
				inverse.getInverse( this.bones[ b ].matrixWorld );
	
			}
	
			this.boneInverses.push( inverse );
	
		}
	
	};
	
	THREE.Skeleton.prototype.pose = function () {
	
		var bone;
	
		// recover the bind-time world matrices
	
		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
			bone = this.bones[ b ];
	
			if ( bone ) {
	
				bone.matrixWorld.getInverse( this.boneInverses[ b ] );
	
			}
	
		}
	
		// compute the local matrices, positions, rotations and scales
	
		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
			bone = this.bones[ b ];
	
			if ( bone ) {
	
				if ( bone.parent ) {
	
					bone.matrix.getInverse( bone.parent.matrixWorld );
					bone.matrix.multiply( bone.matrixWorld );
	
				} else {
	
					bone.matrix.copy( bone.matrixWorld );
	
				}
	
				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );
	
			}
	
		}
	
	};
	
	THREE.Skeleton.prototype.update = ( function () {
	
		var offsetMatrix = new THREE.Matrix4();
	
		return function update() {
	
			// flatten bone matrices to array
	
			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
				// compute the offset between the current and the original transform
	
				var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;
	
				offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
				offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );
	
			}
	
			if ( this.useVertexTexture ) {
	
				this.boneTexture.needsUpdate = true;
	
			}
	
		};
	
	} )();
	
	THREE.Skeleton.prototype.clone = function () {
	
		return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );
	
	};
	
	// File:src/objects/SkinnedMesh.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */
	
	THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {
	
		THREE.Mesh.call( this, geometry, material );
	
		this.type = 'SkinnedMesh';
	
		this.bindMode = "attached";
		this.bindMatrix = new THREE.Matrix4();
		this.bindMatrixInverse = new THREE.Matrix4();
	
		// init bones
	
		// TODO: remove bone creation as there is no reason (other than
		// convenience) for THREE.SkinnedMesh to do this.
	
		var bones = [];
	
		if ( this.geometry && this.geometry.bones !== undefined ) {
	
			var bone, gbone;
	
			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {
	
				gbone = this.geometry.bones[ b ];
	
				bone = new THREE.Bone( this );
				bones.push( bone );
	
				bone.name = gbone.name;
				bone.position.fromArray( gbone.pos );
				bone.quaternion.fromArray( gbone.rotq );
				if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );
	
			}
	
			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {
	
				gbone = this.geometry.bones[ b ];
	
				if ( gbone.parent !== - 1 && gbone.parent !== null) {
	
					bones[ gbone.parent ].add( bones[ b ] );
	
				} else {
	
					this.add( bones[ b ] );
	
				}
	
			}
	
		}
	
		this.normalizeSkinWeights();
	
		this.updateMatrixWorld( true );
		this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );
	
	};
	
	
	THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;
	
	THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {
	
		this.skeleton = skeleton;
	
		if ( bindMatrix === undefined ) {
	
			this.updateMatrixWorld( true );
			
			this.skeleton.calculateInverses();
	
			bindMatrix = this.matrixWorld;
	
		}
	
		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.getInverse( bindMatrix );
	
	};
	
	THREE.SkinnedMesh.prototype.pose = function () {
	
		this.skeleton.pose();
	
	};
	
	THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
	
		if ( this.geometry instanceof THREE.Geometry ) {
	
			for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {
	
				var sw = this.geometry.skinWeights[ i ];
	
				var scale = 1.0 / sw.lengthManhattan();
	
				if ( scale !== Infinity ) {
	
					sw.multiplyScalar( scale );
	
				} else {
	
					sw.set( 1 ); // this will be normalized by the shader anyway
	
				}
	
			}
	
		} else {
	
			// skinning weights assumed to be normalized for THREE.BufferGeometry
	
		}
	
	};
	
	THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {
	
		THREE.Mesh.prototype.updateMatrixWorld.call( this, true );
	
		if ( this.bindMode === "attached" ) {
	
			this.bindMatrixInverse.getInverse( this.matrixWorld );
	
		} else if ( this.bindMode === "detached" ) {
	
			this.bindMatrixInverse.getInverse( this.bindMatrix );
	
		} else {
	
			console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );
	
		}
	
	};
	
	THREE.SkinnedMesh.prototype.clone = function() {
	
		return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );
	
	};
	
	// File:src/objects/LOD.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LOD = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'LOD';
	
		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			},
			objects: {
				get: function () {
	
					console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
					return this.levels;
	
				}
			}
		} );
	
	};
	
	
	THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
	THREE.LOD.prototype.constructor = THREE.LOD;
	
	THREE.LOD.prototype.addLevel = function ( object, distance ) {
	
		if ( distance === undefined ) distance = 0;
	
		distance = Math.abs( distance );
	
		var levels = this.levels;
	
		for ( var l = 0; l < levels.length; l ++ ) {
	
			if ( distance < levels[ l ].distance ) {
	
				break;
	
			}
	
		}
	
		levels.splice( l, 0, { distance: distance, object: object } );
	
		this.add( object );
	
	};
	
	THREE.LOD.prototype.getObjectForDistance = function ( distance ) {
	
		var levels = this.levels;
	
		for ( var i = 1, l = levels.length; i < l; i ++ ) {
	
			if ( distance < levels[ i ].distance ) {
	
				break;
	
			}
	
		}
	
		return levels[ i - 1 ].object;
	
	};
	
	THREE.LOD.prototype.raycast = ( function () {
	
		var matrixPosition = new THREE.Vector3();
	
		return function raycast( raycaster, intersects ) {
	
			matrixPosition.setFromMatrixPosition( this.matrixWorld );
	
			var distance = raycaster.ray.origin.distanceTo( matrixPosition );
	
			this.getObjectForDistance( distance ).raycast( raycaster, intersects );
	
		};
	
	}() );
	
	THREE.LOD.prototype.update = function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
	
		return function update( camera ) {
	
			var levels = this.levels;
	
			if ( levels.length > 1 ) {
	
				v1.setFromMatrixPosition( camera.matrixWorld );
				v2.setFromMatrixPosition( this.matrixWorld );
	
				var distance = v1.distanceTo( v2 );
	
				levels[ 0 ].object.visible = true;
	
				for ( var i = 1, l = levels.length; i < l; i ++ ) {
	
					if ( distance >= levels[ i ].distance ) {
	
						levels[ i - 1 ].object.visible = false;
						levels[ i ].object.visible = true;
	
					} else {
	
						break;
	
					}
	
				}
	
				for ( ; i < l; i ++ ) {
	
					levels[ i ].object.visible = false;
	
				}
	
			}
	
		};
	
	}();
	
	THREE.LOD.prototype.copy = function ( source ) {
	
		THREE.Object3D.prototype.copy.call( this, source, false );
	
		var levels = source.levels;
	
		for ( var i = 0, l = levels.length; i < l; i ++ ) {
	
			var level = levels[ i ];
	
			this.addLevel( level.object.clone(), level.distance );
	
		}
	
		return this;
	
	};
	
	THREE.LOD.prototype.toJSON = function ( meta ) {
	
		var data = THREE.Object3D.prototype.toJSON.call( this, meta );
	
		data.object.levels = [];
	
		var levels = this.levels;
	
		for ( var i = 0, l = levels.length; i < l; i ++ ) {
	
			var level = levels[ i ];
	
			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );
	
		}
	
		return data;
	
	};
	
	// File:src/objects/Sprite.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Sprite = ( function () {
	
		var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
		var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
		var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );
	
		var geometry = new THREE.BufferGeometry();
		geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
	
		return function Sprite( material ) {
	
			THREE.Object3D.call( this );
	
			this.type = 'Sprite';
	
			this.geometry = geometry;
			this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();
	
		};
	
	} )();
	
	THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Sprite.prototype.constructor = THREE.Sprite;
	
	THREE.Sprite.prototype.raycast = ( function () {
	
		var matrixPosition = new THREE.Vector3();
	
		return function raycast( raycaster, intersects ) {
	
			matrixPosition.setFromMatrixPosition( this.matrixWorld );
	
			var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
			var guessSizeSq = this.scale.x * this.scale.y;
	
			if ( distanceSq > guessSizeSq ) {
	
				return;
	
			}
	
			intersects.push( {
	
				distance: Math.sqrt( distanceSq ),
				point: this.position,
				face: null,
				object: this
	
			} );
	
		};
	
	}() );
	
	THREE.Sprite.prototype.clone = function () {
	
		return new this.constructor( this.material ).copy( this );
	
	};
	
	// Backwards compatibility
	
	THREE.Particle = THREE.Sprite;
	
	// File:src/objects/LensFlare.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.LensFlare = function ( texture, size, distance, blending, color ) {
	
		THREE.Object3D.call( this );
	
		this.lensFlares = [];
	
		this.positionScreen = new THREE.Vector3();
		this.customUpdateCallback = undefined;
	
		if ( texture !== undefined ) {
	
			this.add( texture, size, distance, blending, color );
	
		}
	
	};
	
	THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
	THREE.LensFlare.prototype.constructor = THREE.LensFlare;
	
	
	/*
	 * Add: adds another flare
	 */
	
	THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {
	
		if ( size === undefined ) size = - 1;
		if ( distance === undefined ) distance = 0;
		if ( opacity === undefined ) opacity = 1;
		if ( color === undefined ) color = new THREE.Color( 0xffffff );
		if ( blending === undefined ) blending = THREE.NormalBlending;
	
		distance = Math.min( distance, Math.max( 0, distance ) );
	
		this.lensFlares.push( {
			texture: texture,	// THREE.Texture
			size: size, 		// size in pixels (-1 = use texture.width)
			distance: distance, 	// distance (0-1) from light source (0=at light source)
			x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
			scale: 1, 		// scale
			rotation: 0, 		// rotation
			opacity: opacity,	// opacity
			color: color,		// color
			blending: blending	// blending
		} );
	
	};
	
	/*
	 * Update lens flares update positions on all flares based on the screen position
	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
	 */
	
	THREE.LensFlare.prototype.updateLensFlares = function () {
	
		var f, fl = this.lensFlares.length;
		var flare;
		var vecX = - this.positionScreen.x * 2;
		var vecY = - this.positionScreen.y * 2;
	
		for ( f = 0; f < fl; f ++ ) {
	
			flare = this.lensFlares[ f ];
	
			flare.x = this.positionScreen.x + vecX * flare.distance;
			flare.y = this.positionScreen.y + vecY * flare.distance;
	
			flare.wantedRotation = flare.x * Math.PI * 0.25;
			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;
	
		}
	
	};
	
	THREE.LensFlare.prototype.copy = function ( source ) {
	
		THREE.Object3D.prototype.copy.call( this, source );
	
		this.positionScreen.copy( source.positionScreen );
		this.customUpdateCallback = source.customUpdateCallback;
	
		for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {
	
			this.lensFlares.push( source.lensFlares[ i ] );
	
		}
	
		return this;
	
	};
	
	// File:src/scenes/Scene.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Scene = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'Scene';
	
		this.fog = null;
		this.overrideMaterial = null;
	
		this.autoUpdate = true; // checked by the renderer
	
	};
	
	THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Scene.prototype.constructor = THREE.Scene;
	
	THREE.Scene.prototype.copy = function ( source ) {
	
		THREE.Object3D.prototype.copy.call( this, source );
	
		if ( source.fog !== null ) this.fog = source.fog.clone();
		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();
	
		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;
	
		return this;
	
	};
	
	// File:src/scenes/Fog.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Fog = function ( color, near, far ) {
	
		this.name = '';
	
		this.color = new THREE.Color( color );
	
		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;
	
	};
	
	THREE.Fog.prototype.clone = function () {
	
		return new THREE.Fog( this.color.getHex(), this.near, this.far );
	
	};
	
	// File:src/scenes/FogExp2.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.FogExp2 = function ( color, density ) {
	
		this.name = '';
	
		this.color = new THREE.Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;
	
	};
	
	THREE.FogExp2.prototype.clone = function () {
	
		return new THREE.FogExp2( this.color.getHex(), this.density );
	
	};
	
	// File:src/renderers/shaders/ShaderChunk.js
	
	THREE.ShaderChunk = {};
	
	// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl
	
	THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl
	
	THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl
	
	THREE.ShaderChunk[ 'aomap_fragment'] = "#ifdef USE_AOMAP\n\n	totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'aomap_pars_fragment'] = "#ifdef USE_AOMAP\n\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl
	
	THREE.ShaderChunk[ 'begin_vertex'] = "\nvec3 transformed = vec3( position );\n";
	
	// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'beginnormal_vertex'] = "\nvec3 objectNormal = vec3( normal );\n";
	
	// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl
	
	THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl
	
	THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n	vColor.xyz = color.xyz;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/common.glsl
	
	THREE.ShaderChunk[ 'common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	float distance = dot( planeNormal, point - pointOnPlane );\n\n	return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n	if ( decayExponent > 0.0 ) {\n\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n	}\n\n	return 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n\n	float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );\n\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n\n	return 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n\n	return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n	vec3 halfDir = normalize( lightDir + viewDir );\n\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( lightDir, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n	float D = D_BlinnPhong( shininess, dotNH );\n\n	return F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n	#ifdef GAMMA_INPUT\n\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n	#ifdef GAMMA_OUTPUT\n\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n";
	
	// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'defaultnormal_vertex'] = "#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
	
	// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl
	
	THREE.ShaderChunk[ 'displacementmap_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'displacementmap_pars_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl
	
	THREE.ShaderChunk[ 'emissivemap_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\n	totalEmissiveLight *= emissiveColor.rgb;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'emissivemap_pars_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	uniform sampler2D emissiveMap;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl
	
	THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl
	
	THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl
	
	THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/hemilight_fragment.glsl
	
	THREE.ShaderChunk[ 'hemilight_fragment'] = "#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalAmbientLight += lightColor;\n\n	}\n\n#endif\n\n";
	
	// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl
	
	THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl
	
	THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lVector = pointLightPosition[ i ] - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float dotProduct = dot( normal, lightDir );\n\n			vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl
	
	THREE.ShaderChunk[ 'lights_phong_fragment'] = "vec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lightPosition = pointLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float cosineTerm = saturate( dot( normal, lightDir ) );\n\n			totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n			vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n			totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n	}\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl
	
	THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl
	
	THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl
	
	THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl
	
	THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'map_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl
	
	THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl
	
	THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/normal_phong_fragment.glsl
	
	THREE.ShaderChunk[ 'normal_phong_fragment'] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n";
	
	// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl
	
	THREE.ShaderChunk[ 'project_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl
	
	THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		float texelSizeY =  1.0 / shadowMapSize[ i ].y;\n\n		float shadow = 0.0;\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		bool isPointLight = shadowDarkness[ i ] < 0.0;\n\n		if ( isPointLight ) {\n\n			float realShadowDarkness = abs( shadowDarkness[ i ] );\n\n			vec3 lightToPosition = vShadowCoord[ i ].xyz;\n\n	#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n			const float Dr = 1.25;\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			const float Dr = 2.25;\n	#endif\n\n			float os = Dr *  2.0 * texelSizeY;\n\n			const vec3 Gsd = vec3( - 1, 0, 1 );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness * ( 1.0 / 21.0 );\n\n	#else \n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness;\n\n	#endif\n\n		} else {\n\n#endif \n			float texelSizeX =  1.0 / shadowMapSize[ i ].x;\n\n			vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n\n			bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n			bool inFrustum = all( inFrustumVec );\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n			bool frustumTest = all( frustumTestVec );\n\n			if ( frustumTest ) {\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n\n\n				/*\n					for ( float y = -1.25; y <= 1.25; y += 1.25 )\n						for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n							vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n							float fDepth = unpackDepth( rgbaDepth );\n							if ( fDepth < shadowCoord.z )\n								shadow += 1.0;\n					}\n					shadow /= 9.0;\n				*/\n\n				shadowCoord.z += shadowBias[ i ];\n\n				const float ShadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.25 * xPixelOffset;\n				float dy0 = - 1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				float fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				shadow *= shadowDarkness[ i ];\n\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\n				shadowCoord.z += shadowBias[ i ];\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.0 * xPixelOffset;\n				float dy0 = - 1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[ 0 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[ 0 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[ 0 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[ 1 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[ 1 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[ 1 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[ 2 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[ 2 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[ 2 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[ 0 ] = vec3( lessThan( depthKernel[ 0 ], shadowZ ) );\n				shadowKernel[ 0 ] *= vec3( 0.25 );\n\n				shadowKernel[ 1 ] = vec3( lessThan( depthKernel[ 1 ], shadowZ ) );\n				shadowKernel[ 1 ] *= vec3( 0.25 );\n\n				shadowKernel[ 2 ] = vec3( lessThan( depthKernel[ 2 ], shadowZ ) );\n				shadowKernel[ 2 ] *= vec3( 0.25 );\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[ i ].xy );\n\n				shadowKernel[ 0 ] = mix( shadowKernel[ 1 ], shadowKernel[ 0 ], fractionalCoord.x );\n				shadowKernel[ 1 ] = mix( shadowKernel[ 2 ], shadowKernel[ 1 ], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[ 0 ][ 1 ], shadowKernel[ 0 ][ 0 ], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[ 0 ][ 2 ], shadowKernel[ 0 ][ 1 ], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[ 1 ][ 1 ], shadowKernel[ 1 ][ 0 ], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[ 1 ][ 2 ], shadowKernel[ 1 ][ 1 ], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) ) * shadowDarkness[ i ];\n\n	#else \n				shadowCoord.z += shadowBias[ i ];\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n					shadow = shadowDarkness[ i ];\n\n	#endif\n\n			}\n\n#ifdef SHADOWMAP_DEBUG\n\n			if ( inFrustum ) {\n\n				if ( i == 0 ) {\n\n					outgoingLight *= vec3( 1.0, 0.5, 0.0 );\n\n				} else if ( i == 1 ) {\n\n					outgoingLight *= vec3( 0.0, 1.0, 0.8 );\n\n				} else {\n\n					outgoingLight *= vec3( 0.0, 0.5, 1.0 );\n\n				}\n\n			}\n\n#endif\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		}\n\n#endif\n\n		shadowMask = shadowMask * vec3( 1.0 - shadow );\n\n	}\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n	#if defined(POINT_LIGHT_SHADOWS)\n\n\n		void adjustShadowValue1K( const float testDepth, const vec4 textureData, const float bias, inout float shadowValue ) {\n\n			const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n			if ( testDepth >= dot( textureData, bitSh ) * 1000.0 + bias )\n				shadowValue += 1.0;\n\n		}\n\n\n		vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\n			vec3 absV = abs( v );\n\n\n			float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n			absV *= scaleToCube;\n\n\n			v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\n\n			vec2 planar = v.xy;\n\n			float almostATexel = 1.5 * texelSizeY;\n			float almostOne = 1.0 - almostATexel;\n\n			if ( absV.z >= almostOne ) {\n\n				if ( v.z > 0.0 )\n					planar.x = 4.0 - v.x;\n\n			} else if ( absV.x >= almostOne ) {\n\n				float signX = sign( v.x );\n				planar.x = v.z * signX + 2.0 * signX;\n\n			} else if ( absV.y >= almostOne ) {\n\n				float signY = sign( v.y );\n				planar.x = v.x + 2.0 * signY + 2.0;\n				planar.y = v.z * signY - 2.0;\n\n			}\n\n\n			return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n		}\n\n	#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl
	
	THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl
	
	THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl
	
	THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl
	
	THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl
	
	THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'uv2_pars_fragment'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	varying vec2 vUv2;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'uv2_pars_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl
	
	THREE.ShaderChunk[ 'uv2_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	vUv2 = uv2;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl
	
	THREE.ShaderChunk[ 'uv_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl
	
	THREE.ShaderChunk[ 'uv_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";
	
	// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl
	
	THREE.ShaderChunk[ 'uv_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";
	
	// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl
	
	THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n	#endif\n\n#endif\n";
	
	// File:src/renderers/shaders/UniformsUtils.js
	
	/**
	 * Uniform Utilities
	 */
	
	THREE.UniformsUtils = {
	
		merge: function ( uniforms ) {
	
			var merged = {};
	
			for ( var u = 0; u < uniforms.length; u ++ ) {
	
				var tmp = this.clone( uniforms[ u ] );
	
				for ( var p in tmp ) {
	
					merged[ p ] = tmp[ p ];
	
				}
	
			}
	
			return merged;
	
		},
	
		clone: function ( uniforms_src ) {
	
			var uniforms_dst = {};
	
			for ( var u in uniforms_src ) {
	
				uniforms_dst[ u ] = {};
	
				for ( var p in uniforms_src[ u ] ) {
	
					var parameter_src = uniforms_src[ u ][ p ];
	
					if ( parameter_src instanceof THREE.Color ||
						 parameter_src instanceof THREE.Vector2 ||
						 parameter_src instanceof THREE.Vector3 ||
						 parameter_src instanceof THREE.Vector4 ||
						 parameter_src instanceof THREE.Matrix3 ||
						 parameter_src instanceof THREE.Matrix4 ||
						 parameter_src instanceof THREE.Texture ) {
	
						uniforms_dst[ u ][ p ] = parameter_src.clone();
	
					} else if ( Array.isArray( parameter_src ) ) {
	
						uniforms_dst[ u ][ p ] = parameter_src.slice();
	
					} else {
	
						uniforms_dst[ u ][ p ] = parameter_src;
	
					}
	
				}
	
			}
	
			return uniforms_dst;
	
		}
	
	};
	
	// File:src/renderers/shaders/UniformsLib.js
	
	/**
	 * Uniforms library for shared webgl shaders
	 */
	
	THREE.UniformsLib = {
	
		common: {
	
			"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },
	
			"map" : { type: "t", value: null },
			"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },
	
			"specularMap" : { type: "t", value: null },
			"alphaMap" : { type: "t", value: null },
	
			"envMap" : { type: "t", value: null },
			"flipEnvMap" : { type: "f", value: - 1 },
			"reflectivity" : { type: "f", value: 1.0 },
			"refractionRatio" : { type: "f", value: 0.98 }
	
		},
	
		aomap: {
	
			"aoMap" : { type: "t", value: null },
			"aoMapIntensity" : { type: "f", value: 1 },
	
		},
	
		lightmap: {
	
			"lightMap" : { type: "t", value: null },
			"lightMapIntensity" : { type: "f", value: 1 },
	
		},
	
		emissivemap: {
	
			"emissiveMap" : { type: "t", value: null },
	
		},
	
		bumpmap: {
	
			"bumpMap" : { type: "t", value: null },
			"bumpScale" : { type: "f", value: 1 }
	
		},
	
		normalmap: {
	
			"normalMap" : { type: "t", value: null },
			"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
	
		},
	
		displacementmap: {
	
			"displacementMap" : { type: "t", value: null },
			"displacementScale" : { type: "f", value: 1 },
			"displacementBias" : { type: "f", value: 0 }
	
		},
	
		fog : {
	
			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }
	
		},
	
		lights: {
	
			"ambientLightColor" : { type: "fv", value: [] },
	
			"directionalLightDirection" : { type: "fv", value: [] },
			"directionalLightColor" : { type: "fv", value: [] },
	
			"hemisphereLightDirection" : { type: "fv", value: [] },
			"hemisphereLightSkyColor" : { type: "fv", value: [] },
			"hemisphereLightGroundColor" : { type: "fv", value: [] },
	
			"pointLightColor" : { type: "fv", value: [] },
			"pointLightPosition" : { type: "fv", value: [] },
			"pointLightDistance" : { type: "fv1", value: [] },
			"pointLightDecay" : { type: "fv1", value: [] },
	
			"spotLightColor" : { type: "fv", value: [] },
			"spotLightPosition" : { type: "fv", value: [] },
			"spotLightDirection" : { type: "fv", value: [] },
			"spotLightDistance" : { type: "fv1", value: [] },
			"spotLightAngleCos" : { type: "fv1", value: [] },
			"spotLightExponent" : { type: "fv1", value: [] },
			"spotLightDecay" : { type: "fv1", value: [] }
	
		},
	
		points: {
	
			"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },
			"size" : { type: "f", value: 1.0 },
			"scale" : { type: "f", value: 1.0 },
			"map" : { type: "t", value: null },
			"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },
	
			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }
	
		},
	
		shadowmap: {
	
			"shadowMap": { type: "tv", value: [] },
			"shadowMapSize": { type: "v2v", value: [] },
	
			"shadowBias" : { type: "fv1", value: [] },
			"shadowDarkness": { type: "fv1", value: [] },
	
			"shadowMatrix" : { type: "m4v", value: [] }
	
		}
	
	};
	
	// File:src/renderers/shaders/ShaderLib.js
	
	/**
	 * Webgl Shader Library for three.js
	 *
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */
	
	
	THREE.ShaderLib = {
	
		'basic': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "aomap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "shadowmap" ]
	
			] ),
	
			vertexShader: [
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
	
				"	#ifdef USE_ENVMAP",
	
					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
				"	#endif",
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform float opacity;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "aomap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
				"	vec3 totalAmbientLight = vec3( 1.0 );", // hardwired
				"	vec3 shadowMask = vec3( 1.0 );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "aomap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],
	
				"	outgoingLight = diffuseColor.rgb * totalAmbientLight * shadowMask;",
	
					THREE.ShaderChunk[ "envmap_fragment" ],
	
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'lambert': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],
	
				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) }
				}
	
			] ),
	
			vertexShader: [
	
				"#define LAMBERT",
	
				"varying vec3 vLightFront;",
	
				"#ifdef DOUBLE_SIDED",
	
				"	varying vec3 vLightBack;",
	
				"#endif",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
	
					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_lambert_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform float opacity;",
	
				"uniform vec3 ambientLightColor;",
	
				"varying vec3 vLightFront;",
	
				"#ifdef DOUBLE_SIDED",
	
				"	varying vec3 vLightBack;",
	
				"#endif",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
				"	vec3 totalAmbientLight = ambientLightColor;",
				"	vec3 shadowMask = vec3( 1.0 );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],
	
				"	#ifdef DOUBLE_SIDED",
	
				"		if ( gl_FrontFacing )",
				"			outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;",
				"		else",
				"			outgoingLight += diffuseColor.rgb * ( vLightBack * shadowMask + totalAmbientLight ) + emissive;",
	
				"	#else",
	
				"		outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;",
	
				"	#endif",
	
					THREE.ShaderChunk[ "envmap_fragment" ],
	
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'phong': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "aomap" ],
				THREE.UniformsLib[ "lightmap" ],
				THREE.UniformsLib[ "emissivemap" ],
				THREE.UniformsLib[ "bumpmap" ],
				THREE.UniformsLib[ "normalmap" ],
				THREE.UniformsLib[ "displacementmap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],
	
				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
					"shininess": { type: "f", value: 30 }
				}
	
			] ),
	
			vertexShader: [
	
				"#define PHONG",
	
				"varying vec3 vViewPosition;",
	
				"#ifndef FLAT_SHADED",
	
				"	varying vec3 vNormal;",
	
				"#endif",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "displacementmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
	
					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
				"#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED
	
				"	vNormal = normalize( transformedNormal );",
	
				"#endif",
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "displacementmap_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"	vViewPosition = - mvPosition.xyz;",
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_phong_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"#define PHONG",
	
				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform vec3 specular;",
				"uniform float shininess;",
				"uniform float opacity;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "aomap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
				THREE.ShaderChunk[ "normalmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
				"	vec3 totalAmbientLight = ambientLightColor;",
				"	vec3 totalEmissiveLight = emissive;",
				"	vec3 shadowMask = vec3( 1.0 );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "normal_phong_fragment" ],
					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "hemilight_fragment" ],
					THREE.ShaderChunk[ "aomap_fragment" ],
					THREE.ShaderChunk[ "emissivemap_fragment" ],
	
					THREE.ShaderChunk[ "lights_phong_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],
	
					"totalDiffuseLight *= shadowMask;",
					"totalSpecularLight *= shadowMask;",
	
					"#ifdef METAL",
	
					"	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;",
	
					"#else",
	
					"	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;",
	
					"#endif",
	
					THREE.ShaderChunk[ "envmap_fragment" ],
	
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'points': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "points" ],
				THREE.UniformsLib[ "shadowmap" ]
	
			] ),
	
			vertexShader: [
	
				"uniform float size;",
				"uniform float scale;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "color_vertex" ],
	
				"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
	
				"	#ifdef USE_SIZEATTENUATION",
				"		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
				"	#else",
				"		gl_PointSize = size;",
				"	#endif",
	
				"	gl_Position = projectionMatrix * mvPosition;",
	
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform vec3 psColor;",
				"uniform float opacity;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_particle_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( psColor, opacity );",
				"	vec3 shadowMask = vec3( 1.0 );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_particle_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],
	
				"	outgoingLight = diffuseColor.rgb * shadowMask;",
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'dashed': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
	
				{
					"scale"    : { type: "f", value: 1 },
					"dashSize" : { type: "f", value: 1 },
					"totalSize": { type: "f", value: 2 }
				}
	
			] ),
	
			vertexShader: [
	
				"uniform float scale;",
				"attribute float lineDistance;",
	
				"varying float vLineDistance;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "color_vertex" ],
	
				"	vLineDistance = scale * lineDistance;",
	
				"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"	gl_Position = projectionMatrix * mvPosition;",
	
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform float opacity;",
	
				"uniform float dashSize;",
				"uniform float totalSize;",
	
				"varying float vLineDistance;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	if ( mod( vLineDistance, totalSize ) > dashSize ) {",
	
				"		discard;",
	
				"	}",
	
				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
	
				"	outgoingLight = diffuseColor.rgb;", // simple shader
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'depth': {
	
			uniforms: {
	
				"mNear": { type: "f", value: 1.0 },
				"mFar" : { type: "f", value: 2000.0 },
				"opacity" : { type: "f", value: 1.0 }
	
			},
	
			vertexShader: [
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform float mNear;",
				"uniform float mFar;",
				"uniform float opacity;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"	#ifdef USE_LOGDEPTHBUF_EXT",
	
				"		float depth = gl_FragDepthEXT / gl_FragCoord.w;",
	
				"	#else",
	
				"		float depth = gl_FragCoord.z / gl_FragCoord.w;",
	
				"	#endif",
	
				"	float color = 1.0 - smoothstep( mNear, mFar, depth );",
				"	gl_FragColor = vec4( vec3( color ), opacity );",
	
				"}"
	
			].join( "\n" )
	
		},
	
		'normal': {
	
			uniforms: {
	
				"opacity" : { type: "f", value: 1.0 }
	
			},
	
			vertexShader: [
	
				"varying vec3 vNormal;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
				"	vNormal = normalize( normalMatrix * normal );",
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform float opacity;",
				"varying vec3 vNormal;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"}"
	
			].join( "\n" )
	
		},
	
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
	
		'cube': {
	
			uniforms: { "tCube": { type: "t", value: null },
						"tFlip": { type: "f", value: - 1 } },
	
			vertexShader: [
	
				"varying vec3 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
				"	vWorldPosition = transformDirection( position, modelMatrix );",
	
				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform samplerCube tCube;",
				"uniform float tFlip;",
	
				"varying vec3 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
				"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"}"
	
			].join( "\n" )
	
		},
	
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
	
		'equirect': {
	
			uniforms: { "tEquirect": { type: "t", value: null },
						"tFlip": { type: "f", value: - 1 } },
	
			vertexShader: [
	
				"varying vec3 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
				"	vWorldPosition = transformDirection( position, modelMatrix );",
	
				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform sampler2D tEquirect;",
				"uniform float tFlip;",
	
				"varying vec3 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"void main() {",
	
					// "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
					"vec3 direction = normalize( vWorldPosition );",
					"vec2 sampleUV;",
					"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
					"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
					"gl_FragColor = texture2D( tEquirect, sampleUV );",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"}"
	
			].join( "\n" )
	
		},
	
		/* Depth encoding into RGBA texture
		 *
		 * based on SpiderGL shadow map example
		 * http://spidergl.org/example.php?id=6
		 *
		 * originally from
		 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
		 *
		 * see also
		 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
		 */
	
		'depthRGBA': {
	
			uniforms: {},
	
			vertexShader: [
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "skinbase_vertex" ],
	
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
	
				"vec4 pack_depth( const in float depth ) {",
	
				"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
				"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
				"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
				"	res -= res.xxyz * bit_mask;",
				"	return res;",
	
				"}",
	
				"void main() {",
	
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
	
				"	#ifdef USE_LOGDEPTHBUF_EXT",
	
				"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",
	
				"	#else",
	
				"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",
	
				"	#endif",
	
					//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
					//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
					//"gl_FragData[ 0 ] = pack_depth( z );",
					//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",
	
				"}"
	
			].join( "\n" )
	
		},
	
	
		'distanceRGBA': {
	
			uniforms: {
	
				"lightPos": { type: "v3", value: new THREE.Vector3( 0, 0, 0 ) }
	
			},
	
			vertexShader: [
	
				"varying vec4 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "worldpos_vertex" ],
	
					"vWorldPosition = worldPosition;",
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform vec3 lightPos;",
				"varying vec4 vWorldPosition;",
	
				THREE.ShaderChunk[ "common" ],
	
				"vec4 pack1K ( float depth ) {",
	
				"   depth /= 1000.0;",
				"   const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
	  			"	const vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
	   			"	vec4 res = fract( depth * bitSh );",
	   			"	res -= res.xxyz * bitMsk;",
	   			"	return res; ",
	
				"}",
	
				"float unpack1K ( vec4 color ) {",
	
				"	const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
				"	return dot( color, bitSh ) * 1000.0;",
	
				"}",
	
				"void main () {",
	
				"	gl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );",
	
				"}"
	
			].join( "\n" )
	
		}
	
	};
	
	// File:src/renderers/WebGLRenderer.js
	
	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */
	
	THREE.WebGLRenderer = function ( parameters ) {
	
		console.log( 'THREE.WebGLRenderer', THREE.REVISION );
	
		parameters = parameters || {};
	
		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
		_context = parameters.context !== undefined ? parameters.context : null,
	
		_width = _canvas.width,
		_height = _canvas.height,
	
		pixelRatio = 1,
	
		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
	
		_clearColor = new THREE.Color( 0x000000 ),
		_clearAlpha = 0;
	
		var lights = [];
	
		var opaqueObjects = [];
		var opaqueObjectsLastIndex = - 1;
		var transparentObjects = [];
		var transparentObjectsLastIndex = - 1;
	
		var morphInfluences = new Float32Array( 8 );
	
	
		var sprites = [];
		var lensFlares = [];
	
		// public properties
	
		this.domElement = _canvas;
		this.context = null;
	
		// clearing
	
		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;
	
		// scene graph
	
		this.sortObjects = true;
	
		// physically based shading
	
		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;
	
		// morphs
	
		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;
	
		// flags
	
		this.autoScaleCubemaps = true;
	
		// internal properties
	
		var _this = this,
	
		// internal state cache
	
		_currentProgram = null,
		_currentFramebuffer = null,
		_currentMaterialId = - 1,
		_currentGeometryProgram = '',
		_currentCamera = null,
	
		_usedTextureUnits = 0,
	
		_viewportX = 0,
		_viewportY = 0,
		_viewportWidth = _canvas.width,
		_viewportHeight = _canvas.height,
		_currentWidth = 0,
		_currentHeight = 0,
	
		// frustum
	
		_frustum = new THREE.Frustum(),
	
		 // camera matrices cache
	
		_projScreenMatrix = new THREE.Matrix4(),
	
		_vector3 = new THREE.Vector3(),
	
		// light arrays cache
	
		_direction = new THREE.Vector3(),
	
		_lightsNeedUpdate = true,
	
		_lights = {
	
			ambient: [ 0, 0, 0 ],
			directional: { length: 0, colors: [], positions: [] },
			point: { length: 0, colors: [], positions: [], distances: [], decays: [] },
			spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },
			hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }
	
		},
	
		// info
	
		_infoMemory = {
	
			geometries: 0,
			textures: 0
	
		},
	
		_infoRender = {
	
			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0
	
		};
	
		this.info = {
	
			render: _infoRender,
			memory: _infoMemory,
			programs: null
	
		};
	
	
		// initialize
	
		var _gl;
	
		try {
	
			var attributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer
			};
	
			_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );
	
			if ( _gl === null ) {
	
				if ( _canvas.getContext( 'webgl' ) !== null ) {
	
					throw 'Error creating WebGL context with your selected attributes.';
	
				} else {
	
					throw 'Error creating WebGL context.';
	
				}
	
			}
	
			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
	
		} catch ( error ) {
	
			console.error( 'THREE.WebGLRenderer: ' + error );
	
		}
	
		var extensions = new THREE.WebGLExtensions( _gl );
	
		extensions.get( 'OES_texture_float' );
		extensions.get( 'OES_texture_float_linear' );
		extensions.get( 'OES_texture_half_float' );
		extensions.get( 'OES_texture_half_float_linear' );
		extensions.get( 'OES_standard_derivatives' );
		extensions.get( 'ANGLE_instanced_arrays' );
	
		if ( extensions.get( 'OES_element_index_uint' ) ) {
	
			THREE.BufferGeometry.MaxIndex = 4294967296;
	
		}
	
		var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );
	
		var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );
		var properties = new THREE.WebGLProperties();
		var objects = new THREE.WebGLObjects( _gl, properties, this.info );
		var programCache = new THREE.WebGLPrograms( this, capabilities );
	
		this.info.programs = programCache.programs;
	
		var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );
		var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );
	
		//
	
		function glClearColor( r, g, b, a ) {
	
			if ( _premultipliedAlpha === true ) {
	
				r *= a; g *= a; b *= a;
	
			}
	
			_gl.clearColor( r, g, b, a );
	
		}
	
		function setDefaultGLState() {
	
			state.init();
	
			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );
	
			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		}
	
		function resetGLState() {
	
			_currentProgram = null;
			_currentCamera = null;
	
			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
	
			_lightsNeedUpdate = true;
	
			state.reset();
	
		}
	
		setDefaultGLState();
	
		this.context = _gl;
		this.capabilities = capabilities;
		this.extensions = extensions;
		this.state = state;
	
		// shadow map
	
		var shadowMap = new THREE.WebGLShadowMap( this, lights, objects );
	
		this.shadowMap = shadowMap;
	
	
		// Plugins
	
		var spritePlugin = new THREE.SpritePlugin( this, sprites );
		var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );
	
		// API
	
		this.getContext = function () {
	
			return _gl;
	
		};
	
		this.getContextAttributes = function () {
	
			return _gl.getContextAttributes();
	
		};
	
		this.forceContextLoss = function () {
	
			extensions.get( 'WEBGL_lose_context' ).loseContext();
	
		};
	
		this.getMaxAnisotropy = ( function () {
	
			var value;
	
			return function getMaxAnisotropy() {
	
				if ( value !== undefined ) return value;
	
				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
				if ( extension !== null ) {
	
					value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );
	
				} else {
	
					value = 0;
	
				}
	
				return value;
	
			}
	
		} )();
	
		this.getPrecision = function () {
	
			return capabilities.precision;
	
		};
	
		this.getPixelRatio = function () {
	
			return pixelRatio;
	
		};
	
		this.setPixelRatio = function ( value ) {
	
			if ( value !== undefined ) pixelRatio = value;
	
		};
	
		this.getSize = function () {
	
			return {
				width: _width,
				height: _height
			};
	
		};
	
		this.setSize = function ( width, height, updateStyle ) {
	
			_width = width;
			_height = height;
	
			_canvas.width = width * pixelRatio;
			_canvas.height = height * pixelRatio;
	
			if ( updateStyle !== false ) {
	
				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';
	
			}
	
			this.setViewport( 0, 0, width, height );
	
		};
	
		this.setViewport = function ( x, y, width, height ) {
	
			_viewportX = x * pixelRatio;
			_viewportY = y * pixelRatio;
	
			_viewportWidth = width * pixelRatio;
			_viewportHeight = height * pixelRatio;
	
			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );
	
		};
	
		this.getViewport = function ( dimensions ) {
	
			dimensions.x = _viewportX / pixelRatio;
			dimensions.y = _viewportY / pixelRatio;
	
			dimensions.z = _viewportWidth / pixelRatio;
			dimensions.w = _viewportHeight / pixelRatio;
	
		};
	
		this.setScissor = function ( x, y, width, height ) {
	
			_gl.scissor(
				x * pixelRatio,
				y * pixelRatio,
				width * pixelRatio,
				height * pixelRatio
			);
	
		};
	
		this.enableScissorTest = function ( boolean ) {
	
			state.setScissorTest( boolean );
	
		};
	
		// Clearing
	
		this.getClearColor = function () {
	
			return _clearColor;
	
		};
	
		this.setClearColor = function ( color, alpha ) {
	
			_clearColor.set( color );
	
			_clearAlpha = alpha !== undefined ? alpha : 1;
	
			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		};
	
		this.getClearAlpha = function () {
	
			return _clearAlpha;
	
		};
	
		this.setClearAlpha = function ( alpha ) {
	
			_clearAlpha = alpha;
	
			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		};
	
		this.clear = function ( color, depth, stencil ) {
	
			var bits = 0;
	
			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;
	
			_gl.clear( bits );
	
		};
	
		this.clearColor = function () {
	
			_gl.clear( _gl.COLOR_BUFFER_BIT );
	
		};
	
		this.clearDepth = function () {
	
			_gl.clear( _gl.DEPTH_BUFFER_BIT );
	
		};
	
		this.clearStencil = function () {
	
			_gl.clear( _gl.STENCIL_BUFFER_BIT );
	
		};
	
		this.clearTarget = function ( renderTarget, color, depth, stencil ) {
	
			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );
	
		};
	
		// Reset
	
		this.resetGLState = resetGLState;
	
		this.dispose = function() {
	
			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
	
		};
	
		// Events
	
		function onContextLost( event ) {
	
			event.preventDefault();
	
			resetGLState();
			setDefaultGLState();
	
			properties.clear();
	
		};
	
		function onTextureDispose( event ) {
	
			var texture = event.target;
	
			texture.removeEventListener( 'dispose', onTextureDispose );
	
			deallocateTexture( texture );
	
			_infoMemory.textures --;
	
	
		}
	
		function onRenderTargetDispose( event ) {
	
			var renderTarget = event.target;
	
			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );
	
			deallocateRenderTarget( renderTarget );
	
			_infoMemory.textures --;
	
		}
	
		function onMaterialDispose( event ) {
	
			var material = event.target;
	
			material.removeEventListener( 'dispose', onMaterialDispose );
	
			deallocateMaterial( material );
	
		}
	
		// Buffer deallocation
	
		function deallocateTexture( texture ) {
	
			var textureProperties = properties.get( texture );
	
			if ( texture.image && textureProperties.__image__webglTextureCube ) {
	
				// cube texture
	
				_gl.deleteTexture( textureProperties.__image__webglTextureCube );
	
			} else {
	
				// 2D texture
	
				if ( textureProperties.__webglInit === undefined ) return;
	
				_gl.deleteTexture( textureProperties.__webglTexture );
	
			}
	
			// remove all webgl properties
			properties.delete( texture );
	
		}
	
		function deallocateRenderTarget( renderTarget ) {
	
			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );
	
			if ( ! renderTarget || textureProperties.__webglTexture === undefined ) return;
	
			_gl.deleteTexture( textureProperties.__webglTexture );
	
			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {
	
				for ( var i = 0; i < 6; i ++ ) {
	
					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					_gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer[ i ] );
	
				}
	
			} else {
	
				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				_gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer );
	
			}
	
			properties.delete( renderTarget.texture );
			properties.delete( renderTarget );
	
		}
	
		function deallocateMaterial( material ) {
	
			releaseMaterialProgramReference( material );
	
			properties.delete( material );
	
		}
	
	
		function releaseMaterialProgramReference( material ) {
	
			var programInfo = properties.get( material ).program;
	
			material.program = undefined;
	
			if ( programInfo !== undefined ) {
	
				programCache.releaseProgram( programInfo );
	
			}
	
		}
	
		// Buffer rendering
	
		this.renderBufferImmediate = function ( object, program, material ) {
	
			state.initAttributes();
	
			var buffers = properties.get( object );
	
			if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
			if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
			if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
			if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();
	
			var attributes = program.getAttributes();
	
			if ( object.hasPositions ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasNormals ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );
	
				if ( material.type !== 'MeshPhongMaterial' && material.shading === THREE.FlatShading ) {
	
					for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {
	
						var array = object.normalArray;
	
						var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
						var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
						var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;
	
						array[ i + 0 ] = nx;
						array[ i + 1 ] = ny;
						array[ i + 2 ] = nz;
	
						array[ i + 3 ] = nx;
						array[ i + 4 ] = ny;
						array[ i + 5 ] = nz;
	
						array[ i + 6 ] = nx;
						array[ i + 7 ] = ny;
						array[ i + 8 ] = nz;
	
					}
	
				}
	
				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( attributes.normal );
	
				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasUvs && material.map ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( attributes.uv );
	
				_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
	
				state.enableAttribute( attributes.color );
	
				_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			state.disableUnusedAttributes();
	
			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );
	
			object.count = 0;
	
		};
	
		this.renderBufferDirect = function ( camera, lights, fog, geometry, material, object, group ) {
	
			setMaterial( material );
	
			var program = setProgram( camera, lights, fog, material, object );
	
			var updateBuffers = false;
			var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;
	
			if ( geometryProgram !== _currentGeometryProgram ) {
	
				_currentGeometryProgram = geometryProgram;
				updateBuffers = true;
	
			}
	
			// morph targets
	
			var morphTargetInfluences = object.morphTargetInfluences;
	
			if ( morphTargetInfluences !== undefined ) {
	
				var activeInfluences = [];
	
				for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {
	
					var influence = morphTargetInfluences[ i ];
					activeInfluences.push( [ influence, i ] );
	
				}
	
				activeInfluences.sort( numericalSort );
	
				if ( activeInfluences.length > 8 ) {
	
					activeInfluences.length = 8;
	
				}
	
				var morphAttributes = geometry.morphAttributes;
	
				for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {
	
					var influence = activeInfluences[ i ];
					morphInfluences[ i ] = influence[ 0 ];
	
					if ( influence[ 0 ] !== 0 ) {
	
						var index = influence[ 1 ];
	
						if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
						if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );
	
					} else {
	
						if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
						if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );
	
					}
	
				}
	
				var uniforms = program.getUniforms();
	
				if ( uniforms.morphTargetInfluences !== null ) {
	
					_gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );
	
				}
	
				updateBuffers = true;
	
			}
	
			//
	
			var index = geometry.index;
			var position = geometry.attributes.position;
	
			if ( material.wireframe === true ) {
	
				index = objects.getWireframeAttribute( geometry );
	
			}
	
			var renderer;
	
			if ( index !== null ) {
	
				renderer = indexedBufferRenderer;
				renderer.setIndex( index );
	
			} else {
	
				renderer = bufferRenderer;
	
			}
	
			if ( updateBuffers ) {
	
				setupVertexAttributes( material, program, geometry );
	
				if ( index !== null ) {
	
					_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );
	
				}
	
			}
	
			//
	
			var dataStart = 0;
			var dataCount = Infinity;
	
			if ( index !== null ) {
	
				dataCount = index.count
	
			} else if ( position !== undefined ) {
	
				dataCount = position.count;
	
			}
	
			var rangeStart = geometry.drawRange.start;
			var rangeCount = geometry.drawRange.count;
	
			var groupStart = group !== null ? group.start : 0;
			var groupCount = group !== null ? group.count : Infinity;
	
			var drawStart = Math.max( dataStart, rangeStart, groupStart );
			var drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;
	
			var drawCount = Math.max( 0, drawEnd - drawStart + 1 );
	
			//
	
			if ( object instanceof THREE.Mesh ) {
	
				if ( material.wireframe === true ) {
	
					state.setLineWidth( material.wireframeLinewidth * pixelRatio );
					renderer.setMode( _gl.LINES );
	
				} else {
	
					renderer.setMode( _gl.TRIANGLES );
	
				}
	
				if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {
	
					renderer.renderInstances( geometry );
	
				} else {
	
					renderer.render( drawStart, drawCount );
	
				}
	
			} else if ( object instanceof THREE.Line ) {
	
				var lineWidth = material.linewidth;
	
				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material
	
				state.setLineWidth( lineWidth * pixelRatio );
	
				if ( object instanceof THREE.LineSegments ) {
	
					renderer.setMode( _gl.LINES );
	
				} else {
	
					renderer.setMode( _gl.LINE_STRIP );
	
				}
	
				renderer.render( drawStart, drawCount );
	
			} else if ( object instanceof THREE.Points ) {
	
				renderer.setMode( _gl.POINTS );
				renderer.render( drawStart, drawCount );
	
			}
	
		};
	
		function setupVertexAttributes( material, program, geometry, startIndex ) {
	
			var extension;
	
			if ( geometry instanceof THREE.InstancedBufferGeometry ) {
	
				extension = extensions.get( 'ANGLE_instanced_arrays' );
	
				if ( extension === null ) {
	
					console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;
	
				}
	
			}
	
			if ( startIndex === undefined ) startIndex = 0;
	
			state.initAttributes();
	
			var geometryAttributes = geometry.attributes;
	
			var programAttributes = program.getAttributes();
	
			var materialDefaultAttributeValues = material.defaultAttributeValues;
	
			for ( var name in programAttributes ) {
	
				var programAttribute = programAttributes[ name ];
	
				if ( programAttribute >= 0 ) {
	
					var geometryAttribute = geometryAttributes[ name ];
	
					if ( geometryAttribute !== undefined ) {
	
						var size = geometryAttribute.itemSize;
						var buffer = objects.getAttributeBuffer( geometryAttribute );
	
						if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {
	
							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;
	
							if ( data instanceof THREE.InstancedInterleavedBuffer ) {
	
								state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );
	
								if ( geometry.maxInstancedCount === undefined ) {
	
									geometry.maxInstancedCount = data.meshPerAttribute * data.count;
	
								}
	
							} else {
	
								state.enableAttribute( programAttribute );
	
							}
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );
	
						} else {
	
							if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {
	
								state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );
	
								if ( geometry.maxInstancedCount === undefined ) {
	
									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
	
								}
	
							} else {
	
								state.enableAttribute( programAttribute );
	
							}
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32
	
						}
	
					} else if ( materialDefaultAttributeValues !== undefined ) {
	
						var value = materialDefaultAttributeValues[ name ];
	
						if ( value !== undefined ) {
	
							switch ( value.length ) {
	
								case 2:
									_gl.vertexAttrib2fv( programAttribute, value );
									break;
	
								case 3:
									_gl.vertexAttrib3fv( programAttribute, value );
									break;
	
								case 4:
									_gl.vertexAttrib4fv( programAttribute, value );
									break;
	
								default:
									_gl.vertexAttrib1fv( programAttribute, value );
	
							}
	
						}
	
					}
	
				}
	
			}
	
			state.disableUnusedAttributes();
	
		}
	
		// Sorting
	
		function numericalSort ( a, b ) {
	
			return b[ 0 ] - a[ 0 ];
	
		}
	
		function painterSortStable ( a, b ) {
	
			if ( a.object.renderOrder !== b.object.renderOrder ) {
	
				return a.object.renderOrder - b.object.renderOrder;
	
			} else if ( a.material.id !== b.material.id ) {
	
				return a.material.id - b.material.id;
	
			} else if ( a.z !== b.z ) {
	
				return a.z - b.z;
	
			} else {
	
				return a.id - b.id;
	
			}
	
		}
	
		function reversePainterSortStable ( a, b ) {
	
			if ( a.object.renderOrder !== b.object.renderOrder ) {
	
				return a.object.renderOrder - b.object.renderOrder;
	
			} if ( a.z !== b.z ) {
	
				return b.z - a.z;
	
			} else {
	
				return a.id - b.id;
	
			}
	
		}
	
		// Rendering
	
		this.render = function ( scene, camera, renderTarget, forceClear ) {
	
			if ( camera instanceof THREE.Camera === false ) {
	
				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;
	
			}
	
			var fog = scene.fog;
	
			// reset caching for this frame
	
			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
			_currentCamera = null;
			_lightsNeedUpdate = true;
	
			// update scene graph
	
			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
	
			// update camera matrices and frustum
	
			if ( camera.parent === null ) camera.updateMatrixWorld();
	
			camera.matrixWorldInverse.getInverse( camera.matrixWorld );
	
			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );
	
			lights.length = 0;
	
			opaqueObjectsLastIndex = - 1;
			transparentObjectsLastIndex = - 1;
	
			sprites.length = 0;
			lensFlares.length = 0;
	
			projectObject( scene, camera );
	
			opaqueObjects.length = opaqueObjectsLastIndex + 1;
			transparentObjects.length = transparentObjectsLastIndex + 1;
	
			if ( _this.sortObjects === true ) {
	
				opaqueObjects.sort( painterSortStable );
				transparentObjects.sort( reversePainterSortStable );
	
			}
	
			//
	
			shadowMap.render( scene );
	
			//
	
			_infoRender.calls = 0;
			_infoRender.vertices = 0;
			_infoRender.faces = 0;
			_infoRender.points = 0;
	
			this.setRenderTarget( renderTarget );
	
			if ( this.autoClear || forceClear ) {
	
				this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );
	
			}
	
			//
	
			if ( scene.overrideMaterial ) {
	
				var overrideMaterial = scene.overrideMaterial;
	
				renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
				renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );
	
			} else {
	
				// opaque pass (front-to-back order)
	
				state.setBlending( THREE.NoBlending );
				renderObjects( opaqueObjects, camera, lights, fog );
	
				// transparent pass (back-to-front order)
	
				renderObjects( transparentObjects, camera, lights, fog );
	
			}
	
			// custom render plugins (post pass)
	
			spritePlugin.render( scene, camera );
			lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );
	
			// Generate mipmap if we're using any kind of mipmap filtering
	
			if ( renderTarget ) {
	
				var texture = renderTarget.texture;
				var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );
				if ( texture.generateMipmaps && isTargetPowerOfTwo && texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {
	
					 updateRenderTargetMipmap( renderTarget );
	
				}
	
			}
	
			// Ensure depth buffer writing is enabled so it can be cleared on next render
	
			state.setDepthTest( true );
			state.setDepthWrite( true );
			state.setColorWrite( true );
	
			// _gl.finish();
	
		};
	
		function pushRenderItem( object, geometry, material, z, group ) {
	
			var array, index;
	
			// allocate the next position in the appropriate array
	
			if ( material.transparent ) {
	
				array = transparentObjects;
				index = ++ transparentObjectsLastIndex;
	
			} else {
	
				array = opaqueObjects;
				index = ++ opaqueObjectsLastIndex;
	
			}
	
			// recycle existing render item or grow the array
	
			var renderItem = array[ index ];
	
			if ( renderItem !== undefined ) {
	
				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.z = _vector3.z;
				renderItem.group = group;
	
			} else {
	
				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					z: _vector3.z,
					group: group
				};
	
				// assert( index === array.length );
				array.push( renderItem );
	
			}
	
		}
	
		function projectObject( object, camera ) {
	
			if ( object.visible === false ) return;
	
			if ( ( object.channels.mask & camera.channels.mask ) !== 0 ) {
	
				if ( object instanceof THREE.Light ) {
	
					lights.push( object );
	
				} else if ( object instanceof THREE.Sprite ) {
	
					sprites.push( object );
	
				} else if ( object instanceof THREE.LensFlare ) {
	
					lensFlares.push( object );
	
				} else if ( object instanceof THREE.ImmediateRenderObject ) {
	
					if ( _this.sortObjects === true ) {
	
						_vector3.setFromMatrixPosition( object.matrixWorld );
						_vector3.applyProjection( _projScreenMatrix );
	
					}
	
					pushRenderItem( object, null, object.material, _vector3.z, null );
	
				} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {
	
					if ( object instanceof THREE.SkinnedMesh ) {
	
						object.skeleton.update();
	
					}
	
					if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {
	
						var material = object.material;
	
						if ( material.visible === true ) {
	
							if ( _this.sortObjects === true ) {
	
								_vector3.setFromMatrixPosition( object.matrixWorld );
								_vector3.applyProjection( _projScreenMatrix );
	
							}
	
							var geometry = objects.update( object );
	
							if ( material instanceof THREE.MeshFaceMaterial ) {
	
								var groups = geometry.groups;
								var materials = material.materials;
	
								for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
									var group = groups[ i ];
									var groupMaterial = materials[ group.materialIndex ];
	
									if ( groupMaterial.visible === true ) {
	
										pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );
	
									}
	
								}
	
							} else {
	
								pushRenderItem( object, geometry, material, _vector3.z, null );
	
							}
	
						}
	
					}
	
				}
	
			}
	
			var children = object.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				projectObject( children[ i ], camera );
	
			}
	
		}
	
		function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {
	
			for ( var i = 0, l = renderList.length; i < l; i ++ ) {
	
				var renderItem = renderList[ i ];
	
				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
				var group = renderItem.group;
	
				object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
				object.normalMatrix.getNormalMatrix( object.modelViewMatrix );
	
				if ( object instanceof THREE.ImmediateRenderObject ) {
	
					setMaterial( material );
	
					var program = setProgram( camera, lights, fog, material, object );
	
					_currentGeometryProgram = '';
	
					object.render( function ( object ) {
	
						_this.renderBufferImmediate( object, program, material );
	
					} );
	
				} else {
	
					_this.renderBufferDirect( camera, lights, fog, geometry, material, object, group );
	
				}
	
			}
	
		}
	
		function initMaterial( material, lights, fog, object ) {
	
			var materialProperties = properties.get( material );
	
			var parameters = programCache.getParameters( material, lights, fog, object );
			var code = programCache.getProgramCode( material, parameters );
	
			var program = materialProperties.program;
			var programChange = true;
	
			if ( program === undefined ) {
	
				// new material
				material.addEventListener( 'dispose', onMaterialDispose );
	
			} else if ( program.code !== code ) {
	
				// changed glsl or parameters
				releaseMaterialProgramReference( material );
	
			} else if ( parameters.shaderID !== undefined ) {
	
				// same glsl and uniform list
				return;
	
			} else {
	
				// only rebuild uniform list
				programChange = false;
	
			}
	
			if ( programChange ) {
	
				if ( parameters.shaderID ) {
	
					var shader = THREE.ShaderLib[ parameters.shaderID ];
	
					materialProperties.__webglShader = {
						name: material.type,
						uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader
					};
	
				} else {
	
					materialProperties.__webglShader = {
						name: material.type,
						uniforms: material.uniforms,
						vertexShader: material.vertexShader,
						fragmentShader: material.fragmentShader
					};
	
				}
	
				material.__webglShader = materialProperties.__webglShader;
	
				program = programCache.acquireProgram( material, parameters, code );
	
				materialProperties.program = program;
				material.program = program;
	
			}
	
			var attributes = program.getAttributes();
	
			if ( material.morphTargets ) {
	
				material.numSupportedMorphTargets = 0;
	
				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {
	
					if ( attributes[ 'morphTarget' + i ] >= 0 ) {
	
						material.numSupportedMorphTargets ++;
	
					}
	
				}
	
			}
	
			if ( material.morphNormals ) {
	
				material.numSupportedMorphNormals = 0;
	
				for ( i = 0; i < _this.maxMorphNormals; i ++ ) {
	
					if ( attributes[ 'morphNormal' + i ] >= 0 ) {
	
						material.numSupportedMorphNormals ++;
	
					}
	
				}
	
			}
	
			materialProperties.uniformsList = [];
	
			var uniformLocations = materialProperties.program.getUniforms();
	
			for ( var u in materialProperties.__webglShader.uniforms ) {
	
				var location = uniformLocations[ u ];
	
				if ( location ) {
	
					materialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );
	
				}
	
			}
	
		}
	
		function setMaterial( material ) {
	
			setMaterialFaces( material );
	
			if ( material.transparent === true ) {
	
				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );
	
			} else {
	
				state.setBlending( THREE.NoBlending );
	
			}
	
			state.setDepthFunc( material.depthFunc );
			state.setDepthTest( material.depthTest );
			state.setDepthWrite( material.depthWrite );
			state.setColorWrite( material.colorWrite );
			state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
	
		}
	
		function setMaterialFaces( material ) {
	
			material.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );
			state.setFlipSided( material.side === THREE.BackSide );
	
		}
	
		function setProgram( camera, lights, fog, material, object ) {
	
			_usedTextureUnits = 0;
	
			var materialProperties = properties.get( material );
	
			if ( material.needsUpdate || ! materialProperties.program ) {
	
				initMaterial( material, lights, fog, object );
				material.needsUpdate = false;
	
			}
	
			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;
	
			var program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.__webglShader.uniforms;
	
			if ( program.id !== _currentProgram ) {
	
				_gl.useProgram( program.program );
				_currentProgram = program.id;
	
				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;
	
			}
	
			if ( material.id !== _currentMaterialId ) {
	
				if ( _currentMaterialId === - 1 ) refreshLights = true;
				_currentMaterialId = material.id;
	
				refreshMaterial = true;
	
			}
	
			if ( refreshProgram || camera !== _currentCamera ) {
	
				_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );
	
				if ( capabilities.logarithmicDepthBuffer ) {
	
					_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );
	
				}
	
	
				if ( camera !== _currentCamera ) _currentCamera = camera;
	
				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)
	
				if ( material instanceof THREE.ShaderMaterial ||
					 material instanceof THREE.MeshPhongMaterial ||
					 material.envMap ) {
	
					if ( p_uniforms.cameraPosition !== undefined ) {
	
						_vector3.setFromMatrixPosition( camera.matrixWorld );
						_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );
	
					}
	
				}
	
				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.ShaderMaterial ||
					 material.skinning ) {
	
					if ( p_uniforms.viewMatrix !== undefined ) {
	
						_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );
	
					}
	
				}
	
			}
	
			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen
	
			if ( material.skinning ) {
	
				if ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {
	
					_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );
	
				}
	
				if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {
	
					_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );
	
				}
	
				if ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {
	
					if ( p_uniforms.boneTexture !== undefined ) {
	
						var textureUnit = getTextureUnit();
	
						_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
						_this.setTexture( object.skeleton.boneTexture, textureUnit );
	
					}
	
					if ( p_uniforms.boneTextureWidth !== undefined ) {
	
						_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );
	
					}
	
					if ( p_uniforms.boneTextureHeight !== undefined ) {
	
						_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );
	
					}
	
				} else if ( object.skeleton && object.skeleton.boneMatrices ) {
	
					if ( p_uniforms.boneGlobalMatrices !== undefined ) {
	
						_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );
	
					}
	
				}
	
			}
	
			if ( refreshMaterial ) {
	
				// refresh uniforms common to several materials
	
				if ( fog && material.fog ) {
	
					refreshUniformsFog( m_uniforms, fog );
	
				}
	
				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material.lights ) {
	
					if ( _lightsNeedUpdate ) {
	
						refreshLights = true;
						setupLights( lights, camera );
						_lightsNeedUpdate = false;
	
					}
	
					if ( refreshLights ) {
	
						refreshUniformsLights( m_uniforms, _lights );
						markUniformsLightsNeedsUpdate( m_uniforms, true );
	
					} else {
	
						markUniformsLightsNeedsUpdate( m_uniforms, false );
	
					}
	
				}
	
				if ( material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshPhongMaterial ) {
	
					refreshUniformsCommon( m_uniforms, material );
	
				}
	
				// refresh single material specific uniforms
	
				if ( material instanceof THREE.LineBasicMaterial ) {
	
					refreshUniformsLine( m_uniforms, material );
	
				} else if ( material instanceof THREE.LineDashedMaterial ) {
	
					refreshUniformsLine( m_uniforms, material );
					refreshUniformsDash( m_uniforms, material );
	
				} else if ( material instanceof THREE.PointsMaterial ) {
	
					refreshUniformsParticle( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshPhongMaterial ) {
	
					refreshUniformsPhong( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshDepthMaterial ) {
	
					m_uniforms.mNear.value = camera.near;
					m_uniforms.mFar.value = camera.far;
					m_uniforms.opacity.value = material.opacity;
	
				} else if ( material instanceof THREE.MeshNormalMaterial ) {
	
					m_uniforms.opacity.value = material.opacity;
	
				}
	
				if ( object.receiveShadow && ! material._shadowPass ) {
	
					refreshUniformsShadow( m_uniforms, lights, camera );
	
				}
	
				// load common uniforms
	
				loadUniformsGeneric( materialProperties.uniformsList );
	
			}
	
			loadUniformsMatrices( p_uniforms, object );
	
			if ( p_uniforms.modelMatrix !== undefined ) {
	
				_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );
	
			}
	
			return program;
	
		}
	
		// Uniforms (refresh uniforms objects)
	
		function refreshUniformsCommon ( uniforms, material ) {
	
			uniforms.opacity.value = material.opacity;
	
			uniforms.diffuse.value = material.color;
	
			if ( material.emissive ) {
	
				uniforms.emissive.value = material.emissive;
	
			}
	
			uniforms.map.value = material.map;
			uniforms.specularMap.value = material.specularMap;
			uniforms.alphaMap.value = material.alphaMap;
	
			if ( material.aoMap ) {
	
				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;
	
			}
	
			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map
	
			var uvScaleMap;
	
			if ( material.map ) {
	
				uvScaleMap = material.map;
	
			} else if ( material.specularMap ) {
	
				uvScaleMap = material.specularMap;
	
			} else if ( material.displacementMap ) {
	
				uvScaleMap = material.displacementMap;
	
			} else if ( material.normalMap ) {
	
				uvScaleMap = material.normalMap;
	
			} else if ( material.bumpMap ) {
	
				uvScaleMap = material.bumpMap;
	
			} else if ( material.alphaMap ) {
	
				uvScaleMap = material.alphaMap;
	
			} else if ( material.emissiveMap ) {
	
				uvScaleMap = material.emissiveMap;
	
			}
	
			if ( uvScaleMap !== undefined ) {
	
				if ( uvScaleMap instanceof THREE.WebGLRenderTarget ) uvScaleMap = uvScaleMap.texture;
				var offset = uvScaleMap.offset;
				var repeat = uvScaleMap.repeat;
	
				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
			}
	
			uniforms.envMap.value = material.envMap;
			uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;
	
			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;
	
		}
	
		function refreshUniformsLine ( uniforms, material ) {
	
			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
	
		}
	
		function refreshUniformsDash ( uniforms, material ) {
	
			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;
	
		}
	
		function refreshUniformsParticle ( uniforms, material ) {
	
			uniforms.psColor.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size;
			uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.
	
			uniforms.map.value = material.map;
	
			if ( material.map !== null ) {
	
				var offset = material.map.offset;
				var repeat = material.map.repeat;
	
				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
			}
	
		}
	
		function refreshUniformsFog ( uniforms, fog ) {
	
			uniforms.fogColor.value = fog.color;
	
			if ( fog instanceof THREE.Fog ) {
	
				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;
	
			} else if ( fog instanceof THREE.FogExp2 ) {
	
				uniforms.fogDensity.value = fog.density;
	
			}
	
		}
	
		function refreshUniformsPhong ( uniforms, material ) {
	
			uniforms.specular.value = material.specular;
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )
	
			if ( material.lightMap ) {
	
				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
	
			}
	
			if ( material.emissiveMap ) {
	
				uniforms.emissiveMap.value = material.emissiveMap;
	
			}
	
			if ( material.bumpMap ) {
	
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
	
			}
	
			if ( material.normalMap ) {
	
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
	
			}
	
			if ( material.displacementMap ) {
	
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
	
			}
	
		}
	
		function refreshUniformsLights ( uniforms, lights ) {
	
			uniforms.ambientLightColor.value = lights.ambient;
	
			uniforms.directionalLightColor.value = lights.directional.colors;
			uniforms.directionalLightDirection.value = lights.directional.positions;
	
			uniforms.pointLightColor.value = lights.point.colors;
			uniforms.pointLightPosition.value = lights.point.positions;
			uniforms.pointLightDistance.value = lights.point.distances;
			uniforms.pointLightDecay.value = lights.point.decays;
	
			uniforms.spotLightColor.value = lights.spot.colors;
			uniforms.spotLightPosition.value = lights.spot.positions;
			uniforms.spotLightDistance.value = lights.spot.distances;
			uniforms.spotLightDirection.value = lights.spot.directions;
			uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
			uniforms.spotLightExponent.value = lights.spot.exponents;
			uniforms.spotLightDecay.value = lights.spot.decays;
	
			uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
			uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
			uniforms.hemisphereLightDirection.value = lights.hemi.positions;
	
		}
	
		// If uniforms are marked as clean, they don't need to be loaded to the GPU.
	
		function markUniformsLightsNeedsUpdate ( uniforms, value ) {
	
			uniforms.ambientLightColor.needsUpdate = value;
	
			uniforms.directionalLightColor.needsUpdate = value;
			uniforms.directionalLightDirection.needsUpdate = value;
	
			uniforms.pointLightColor.needsUpdate = value;
			uniforms.pointLightPosition.needsUpdate = value;
			uniforms.pointLightDistance.needsUpdate = value;
			uniforms.pointLightDecay.needsUpdate = value;
	
			uniforms.spotLightColor.needsUpdate = value;
			uniforms.spotLightPosition.needsUpdate = value;
			uniforms.spotLightDistance.needsUpdate = value;
			uniforms.spotLightDirection.needsUpdate = value;
			uniforms.spotLightAngleCos.needsUpdate = value;
			uniforms.spotLightExponent.needsUpdate = value;
			uniforms.spotLightDecay.needsUpdate = value;
	
			uniforms.hemisphereLightSkyColor.needsUpdate = value;
			uniforms.hemisphereLightGroundColor.needsUpdate = value;
			uniforms.hemisphereLightDirection.needsUpdate = value;
	
		}
	
		function refreshUniformsShadow ( uniforms, lights, camera ) {
	
			if ( uniforms.shadowMatrix ) {
	
				var j = 0;
	
				for ( var i = 0, il = lights.length; i < il; i ++ ) {
	
					var light = lights[ i ];
	
					if ( light.castShadow === true ) {
	
						if ( light instanceof THREE.PointLight || light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight ) {
	
							var shadow = light.shadow;
	
							if ( light instanceof THREE.PointLight ) {
	
								// for point lights we set the shadow matrix to be a translation-only matrix
								// equal to inverse of the light's position
								_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
								shadow.matrix.identity().setPosition( _vector3 );
	
								// for point lights we set the sign of the shadowDarkness uniform to be negative
								uniforms.shadowDarkness.value[ j ] = - shadow.darkness;
	
							} else {
	
								uniforms.shadowDarkness.value[ j ] = shadow.darkness;
	
							}
	
							uniforms.shadowMatrix.value[ j ] = shadow.matrix;
							uniforms.shadowMap.value[ j ] = shadow.map;
							uniforms.shadowMapSize.value[ j ] = shadow.mapSize;
							uniforms.shadowBias.value[ j ] = shadow.bias;
	
							j ++;
	
						}
	
					}
	
				}
	
			}
	
		}
	
		// Uniforms (load to GPU)
	
		function loadUniformsMatrices ( uniforms, object ) {
	
			_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );
	
			if ( uniforms.normalMatrix ) {
	
				_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );
	
			}
	
		}
	
		function getTextureUnit() {
	
			var textureUnit = _usedTextureUnits;
	
			if ( textureUnit >= capabilities.maxTextures ) {
	
				console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );
	
			}
	
			_usedTextureUnits += 1;
	
			return textureUnit;
	
		}
	
		function loadUniformsGeneric ( uniforms ) {
	
			var texture, textureUnit;
	
			for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {
	
				var uniform = uniforms[ j ][ 0 ];
	
				// needsUpdate property is not added to all uniforms.
				if ( uniform.needsUpdate === false ) continue;
	
				var type = uniform.type;
				var value = uniform.value;
				var location = uniforms[ j ][ 1 ];
	
				switch ( type ) {
	
					case '1i':
						_gl.uniform1i( location, value );
						break;
	
					case '1f':
						_gl.uniform1f( location, value );
						break;
	
					case '2f':
						_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
						break;
	
					case '3f':
						_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
						break;
	
					case '4f':
						_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
						break;
	
					case '1iv':
						_gl.uniform1iv( location, value );
						break;
	
					case '3iv':
						_gl.uniform3iv( location, value );
						break;
	
					case '1fv':
						_gl.uniform1fv( location, value );
						break;
	
					case '2fv':
						_gl.uniform2fv( location, value );
						break;
	
					case '3fv':
						_gl.uniform3fv( location, value );
						break;
	
					case '4fv':
						_gl.uniform4fv( location, value );
						break;
	
					case 'Matrix3fv':
						_gl.uniformMatrix3fv( location, false, value );
						break;
	
					case 'Matrix4fv':
						_gl.uniformMatrix4fv( location, false, value );
						break;
	
					//
	
					case 'i':
	
						// single integer
						_gl.uniform1i( location, value );
	
						break;
	
					case 'f':
	
						// single float
						_gl.uniform1f( location, value );
	
						break;
	
					case 'v2':
	
						// single THREE.Vector2
						_gl.uniform2f( location, value.x, value.y );
	
						break;
	
					case 'v3':
	
						// single THREE.Vector3
						_gl.uniform3f( location, value.x, value.y, value.z );
	
						break;
	
					case 'v4':
	
						// single THREE.Vector4
						_gl.uniform4f( location, value.x, value.y, value.z, value.w );
	
						break;
	
					case 'c':
	
						// single THREE.Color
						_gl.uniform3f( location, value.r, value.g, value.b );
	
						break;
	
					case 'iv1':
	
						// flat array of integers (JS or typed array)
						_gl.uniform1iv( location, value );
	
						break;
	
					case 'iv':
	
						// flat array of integers with 3 x N size (JS or typed array)
						_gl.uniform3iv( location, value );
	
						break;
	
					case 'fv1':
	
						// flat array of floats (JS or typed array)
						_gl.uniform1fv( location, value );
	
						break;
	
					case 'fv':
	
						// flat array of floats with 3 x N size (JS or typed array)
						_gl.uniform3fv( location, value );
	
						break;
	
					case 'v2v':
	
						// array of THREE.Vector2
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 2 * value.length );
	
						}
	
						for ( var i = 0, i2 = 0, il = value.length; i < il; i ++, i2 += 2 ) {
	
							uniform._array[ i2 + 0 ] = value[ i ].x;
							uniform._array[ i2 + 1 ] = value[ i ].y;
	
						}
	
						_gl.uniform2fv( location, uniform._array );
	
						break;
	
					case 'v3v':
	
						// array of THREE.Vector3
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 3 * value.length );
	
						}
	
						for ( var i = 0, i3 = 0, il = value.length; i < il; i ++, i3 += 3 ) {
	
							uniform._array[ i3 + 0 ] = value[ i ].x;
							uniform._array[ i3 + 1 ] = value[ i ].y;
							uniform._array[ i3 + 2 ] = value[ i ].z;
	
						}
	
						_gl.uniform3fv( location, uniform._array );
	
						break;
	
					case 'v4v':
	
						// array of THREE.Vector4
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 4 * value.length );
	
						}
	
						for ( var i = 0, i4 = 0, il = value.length; i < il; i ++, i4 += 4 ) {
	
							uniform._array[ i4 + 0 ] = value[ i ].x;
							uniform._array[ i4 + 1 ] = value[ i ].y;
							uniform._array[ i4 + 2 ] = value[ i ].z;
							uniform._array[ i4 + 3 ] = value[ i ].w;
	
						}
	
						_gl.uniform4fv( location, uniform._array );
	
						break;
	
					case 'm3':
	
						// single THREE.Matrix3
						_gl.uniformMatrix3fv( location, false, value.elements );
	
						break;
	
					case 'm3v':
	
						// array of THREE.Matrix3
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 9 * value.length );
	
						}
	
						for ( var i = 0, il = value.length; i < il; i ++ ) {
	
							value[ i ].flattenToArrayOffset( uniform._array, i * 9 );
	
						}
	
						_gl.uniformMatrix3fv( location, false, uniform._array );
	
						break;
	
					case 'm4':
	
						// single THREE.Matrix4
						_gl.uniformMatrix4fv( location, false, value.elements );
	
						break;
	
					case 'm4v':
	
						// array of THREE.Matrix4
	
						if ( uniform._array === undefined ) {
	
							uniform._array = new Float32Array( 16 * value.length );
	
						}
	
						for ( var i = 0, il = value.length; i < il; i ++ ) {
	
							value[ i ].flattenToArrayOffset( uniform._array, i * 16 );
	
						}
	
						_gl.uniformMatrix4fv( location, false, uniform._array );
	
						break;
	
					case 't':
	
						// single THREE.Texture (2d or cube)
	
						texture = value;
						textureUnit = getTextureUnit();
	
						_gl.uniform1i( location, textureUnit );
	
						if ( ! texture ) continue;
	
						if ( texture instanceof THREE.CubeTexture ||
							 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {
	
							// CompressedTexture can have Array in image :/
	
							setCubeTexture( texture, textureUnit );
	
						} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {
	
							setCubeTextureDynamic( texture.texture, textureUnit );
	
						} else if ( texture instanceof THREE.WebGLRenderTarget ) {
	
							_this.setTexture( texture.texture, textureUnit );
	
						} else {
	
							_this.setTexture( texture, textureUnit );
	
						}
	
						break;
	
					case 'tv':
	
						// array of THREE.Texture (2d or cube)
	
						if ( uniform._array === undefined ) {
	
							uniform._array = [];
	
						}
	
						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {
	
							uniform._array[ i ] = getTextureUnit();
	
						}
	
						_gl.uniform1iv( location, uniform._array );
	
						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {
	
							texture = uniform.value[ i ];
							textureUnit = uniform._array[ i ];
	
							if ( ! texture ) continue;
	
							if ( texture instanceof THREE.CubeTexture ||
								 ( texture.image instanceof Array && texture.image.length === 6 ) ) {
	
								// CompressedTexture can have Array in image :/
	
								setCubeTexture( texture, textureUnit );
	
							} else if ( texture instanceof THREE.WebGLRenderTarget ) {
	
								_this.setTexture( texture.texture, textureUnit );
	
							} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {
	
								setCubeTextureDynamic( texture.texture, textureUnit );
	
							} else {
	
								_this.setTexture( texture, textureUnit );
	
							}
	
						}
	
						break;
	
					default:
	
						console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );
	
				}
	
			}
	
		}
	
		function setColorLinear( array, offset, color, intensity ) {
	
			array[ offset + 0 ] = color.r * intensity;
			array[ offset + 1 ] = color.g * intensity;
			array[ offset + 2 ] = color.b * intensity;
	
		}
	
		function setupLights ( lights, camera ) {
	
			var l, ll, light,
			r = 0, g = 0, b = 0,
			color, skyColor, groundColor,
			intensity,
			distance,
	
			zlights = _lights,
	
			viewMatrix = camera.matrixWorldInverse,
	
			dirColors = zlights.directional.colors,
			dirPositions = zlights.directional.positions,
	
			pointColors = zlights.point.colors,
			pointPositions = zlights.point.positions,
			pointDistances = zlights.point.distances,
			pointDecays = zlights.point.decays,
	
			spotColors = zlights.spot.colors,
			spotPositions = zlights.spot.positions,
			spotDistances = zlights.spot.distances,
			spotDirections = zlights.spot.directions,
			spotAnglesCos = zlights.spot.anglesCos,
			spotExponents = zlights.spot.exponents,
			spotDecays = zlights.spot.decays,
	
			hemiSkyColors = zlights.hemi.skyColors,
			hemiGroundColors = zlights.hemi.groundColors,
			hemiPositions = zlights.hemi.positions,
	
			dirLength = 0,
			pointLength = 0,
			spotLength = 0,
			hemiLength = 0,
	
			dirCount = 0,
			pointCount = 0,
			spotCount = 0,
			hemiCount = 0,
	
			dirOffset = 0,
			pointOffset = 0,
			spotOffset = 0,
			hemiOffset = 0;
	
			for ( l = 0, ll = lights.length; l < ll; l ++ ) {
	
				light = lights[ l ];
	
				color = light.color;
				intensity = light.intensity;
				distance = light.distance;
	
				if ( light instanceof THREE.AmbientLight ) {
	
					if ( ! light.visible ) continue;
	
					r += color.r;
					g += color.g;
					b += color.b;
	
				} else if ( light instanceof THREE.DirectionalLight ) {
	
					dirCount += 1;
	
					if ( ! light.visible ) continue;
	
					_direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.transformDirection( viewMatrix );
	
					dirOffset = dirLength * 3;
	
					dirPositions[ dirOffset + 0 ] = _direction.x;
					dirPositions[ dirOffset + 1 ] = _direction.y;
					dirPositions[ dirOffset + 2 ] = _direction.z;
	
					setColorLinear( dirColors, dirOffset, color, intensity );
	
					dirLength += 1;
	
				} else if ( light instanceof THREE.PointLight ) {
	
					pointCount += 1;
	
					if ( ! light.visible ) continue;
	
					pointOffset = pointLength * 3;
	
					setColorLinear( pointColors, pointOffset, color, intensity );
	
					_vector3.setFromMatrixPosition( light.matrixWorld );
					_vector3.applyMatrix4( viewMatrix );
	
					pointPositions[ pointOffset + 0 ] = _vector3.x;
					pointPositions[ pointOffset + 1 ] = _vector3.y;
					pointPositions[ pointOffset + 2 ] = _vector3.z;
	
					// distance is 0 if decay is 0, because there is no attenuation at all.
					pointDistances[ pointLength ] = distance;
					pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;
	
					pointLength += 1;
	
				} else if ( light instanceof THREE.SpotLight ) {
	
					spotCount += 1;
	
					if ( ! light.visible ) continue;
	
					spotOffset = spotLength * 3;
	
					setColorLinear( spotColors, spotOffset, color, intensity );
	
					_direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.copy( _direction ).applyMatrix4( viewMatrix );
	
					spotPositions[ spotOffset + 0 ] = _vector3.x;
					spotPositions[ spotOffset + 1 ] = _vector3.y;
					spotPositions[ spotOffset + 2 ] = _vector3.z;
	
					spotDistances[ spotLength ] = distance;
	
					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.transformDirection( viewMatrix );
	
					spotDirections[ spotOffset + 0 ] = _direction.x;
					spotDirections[ spotOffset + 1 ] = _direction.y;
					spotDirections[ spotOffset + 2 ] = _direction.z;
	
					spotAnglesCos[ spotLength ] = Math.cos( light.angle );
					spotExponents[ spotLength ] = light.exponent;
					spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;
	
					spotLength += 1;
	
				} else if ( light instanceof THREE.HemisphereLight ) {
	
					hemiCount += 1;
	
					if ( ! light.visible ) continue;
	
					_direction.setFromMatrixPosition( light.matrixWorld );
					_direction.transformDirection( viewMatrix );
	
					hemiOffset = hemiLength * 3;
	
					hemiPositions[ hemiOffset + 0 ] = _direction.x;
					hemiPositions[ hemiOffset + 1 ] = _direction.y;
					hemiPositions[ hemiOffset + 2 ] = _direction.z;
	
					skyColor = light.color;
					groundColor = light.groundColor;
	
					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );
	
					hemiLength += 1;
	
				}
	
			}
	
			// null eventual remains from removed lights
			// (this is to avoid if in shader)
	
			for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
			for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
			for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;
	
			zlights.directional.length = dirLength;
			zlights.point.length = pointLength;
			zlights.spot.length = spotLength;
			zlights.hemi.length = hemiLength;
	
			zlights.ambient[ 0 ] = r;
			zlights.ambient[ 1 ] = g;
			zlights.ambient[ 2 ] = b;
	
		}
	
		// GL state setting
	
		this.setFaceCulling = function ( cullFace, frontFaceDirection ) {
	
			if ( cullFace === THREE.CullFaceNone ) {
	
				state.disable( _gl.CULL_FACE );
	
			} else {
	
				if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {
	
					_gl.frontFace( _gl.CW );
	
				} else {
	
					_gl.frontFace( _gl.CCW );
	
				}
	
				if ( cullFace === THREE.CullFaceBack ) {
	
					_gl.cullFace( _gl.BACK );
	
				} else if ( cullFace === THREE.CullFaceFront ) {
	
					_gl.cullFace( _gl.FRONT );
	
				} else {
	
					_gl.cullFace( _gl.FRONT_AND_BACK );
	
				}
	
				state.enable( _gl.CULL_FACE );
	
			}
	
		};
	
		// Textures
	
		function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {
	
			var extension;
	
			if ( isImagePowerOfTwo ) {
	
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );
	
				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );
	
			} else {
	
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
	
				if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {
	
					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );
	
				}
	
				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );
	
				if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {
	
					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );
	
				}
	
			}
	
			extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
			if ( extension ) {
	
				if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
				if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;
	
				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {
	
					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;
	
				}
	
			}
	
		}
	
		function uploadTexture( textureProperties, texture, slot ) {
	
			if ( textureProperties.__webglInit === undefined ) {
	
				textureProperties.__webglInit = true;
	
				texture.addEventListener( 'dispose', onTextureDispose );
	
				textureProperties.__webglTexture = _gl.createTexture();
	
				_infoMemory.textures ++;
	
			}
	
			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
	
			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
	
			texture.image = clampToMaxSize( texture.image, capabilities.maxTextureSize );
	
			if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false ) {
	
				texture.image = makePowerOfTwo( texture.image );
	
			}
	
			var image = texture.image,
			isImagePowerOfTwo = isPowerOfTwo( image ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );
	
			setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );
	
			var mipmap, mipmaps = texture.mipmaps;
	
			if ( texture instanceof THREE.DataTexture ) {
	
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
	
				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {
	
					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
					}
	
					texture.generateMipmaps = false;
	
				} else {
	
					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );
	
				}
	
			} else if ( texture instanceof THREE.CompressedTexture ) {
	
				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
					mipmap = mipmaps[ i ];
	
					if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {
	
						if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
	
							state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
						} else {
	
							console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );
	
						}
	
					} else {
	
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
					}
	
				}
	
			} else {
	
				// regular Texture (image, video, canvas)
	
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
	
				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {
	
					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );
	
					}
	
					texture.generateMipmaps = false;
	
				} else {
	
					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );
	
				}
	
			}
	
			if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
	
			textureProperties.__version = texture.version;
	
			if ( texture.onUpdate ) texture.onUpdate( texture );
	
		}
	
		this.setTexture = function ( texture, slot ) {
	
			var textureProperties = properties.get( texture );
	
			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
				var image = texture.image;
	
				if ( image === undefined ) {
	
					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
					return;
	
				}
	
				if ( image.complete === false ) {
	
					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
					return;
	
				}
	
				uploadTexture( textureProperties, texture, slot );
	
				return;
	
			}
	
			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
	
		};
	
		function clampToMaxSize ( image, maxSize ) {
	
			if ( image.width > maxSize || image.height > maxSize ) {
	
				// Warning: Scaling through the canvas will only work with images that use
				// premultiplied alpha.
	
				var scale = maxSize / Math.max( image.width, image.height );
	
				var canvas = document.createElement( 'canvas' );
				canvas.width = Math.floor( image.width * scale );
				canvas.height = Math.floor( image.height * scale );
	
				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );
	
				console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
	
				return canvas;
	
			}
	
			return image;
	
		}
	
		function isPowerOfTwo( image ) {
	
			return THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );
	
		}
	
		function textureNeedsPowerOfTwo( texture ) {
	
			if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;
			if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;
	
			return false;
	
		}
	
		function makePowerOfTwo( image ) {
	
			if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {
	
				var canvas = document.createElement( 'canvas' );
				canvas.width = THREE.Math.nearestPowerOfTwo( image.width );
				canvas.height = THREE.Math.nearestPowerOfTwo( image.height );
	
				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, canvas.width, canvas.height );
	
				console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
	
				return canvas;
	
			}
	
			return image;
	
		}
	
		function setCubeTexture ( texture, slot ) {
	
			var textureProperties = properties.get( texture );
	
			if ( texture.image.length === 6 ) {
	
				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
					if ( ! textureProperties.__image__webglTextureCube ) {
	
						texture.addEventListener( 'dispose', onTextureDispose );
	
						textureProperties.__image__webglTextureCube = _gl.createTexture();
	
						_infoMemory.textures ++;
	
					}
	
					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
	
					_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
	
					var isCompressed = texture instanceof THREE.CompressedTexture;
					var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;
	
					var cubeImage = [];
	
					for ( var i = 0; i < 6; i ++ ) {
	
						if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {
	
							cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );
	
						} else {
	
							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];
	
						}
	
					}
	
					var image = cubeImage[ 0 ],
					isImagePowerOfTwo = isPowerOfTwo( image ),
					glFormat = paramThreeToGL( texture.format ),
					glType = paramThreeToGL( texture.type );
	
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );
	
					for ( var i = 0; i < 6; i ++ ) {
	
						if ( ! isCompressed ) {
	
							if ( isDataTexture ) {
	
								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );
	
							} else {
	
								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );
	
							}
	
						} else {
	
							var mipmap, mipmaps = cubeImage[ i ].mipmaps;
	
							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {
	
								mipmap = mipmaps[ j ];
	
								if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {
	
									if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
	
										state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
									} else {
	
										console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );
	
									}
	
								} else {
	
									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
								}
	
							}
	
						}
	
					}
	
					if ( texture.generateMipmaps && isImagePowerOfTwo ) {
	
						_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
	
					}
	
					textureProperties.__version = texture.version;
	
					if ( texture.onUpdate ) texture.onUpdate( texture );
	
				} else {
	
					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
	
				}
	
			}
	
		}
	
		function setCubeTextureDynamic ( texture, slot ) {
	
			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );
	
		}
	
		// Render targets
	
		function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {
	
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
	
		}
	
		function setupRenderBuffer ( renderbuffer, renderTarget ) {
	
			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
	
			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
			/* For some reason this is not working. Defaulting to RGBA4.
			} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
			*/
	
			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
			} else {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );
	
			}
	
		}
	
		this.setRenderTarget = function ( renderTarget ) {
	
			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
	
			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {
	
				var renderTargetProperties = properties.get( renderTarget );
				var textureProperties = properties.get( renderTarget.texture );
	
				if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
				if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;
	
				renderTarget.addEventListener( 'dispose', onRenderTargetDispose );
	
				textureProperties.__webglTexture = _gl.createTexture();
	
				_infoMemory.textures ++;
	
				// Setup texture, create render and frame buffers
	
				var isTargetPowerOfTwo = isPowerOfTwo( renderTarget ),
					glFormat = paramThreeToGL( renderTarget.texture.format ),
					glType = paramThreeToGL( renderTarget.texture.type );
	
				if ( isCube ) {
	
					renderTargetProperties.__webglFramebuffer = [];
					renderTargetProperties.__webglRenderbuffer = [];
	
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
	
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );
	
					for ( var i = 0; i < 6; i ++ ) {
	
						renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
						renderTargetProperties.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();
						state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
	
						setupFrameBuffer( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
						setupRenderBuffer( renderTargetProperties.__webglRenderbuffer[ i ], renderTarget );
	
					}
	
					if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
	
				} else {
	
					renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
	
					if ( renderTarget.shareDepthFrom ) {
	
						renderTargetProperties.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;
	
					} else {
	
						renderTargetProperties.__webglRenderbuffer = _gl.createRenderbuffer();
	
					}
	
					state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
	
					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
	
					setupFrameBuffer( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );
	
					if ( renderTarget.shareDepthFrom ) {
	
						if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {
	
							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );
	
						} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );
	
						}
	
					} else {
	
						setupRenderBuffer( renderTargetProperties.__webglRenderbuffer, renderTarget );
	
					}
	
					if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
	
				}
	
				// Release everything
	
				if ( isCube ) {
	
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );
	
				} else {
	
					state.bindTexture( _gl.TEXTURE_2D, null );
	
				}
	
				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	
			}
	
			var framebuffer, width, height, vx, vy;
	
			if ( renderTarget ) {
	
				var renderTargetProperties = properties.get( renderTarget );
	
				if ( isCube ) {
	
					framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];
	
				} else {
	
					framebuffer = renderTargetProperties.__webglFramebuffer;
	
				}
	
				width = renderTarget.width;
				height = renderTarget.height;
	
				vx = 0;
				vy = 0;
	
			} else {
	
				framebuffer = null;
	
				width = _viewportWidth;
				height = _viewportHeight;
	
				vx = _viewportX;
				vy = _viewportY;
	
			}
	
			if ( framebuffer !== _currentFramebuffer ) {
	
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_gl.viewport( vx, vy, width, height );
	
				_currentFramebuffer = framebuffer;
	
			}
	
			if ( isCube ) {
	
				var textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, 0 );
	
			}
	
			_currentWidth = width;
			_currentHeight = height;
	
		};
	
		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {
	
			if ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {
	
				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;
	
			}
	
			var framebuffer = properties.get( renderTarget ).__webglFramebuffer;
	
			if ( framebuffer ) {
	
				var restore = false;
	
				if ( framebuffer !== _currentFramebuffer ) {
	
					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
	
					restore = true;
	
				}
	
				try {
	
					var texture = renderTarget.texture;
	
					if ( texture.format !== THREE.RGBAFormat
						&& paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {
	
						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;
	
					}
	
					if ( texture.type !== THREE.UnsignedByteType
						&& paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE )
						&& ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) )
						&& ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {
	
						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;
	
					}
	
					if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {
	
						_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );
	
					} else {
	
						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );
	
					}
	
				} finally {
	
					if ( restore ) {
	
						_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );
	
					}
	
				}
	
			}
	
		};
	
		function updateRenderTargetMipmap( renderTarget ) {
	
			var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
			var texture = properties.get( renderTarget.texture ).__webglTexture;
	
			state.bindTexture( target, texture );
			_gl.generateMipmap( target );
			state.bindTexture( target, null );
	
		}
	
		// Fallback filters for non-power-of-2 textures
	
		function filterFallback ( f ) {
	
			if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {
	
				return _gl.NEAREST;
	
			}
	
			return _gl.LINEAR;
	
		}
	
		// Map three.js constants to WebGL constants
	
		function paramThreeToGL ( p ) {
	
			var extension;
	
			if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
			if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
			if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;
	
			if ( p === THREE.NearestFilter ) return _gl.NEAREST;
			if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
			if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;
	
			if ( p === THREE.LinearFilter ) return _gl.LINEAR;
			if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
			if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;
	
			if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
			if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;
	
			if ( p === THREE.ByteType ) return _gl.BYTE;
			if ( p === THREE.ShortType ) return _gl.SHORT;
			if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
			if ( p === THREE.IntType ) return _gl.INT;
			if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
			if ( p === THREE.FloatType ) return _gl.FLOAT;
	
			extension = extensions.get( 'OES_texture_half_float' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;
	
			}
	
			if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
			if ( p === THREE.RGBFormat ) return _gl.RGB;
			if ( p === THREE.RGBAFormat ) return _gl.RGBA;
			if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
			if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
	
			if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
			if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
			if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;
	
			if ( p === THREE.ZeroFactor ) return _gl.ZERO;
			if ( p === THREE.OneFactor ) return _gl.ONE;
			if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
			if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
			if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
			if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
			if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
			if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;
	
			if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
			if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
			if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;
	
			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
	
			}
	
			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
	
			}
	
			extension = extensions.get( 'EXT_blend_minmax' );
	
			if ( extension !== null ) {
	
				if ( p === THREE.MinEquation ) return extension.MIN_EXT;
				if ( p === THREE.MaxEquation ) return extension.MAX_EXT;
	
			}
	
			return 0;
	
		}
	
		// DEPRECATED
	
		this.supportsFloatTextures = function () {
	
			console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
			return extensions.get( 'OES_texture_float' );
	
		};
	
		this.supportsHalfFloatTextures = function () {
	
			console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
			return extensions.get( 'OES_texture_half_float' );
	
		};
	
		this.supportsStandardDerivatives = function () {
	
			console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
			return extensions.get( 'OES_standard_derivatives' );
	
		};
	
		this.supportsCompressedTextureS3TC = function () {
	
			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
			return extensions.get( 'WEBGL_compressed_texture_s3tc' );
	
		};
	
		this.supportsCompressedTexturePVRTC = function () {
	
			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
			return extensions.get( 'WEBGL_compressed_texture_pvrtc' );
	
		};
	
		this.supportsBlendMinMax = function () {
	
			console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
			return extensions.get( 'EXT_blend_minmax' );
	
		};
	
		this.supportsVertexTextures = function () {
	
			return capabilities.vertexTextures;
	
		};
	
		this.supportsInstancedArrays = function () {
	
			console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
			return extensions.get( 'ANGLE_instanced_arrays' );
	
		};
	
		//
	
		this.initMaterial = function () {
	
			console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
	
		};
	
		this.addPrePlugin = function () {
	
			console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
	
		};
	
		this.addPostPlugin = function () {
	
			console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
	
		};
	
		this.updateShadowMap = function () {
	
			console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
	
		};
	
		Object.defineProperties( this, {
			shadowMapEnabled: {
				get: function () {
	
					return shadowMap.enabled;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
					shadowMap.enabled = value;
	
				}
			},
			shadowMapType: {
				get: function () {
	
					return shadowMap.type;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
					shadowMap.type = value;
	
				}
			},
			shadowMapCullFace: {
				get: function () {
	
					return shadowMap.cullFace;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
					shadowMap.cullFace = value;
	
				}
			},
			shadowMapDebug: {
				get: function () {
	
					return shadowMap.debug;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.' );
					shadowMap.debug = value;
	
				}
			}
		} );
	
	};
	
	// File:src/renderers/WebGLRenderTarget.js
	
	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.WebGLRenderTarget = function ( width, height, options ) {
	
		this.uuid = THREE.Math.generateUUID();
	
		this.width = width;
		this.height = height;
	
		options = options || {};
	
		if ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;
	
		this.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy );
	
		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
	
		this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;
	
	};
	
	THREE.WebGLRenderTarget.prototype = {
	
		constructor: THREE.WebGLRenderTarget,
	
		get wrapS() {
	
			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
	
			return this.texture.wrapS;
	
		},
	
		set wrapS( value ) {
	
			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
	
			this.texture.wrapS = value;
	
		},
	
		get wrapT() {
	
			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
	
			return this.texture.wrapT;
	
		},
	
		set wrapT( value ) {
	
			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
	
			this.texture.wrapT = value;
	
		},
	
		get magFilter() {
	
			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
	
			return this.texture.magFilter;
	
		},
	
		set magFilter( value ) {
	
			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
	
			this.texture.magFilter = value;
	
		},
	
		get minFilter() {
	
			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
	
			return this.texture.minFilter;
	
		},
	
		set minFilter( value ) {
	
			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
	
			this.texture.minFilter = value;
	
		},
	
		get anisotropy() {
	
			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
	
			return this.texture.anisotropy;
	
		},
	
		set anisotropy( value ) {
	
			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
	
			this.texture.anisotropy = value;
	
		},
	
		get offset() {
	
			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
	
			return this.texture.offset;
	
		},
	
		set offset( value ) {
	
			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
	
			this.texture.offset = value;
	
		},
	
		get repeat() {
	
			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
	
			return this.texture.repeat;
	
		},
	
		set repeat( value ) {
	
			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
	
			this.texture.repeat = value;
	
		},
	
		get format() {
	
			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
	
			return this.texture.format;
	
		},
	
		set format( value ) {
	
			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
	
			this.texture.format = value;
	
		},
	
		get type() {
	
			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
	
			return this.texture.type;
	
		},
	
		set type( value ) {
	
			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
	
			this.texture.type = value;
	
		},
	
		get generateMipmaps() {
	
			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
	
			return this.texture.generateMipmaps;
	
		},
	
		set generateMipmaps( value ) {
	
			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
	
			this.texture.generateMipmaps = value;
	
		},
	
		//
	
		setSize: function ( width, height ) {
	
			if ( this.width !== width || this.height !== height ) {
	
				this.width = width;
				this.height = height;
	
				this.dispose();
	
			}
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.width = source.width;
			this.height = source.height;
	
			this.texture = source.texture.clone();
	
			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
	
			this.shareDepthFrom = source.shareDepthFrom;
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );
	
	// File:src/renderers/WebGLRenderTargetCube.js
	
	/**
	 * @author alteredq / http://alteredqualia.com
	 */
	
	THREE.WebGLRenderTargetCube = function ( width, height, options ) {
	
		THREE.WebGLRenderTarget.call( this, width, height, options );
	
		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
	
	};
	
	THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
	THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;
	
	// File:src/renderers/webgl/WebGLBufferRenderer.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {
	
		var mode;
	
		function setMode( value ) {
	
			mode = value;
	
		}
	
		function render( start, count ) {
	
			_gl.drawArrays( mode, start, count );
	
			_infoRender.calls ++;
			_infoRender.vertices += count;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;
	
		}
	
		function renderInstances( geometry ) {
	
			var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
			if ( extension === null ) {
	
				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;
	
			}
	
			var position = geometry.attributes.position;
	
			if ( position instanceof THREE.InterleavedBufferAttribute ) {
	
				extension.drawArraysInstancedANGLE( mode, 0, position.data.count, geometry.maxInstancedCount );
	
			} else {
	
				extension.drawArraysInstancedANGLE( mode, 0, position.count, geometry.maxInstancedCount );
	
			}
	
		}
	
		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;
	
	};
	
	// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {
	
		var mode;
	
		function setMode( value ) {
	
			mode = value;
	
		}
	
		var type, size;
	
		function setIndex( index ) {
	
			if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {
	
				type = _gl.UNSIGNED_INT;
				size = 4;
	
			} else {
	
				type = _gl.UNSIGNED_SHORT;
				size = 2;
	
			}
	
		}
	
		function render( start, count ) {
	
			_gl.drawElements( mode, count, type, start * size );
	
			_infoRender.calls ++;
			_infoRender.vertices += count;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;
	
		}
	
		function renderInstances( geometry ) {
	
			var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
			if ( extension === null ) {
	
				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;
	
			}
	
			var index = geometry.index;
	
			extension.drawElementsInstancedANGLE( mode, index.array.length, type, 0, geometry.maxInstancedCount );
	
		}
	
		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;
	
	};
	
	// File:src/renderers/webgl/WebGLExtensions.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLExtensions = function ( gl ) {
	
		var extensions = {};
	
		this.get = function ( name ) {
	
			if ( extensions[ name ] !== undefined ) {
	
				return extensions[ name ];
	
			}
	
			var extension;
	
			switch ( name ) {
	
				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;
	
				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;
	
				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;
	
				default:
					extension = gl.getExtension( name );
	
			}
	
			if ( extension === null ) {
	
				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );
	
			}
	
			extensions[ name ] = extension;
	
			return extension;
	
		};
	
	};
	
	// File:src/renderers/webgl/WebGLCapabilities.js
	
	THREE.WebGLCapabilities = function ( gl, extensions, parameters ) {
	
		function getMaxPrecision( precision ) {
	
			if ( precision === 'highp' ) {
	
				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {
	
					return 'highp';
	
				}
	
				precision = 'mediump';
	
			}
	
			if ( precision === 'mediump' ) {
	
				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {
	
					return 'mediump';
	
				}
	
			}
	
			return 'lowp';
	
		}
	
		this.getMaxPrecision = getMaxPrecision;
	
		this.precision = parameters.precision !== undefined ? parameters.precision : 'highp',
		this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;
	
		this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
		this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
		this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );
	
		this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
		this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
		this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );
	
		this.vertexTextures = this.maxVertexTextures > 0;
		this.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
		this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
	
		var _maxPrecision = getMaxPrecision( this.precision );
	
		if ( _maxPrecision !== this.precision ) {
	
			console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
			this.precision = _maxPrecision;
	
		}
	
		if ( this.logarithmicDepthBuffer ) {
	
			this.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );
	
		}
	
	};
	
	// File:src/renderers/webgl/WebGLGeometries.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLGeometries = function ( gl, properties, info ) {
	
		var geometries = {};
	
		function get( object ) {
	
			var geometry = object.geometry;
	
			if ( geometries[ geometry.id ] !== undefined ) {
	
				return geometries[ geometry.id ];
	
			}
	
			geometry.addEventListener( 'dispose', onGeometryDispose );
	
			var buffergeometry;
	
			if ( geometry instanceof THREE.BufferGeometry ) {
	
				buffergeometry = geometry;
	
			} else if ( geometry instanceof THREE.Geometry ) {
	
				if ( geometry._bufferGeometry === undefined ) {
	
					geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );
	
				}
	
				buffergeometry = geometry._bufferGeometry;
	
			}
	
			geometries[ geometry.id ] = buffergeometry;
	
			info.memory.geometries ++;
	
			return buffergeometry;
	
		}
	
		function onGeometryDispose( event ) {
	
			var geometry = event.target;
			var buffergeometry = geometries[ geometry.id ];
	
			deleteAttributes( buffergeometry.attributes );
	
			geometry.removeEventListener( 'dispose', onGeometryDispose );
	
			delete geometries[ geometry.id ];
	
			var property = properties.get( geometry );
			if ( property.wireframe ) deleteAttribute( property.wireframe );
	
			info.memory.geometries --;
	
		}
	
		function getAttributeBuffer( attribute ) {
	
			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {
	
				return properties.get( attribute.data ).__webglBuffer;
	
			}
	
			return properties.get( attribute ).__webglBuffer;
	
		}
	
		function deleteAttribute( attribute ) {
	
			var buffer = getAttributeBuffer( attribute );
	
			if ( buffer !== undefined ) {
	
				gl.deleteBuffer( buffer );
				removeAttributeBuffer( attribute );
	
			}
	
		}
	
		function deleteAttributes( attributes ) {
	
			for ( var name in attributes ) {
	
				deleteAttribute( attributes[ name ] );
	
			}
	
		}
	
		function removeAttributeBuffer( attribute ) {
	
			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {
	
				properties.delete( attribute.data );
	
			} else {
	
				properties.delete( attribute );
	
			}
	
		}
	
		this.get = get;
	
	};
	
	// File:src/renderers/webgl/WebGLObjects.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLObjects = function ( gl, properties, info ) {
	
		var geometries = new THREE.WebGLGeometries( gl, properties, info );
	
		//
	
		function update( object ) {
	
			// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.
	
			var geometry = geometries.get( object );
	
			if ( object.geometry instanceof THREE.Geometry ) {
	
				geometry.updateFromObject( object );
	
			}
	
			var index = geometry.index;
			var attributes = geometry.attributes;
	
			if ( index !== null ) {
	
				updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );
	
			}
	
			for ( var name in attributes ) {
	
				updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );
	
			}
	
			// morph targets
	
			var morphAttributes = geometry.morphAttributes;
	
			for ( var name in morphAttributes ) {
	
				var array = morphAttributes[ name ];
	
				for ( var i = 0, l = array.length; i < l; i ++ ) {
	
					updateAttribute( array[ i ], gl.ARRAY_BUFFER );
	
				}
	
			}
	
			return geometry;
	
		}
	
		function updateAttribute( attribute, bufferType ) {
	
			var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;
	
			var attributeProperties = properties.get( data );
	
			if ( attributeProperties.__webglBuffer === undefined ) {
	
				createBuffer( attributeProperties, data, bufferType );
	
			} else if ( attributeProperties.version !== data.version ) {
	
				updateBuffer( attributeProperties, data, bufferType );
	
			}
	
		}
	
		function createBuffer( attributeProperties, data, bufferType ) {
	
			attributeProperties.__webglBuffer = gl.createBuffer();
			gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );
	
			var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
	
			gl.bufferData( bufferType, data.array, usage );
	
			attributeProperties.version = data.version;
	
		}
	
		function updateBuffer( attributeProperties, data, bufferType ) {
	
			gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );
	
			if ( data.dynamic === false || data.updateRange.count === - 1 ) {
	
				// Not using update ranges
	
				gl.bufferSubData( bufferType, 0, data.array );
	
			} else if ( data.updateRange.count === 0 ) {
	
				console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );
	
			} else {
	
				gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
								  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );
	
				data.updateRange.count = 0; // reset range
	
			}
	
			attributeProperties.version = data.version;
	
		}
	
		function getAttributeBuffer( attribute ) {
	
			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {
	
				return properties.get( attribute.data ).__webglBuffer;
	
			}
	
			return properties.get( attribute ).__webglBuffer;
	
		}
	
		function getWireframeAttribute( geometry ) {
	
			var property = properties.get( geometry );
	
			if ( property.wireframe !== undefined ) {
	
				return property.wireframe;
	
			}
	
			var indices = [];
	
			var index = geometry.index;
			var attributes = geometry.attributes;
			var position = attributes.position;
	
			// console.time( 'wireframe' );
	
			if ( index !== null ) {
	
				var edges = {};
				var array = index.array;
	
				for ( var i = 0, l = array.length; i < l; i += 3 ) {
	
					var a = array[ i + 0 ];
					var b = array[ i + 1 ];
					var c = array[ i + 2 ];
	
					if ( checkEdge( edges, a, b ) ) indices.push( a, b );
					if ( checkEdge( edges, b, c ) ) indices.push( b, c );
					if ( checkEdge( edges, c, a ) ) indices.push( c, a );
	
				}
	
			} else {
	
				var array = attributes.position.array;
	
				for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {
	
					var a = i + 0;
					var b = i + 1;
					var c = i + 2;
	
					indices.push( a, b, b, c, c, a );
	
				}
	
			}
	
			// console.timeEnd( 'wireframe' );
	
			var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
			var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );
	
			updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );
	
			property.wireframe = attribute;
	
			return attribute;
	
		}
	
		function checkEdge( edges, a, b ) {
	
			if ( a > b ) {
	
				var tmp = a;
				a = b;
				b = tmp;
	
			}
	
			var list = edges[ a ];
	
			if ( list === undefined ) {
	
				edges[ a ] = [ b ];
				return true;
	
			} else if ( list.indexOf( b ) === -1 ) {
	
				list.push( b );
				return true;
	
			}
	
			return false;
	
		}
	
		this.getAttributeBuffer = getAttributeBuffer;
		this.getWireframeAttribute = getWireframeAttribute;
	
		this.update = update;
	
	};
	
	// File:src/renderers/webgl/WebGLProgram.js
	
	THREE.WebGLProgram = ( function () {
	
		var programIdCount = 0;
	
		function generateDefines( defines ) {
	
			var chunks = [];
	
			for ( var name in defines ) {
	
				var value = defines[ name ];
	
				if ( value === false ) continue;
	
				chunks.push( '#define ' + name + ' ' + value );
	
			}
	
			return chunks.join( '\n' );
	
		}
	
		function fetchUniformLocations( gl, program, identifiers ) {
	
			var uniforms = {};
	
			var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );
	
			for ( var i = 0; i < n; i ++ ) {
	
				var info = gl.getActiveUniform( program, i );
				var name = info.name;
				var location = gl.getUniformLocation( program, name );
	
				// console.log("THREE.WebGLProgram: ACTIVE UNIFORM:", name);
	
				var suffixPos = name.lastIndexOf( '[0]' );
				if ( suffixPos !== - 1 && suffixPos === name.length - 3 ) {
	
					uniforms[ name.substr( 0, suffixPos ) ] = location;
	
				}
	
				uniforms[ name ] = location;
	
			}
	
			return uniforms;
	
		}
	
		function fetchAttributeLocations( gl, program, identifiers ) {
	
			var attributes = {};
	
			var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );
	
			for ( var i = 0; i < n; i ++ ) {
	
				var info = gl.getActiveAttrib( program, i );
				var name = info.name;
	
				// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );
	
				attributes[ name ] = gl.getAttribLocation( program, name );
	
			}
	
			return attributes;
	
		}
	
		function filterEmptyLine( string ) {
	
			return string !== '';
	
		}
	
		return function WebGLProgram( renderer, code, material, parameters ) {
	
			var gl = renderer.context;
	
			var defines = material.defines;
	
			var vertexShader = material.__webglShader.vertexShader;
			var fragmentShader = material.__webglShader.fragmentShader;
	
			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
	
			if ( parameters.shadowMapType === THREE.PCFShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
	
			} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
	
			}
	
			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
			var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
	
			if ( parameters.envMap ) {
	
				switch ( material.envMap.mapping ) {
	
					case THREE.CubeReflectionMapping:
					case THREE.CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;
	
					case THREE.EquirectangularReflectionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;
	
					case THREE.SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;
	
				}
	
				switch ( material.envMap.mapping ) {
	
					case THREE.CubeRefractionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;
	
				}
	
				switch ( material.combine ) {
	
					case THREE.MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;
	
					case THREE.MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;
	
					case THREE.AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;
	
				}
	
			}
	
			var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;
	
			// console.log( 'building new program ' );
	
			//
	
			var customDefines = generateDefines( defines );
	
			//
	
			var program = gl.createProgram();
	
			var prefixVertex, prefixFragment;
	
			if ( material instanceof THREE.RawShaderMaterial ) {
	
				prefixVertex = '';
				prefixFragment = '';
	
			} else {
	
				prefixVertex = [
	
					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',
	
					'#define SHADER_NAME ' + material.__webglShader.name,
	
					customDefines,
	
					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
	
					renderer.gammaInput ? '#define GAMMA_INPUT' : '',
					renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
					'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
					'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
					'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
					'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
					'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,
	
					'#define MAX_SHADOWS ' + parameters.maxShadows,
	
					'#define MAX_BONES ' + parameters.maxBones,
	
					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
	
					parameters.flatShading ? '#define FLAT_SHADED' : '',
	
					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
	
					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',
	
					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
					parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
					parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',
	
					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
	
					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
	
					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',
	
					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',
	
					'#ifdef USE_COLOR',
	
					'	attribute vec3 color;',
	
					'#endif',
	
					'#ifdef USE_MORPHTARGETS',
	
					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',
	
					'	#ifdef USE_MORPHNORMALS',
	
					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',
	
					'	#else',
	
					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',
	
					'	#endif',
	
					'#endif',
	
					'#ifdef USE_SKINNING',
	
					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',
	
					'#endif',
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
				prefixFragment = [
	
					parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ? '#extension GL_OES_standard_derivatives : enable' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
	
					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',
	
					'#define SHADER_NAME ' + material.__webglShader.name,
	
					customDefines,
	
					'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
					'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
					'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
					'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,
	
					'#define MAX_SHADOWS ' + parameters.maxShadows,
	
					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
	
					renderer.gammaInput ? '#define GAMMA_INPUT' : '',
					renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
					'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',
	
					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
	
					parameters.flatShading ? '#define FLAT_SHADED' : '',
	
					parameters.metal ? '#define METAL' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',
	
					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
					parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
					parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',
	
					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
			}
	
			var vertexGlsl = prefixVertex + vertexShader;
			var fragmentGlsl = prefixFragment + fragmentShader;
	
			var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
			var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );
	
			gl.attachShader( program, glVertexShader );
			gl.attachShader( program, glFragmentShader );
	
			// Force a particular attribute to index 0.
	
			if ( material.index0AttributeName !== undefined ) {
	
				gl.bindAttribLocation( program, 0, material.index0AttributeName );
	
			} else if ( parameters.morphTargets === true ) {
	
				// programs with morphTargets displace position out of attribute 0
				gl.bindAttribLocation( program, 0, 'position' );
	
			}
	
			gl.linkProgram( program );
	
			var programLog = gl.getProgramInfoLog( program );
			var vertexLog = gl.getShaderInfoLog( glVertexShader );
			var fragmentLog = gl.getShaderInfoLog( glFragmentShader );
	
			var runnable = true;
			var haveDiagnostics = true;
	
			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {
	
				runnable = false;
	
				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );
	
			} else if ( programLog !== '' ) {
	
				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );
	
			} else if ( vertexLog === '' || fragmentLog === '' ) {
	
				haveDiagnostics = false;
	
			}
	
			if ( haveDiagnostics ) {
	
				this.diagnostics = {
	
					runnable: runnable,
					material: material,
	
					programLog: programLog,
	
					vertexShader: {
	
						log: vertexLog,
						prefix: prefixVertex
	
					},
	
					fragmentShader: {
	
						log: fragmentLog,
						prefix: prefixFragment
	
					}
	
				};
	
			}
	
			// clean up
	
			gl.deleteShader( glVertexShader );
			gl.deleteShader( glFragmentShader );
	
			// set up caching for uniform locations
	
			var cachedUniforms;
	
			this.getUniforms = function() {
	
				if ( cachedUniforms === undefined ) {
	
					cachedUniforms = fetchUniformLocations( gl, program );
	
				}
	
				return cachedUniforms;
	
			};
	
			// set up caching for attribute locations
	
			var cachedAttributes;
	
			this.getAttributes = function() {
	
				if ( cachedAttributes === undefined ) {
	
					cachedAttributes = fetchAttributeLocations( gl, program );
	
				}
	
				return cachedAttributes;
	
			};
	
			// free resource
	
			this.destroy = function() {
	
				gl.deleteProgram( program );
				this.program = undefined;
	
			};
	
			// DEPRECATED
	
			Object.defineProperties( this, {
	
				uniforms: {
					get: function() {
	
						console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
						return this.getUniforms();
	
					}
				},
	
				attributes: {
					get: function() {
	
						console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
						return this.getAttributes();
	
					}
				}
	
			} );
	
	
			//
	
			this.id = programIdCount ++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;
	
			return this;
	
		};
	
	} )();
	
	// File:src/renderers/webgl/WebGLPrograms.js
	
	THREE.WebGLPrograms = function ( renderer, capabilities ) {
	
		var programs = [];
	
		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points'
		};
	
		var parameterNames = [
			"precision", "supportsVertexTextures", "map", "envMap", "envMapMode",
			"lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "specularMap",
			"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
			"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
			"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
			"maxMorphTargets", "maxMorphNormals", "maxDirLights", "maxPointLights",
			"maxSpotLights", "maxHemiLights", "maxShadows", "shadowMapEnabled", "pointLightShadows",
			"shadowMapType", "shadowMapDebug", "alphaTest", "metal", "doubleSided",
			"flipSided"
		];
	
	
		function allocateBones ( object ) {
	
			if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {
	
				return 1024;
	
			} else {
	
				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)
	
				var nVertexUniforms = capabilities.maxVertexUniforms;
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );
	
				var maxBones = nVertexMatrices;
	
				if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {
	
					maxBones = Math.min( object.skeleton.bones.length, maxBones );
	
					if ( maxBones < object.skeleton.bones.length ) {
	
						console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );
	
					}
	
				}
	
				return maxBones;
	
			}
	
		}
	
		function allocateLights( lights ) {
	
			var dirLights = 0;
			var pointLights = 0;
			var spotLights = 0;
			var hemiLights = 0;
	
			for ( var l = 0, ll = lights.length; l < ll; l ++ ) {
	
				var light = lights[ l ];
	
				if ( light.visible === false ) continue;
	
				if ( light instanceof THREE.DirectionalLight ) dirLights ++;
				if ( light instanceof THREE.PointLight ) pointLights ++;
				if ( light instanceof THREE.SpotLight ) spotLights ++;
				if ( light instanceof THREE.HemisphereLight ) hemiLights ++;
	
			}
	
			return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };
	
		}
	
		function allocateShadows( lights ) {
	
			var maxShadows = 0;
			var pointLightShadows = 0;
	
			for ( var l = 0, ll = lights.length; l < ll; l ++ ) {
	
				var light = lights[ l ];
	
				if ( ! light.castShadow ) continue;
	
				if ( light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight ) maxShadows ++;
				if ( light instanceof THREE.PointLight ) {
	
					maxShadows ++;
					pointLightShadows ++;
	
				}
	
			}
	
			return { 'maxShadows': maxShadows, 'pointLightShadows': pointLightShadows };
	
		}
	
		this.getParameters = function ( material, lights, fog, object ) {
	
			var shaderID = shaderIDs[ material.type ];
			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)
	
			var maxLightCount = allocateLights( lights );
			var allocatedShadows = allocateShadows( lights );
			var maxBones = allocateBones( object );
			var precision = renderer.getPrecision();
	
			if ( material.precision !== null ) {
	
				precision = capabilities.getMaxPrecision( material.precision );
	
				if ( precision !== material.precision ) {
	
					console.warn( 'THREE.WebGLRenderer.initMaterial:', material.precision, 'not supported, using', precision, 'instead.' );
	
				}
	
			}
	
			var parameters = {
	
				shaderID: shaderID,
	
				precision: precision,
				supportsVertexTextures: capabilities.vertexTextures,
	
				map: !! material.map,
				envMap: !! material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				lightMap: !! material.lightMap,
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				displacementMap: !! material.displacementMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,
	
				combine: material.combine,
	
				vertexColors: material.vertexColors,
	
				fog: fog,
				useFog: material.fog,
				fogExp: fog instanceof THREE.FogExp2,
	
				flatShading: material.shading === THREE.FlatShading,
	
				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
	
				skinning: material.skinning,
				maxBones: maxBones,
				useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
	
				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,
	
				maxDirLights: maxLightCount.directional,
				maxPointLights: maxLightCount.point,
				maxSpotLights: maxLightCount.spot,
				maxHemiLights: maxLightCount.hemi,
	
				maxShadows: allocatedShadows.maxShadows,
				pointLightShadows: allocatedShadows.pointLightShadows,
				shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && allocatedShadows.maxShadows > 0,
				shadowMapType: renderer.shadowMap.type,
				shadowMapDebug: renderer.shadowMap.debug,
	
				alphaTest: material.alphaTest,
				metal: material.metal,
				doubleSided: material.side === THREE.DoubleSide,
				flipSided: material.side === THREE.BackSide
	
			};
	
			return parameters;
	
		};
	
		this.getProgramCode = function ( material, parameters ) {
	
			var chunks = [];
	
			if ( parameters.shaderID ) {
	
				chunks.push( parameters.shaderID );
	
			} else {
	
				chunks.push( material.fragmentShader );
				chunks.push( material.vertexShader );
	
			}
	
			if ( material.defines !== undefined ) {
	
				for ( var name in material.defines ) {
	
					chunks.push( name );
					chunks.push( material.defines[ name ] );
	
				}
	
			}
	
			for ( var i = 0; i < parameterNames.length; i ++ ) {
	
				var parameterName = parameterNames[ i ];
				chunks.push( parameterName );
				chunks.push( parameters[ parameterName ] );
	
			}
	
			return chunks.join();
	
		};
	
		this.acquireProgram = function ( material, parameters, code ) {
	
			var program;
	
			// Check if code has been already compiled
			for ( var p = 0, pl = programs.length; p < pl; p ++ ) {
	
				var programInfo = programs[ p ];
	
				if ( programInfo.code === code ) {
	
					program = programInfo;
					++ program.usedTimes;
	
					break;
	
				}
	
			}
	
			if ( program === undefined ) {
	
				program = new THREE.WebGLProgram( renderer, code, material, parameters );
				programs.push( program );
	
			}
	
			return program;
	
		};
	
		this.releaseProgram = function( program ) {
	
			if ( -- program.usedTimes === 0 ) {
	
				// Remove from unordered set
				var i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();
	
				// Free WebGL resources
				program.destroy();
	
			}
	
		};
	
		// Exposed for resource monitoring & error feedback via renderer.info:
		this.programs = programs;
	
	};
	
	// File:src/renderers/webgl/WebGLProperties.js
	
	/**
	* @author fordacious / fordacious.github.io
	*/
	
	THREE.WebGLProperties = function () {
	
		var properties = {};
	
		this.get = function ( object ) {
	
			var uuid = object.uuid;
			var map = properties[ uuid ];
	
			if ( map === undefined ) {
	
				map = {};
				properties[ uuid ] = map;
	
			}
	
			return map;
	
		};
	
		this.delete = function ( object ) {
	
			delete properties[ object.uuid ];
	
		};
	
		this.clear = function () {
	
			properties = {};
	
		};
	
	};
	
	// File:src/renderers/webgl/WebGLShader.js
	
	THREE.WebGLShader = ( function () {
	
		function addLineNumbers( string ) {
	
			var lines = string.split( '\n' );
	
			for ( var i = 0; i < lines.length; i ++ ) {
	
				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];
	
			}
	
			return lines.join( '\n' );
	
		}
	
		return function WebGLShader( gl, type, string ) {
	
			var shader = gl.createShader( type );
	
			gl.shaderSource( shader, string );
			gl.compileShader( shader );
	
			if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {
	
				console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );
	
			}
	
			if ( gl.getShaderInfoLog( shader ) !== '' ) {
	
				console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );
	
			}
	
			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
	
			return shader;
	
		};
	
	} )();
	
	// File:src/renderers/webgl/WebGLShadowMap.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {
	
		var _gl = _renderer.context,
		_state = _renderer.state,
		_frustum = new THREE.Frustum(),
		_projScreenMatrix = new THREE.Matrix4(),
	
		_min = new THREE.Vector3(),
		_max = new THREE.Vector3(),
	
		_lookTarget = new THREE.Vector3(),
		_lightPositionWorld = new THREE.Vector3(),
	
		_renderList = [],
	
		_MorphingFlag = 1,
		_SkinningFlag = 2,
	
		_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,
	
		_depthMaterials = new Array( _NumberOfMaterialVariants ),
		_distanceMaterials = new Array( _NumberOfMaterialVariants );
	
		var cubeDirections = [
			new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),
			new THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )
		];
	
		var cubeUps = [
			new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),
			new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),	new THREE.Vector3( 0, 0, - 1 )
		];
	
		var cube2DViewPorts = [
			new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),
			new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()
		];
	
		var _vector4 = new THREE.Vector4();
	
		// init
	
		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );
	
		var distanceShader = THREE.ShaderLib[ "distanceRGBA" ];
		var distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );
	
		for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {
	
			var useMorphing = ( i & _MorphingFlag ) !== 0;
			var useSkinning = ( i & _SkinningFlag ) !== 0;
	
			var depthMaterial = new THREE.ShaderMaterial( {
				uniforms: depthUniforms,
				vertexShader: depthShader.vertexShader,
				fragmentShader: depthShader.fragmentShader,
				morphTargets: useMorphing,
				skinning: useSkinning
			} );
	
			depthMaterial._shadowPass = true;
	
			_depthMaterials[ i ] = depthMaterial;
	
			var distanceMaterial = new THREE.ShaderMaterial( {
				uniforms: distanceUniforms,
				vertexShader: distanceShader.vertexShader,
				fragmentShader: distanceShader.fragmentShader,
				morphTargets: useMorphing,
				skinning: useSkinning
			} );
	
			distanceMaterial._shadowPass = true;
	
			_distanceMaterials[ i ] = distanceMaterial;
	
		}
	
		//
	
		var scope = this;
	
		this.enabled = false;
	
		this.autoUpdate = true;
		this.needsUpdate = false;
	
		this.type = THREE.PCFShadowMap;
		this.cullFace = THREE.CullFaceFront;
	
		this.render = function ( scene ) {
	
			var faceCount, isPointLight;
	
			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;
	
			// Set GL state for depth map.
			_gl.clearColor( 1, 1, 1, 1 );
			_state.disable( _gl.BLEND );
			_state.enable( _gl.CULL_FACE );
			_gl.frontFace( _gl.CCW );
			_gl.cullFace( scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK );
			_state.setDepthTest( true );
	
			// save the existing viewport so it can be restored later
			_renderer.getViewport( _vector4 );
	
			// render depth map
	
			for ( var i = 0, il = _lights.length; i < il; i ++ ) {
	
				var light = _lights[ i ];
	
				if ( light.castShadow === true ) {
	
					var shadow = light.shadow;
					var shadowCamera = shadow.camera;
					var shadowMapSize = shadow.mapSize;
	
					if ( light instanceof THREE.PointLight ) {
	
						faceCount = 6;
						isPointLight = true;
	
						var vpWidth = shadowMapSize.x / 4.0;
						var vpHeight = shadowMapSize.y / 2.0;
	
						// These viewports map a cube-map onto a 2D texture with the
						// following orientation:
						//
						//  xzXZ
						//   y Y
						//
						// X - Positive x direction
						// x - Negative x direction
						// Y - Positive y direction
						// y - Negative y direction
						// Z - Positive z direction
						// z - Negative z direction
	
						// positive X
						cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
						// negative X
						cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
						// positive Z
						cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
						// negative Z
						cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
						// positive Y
						cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
						// negative Y
						cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );
	
					} else {
	
						faceCount = 1;
						isPointLight = false;
	
					}
	
					if ( shadow.map === null ) {
	
						var shadowFilter = THREE.LinearFilter;
	
						if ( scope.type === THREE.PCFSoftShadowMap ) {
	
							shadowFilter = THREE.NearestFilter;
	
						}
	
						var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };
	
						shadow.map = new THREE.WebGLRenderTarget( shadowMapSize.x, shadowMapSize.y, pars );
						shadow.matrix = new THREE.Matrix4();
	
						//
	
						if ( light instanceof THREE.SpotLight ) {
	
							shadowCamera.aspect = shadowMapSize.x / shadowMapSize.y;
	
						}
	
						shadowCamera.updateProjectionMatrix();
	
					}
	
					var shadowMap = shadow.map;
					var shadowMatrix = shadow.matrix;
	
					_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
					shadowCamera.position.copy( _lightPositionWorld );
	
					_renderer.setRenderTarget( shadowMap );
					_renderer.clear();
	
					// render shadow map for each cube face (if omni-directional) or
					// run a single pass if not
	
					for ( var face = 0; face < faceCount; face ++ ) {
	
						if ( isPointLight ) {
	
							_lookTarget.copy( shadowCamera.position );
							_lookTarget.add( cubeDirections[ face ] );
							shadowCamera.up.copy( cubeUps[ face ] );
							shadowCamera.lookAt( _lookTarget );
							var vpDimensions = cube2DViewPorts[ face ];
							_renderer.setViewport( vpDimensions.x, vpDimensions.y, vpDimensions.z, vpDimensions.w );
	
						} else {
	
							_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
							shadowCamera.lookAt( _lookTarget );
	
						}
	
						shadowCamera.updateMatrixWorld();
						shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );
	
						// compute shadow matrix
	
						shadowMatrix.set(
							0.5, 0.0, 0.0, 0.5,
							0.0, 0.5, 0.0, 0.5,
							0.0, 0.0, 0.5, 0.5,
							0.0, 0.0, 0.0, 1.0
						);
	
						shadowMatrix.multiply( shadowCamera.projectionMatrix );
						shadowMatrix.multiply( shadowCamera.matrixWorldInverse );
	
						// update camera matrices and frustum
	
						_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
						_frustum.setFromMatrix( _projScreenMatrix );
	
						// set object matrices & frustum culling
	
						_renderList.length = 0;
	
						projectObject( scene, shadowCamera );
	
						// render shadow map
						// render regular objects
	
						for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {
	
							var object = _renderList[ j ];
							var geometry = _objects.update( object );
							var material = object.material;
	
							if ( material instanceof THREE.MeshFaceMaterial ) {
	
								var groups = geometry.groups;
								var materials = material.materials;
	
								for ( var k = 0, kl = groups.length; k < kl; k ++ ) {
	
									var group = groups[ k ];
									var groupMaterial = materials[ group.materialIndex ];
	
									if ( groupMaterial.visible === true ) {
	
										var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
										_renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, depthMaterial, object, group );
	
									}
	
								}
	
							} else {
	
								var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
								_renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, depthMaterial, object, null );
	
							}
	
						}
	
					}
	
					// We must call _renderer.resetGLState() at the end of each iteration of
					// the light loop in order to force material updates for each light.
					_renderer.resetGLState();
	
				}
	
			}
	
			_renderer.setViewport( _vector4.x, _vector4.y, _vector4.z, _vector4.w );
	
			// Restore GL state.
			var clearColor = _renderer.getClearColor(),
			clearAlpha = _renderer.getClearAlpha();
			_renderer.setClearColor( clearColor, clearAlpha );
			_state.enable( _gl.BLEND );
	
			if ( scope.cullFace === THREE.CullFaceFront ) {
	
				_gl.cullFace( _gl.BACK );
	
			}
	
			_renderer.resetGLState();
	
			scope.needsUpdate = false;
	
		};
	
		function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {
	
			var geometry = object.geometry;
	
			var newMaterial = null;
	
			var materialVariants = _depthMaterials;
			var customMaterial = object.customDepthMaterial;
	
			if ( isPointLight ) {
	
				materialVariants = _distanceMaterials;
				customMaterial = object.customDistanceMaterial;
	
			}
	
			if ( ! customMaterial ) {
	
				var useMorphing = geometry.morphTargets !== undefined &&
						geometry.morphTargets.length > 0 && material.morphTargets;
	
				var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;
	
				var variantIndex = 0;
	
				if ( useMorphing ) variantIndex |= _MorphingFlag;
				if ( useSkinning ) variantIndex |= _SkinningFlag;
	
				newMaterial = materialVariants[ variantIndex ];
	
			} else {
	
				newMaterial = customMaterial;
	
			}
	
			newMaterial.visible = material.visible;
			newMaterial.wireframe = material.wireframe;
			newMaterial.wireframeLinewidth = material.wireframeLinewidth;
	
			if ( isPointLight && newMaterial.uniforms.lightPos !== undefined ) {
	
				newMaterial.uniforms.lightPos.value.copy( lightPositionWorld );
	
			}
	
			return newMaterial;
	
		}
	
		function projectObject( object, camera ) {
	
			if ( object.visible === false ) return;
	
			if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {
	
				if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {
	
					var material = object.material;
	
					if ( material.visible === true ) {
	
						object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
						_renderList.push( object );
	
					}
	
				}
	
			}
	
			var children = object.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				projectObject( children[ i ], camera );
	
			}
	
		}
	
	};
	
	// File:src/renderers/webgl/WebGLState.js
	
	/**
	* @author mrdoob / http://mrdoob.com/
	*/
	
	THREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {
	
		var _this = this;
	
		var newAttributes = new Uint8Array( 16 );
		var enabledAttributes = new Uint8Array( 16 );
		var attributeDivisors = new Uint8Array( 16 );
	
		var capabilities = {};
	
		var compressedTextureFormats = null;
	
		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
	
		var currentDepthFunc = null;
		var currentDepthWrite = null;
	
		var currentColorWrite = null;
	
		var currentFlipSided = null;
	
		var currentLineWidth = null;
	
		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;
	
		var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	
		var currentTextureSlot = undefined;
		var currentBoundTextures = {};
	
		this.init = function () {
	
			gl.clearColor( 0, 0, 0, 1 );
			gl.clearDepth( 1 );
			gl.clearStencil( 0 );
	
			this.enable( gl.DEPTH_TEST );
			gl.depthFunc( gl.LEQUAL );
	
			gl.frontFace( gl.CCW );
			gl.cullFace( gl.BACK );
			this.enable( gl.CULL_FACE );
	
			this.enable( gl.BLEND );
			gl.blendEquation( gl.FUNC_ADD );
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
	
		};
	
		this.initAttributes = function () {
	
			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {
	
				newAttributes[ i ] = 0;
	
			}
	
		};
	
		this.enableAttribute = function ( attribute ) {
	
			newAttributes[ attribute ] = 1;
	
			if ( enabledAttributes[ attribute ] === 0 ) {
	
				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;
	
			}
	
			if ( attributeDivisors[ attribute ] !== 0 ) {
	
				var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
				extension.vertexAttribDivisorANGLE( attribute, 0 );
				attributeDivisors[ attribute ] = 0;
	
			}
	
		};
	
		this.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {
	
			newAttributes[ attribute ] = 1;
	
			if ( enabledAttributes[ attribute ] === 0 ) {
	
				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;
	
			}
	
			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {
	
				extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;
	
			}
	
		};
	
		this.disableUnusedAttributes = function () {
	
			for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {
	
				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {
	
					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;
	
				}
	
			}
	
		};
	
		this.enable = function ( id ) {
	
			if ( capabilities[ id ] !== true ) {
	
				gl.enable( id );
				capabilities[ id ] = true;
	
			}
	
		};
	
		this.disable = function ( id ) {
	
			if ( capabilities[ id ] !== false ) {
	
				gl.disable( id );
				capabilities[ id ] = false;
	
			}
	
		};
	
		this.getCompressedTextureFormats = function () {
	
			if ( compressedTextureFormats === null ) {
	
				compressedTextureFormats = [];
	
				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {
	
					var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );
	
					for ( var i = 0; i < formats.length; i ++ ) {
	
						compressedTextureFormats.push( formats[ i ] );
	
					}
	
				}
	
			}
	
			return compressedTextureFormats;
	
		};
	
		this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {
	
			if ( blending !== currentBlending ) {
	
				if ( blending === THREE.NoBlending ) {
	
					this.disable( gl.BLEND );
	
				} else if ( blending === THREE.AdditiveBlending ) {
	
					this.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
	
				} else if ( blending === THREE.SubtractiveBlending ) {
	
					// TODO: Find blendFuncSeparate() combination
	
					this.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );
	
				} else if ( blending === THREE.MultiplyBlending ) {
	
					// TODO: Find blendFuncSeparate() combination
	
					this.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
	
				} else if ( blending === THREE.CustomBlending ) {
	
					this.enable( gl.BLEND );
	
				} else {
	
					this.enable( gl.BLEND );
					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
	
				}
	
				currentBlending = blending;
	
			}
	
			if ( blending === THREE.CustomBlending ) {
	
				blendEquationAlpha = blendEquationAlpha || blendEquation;
				blendSrcAlpha = blendSrcAlpha || blendSrc;
				blendDstAlpha = blendDstAlpha || blendDst;
	
				if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {
	
					gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );
	
					currentBlendEquation = blendEquation;
					currentBlendEquationAlpha = blendEquationAlpha;
	
				}
	
				if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {
	
					gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );
	
					currentBlendSrc = blendSrc;
					currentBlendDst = blendDst;
					currentBlendSrcAlpha = blendSrcAlpha;
					currentBlendDstAlpha = blendDstAlpha;
	
				}
	
			} else {
	
				currentBlendEquation = null;
				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendEquationAlpha = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;
	
			}
	
		};
	
		this.setDepthFunc = function ( depthFunc ) {
	
			if ( currentDepthFunc !== depthFunc ) {
	
				if ( depthFunc ) {
	
					switch ( depthFunc ) {
	
						case THREE.NeverDepth:
	
							gl.depthFunc( gl.NEVER );
							break;
	
						case THREE.AlwaysDepth:
	
							gl.depthFunc( gl.ALWAYS );
							break;
	
						case THREE.LessDepth:
	
							gl.depthFunc( gl.LESS );
							break;
	
						case THREE.LessEqualDepth:
	
							gl.depthFunc( gl.LEQUAL );
							break;
	
						case THREE.EqualDepth:
	
							gl.depthFunc( gl.EQUAL );
							break;
	
						case THREE.GreaterEqualDepth:
	
							gl.depthFunc( gl.GEQUAL );
							break;
	
						case THREE.GreaterDepth:
	
							gl.depthFunc( gl.GREATER );
							break;
	
						case THREE.NotEqualDepth:
	
							gl.depthFunc( gl.NOTEQUAL );
							break;
	
						default:
	
							gl.depthFunc( gl.LEQUAL );
	
					}
	
				} else {
	
					gl.depthFunc( gl.LEQUAL );
	
				}
	
				currentDepthFunc = depthFunc;
	
			}
	
		};
	
		this.setDepthTest = function ( depthTest ) {
	
			if ( depthTest ) {
	
				this.enable( gl.DEPTH_TEST );
	
			} else {
	
				this.disable( gl.DEPTH_TEST );
	
			}
	
		};
	
		this.setDepthWrite = function ( depthWrite ) {
	
			if ( currentDepthWrite !== depthWrite ) {
	
				gl.depthMask( depthWrite );
				currentDepthWrite = depthWrite;
	
			}
	
		};
	
		this.setColorWrite = function ( colorWrite ) {
	
			if ( currentColorWrite !== colorWrite ) {
	
				gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
				currentColorWrite = colorWrite;
	
			}
	
		};
	
		this.setFlipSided = function ( flipSided ) {
	
			if ( currentFlipSided !== flipSided ) {
	
				if ( flipSided ) {
	
					gl.frontFace( gl.CW );
	
				} else {
	
					gl.frontFace( gl.CCW );
	
				}
	
				currentFlipSided = flipSided;
	
			}
	
		};
	
		this.setLineWidth = function ( width ) {
	
			if ( width !== currentLineWidth ) {
	
				gl.lineWidth( width );
	
				currentLineWidth = width;
	
			}
	
		};
	
		this.setPolygonOffset = function ( polygonOffset, factor, units ) {
	
			if ( polygonOffset ) {
	
				this.enable( gl.POLYGON_OFFSET_FILL );
	
			} else {
	
				this.disable( gl.POLYGON_OFFSET_FILL );
	
			}
	
			if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {
	
				gl.polygonOffset( factor, units );
	
				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;
	
			}
	
		};
	
		this.setScissorTest = function ( scissorTest ) {
	
			if ( scissorTest ) {
	
				this.enable( gl.SCISSOR_TEST );
	
			} else {
	
				this.disable( gl.SCISSOR_TEST );
	
			}
	
		};
	
		// texture
	
		this.activeTexture = function ( webglSlot ) {
	
			if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;
	
			if ( currentTextureSlot !== webglSlot ) {
	
				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;
	
			}
	
		}
	
		this.bindTexture = function ( webglType, webglTexture ) {
	
			if ( currentTextureSlot === undefined ) {
	
				_this.activeTexture();
	
			}
	
			var boundTexture = currentBoundTextures[ currentTextureSlot ];
	
			if ( boundTexture === undefined ) {
	
				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;
	
			}
	
			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {
	
				gl.bindTexture( webglType, webglTexture );
	
				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;
	
			}
	
		};
	
		this.compressedTexImage2D = function () {
	
			try {
	
				gl.compressedTexImage2D.apply( gl, arguments );
	
			} catch ( error ) {
	
				console.error( error );
	
			}
	
		};
	
		this.texImage2D = function () {
	
			try {
	
				gl.texImage2D.apply( gl, arguments );
	
			} catch ( error ) {
	
				console.error( error );
	
			}
	
		};
	
		//
	
		this.reset = function () {
	
			for ( var i = 0; i < enabledAttributes.length; i ++ ) {
	
				if ( enabledAttributes[ i ] === 1 ) {
	
					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;
	
				}
	
			}
	
			capabilities = {};
	
			compressedTextureFormats = null;
	
			currentBlending = null;
	
			currentDepthWrite = null;
			currentColorWrite = null;
	
			currentFlipSided = null;
	
		};
	
	};
	
	// File:src/renderers/webgl/plugins/LensFlarePlugin.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.LensFlarePlugin = function ( renderer, flares ) {
	
		var gl = renderer.context;
		var state = renderer.state;
	
		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;
		var hasVertexTexture;
	
		var tempTexture, occlusionTexture;
	
		function init() {
	
			var vertices = new Float32Array( [
				- 1, - 1,  0, 0,
				 1, - 1,  1, 0,
				 1,  1,  1, 1,
				- 1,  1,  0, 1
			] );
	
			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );
	
			// buffers
	
			vertexBuffer     = gl.createBuffer();
			elementBuffer    = gl.createBuffer();
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
	
			// textures
	
			tempTexture      = gl.createTexture();
			occlusionTexture = gl.createTexture();
	
			state.bindTexture( gl.TEXTURE_2D, tempTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	
			state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	
			hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;
	
			var shader;
	
			if ( hasVertexTexture ) {
	
				shader = {
	
					vertexShader: [
	
						"uniform lowp int renderType;",
	
						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",
	
						"uniform sampler2D occlusionMap;",
	
						"attribute vec2 position;",
						"attribute vec2 uv;",
	
						"varying vec2 vUV;",
						"varying float vVisibility;",
	
						"void main() {",
	
							"vUV = uv;",
	
							"vec2 pos = position;",
	
							"if ( renderType == 2 ) {",
	
								"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",
	
								"vVisibility =        visibility.r / 9.0;",
								"vVisibility *= 1.0 - visibility.g / 9.0;",
								"vVisibility *=       visibility.b / 9.0;",
								"vVisibility *= 1.0 - visibility.a / 9.0;",
	
								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
	
							"}",
	
							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
	
						"}"
	
					].join( "\n" ),
	
					fragmentShader: [
	
						"uniform lowp int renderType;",
	
						"uniform sampler2D map;",
						"uniform float opacity;",
						"uniform vec3 color;",
	
						"varying vec2 vUV;",
						"varying float vVisibility;",
	
						"void main() {",
	
							// pink square
	
							"if ( renderType == 0 ) {",
	
								"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",
	
							// restore
	
							"} else if ( renderType == 1 ) {",
	
								"gl_FragColor = texture2D( map, vUV );",
	
							// flare
	
							"} else {",
	
								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * vVisibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",
	
							"}",
	
						"}"
	
					].join( "\n" )
	
				};
	
			} else {
	
				shader = {
	
					vertexShader: [
	
						"uniform lowp int renderType;",
	
						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",
	
						"attribute vec2 position;",
						"attribute vec2 uv;",
	
						"varying vec2 vUV;",
	
						"void main() {",
	
							"vUV = uv;",
	
							"vec2 pos = position;",
	
							"if ( renderType == 2 ) {",
	
								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
	
							"}",
	
							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
	
						"}"
	
					].join( "\n" ),
	
					fragmentShader: [
	
						"precision mediump float;",
	
						"uniform lowp int renderType;",
	
						"uniform sampler2D map;",
						"uniform sampler2D occlusionMap;",
						"uniform float opacity;",
						"uniform vec3 color;",
	
						"varying vec2 vUV;",
	
						"void main() {",
	
							// pink square
	
							"if ( renderType == 0 ) {",
	
								"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",
	
							// restore
	
							"} else if ( renderType == 1 ) {",
	
								"gl_FragColor = texture2D( map, vUV );",
	
							// flare
	
							"} else {",
	
								"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
								"visibility = ( 1.0 - visibility / 4.0 );",
	
								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * visibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",
	
							"}",
	
						"}"
	
					].join( "\n" )
	
				};
	
			}
	
			program = createProgram( shader );
	
			attributes = {
				vertex: gl.getAttribLocation ( program, "position" ),
				uv:     gl.getAttribLocation ( program, "uv" )
			};
	
			uniforms = {
				renderType:     gl.getUniformLocation( program, "renderType" ),
				map:            gl.getUniformLocation( program, "map" ),
				occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
				opacity:        gl.getUniformLocation( program, "opacity" ),
				color:          gl.getUniformLocation( program, "color" ),
				scale:          gl.getUniformLocation( program, "scale" ),
				rotation:       gl.getUniformLocation( program, "rotation" ),
				screenPosition: gl.getUniformLocation( program, "screenPosition" )
			};
	
		}
	
		/*
		 * Render lens flares
		 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
		 *         reads these back and calculates occlusion.
		 */
	
		this.render = function ( scene, camera, viewportWidth, viewportHeight ) {
	
			if ( flares.length === 0 ) return;
	
			var tempPosition = new THREE.Vector3();
	
			var invAspect = viewportHeight / viewportWidth,
				halfViewportWidth = viewportWidth * 0.5,
				halfViewportHeight = viewportHeight * 0.5;
	
			var size = 16 / viewportHeight,
				scale = new THREE.Vector2( size * invAspect, size );
	
			var screenPosition = new THREE.Vector3( 1, 1, 0 ),
				screenPositionPixels = new THREE.Vector2( 1, 1 );
	
			if ( program === undefined ) {
	
				init();
	
			}
	
			gl.useProgram( program );
	
			state.initAttributes();
			state.enableAttribute( attributes.vertex );
			state.enableAttribute( attributes.uv );
			state.disableUnusedAttributes();
	
			// loop through all lens flares to update their occlusion and positions
			// setup gl and common used attribs/uniforms
	
			gl.uniform1i( uniforms.occlusionMap, 0 );
			gl.uniform1i( uniforms.map, 1 );
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
			state.disable( gl.CULL_FACE );
			gl.depthMask( false );
	
			for ( var i = 0, l = flares.length; i < l; i ++ ) {
	
				size = 16 / viewportHeight;
				scale.set( size * invAspect, size );
	
				// calc object screen position
	
				var flare = flares[ i ];
	
				tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );
	
				tempPosition.applyMatrix4( camera.matrixWorldInverse );
				tempPosition.applyProjection( camera.projectionMatrix );
	
				// setup arrays for gl programs
	
				screenPosition.copy( tempPosition );
	
				screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
				screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;
	
				// screen cull
	
				if ( hasVertexTexture || (
					screenPositionPixels.x > 0 &&
					screenPositionPixels.x < viewportWidth &&
					screenPositionPixels.y > 0 &&
					screenPositionPixels.y < viewportHeight ) ) {
	
					// save current RGB to temp texture
	
					state.activeTexture( gl.TEXTURE0 );
					state.bindTexture( gl.TEXTURE_2D, null );
					state.activeTexture( gl.TEXTURE1 );
					state.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );
	
	
					// render pink quad
	
					gl.uniform1i( uniforms.renderType, 0 );
					gl.uniform2f( uniforms.scale, scale.x, scale.y );
					gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
	
					state.disable( gl.BLEND );
					state.enable( gl.DEPTH_TEST );
	
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
	
					// copy result to occlusionMap
	
					state.activeTexture( gl.TEXTURE0 );
					state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );
	
	
					// restore graphics
	
					gl.uniform1i( uniforms.renderType, 1 );
					state.disable( gl.DEPTH_TEST );
	
					state.activeTexture( gl.TEXTURE1 );
					state.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
	
					// update object positions
	
					flare.positionScreen.copy( screenPosition );
	
					if ( flare.customUpdateCallback ) {
	
						flare.customUpdateCallback( flare );
	
					} else {
	
						flare.updateLensFlares();
	
					}
	
					// render flares
	
					gl.uniform1i( uniforms.renderType, 2 );
					state.enable( gl.BLEND );
	
					for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {
	
						var sprite = flare.lensFlares[ j ];
	
						if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {
	
							screenPosition.x = sprite.x;
							screenPosition.y = sprite.y;
							screenPosition.z = sprite.z;
	
							size = sprite.size * sprite.scale / viewportHeight;
	
							scale.x = size * invAspect;
							scale.y = size;
	
							gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
							gl.uniform2f( uniforms.scale, scale.x, scale.y );
							gl.uniform1f( uniforms.rotation, sprite.rotation );
	
							gl.uniform1f( uniforms.opacity, sprite.opacity );
							gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );
	
							state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
							renderer.setTexture( sprite.texture, 1 );
	
							gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
						}
	
					}
	
				}
	
			}
	
			// restore gl
	
			state.enable( gl.CULL_FACE );
			state.enable( gl.DEPTH_TEST );
			gl.depthMask( true );
	
			renderer.resetGLState();
	
		};
	
		function createProgram ( shader ) {
	
			var program = gl.createProgram();
	
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
	
			var prefix = "precision " + renderer.getPrecision() + " float;\n";
	
			gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
			gl.shaderSource( vertexShader, prefix + shader.vertexShader );
	
			gl.compileShader( fragmentShader );
			gl.compileShader( vertexShader );
	
			gl.attachShader( program, fragmentShader );
			gl.attachShader( program, vertexShader );
	
			gl.linkProgram( program );
	
			return program;
	
		}
	
	};
	
	// File:src/renderers/webgl/plugins/SpritePlugin.js
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SpritePlugin = function ( renderer, sprites ) {
	
		var gl = renderer.context;
		var state = renderer.state;
	
		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;
	
		var texture;
	
		// decompose matrixWorld
	
		var spritePosition = new THREE.Vector3();
		var spriteRotation = new THREE.Quaternion();
		var spriteScale = new THREE.Vector3();
	
		function init() {
	
			var vertices = new Float32Array( [
				- 0.5, - 0.5,  0, 0,
				  0.5, - 0.5,  1, 0,
				  0.5,   0.5,  1, 1,
				- 0.5,   0.5,  0, 1
			] );
	
			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );
	
			vertexBuffer  = gl.createBuffer();
			elementBuffer = gl.createBuffer();
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
	
			program = createProgram();
	
			attributes = {
				position:			gl.getAttribLocation ( program, 'position' ),
				uv:					gl.getAttribLocation ( program, 'uv' )
			};
	
			uniforms = {
				uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
				uvScale:			gl.getUniformLocation( program, 'uvScale' ),
	
				rotation:			gl.getUniformLocation( program, 'rotation' ),
				scale:				gl.getUniformLocation( program, 'scale' ),
	
				color:				gl.getUniformLocation( program, 'color' ),
				map:				gl.getUniformLocation( program, 'map' ),
				opacity:			gl.getUniformLocation( program, 'opacity' ),
	
				modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
				projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),
	
				fogType:			gl.getUniformLocation( program, 'fogType' ),
				fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
				fogNear:			gl.getUniformLocation( program, 'fogNear' ),
				fogFar:				gl.getUniformLocation( program, 'fogFar' ),
				fogColor:			gl.getUniformLocation( program, 'fogColor' ),
	
				alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
			};
	
			var canvas = document.createElement( 'canvas' );
			canvas.width = 8;
			canvas.height = 8;
	
			var context = canvas.getContext( '2d' );
			context.fillStyle = 'white';
			context.fillRect( 0, 0, 8, 8 );
	
			texture = new THREE.Texture( canvas );
			texture.needsUpdate = true;
	
		}
	
		this.render = function ( scene, camera ) {
	
			if ( sprites.length === 0 ) return;
	
			// setup gl
	
			if ( program === undefined ) {
	
				init();
	
			}
	
			gl.useProgram( program );
	
			state.initAttributes();
			state.enableAttribute( attributes.position );
			state.enableAttribute( attributes.uv );
			state.disableUnusedAttributes();
	
			state.disable( gl.CULL_FACE );
			state.enable( gl.BLEND );
	
			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
	
			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
			gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );
	
			state.activeTexture( gl.TEXTURE0 );
			gl.uniform1i( uniforms.map, 0 );
	
			var oldFogType = 0;
			var sceneFogType = 0;
			var fog = scene.fog;
	
			if ( fog ) {
	
				gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );
	
				if ( fog instanceof THREE.Fog ) {
	
					gl.uniform1f( uniforms.fogNear, fog.near );
					gl.uniform1f( uniforms.fogFar, fog.far );
	
					gl.uniform1i( uniforms.fogType, 1 );
					oldFogType = 1;
					sceneFogType = 1;
	
				} else if ( fog instanceof THREE.FogExp2 ) {
	
					gl.uniform1f( uniforms.fogDensity, fog.density );
	
					gl.uniform1i( uniforms.fogType, 2 );
					oldFogType = 2;
					sceneFogType = 2;
	
				}
	
			} else {
	
				gl.uniform1i( uniforms.fogType, 0 );
				oldFogType = 0;
				sceneFogType = 0;
	
			}
	
	
			// update positions and sort
	
			for ( var i = 0, l = sprites.length; i < l; i ++ ) {
	
				var sprite = sprites[ i ];
	
				sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
				sprite.z = - sprite.modelViewMatrix.elements[ 14 ];
	
			}
	
			sprites.sort( painterSortStable );
	
			// render all sprites
	
			var scale = [];
	
			for ( var i = 0, l = sprites.length; i < l; i ++ ) {
	
				var sprite = sprites[ i ];
				var material = sprite.material;
	
				gl.uniform1f( uniforms.alphaTest, material.alphaTest );
				gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );
	
				sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );
	
				scale[ 0 ] = spriteScale.x;
				scale[ 1 ] = spriteScale.y;
	
				var fogType = 0;
	
				if ( scene.fog && material.fog ) {
	
					fogType = sceneFogType;
	
				}
	
				if ( oldFogType !== fogType ) {
	
					gl.uniform1i( uniforms.fogType, fogType );
					oldFogType = fogType;
	
				}
	
				if ( material.map !== null ) {
	
					gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
					gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );
	
				} else {
	
					gl.uniform2f( uniforms.uvOffset, 0, 0 );
					gl.uniform2f( uniforms.uvScale, 1, 1 );
	
				}
	
				gl.uniform1f( uniforms.opacity, material.opacity );
				gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );
	
				gl.uniform1f( uniforms.rotation, material.rotation );
				gl.uniform2fv( uniforms.scale, scale );
	
				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
				state.setDepthTest( material.depthTest );
				state.setDepthWrite( material.depthWrite );
	
				if ( material.map && material.map.image && material.map.image.width ) {
	
					renderer.setTexture( material.map, 0 );
	
				} else {
	
					renderer.setTexture( texture, 0 );
	
				}
	
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
			}
	
			// restore gl
	
			state.enable( gl.CULL_FACE );
	
			renderer.resetGLState();
	
		};
	
		function createProgram () {
	
			var program = gl.createProgram();
	
			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
	
			gl.shaderSource( vertexShader, [
	
				'precision ' + renderer.getPrecision() + ' float;',
	
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform float rotation;',
				'uniform vec2 scale;',
				'uniform vec2 uvOffset;',
				'uniform vec2 uvScale;',
	
				'attribute vec2 position;',
				'attribute vec2 uv;',
	
				'varying vec2 vUV;',
	
				'void main() {',
	
					'vUV = uvOffset + uv * uvScale;',
	
					'vec2 alignedPosition = position * scale;',
	
					'vec2 rotatedPosition;',
					'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
					'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',
	
					'vec4 finalPosition;',
	
					'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
					'finalPosition.xy += rotatedPosition;',
					'finalPosition = projectionMatrix * finalPosition;',
	
					'gl_Position = finalPosition;',
	
				'}'
	
			].join( '\n' ) );
	
			gl.shaderSource( fragmentShader, [
	
				'precision ' + renderer.getPrecision() + ' float;',
	
				'uniform vec3 color;',
				'uniform sampler2D map;',
				'uniform float opacity;',
	
				'uniform int fogType;',
				'uniform vec3 fogColor;',
				'uniform float fogDensity;',
				'uniform float fogNear;',
				'uniform float fogFar;',
				'uniform float alphaTest;',
	
				'varying vec2 vUV;',
	
				'void main() {',
	
					'vec4 texture = texture2D( map, vUV );',
	
					'if ( texture.a < alphaTest ) discard;',
	
					'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
	
					'if ( fogType > 0 ) {',
	
						'float depth = gl_FragCoord.z / gl_FragCoord.w;',
						'float fogFactor = 0.0;',
	
						'if ( fogType == 1 ) {',
	
							'fogFactor = smoothstep( fogNear, fogFar, depth );',
	
						'} else {',
	
							'const float LOG2 = 1.442695;',
							'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
							'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
	
						'}',
	
						'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',
	
					'}',
	
				'}'
	
			].join( '\n' ) );
	
			gl.compileShader( vertexShader );
			gl.compileShader( fragmentShader );
	
			gl.attachShader( program, vertexShader );
			gl.attachShader( program, fragmentShader );
	
			gl.linkProgram( program );
	
			return program;
	
		}
	
		function painterSortStable ( a, b ) {
	
			if ( a.z !== b.z ) {
	
				return b.z - a.z;
	
			} else {
	
				return b.id - a.id;
	
			}
	
		}
	
	};
	
	// File:src/extras/CurveUtils.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.CurveUtils = {
	
		tangentQuadraticBezier: function ( t, p0, p1, p2 ) {
	
			return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );
	
		},
	
		// Puay Bing, thanks for helping with this derivative!
	
		tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {
	
			return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
				3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
				6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
				3 * t * t * p3;
	
		},
	
		tangentSpline: function ( t, p0, p1, p2, p3 ) {
	
			// To check if my formulas are correct
	
			var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1
			var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
			var h01 = - 6 * t * t + 6 * t; 	// − 2t3 + 3t2
			var h11 = 3 * t * t - 2 * t;	// t3 − t2
	
			return h00 + h10 + h01 + h11;
	
		},
	
		// Catmull-Rom
	
		interpolate: function( p0, p1, p2, p3, t ) {
	
			var v0 = ( p2 - p0 ) * 0.5;
			var v1 = ( p3 - p1 ) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
		}
	
	};
	
	// File:src/extras/GeometryUtils.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.GeometryUtils = {
	
		merge: function ( geometry1, geometry2, materialIndexOffset ) {
	
			console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
	
			var matrix;
	
			if ( geometry2 instanceof THREE.Mesh ) {
	
				geometry2.matrixAutoUpdate && geometry2.updateMatrix();
	
				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;
	
			}
	
			geometry1.merge( geometry2, matrix, materialIndexOffset );
	
		},
	
		center: function ( geometry ) {
	
			console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();
	
		}
	
	};
	
	// File:src/extras/ImageUtils.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author Daosheng Mu / https://github.com/DaoshengMu/
	 */
	
	THREE.ImageUtils = {
	
		crossOrigin: undefined,
	
		loadTexture: function ( url, mapping, onLoad, onError ) {
	
			console.warn( 'THREE.ImageUtils.loadTexture is being deprecated. Use THREE.TextureLoader() instead.' );
	
			var loader = new THREE.TextureLoader();
			loader.setCrossOrigin( this.crossOrigin );
	
			var texture = loader.load( url, onLoad, undefined, onError );
	
			if ( mapping ) texture.mapping = mapping;
	
			return texture;
	
		},
	
		loadTextureCube: function ( urls, mapping, onLoad, onError ) {
	
			console.warn( 'THREE.ImageUtils.loadTextureCube is being deprecated. Use THREE.CubeTextureLoader() instead.' );
	
			var loader = new THREE.CubeTextureLoader();
			loader.setCrossOrigin( this.crossOrigin );
	
			var texture = loader.load( urls, onLoad, undefined, onError );
	
			if ( mapping ) texture.mapping = mapping;
	
			return texture;
	
		},
	
		loadCompressedTexture: function () {
	
			console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )
	
		},
	
		loadCompressedTextureCube: function () {
	
			console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )
	
		}
	
	};
	
	// File:src/extras/SceneUtils.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SceneUtils = {
	
		createMultiMaterialObject: function ( geometry, materials ) {
	
			var group = new THREE.Group();
	
			for ( var i = 0, l = materials.length; i < l; i ++ ) {
	
				group.add( new THREE.Mesh( geometry, materials[ i ] ) );
	
			}
	
			return group;
	
		},
	
		detach: function ( child, parent, scene ) {
	
			child.applyMatrix( parent.matrixWorld );
			parent.remove( child );
			scene.add( child );
	
		},
	
		attach: function ( child, scene, parent ) {
	
			var matrixWorldInverse = new THREE.Matrix4();
			matrixWorldInverse.getInverse( parent.matrixWorld );
			child.applyMatrix( matrixWorldInverse );
	
			scene.remove( child );
			parent.add( child );
	
		}
	
	};
	
	// File:src/extras/ShapeUtils.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.ShapeUtils = {
	
		// calculate area of the contour polygon
	
		area: function ( contour ) {
	
			var n = contour.length;
			var a = 0.0;
	
			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {
	
				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;
	
			}
	
			return a * 0.5;
	
		},
	
		triangulate: ( function () {
	
			/**
			 * This code is a quick port of code written in C++ which was submitted to
			 * flipcode.com by John W. Ratcliff  // July 22, 2000
			 * See original code and more information here:
			 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
			 *
			 * ported to actionscript by Zevan Rosser
			 * www.actionsnippet.com
			 *
			 * ported to javascript by Joshua Koo
			 * http://www.lab4games.net/zz85/blog
			 *
			 */
	
			function snip( contour, u, v, w, n, verts ) {
	
				var p;
				var ax, ay, bx, by;
				var cx, cy, px, py;
	
				ax = contour[ verts[ u ] ].x;
				ay = contour[ verts[ u ] ].y;
	
				bx = contour[ verts[ v ] ].x;
				by = contour[ verts[ v ] ].y;
	
				cx = contour[ verts[ w ] ].x;
				cy = contour[ verts[ w ] ].y;
	
				if ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;
	
				var aX, aY, bX, bY, cX, cY;
				var apx, apy, bpx, bpy, cpx, cpy;
				var cCROSSap, bCROSScp, aCROSSbp;
	
				aX = cx - bx;  aY = cy - by;
				bX = ax - cx;  bY = ay - cy;
				cX = bx - ax;  cY = by - ay;
	
				for ( p = 0; p < n; p ++ ) {
	
					px = contour[ verts[ p ] ].x;
					py = contour[ verts[ p ] ].y;
	
					if ( ( ( px === ax ) && ( py === ay ) ) ||
						 ( ( px === bx ) && ( py === by ) ) ||
						 ( ( px === cx ) && ( py === cy ) ) )	continue;
	
					apx = px - ax;  apy = py - ay;
					bpx = px - bx;  bpy = py - by;
					cpx = px - cx;  cpy = py - cy;
	
					// see if p is inside triangle abc
	
					aCROSSbp = aX * bpy - aY * bpx;
					cCROSSap = cX * apy - cY * apx;
					bCROSScp = bX * cpy - bY * cpx;
	
					if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;
	
				}
	
				return true;
	
			}
	
			// takes in an contour array and returns
	
			return function ( contour, indices ) {
	
				var n = contour.length;
	
				if ( n < 3 ) return null;
	
				var result = [],
					verts = [],
					vertIndices = [];
	
				/* we want a counter-clockwise polygon in verts */
	
				var u, v, w;
	
				if ( THREE.ShapeUtils.area( contour ) > 0.0 ) {
	
					for ( v = 0; v < n; v ++ ) verts[ v ] = v;
	
				} else {
	
					for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;
	
				}
	
				var nv = n;
	
				/*  remove nv - 2 vertices, creating 1 triangle every time */
	
				var count = 2 * nv;   /* error detection */
	
				for ( v = nv - 1; nv > 2; ) {
	
					/* if we loop, it is probably a non-simple polygon */
	
					if ( ( count -- ) <= 0 ) {
	
						//** Triangulate: ERROR - probable bad polygon!
	
						//throw ( "Warning, unable to triangulate polygon!" );
						//return null;
						// Sometimes warning is fine, especially polygons are triangulated in reverse.
						console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );
	
						if ( indices ) return vertIndices;
						return result;
	
					}
	
					/* three consecutive vertices in current polygon, <u,v,w> */
	
					u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
					v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
					w = v + 1;  if ( nv <= w ) w = 0;     /* next     */
	
					if ( snip( contour, u, v, w, nv, verts ) ) {
	
						var a, b, c, s, t;
	
						/* true names of the vertices */
	
						a = verts[ u ];
						b = verts[ v ];
						c = verts[ w ];
	
						/* output Triangle */
	
						result.push( [ contour[ a ],
							contour[ b ],
							contour[ c ] ] );
	
	
						vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );
	
						/* remove v from the remaining polygon */
	
						for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {
	
							verts[ s ] = verts[ t ];
	
						}
	
						nv --;
	
						/* reset error detection counter */
	
						count = 2 * nv;
	
					}
	
				}
	
				if ( indices ) return vertIndices;
				return result;
	
			}
	
		} )(),
	
		triangulateShape: function ( contour, holes ) {
	
			function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
	
				// inOtherPt needs to be collinear to the inSegment
				if ( inSegPt1.x !== inSegPt2.x ) {
	
					if ( inSegPt1.x < inSegPt2.x ) {
	
						return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
	
					} else {
	
						return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
	
					}
	
				} else {
	
					if ( inSegPt1.y < inSegPt2.y ) {
	
						return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
	
					} else {
	
						return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
	
					}
	
				}
	
			}
	
			function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
	
				var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
				var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
	
				var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
				var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
	
				var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
				var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
	
				if ( Math.abs( limit ) > Number.EPSILON ) {
	
					// not parallel
	
					var perpSeg2;
					if ( limit > 0 ) {
	
						if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
	
					} else {
	
						if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
	
					}
	
					// i.e. to reduce rounding errors
					// intersection at endpoint of segment#1?
					if ( perpSeg2 === 0 ) {
	
						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
						return [ inSeg1Pt1 ];
	
					}
					if ( perpSeg2 === limit ) {
	
						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
						return [ inSeg1Pt2 ];
	
					}
					// intersection at endpoint of segment#2?
					if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
					if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];
	
					// return real intersection point
					var factorSeg1 = perpSeg2 / limit;
					return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
								y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];
	
				} else {
	
					// parallel or collinear
					if ( ( perpSeg1 !== 0 ) ||
						 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];
	
					// they are collinear or degenerate
					var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
					var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
					// both segments are points
					if ( seg1Pt && seg2Pt ) {
	
						if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
							 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
						return [ inSeg1Pt1 ];                 						// they are the same point
	
					}
					// segment#1  is a single point
					if ( seg1Pt ) {
	
						if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
						return [ inSeg1Pt1 ];
	
					}
					// segment#2  is a single point
					if ( seg2Pt ) {
	
						if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
						return [ inSeg2Pt1 ];
	
					}
	
					// they are collinear segments, which might overlap
					var seg1min, seg1max, seg1minVal, seg1maxVal;
					var seg2min, seg2max, seg2minVal, seg2maxVal;
					if ( seg1dx !== 0 ) {
	
						// the segments are NOT on a vertical line
						if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
	
							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
	
						} else {
	
							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
	
						}
						if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
	
							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
	
						} else {
	
							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
	
						}
	
					} else {
	
						// the segments are on a vertical line
						if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
	
							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
	
						} else {
	
							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
	
						}
						if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
	
							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
	
						} else {
	
							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
	
						}
	
					}
					if ( seg1minVal <= seg2minVal ) {
	
						if ( seg1maxVal <  seg2minVal )	return [];
						if ( seg1maxVal === seg2minVal )	{
	
							if ( inExcludeAdjacentSegs )		return [];
							return [ seg2min ];
	
						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
						return	[ seg2min, seg2max ];
	
					} else {
	
						if ( seg1minVal >  seg2maxVal )	return [];
						if ( seg1minVal === seg2maxVal )	{
	
							if ( inExcludeAdjacentSegs )		return [];
							return [ seg1min ];
	
						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
						return	[ seg1min, seg2max ];
	
					}
	
				}
	
			}
	
			function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
	
				// The order of legs is important
	
				// translation of all points, so that Vertex is at (0,0)
				var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
				var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
				var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;
	
				// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
				var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
				var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;
	
				if ( Math.abs( from2toAngle ) > Number.EPSILON ) {
	
					// angle != 180 deg.
	
					var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
					// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );
	
					if ( from2toAngle > 0 ) {
	
						// main angle < 180 deg.
						return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
	
					} else {
	
						// main angle > 180 deg.
						return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
	
					}
	
				} else {
	
					// angle == 180 deg.
					// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
					return	( from2otherAngle > 0 );
	
				}
	
			}
	
	
			function removeHoles( contour, holes ) {
	
				var shape = contour.concat(); // work on this shape
				var hole;
	
				function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
	
					// Check if hole point lies within angle around shape point
					var lastShapeIdx = shape.length - 1;
	
					var prevShapeIdx = inShapeIdx - 1;
					if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;
	
					var nextShapeIdx = inShapeIdx + 1;
					if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;
	
					var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
					if ( ! insideAngle ) {
	
						// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
						return	false;
	
					}
	
					// Check if shape point lies within angle around hole point
					var lastHoleIdx = hole.length - 1;
	
					var prevHoleIdx = inHoleIdx - 1;
					if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;
	
					var nextHoleIdx = inHoleIdx + 1;
					if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;
	
					insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
					if ( ! insideAngle ) {
	
						// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
						return	false;
	
					}
	
					return	true;
	
				}
	
				function intersectsShapeEdge( inShapePt, inHolePt ) {
	
					// checks for intersections with shape edges
					var sIdx, nextIdx, intersection;
					for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
	
						nextIdx = sIdx + 1; nextIdx %= shape.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
						if ( intersection.length > 0 )		return	true;
	
					}
	
					return	false;
	
				}
	
				var indepHoles = [];
	
				function intersectsHoleEdge( inShapePt, inHolePt ) {
	
					// checks for intersections with hole edges
					var ihIdx, chkHole,
						hIdx, nextIdx, intersection;
					for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
	
						chkHole = holes[ indepHoles[ ihIdx ]];
						for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
	
							nextIdx = hIdx + 1; nextIdx %= chkHole.length;
							intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
							if ( intersection.length > 0 )		return	true;
	
						}
	
					}
					return	false;
	
				}
	
				var holeIndex, shapeIndex,
					shapePt, holePt,
					holeIdx, cutKey, failedCuts = [],
					tmpShape1, tmpShape2,
					tmpHole1, tmpHole2;
	
				for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
	
					indepHoles.push( h );
	
				}
	
				var minShapeIndex = 0;
				var counter = indepHoles.length * 2;
				while ( indepHoles.length > 0 ) {
	
					counter --;
					if ( counter < 0 ) {
	
						console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
						break;
	
					}
	
					// search for shape-vertex and hole-vertex,
					// which can be connected without intersections
					for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {
	
						shapePt = shape[ shapeIndex ];
						holeIndex	= - 1;
	
						// search for hole which can be reached without intersections
						for ( var h = 0; h < indepHoles.length; h ++ ) {
	
							holeIdx = indepHoles[ h ];
	
							// prevent multiple checks
							cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
							if ( failedCuts[ cutKey ] !== undefined )			continue;
	
							hole = holes[ holeIdx ];
							for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
	
								holePt = hole[ h2 ];
								if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
								if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
								if ( intersectsHoleEdge( shapePt, holePt ) )		continue;
	
								holeIndex = h2;
								indepHoles.splice( h, 1 );
	
								tmpShape1 = shape.slice( 0, shapeIndex + 1 );
								tmpShape2 = shape.slice( shapeIndex );
								tmpHole1 = hole.slice( holeIndex );
								tmpHole2 = hole.slice( 0, holeIndex + 1 );
	
								shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );
	
								minShapeIndex = shapeIndex;
	
								// Debug only, to show the selected cuts
								// glob_CutLines.push( [ shapePt, holePt ] );
	
								break;
	
							}
							if ( holeIndex >= 0 )	break;		// hole-vertex found
	
							failedCuts[ cutKey ] = true;			// remember failure
	
						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found
	
					}
	
				}
	
				return shape; 			/* shape with no holes */
	
			}
	
	
			var i, il, f, face,
				key, index,
				allPointsMap = {};
	
			// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.
	
			var allpoints = contour.concat();
	
			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
	
				Array.prototype.push.apply( allpoints, holes[ h ] );
	
			}
	
			//console.log( "allpoints",allpoints, allpoints.length );
	
			// prepare all points map
	
			for ( i = 0, il = allpoints.length; i < il; i ++ ) {
	
				key = allpoints[ i ].x + ":" + allpoints[ i ].y;
	
				if ( allPointsMap[ key ] !== undefined ) {
	
					console.warn( "THREE.Shape: Duplicate point", key );
	
				}
	
				allPointsMap[ key ] = i;
	
			}
	
			// remove holes by cutting paths to holes and adding them to the shape
			var shapeWithoutHoles = removeHoles( contour, holes );
	
			var triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
			//console.log( "triangles",triangles, triangles.length );
	
			// check all face vertices against all points map
	
			for ( i = 0, il = triangles.length; i < il; i ++ ) {
	
				face = triangles[ i ];
	
				for ( f = 0; f < 3; f ++ ) {
	
					key = face[ f ].x + ":" + face[ f ].y;
	
					index = allPointsMap[ key ];
	
					if ( index !== undefined ) {
	
						face[ f ] = index;
	
					}
	
				}
	
			}
	
			return triangles.concat();
	
		},
	
		isClockWise: function ( pts ) {
	
			return THREE.ShapeUtils.area( pts ) < 0;
	
		},
	
		// Bezier Curves formulas obtained from
		// http://en.wikipedia.org/wiki/B%C3%A9zier_curve
	
		// Quad Bezier Functions
	
		b2: ( function () {
	
			function b2p0( t, p ) {
	
				var k = 1 - t;
				return k * k * p;
	
			}
	
			function b2p1( t, p ) {
	
				return 2 * ( 1 - t ) * t * p;
	
			}
	
			function b2p2( t, p ) {
	
				return t * t * p;
	
			}
	
			return function ( t, p0, p1, p2 ) {
	
				return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );
	
			};
	
		} )(),
	
		// Cubic Bezier Functions
	
		b3: ( function () {
	
			function b3p0( t, p ) {
	
				var k = 1 - t;
				return k * k * k * p;
	
			}
	
			function b3p1( t, p ) {
	
				var k = 1 - t;
				return 3 * k * k * t * p;
	
			}
	
			function b3p2( t, p ) {
	
				var k = 1 - t;
				return 3 * k * t * t * p;
	
			}
	
			function b3p3( t, p ) {
	
				return t * t * t * p;
	
			}
	
			return function ( t, p0, p1, p2, p3 ) {
	
				return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );
	
			};
	
		} )()
	
	};
	
	// File:src/extras/audio/Audio.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Audio = function ( listener ) {
	
		THREE.Object3D.call( this );
	
		this.type = 'Audio';
	
		this.context = listener.context;
		this.source = this.context.createBufferSource();
		this.source.onended = this.onEnded.bind( this );
	
		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );
	
		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );
	
		this.autoplay = false;
	
		this.startTime = 0;
		this.playbackRate = 1;
		this.isPlaying = false;
	
	};
	
	THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Audio.prototype.constructor = THREE.Audio;
	
	THREE.Audio.prototype.load = function ( file ) {
	
		var scope = this;
	
		var request = new XMLHttpRequest();
		request.open( 'GET', file, true );
		request.responseType = 'arraybuffer';
		request.onload = function ( e ) {
	
			scope.context.decodeAudioData( this.response, function ( buffer ) {
	
				scope.source.buffer = buffer;
	
				if ( scope.autoplay ) scope.play();
	
			} );
	
		};
		request.send();
	
		return this;
	
	};
	
	THREE.Audio.prototype.play = function () {
	
		if ( this.isPlaying === true ) {
	
			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;
	
		}
	
		var source = this.context.createBufferSource();
	
		source.buffer = this.source.buffer;
		source.loop = this.source.loop;
		source.onended = this.source.onended;
		source.start( 0, this.startTime );
		source.playbackRate.value = this.playbackRate;
	
		this.isPlaying = true;
	
		this.source = source;
	
		this.connect();
	
	};
	
	THREE.Audio.prototype.pause = function () {
	
		this.source.stop();
		this.startTime = this.context.currentTime;
	
	};
	
	THREE.Audio.prototype.stop = function () {
	
		this.source.stop();
		this.startTime = 0;
	
	};
	
	THREE.Audio.prototype.connect = function () {
	
		if ( this.filter !== undefined ) {
	
			this.source.connect( this.filter );
			this.filter.connect( this.panner );
	
		} else {
	
			this.source.connect( this.panner );
	
		}
	
	};
	
	THREE.Audio.prototype.disconnect = function () {
	
		if ( this.filter !== undefined ) {
	
			this.source.disconnect( this.filter );
			this.filter.disconnect( this.panner );
	
		} else {
	
			this.source.disconnect( this.panner );
	
		}
	
	};
	
	THREE.Audio.prototype.setFilter = function ( value ) {
	
		if ( this.isPlaying === true ) {
	
			this.disconnect();
			this.filter = value;
			this.connect();
	
		} else {
	
			this.filter = value;
	
		}
	
	};
	
	THREE.Audio.prototype.getFilter = function () {
	
		return this.filter;
	
	};
	
	THREE.Audio.prototype.setPlaybackRate = function ( value ) {
	
		this.playbackRate = value;
	
		if ( this.isPlaying === true ) {
	
			this.source.playbackRate.value = this.playbackRate;
	
		}
	
	};
	
	THREE.Audio.prototype.getPlaybackRate = function () {
	
		return this.playbackRate;
	
	};
	
	THREE.Audio.prototype.onEnded = function() {
	
		this.isPlaying = false;
	
	};
	
	THREE.Audio.prototype.setLoop = function ( value ) {
	
		this.source.loop = value;
	
	};
	
	THREE.Audio.prototype.getLoop = function () {
	
		return this.source.loop;
	
	};
	
	THREE.Audio.prototype.setRefDistance = function ( value ) {
	
		this.panner.refDistance = value;
	
	};
	
	THREE.Audio.prototype.getRefDistance = function () {
	
		return this.panner.refDistance;
	
	};
	
	THREE.Audio.prototype.setRolloffFactor = function ( value ) {
	
		this.panner.rolloffFactor = value;
	
	};
	
	THREE.Audio.prototype.getRolloffFactor = function () {
	
		return this.panner.rolloffFactor;
	
	};
	
	THREE.Audio.prototype.setVolume = function ( value ) {
	
		this.gain.gain.value = value;
	
	};
	
	THREE.Audio.prototype.getVolume = function () {
	
		return this.gain.gain.value;
	
	};
	
	THREE.Audio.prototype.updateMatrixWorld = ( function () {
	
		var position = new THREE.Vector3();
	
		return function updateMatrixWorld( force ) {
	
			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );
	
			position.setFromMatrixPosition( this.matrixWorld );
	
			this.panner.setPosition( position.x, position.y, position.z );
	
		};
	
	} )();
	
	// File:src/extras/audio/AudioListener.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AudioListener = function () {
	
		THREE.Object3D.call( this );
	
		this.type = 'AudioListener';
	
		this.context = new ( window.AudioContext || window.webkitAudioContext )();
	
	};
	
	THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
	THREE.AudioListener.prototype.constructor = THREE.AudioListener;
	
	THREE.AudioListener.prototype.updateMatrixWorld = ( function () {
	
		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3();
	
		var orientation = new THREE.Vector3();
	
		return function updateMatrixWorld( force ) {
	
			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );
	
			var listener = this.context.listener;
			var up = this.up;
	
			this.matrixWorld.decompose( position, quaternion, scale );
	
			orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	
			listener.setPosition( position.x, position.y, position.z );
			listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );
	
		};
	
	} )();
	
	// File:src/extras/core/Curve.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of Curve methods
	 * .getPoint(t), getTangent(t)
	 * .getPointAt(u), getTagentAt(u)
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following classes subclasses THREE.Curve:
	 *
	 * -- 2d classes --
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.CubicBezierCurve
	 * THREE.SplineCurve
	 * THREE.ArcCurve
	 * THREE.EllipseCurve
	 *
	 * -- 3d classes --
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.SplineCurve3
	 * THREE.ClosedSplineCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath
	 *
	 **/
	
	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/
	
	THREE.Curve = function () {
	
	};
	
	THREE.Curve.prototype = {
	
		constructor: THREE.Curve,
	
		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]
	
		getPoint: function ( t ) {
	
			console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
			return null;
	
		},
	
		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]
	
		getPointAt: function ( u ) {
	
			var t = this.getUtoTmapping( u );
			return this.getPoint( t );
	
		},
	
		// Get sequence of points using getPoint( t )
	
		getPoints: function ( divisions ) {
	
			if ( ! divisions ) divisions = 5;
	
			var d, pts = [];
	
			for ( d = 0; d <= divisions; d ++ ) {
	
				pts.push( this.getPoint( d / divisions ) );
	
			}
	
			return pts;
	
		},
	
		// Get sequence of points using getPointAt( u )
	
		getSpacedPoints: function ( divisions ) {
	
			if ( ! divisions ) divisions = 5;
	
			var d, pts = [];
	
			for ( d = 0; d <= divisions; d ++ ) {
	
				pts.push( this.getPointAt( d / divisions ) );
	
			}
	
			return pts;
	
		},
	
		// Get total curve arc length
	
		getLength: function () {
	
			var lengths = this.getLengths();
			return lengths[ lengths.length - 1 ];
	
		},
	
		// Get list of cumulative segment lengths
	
		getLengths: function ( divisions ) {
	
			if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;
	
			if ( this.cacheArcLengths
				&& ( this.cacheArcLengths.length === divisions + 1 )
				&& ! this.needsUpdate ) {
	
				//console.log( "cached", this.cacheArcLengths );
				return this.cacheArcLengths;
	
			}
	
			this.needsUpdate = false;
	
			var cache = [];
			var current, last = this.getPoint( 0 );
			var p, sum = 0;
	
			cache.push( 0 );
	
			for ( p = 1; p <= divisions; p ++ ) {
	
				current = this.getPoint ( p / divisions );
				sum += current.distanceTo( last );
				cache.push( sum );
				last = current;
	
			}
	
			this.cacheArcLengths = cache;
	
			return cache; // { sums: cache, sum:sum }; Sum is in the last element.
	
		},
	
		updateArcLengths: function() {
	
			this.needsUpdate = true;
			this.getLengths();
	
		},
	
		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
	
		getUtoTmapping: function ( u, distance ) {
	
			var arcLengths = this.getLengths();
	
			var i = 0, il = arcLengths.length;
	
			var targetArcLength; // The targeted u distance value to get
	
			if ( distance ) {
	
				targetArcLength = distance;
	
			} else {
	
				targetArcLength = u * arcLengths[ il - 1 ];
	
			}
	
			//var time = Date.now();
	
			// binary search for the index with largest value smaller than target u distance
	
			var low = 0, high = il - 1, comparison;
	
			while ( low <= high ) {
	
				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
	
				comparison = arcLengths[ i ] - targetArcLength;
	
				if ( comparison < 0 ) {
	
					low = i + 1;
	
				} else if ( comparison > 0 ) {
	
					high = i - 1;
	
				} else {
	
					high = i;
					break;
	
					// DONE
	
				}
	
			}
	
			i = high;
	
			//console.log('b' , i, low, high, Date.now()- time);
	
			if ( arcLengths[ i ] === targetArcLength ) {
	
				var t = i / ( il - 1 );
				return t;
	
			}
	
			// we could get finer grain at lengths, or use simple interpolation between two points
	
			var lengthBefore = arcLengths[ i ];
			var lengthAfter = arcLengths[ i + 1 ];
	
			var segmentLength = lengthAfter - lengthBefore;
	
			// determine where we are between the 'before' and 'after' points
	
			var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;
	
			// add that fractional amount to t
	
			var t = ( i + segmentFraction ) / ( il - 1 );
	
			return t;
	
		},
	
		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation
	
		getTangent: function( t ) {
	
			var delta = 0.0001;
			var t1 = t - delta;
			var t2 = t + delta;
	
			// Capping in case of danger
	
			if ( t1 < 0 ) t1 = 0;
			if ( t2 > 1 ) t2 = 1;
	
			var pt1 = this.getPoint( t1 );
			var pt2 = this.getPoint( t2 );
	
			var vec = pt2.clone().sub( pt1 );
			return vec.normalize();
	
		},
	
		getTangentAt: function ( u ) {
	
			var t = this.getUtoTmapping( u );
			return this.getTangent( t );
	
		}
	
	}
	
	THREE.Curve.Utils = THREE.CurveUtils; // backwards compatibility
	
	// TODO: Transformation for Curves?
	
	/**************************************************************
	 *	3D Curves
	 **************************************************************/
	
	// A Factory method for creating new curve subclasses
	
	THREE.Curve.create = function ( constructor, getPointFunc ) {
	
		constructor.prototype = Object.create( THREE.Curve.prototype );
		constructor.prototype.constructor = constructor;
		constructor.prototype.getPoint = getPointFunc;
	
		return constructor;
	
	};
	
	// File:src/extras/core/CurvePath.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/
	
	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/
	
	THREE.CurvePath = function () {
	
		this.curves = [];
	
		this.autoClose = false; // Automatically closes the path
	
	};
	
	THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
	THREE.CurvePath.prototype.constructor = THREE.CurvePath;
	
	THREE.CurvePath.prototype.add = function ( curve ) {
	
		this.curves.push( curve );
	
	};
	
	/*
	THREE.CurvePath.prototype.checkConnection = function() {
		// TODO
		// If the ending of curve is not connected to the starting
		// or the next curve, then, this is not a real path
	};
	*/
	
	THREE.CurvePath.prototype.closePath = function() {
	
		// TODO Test
		// and verify for vector3 (needs to implement equals)
		// Add a line curve if start and end of lines are not connected
		var startPoint = this.curves[ 0 ].getPoint( 0 );
		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );
	
		if ( ! startPoint.equals( endPoint ) ) {
	
			this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );
	
		}
	
	};
	
	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:
	
	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')
	
	THREE.CurvePath.prototype.getPoint = function( t ) {
	
		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0;
	
		// To think about boundaries points.
	
		while ( i < curveLengths.length ) {
	
			if ( curveLengths[ i ] >= d ) {
	
				var diff = curveLengths[ i ] - d;
				var curve = this.curves[ i ];
	
				var u = 1 - diff / curve.getLength();
	
				return curve.getPointAt( u );
	
			}
	
			i ++;
	
		}
	
		return null;
	
		// loop where sum != 0, sum > d , sum+1 <d
	
	};
	
	/*
	THREE.CurvePath.prototype.getTangent = function( t ) {
	};
	*/
	
	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength
	
	THREE.CurvePath.prototype.getLength = function() {
	
		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];
	
	};
	
	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.
	
	THREE.CurvePath.prototype.getCurveLengths = function() {
	
		// We use cache values if curves and cache array are same length
	
		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {
	
			return this.cacheLengths;
	
		}
	
		// Get length of sub-curve
		// Push sums into cached array
	
		var lengths = [], sums = 0;
	
		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {
	
			sums += this.curves[ i ].getLength();
			lengths.push( sums );
	
		}
	
		this.cacheLengths = lengths;
	
		return lengths;
	
	};
	
	
	
	/**************************************************************
	 *	Create Geometries Helpers
	 **************************************************************/
	
	/// Generate geometry from path points (for Line or Points objects)
	
	THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {
	
		var pts = this.getPoints( divisions, true );
		return this.createGeometry( pts );
	
	};
	
	// Generate geometry from equidistant sampling along the path
	
	THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {
	
		var pts = this.getSpacedPoints( divisions, true );
		return this.createGeometry( pts );
	
	};
	
	THREE.CurvePath.prototype.createGeometry = function( points ) {
	
		var geometry = new THREE.Geometry();
	
		for ( var i = 0, l = points.length; i < l; i ++ ) {
	
			var point = points[ i ];
			geometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );
	
		}
	
		return geometry;
	
	};
	
	// File:src/extras/core/Path.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 *
	 **/
	
	THREE.Path = function ( points ) {
	
		THREE.CurvePath.call( this );
	
		this.actions = [];
	
		if ( points ) {
	
			this.fromPoints( points );
	
		}
	
	};
	
	THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
	THREE.Path.prototype.constructor = THREE.Path;
	
	// TODO Clean up PATH API
	
	// Create path using straight lines to connect all points
	// - vectors: array of Vector2
	
	THREE.Path.prototype.fromPoints = function ( vectors ) {
	
		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );
	
		for ( var i = 1, l = vectors.length; i < l; i ++ ) {
	
			this.lineTo( vectors[ i ].x, vectors[ i ].y );
	
		}
	
	};
	
	// startPath() endPath()?
	
	THREE.Path.prototype.moveTo = function ( x, y ) {
	
		this.actions.push( { action: 'moveTo', args: [ x, y ] } );
	
	};
	
	THREE.Path.prototype.lineTo = function ( x, y ) {
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
		this.curves.push( curve );
	
		this.actions.push( { action: 'lineTo', args: [ x, y ] } );
	
	};
	
	THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var curve = new THREE.QuadraticBezierCurve(
			new THREE.Vector2( x0, y0 ),
			new THREE.Vector2( aCPx, aCPy ),
			new THREE.Vector2( aX, aY )
		);
	
		this.curves.push( curve );
	
		this.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );
	
	};
	
	THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var curve = new THREE.CubicBezierCurve(
			new THREE.Vector2( x0, y0 ),
			new THREE.Vector2( aCP1x, aCP1y ),
			new THREE.Vector2( aCP2x, aCP2y ),
			new THREE.Vector2( aX, aY )
		);
	
		this.curves.push( curve );
	
		this.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );
	
	};
	
	THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {
	
		var args = Array.prototype.slice.call( arguments );
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var npts = [ new THREE.Vector2( x0, y0 ) ];
		Array.prototype.push.apply( npts, pts );
	
		var curve = new THREE.SplineCurve( npts );
		this.curves.push( curve );
	
		this.actions.push( { action: 'splineThru', args: args } );
	
	};
	
	// FUTURE: Change the API or follow canvas API?
	
	THREE.Path.prototype.arc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );
	
	 };
	
	 THREE.Path.prototype.absarc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	
	 };
	
	THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	
	 };
	
	
	THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
		var args = [
			aX, aY,
			xRadius, yRadius,
			aStartAngle, aEndAngle,
			aClockwise,
			aRotation || 0 // aRotation is optional.
		];
	
		var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
		this.curves.push( curve );
	
		var lastPoint = curve.getPoint( 1 );
		args.push( lastPoint.x );
		args.push( lastPoint.y );
	
		this.actions.push( { action: 'ellipse', args: args } );
	
	 };
	
	THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {
	
		if ( ! divisions ) divisions = 40;
	
		var points = [];
	
		for ( var i = 0; i < divisions; i ++ ) {
	
			points.push( this.getPoint( i / divisions ) );
	
			//if ( !this.getPoint( i / divisions ) ) throw "DIE";
	
		}
	
		// if ( closedPath ) {
		//
		// 	points.push( points[ 0 ] );
		//
		// }
	
		return points;
	
	};
	
	/* Return an array of vectors based on contour of the path */
	
	THREE.Path.prototype.getPoints = function( divisions, closedPath ) {
	
		divisions = divisions || 12;
	
		var b2 = THREE.ShapeUtils.b2;
		var b3 = THREE.ShapeUtils.b3;
	
		var points = [];
	
		var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
			laste, tx, ty;
	
		for ( var i = 0, l = this.actions.length; i < l; i ++ ) {
	
			var item = this.actions[ i ];
	
			var action = item.action;
			var args = item.args;
	
			switch ( action ) {
	
			case 'moveTo':
	
				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );
	
				break;
	
			case 'lineTo':
	
				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );
	
				break;
	
			case 'quadraticCurveTo':
	
				cpx  = args[ 2 ];
				cpy  = args[ 3 ];
	
				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];
	
				if ( points.length > 0 ) {
	
					laste = points[ points.length - 1 ];
	
					cpx0 = laste.x;
					cpy0 = laste.y;
	
				} else {
	
					laste = this.actions[ i - 1 ].args;
	
					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];
	
				}
	
				for ( var j = 1; j <= divisions; j ++ ) {
	
					var t = j / divisions;
	
					tx = b2( t, cpx0, cpx1, cpx );
					ty = b2( t, cpy0, cpy1, cpy );
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				break;
	
			case 'bezierCurveTo':
	
				cpx  = args[ 4 ];
				cpy  = args[ 5 ];
	
				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];
	
				cpx2 = args[ 2 ];
				cpy2 = args[ 3 ];
	
				if ( points.length > 0 ) {
	
					laste = points[ points.length - 1 ];
	
					cpx0 = laste.x;
					cpy0 = laste.y;
	
				} else {
	
					laste = this.actions[ i - 1 ].args;
	
					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];
	
				}
	
	
				for ( var j = 1; j <= divisions; j ++ ) {
	
					var t = j / divisions;
	
					tx = b3( t, cpx0, cpx1, cpx2, cpx );
					ty = b3( t, cpy0, cpy1, cpy2, cpy );
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				break;
	
			case 'splineThru':
	
				laste = this.actions[ i - 1 ].args;
	
				var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
				var spts = [ last ];
	
				var n = divisions * args[ 0 ].length;
	
				spts = spts.concat( args[ 0 ] );
	
				var spline = new THREE.SplineCurve( spts );
	
				for ( var j = 1; j <= n; j ++ ) {
	
					points.push( spline.getPointAt( j / n ) );
	
				}
	
				break;
	
			case 'arc':
	
				var aX = args[ 0 ], aY = args[ 1 ],
					aRadius = args[ 2 ],
					aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
					aClockwise = !! args[ 5 ];
	
				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;
	
				for ( var j = 1; j <= tdivisions; j ++ ) {
	
					var t = j / tdivisions;
	
					if ( ! aClockwise ) {
	
						t = 1 - t;
	
					}
	
					angle = aStartAngle + t * deltaAngle;
	
					tx = aX + aRadius * Math.cos( angle );
					ty = aY + aRadius * Math.sin( angle );
	
					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				//console.log(points);
	
				break;
	
			case 'ellipse':
	
				var aX = args[ 0 ], aY = args[ 1 ],
					xRadius = args[ 2 ],
					yRadius = args[ 3 ],
					aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
					aClockwise = !! args[ 6 ],
					aRotation = args[ 7 ];
	
	
				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;
	
				var cos, sin;
				if ( aRotation !== 0 ) {
	
					cos = Math.cos( aRotation );
					sin = Math.sin( aRotation );
	
				}
	
				for ( var j = 1; j <= tdivisions; j ++ ) {
	
					var t = j / tdivisions;
	
					if ( ! aClockwise ) {
	
						t = 1 - t;
	
					}
	
					angle = aStartAngle + t * deltaAngle;
	
					tx = aX + xRadius * Math.cos( angle );
					ty = aY + yRadius * Math.sin( angle );
	
					if ( aRotation !== 0 ) {
	
						var x = tx, y = ty;
	
						// Rotate the point about the center of the ellipse.
						tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;
						ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;
	
					}
	
					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				//console.log(points);
	
				break;
	
			} // end switch
	
		}
	
	
	
		// Normalize to remove the closing point by default.
		var lastPoint = points[ points.length - 1 ];
		if ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&
				 Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )
			points.splice( points.length - 1, 1 );
		if ( closedPath ) {
	
			points.push( points[ 0 ] );
	
		}
	
		return points;
	
	};
	
	//
	// Breaks path into shapes
	//
	//	Assumptions (if parameter isCCW==true the opposite holds):
	//	- solid shapes are defined clockwise (CW)
	//	- holes are defined counterclockwise (CCW)
	//
	//	If parameter noHoles==true:
	//  - all subPaths are regarded as solid shapes
	//  - definition order CW/CCW has no relevance
	//
	
	THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {
	
		function extractSubpaths( inActions ) {
	
			var subPaths = [], lastPath = new THREE.Path();
	
			for ( var i = 0, l = inActions.length; i < l; i ++ ) {
	
				var item = inActions[ i ];
	
				var args = item.args;
				var action = item.action;
	
				if ( action === 'moveTo' ) {
	
					if ( lastPath.actions.length !== 0 ) {
	
						subPaths.push( lastPath );
						lastPath = new THREE.Path();
	
					}
	
				}
	
				lastPath[ action ].apply( lastPath, args );
	
			}
	
			if ( lastPath.actions.length !== 0 ) {
	
				subPaths.push( lastPath );
	
			}
	
			// console.log(subPaths);
	
			return	subPaths;
	
		}
	
		function toShapesNoHoles( inSubpaths ) {
	
			var shapes = [];
	
			for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {
	
				var tmpPath = inSubpaths[ i ];
	
				var tmpShape = new THREE.Shape();
				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;
	
				shapes.push( tmpShape );
	
			}
	
			//console.log("shape", shapes);
	
			return shapes;
	
		}
	
		function isPointInsidePolygon( inPt, inPolygon ) {
	
			var polyLen = inPolygon.length;
	
			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			var inside = false;
			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
	
				var edgeLowPt  = inPolygon[ p ];
				var edgeHighPt = inPolygon[ q ];
	
				var edgeDx = edgeHighPt.x - edgeLowPt.x;
				var edgeDy = edgeHighPt.y - edgeLowPt.y;
	
				if ( Math.abs( edgeDy ) > Number.EPSILON ) {
	
					// not parallel
					if ( edgeDy < 0 ) {
	
						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
	
					}
					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;
	
					if ( inPt.y === edgeLowPt.y ) {
	
						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!
	
					} else {
	
						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt
	
					}
	
				} else {
	
					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;
	
				}
	
			}
	
			return	inside;
	
		}
	
		var isClockWise = THREE.ShapeUtils.isClockWise;
	
		var subPaths = extractSubpaths( this.actions );
		if ( subPaths.length === 0 ) return [];
	
		if ( noHoles === true )	return	toShapesNoHoles( subPaths );
	
	
		var solid, tmpPath, tmpShape, shapes = [];
	
		if ( subPaths.length === 1 ) {
	
			tmpPath = subPaths[ 0 ];
			tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;
	
		}
	
		var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;
	
		// console.log("Holes first", holesFirst);
	
		var betterShapeHoles = [];
		var newShapes = [];
		var newShapeHoles = [];
		var mainIdx = 0;
		var tmpPoints;
	
		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];
	
		for ( var i = 0, l = subPaths.length; i < l; i ++ ) {
	
			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;
	
			if ( solid ) {
	
				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;
	
				newShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.actions = tmpPath.actions;
				newShapes[ mainIdx ].s.curves = tmpPath.curves;
	
				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];
	
				//console.log('cw', i);
	
			} else {
	
				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );
	
				//console.log('ccw', i);
	
			}
	
		}
	
		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );
	
	
		if ( newShapes.length > 1 ) {
	
			var ambiguous = false;
			var toChange = [];
	
			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
	
				betterShapeHoles[ sIdx ] = [];
	
			}
	
			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
	
				var sho = newShapeHoles[ sIdx ];
	
				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
	
					var ho = sho[ hIdx ];
					var hole_unassigned = true;
	
					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
	
						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {
	
							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {
	
								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );
	
							} else {
	
								ambiguous = true;
	
							}
	
						}
	
					}
					if ( hole_unassigned ) {
	
						betterShapeHoles[ sIdx ].push( ho );
	
					}
	
				}
	
			}
			// console.log("ambiguous: ", ambiguous);
			if ( toChange.length > 0 ) {
	
				// console.log("to change: ", toChange);
				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;
	
			}
	
		}
	
		var tmpHoles;
	
		for ( var i = 0, il = newShapes.length; i < il; i ++ ) {
	
			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];
	
			for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
	
				tmpShape.holes.push( tmpHoles[ j ].h );
	
			}
	
		}
	
		//console.log("shape", shapes);
	
		return shapes;
	
	};
	
	// File:src/extras/core/Shape.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/
	
	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.
	
	THREE.Shape = function () {
	
		THREE.Path.apply( this, arguments );
	
		this.holes = [];
	
	};
	
	THREE.Shape.prototype = Object.create( THREE.Path.prototype );
	THREE.Shape.prototype.constructor = THREE.Shape;
	
	// Convenience method to return ExtrudeGeometry
	
	THREE.Shape.prototype.extrude = function ( options ) {
	
		return new THREE.ExtrudeGeometry( this, options );
	
	};
	
	// Convenience method to return ShapeGeometry
	
	THREE.Shape.prototype.makeGeometry = function ( options ) {
	
		return new THREE.ShapeGeometry( this, options );
	
	};
	
	// Get points of holes
	
	THREE.Shape.prototype.getPointsHoles = function ( divisions ) {
	
		var holesPts = [];
	
		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {
	
			holesPts[ i ] = this.holes[ i ].getPoints( divisions );
	
		}
	
		return holesPts;
	
	};
	
	
	// Get points of shape and holes (keypoints based on segments parameter)
	
	THREE.Shape.prototype.extractAllPoints = function ( divisions ) {
	
		return {
	
			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )
	
		};
	
	};
	
	THREE.Shape.prototype.extractPoints = function ( divisions ) {
	
		return this.extractAllPoints( divisions );
	
	};
	
	THREE.Shape.Utils = THREE.ShapeUtils; // backwards compatibility
	
	// File:src/extras/curves/LineCurve.js
	
	/**************************************************************
	 *	Line
	 **************************************************************/
	
	THREE.LineCurve = function ( v1, v2 ) {
	
		this.v1 = v1;
		this.v2 = v2;
	
	};
	
	THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.LineCurve.prototype.constructor = THREE.LineCurve;
	
	THREE.LineCurve.prototype.getPoint = function ( t ) {
	
		var point = this.v2.clone().sub( this.v1 );
		point.multiplyScalar( t ).add( this.v1 );
	
		return point;
	
	};
	
	// Line curve is linear, so we can overwrite default getPointAt
	
	THREE.LineCurve.prototype.getPointAt = function ( u ) {
	
		return this.getPoint( u );
	
	};
	
	THREE.LineCurve.prototype.getTangent = function( t ) {
	
		var tangent = this.v2.clone().sub( this.v1 );
	
		return tangent.normalize();
	
	};
	
	// File:src/extras/curves/QuadraticBezierCurve.js
	
	/**************************************************************
	 *	Quadratic Bezier curve
	 **************************************************************/
	
	
	THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {
	
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
	
	};
	
	THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;
	
	
	THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {
	
		var b2 = THREE.ShapeUtils.b2;
	
		return new THREE.Vector2(
			b2( t, this.v0.x, this.v1.x, this.v2.x ),
			b2( t, this.v0.y, this.v1.y, this.v2.y )
		);
	
	};
	
	
	THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {
	
		var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;
	
		return new THREE.Vector2(
			tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
			tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
		).normalize();
	
	};
	
	// File:src/extras/curves/CubicBezierCurve.js
	
	/**************************************************************
	 *	Cubic Bezier curve
	 **************************************************************/
	
	THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {
	
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;
	
	};
	
	THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;
	
	THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {
	
		var b3 = THREE.ShapeUtils.b3;
	
		return new THREE.Vector2( 
			b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
			b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
		);
	
	};
	
	THREE.CubicBezierCurve.prototype.getTangent = function( t ) {
	
		var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;
	
		return new THREE.Vector2( 
			tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
			tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
		).normalize();
	
	};
	
	// File:src/extras/curves/SplineCurve.js
	
	/**************************************************************
	 *	Spline curve
	 **************************************************************/
	
	THREE.SplineCurve = function ( points /* array of Vector2 */ ) {
	
		this.points = ( points == undefined ) ? [] : points;
	
	};
	
	THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;
	
	THREE.SplineCurve.prototype.getPoint = function ( t ) {
	
		var points = this.points;
		var point = ( points.length - 1 ) * t;
	
		var intPoint = Math.floor( point );
		var weight = point - intPoint;
	
		var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		var point1 = points[ intPoint ];
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];
	
		var interpolate = THREE.CurveUtils.interpolate;
	
		return new THREE.Vector2(
			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
			interpolate( point0.y, point1.y, point2.y, point3.y, weight )
		);
	
	};
	
	// File:src/extras/curves/EllipseCurve.js
	
	/**************************************************************
	 *	Ellipse curve
	 **************************************************************/
	
	THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
		this.aX = aX;
		this.aY = aY;
	
		this.xRadius = xRadius;
		this.yRadius = yRadius;
	
		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;
	
		this.aClockwise = aClockwise;
		
		this.aRotation = aRotation || 0;
	
	};
	
	THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;
	
	THREE.EllipseCurve.prototype.getPoint = function ( t ) {
	
		var deltaAngle = this.aEndAngle - this.aStartAngle;
	
		if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
		if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;
	
		var angle;
	
		if ( this.aClockwise === true ) {
	
			angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );
	
		} else {
	
			angle = this.aStartAngle + t * deltaAngle;
	
		}
		
		var x = this.aX + this.xRadius * Math.cos( angle );
		var y = this.aY + this.yRadius * Math.sin( angle );
	
		if ( this.aRotation !== 0 ) {
	
			var cos = Math.cos( this.aRotation );
			var sin = Math.sin( this.aRotation );
	
			var tx = x, ty = y;
	
			// Rotate the point about the center of the ellipse.
			x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;
			y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;
	
		}
	
		return new THREE.Vector2( x, y );
	
	};
	
	// File:src/extras/curves/ArcCurve.js
	
	/**************************************************************
	 *	Arc curve
	 **************************************************************/
	
	THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
		THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	
	};
	
	THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
	THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;
	
	// File:src/extras/curves/LineCurve3.js
	
	/**************************************************************
	 *	Line3D
	 **************************************************************/
	
	THREE.LineCurve3 = THREE.Curve.create(
	
		function ( v1, v2 ) {
	
			this.v1 = v1;
			this.v2 = v2;
	
		},
	
		function ( t ) {
	
			var vector = new THREE.Vector3();
	
			vector.subVectors( this.v2, this.v1 ); // diff
			vector.multiplyScalar( t );
			vector.add( this.v1 );
	
			return vector;
	
		}
	
	);
	
	// File:src/extras/curves/QuadraticBezierCurve3.js
	
	/**************************************************************
	 *	Quadratic Bezier 3D curve
	 **************************************************************/
	
	THREE.QuadraticBezierCurve3 = THREE.Curve.create(
	
		function ( v0, v1, v2 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
	
		},
	
		function ( t ) {
	
			var b2 = THREE.ShapeUtils.b2;		
	
			return new THREE.Vector3(
				b2( t, this.v0.x, this.v1.x, this.v2.x ),
				b2( t, this.v0.y, this.v1.y, this.v2.y ),
				b2( t, this.v0.z, this.v1.z, this.v2.z )
			);
	
		}
	
	);
	
	// File:src/extras/curves/CubicBezierCurve3.js
	
	/**************************************************************
	 *	Cubic Bezier 3D curve
	 **************************************************************/
	
	THREE.CubicBezierCurve3 = THREE.Curve.create(
	
		function ( v0, v1, v2, v3 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
	
		},
	
		function ( t ) {
	
			var b3 = THREE.ShapeUtils.b3;
	
			return new THREE.Vector3(
				b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
				b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
				b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
			);
	
		}
	
	);
	
	// File:src/extras/curves/SplineCurve3.js
	
	/**************************************************************
	 *	Spline 3D curve
	 **************************************************************/
	
	
	THREE.SplineCurve3 = THREE.Curve.create(
	
		function ( points /* array of Vector3 */ ) {
	
			console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
			this.points = ( points == undefined ) ? [] : points;
	
		},
	
		function ( t ) {
	
			var points = this.points;
			var point = ( points.length - 1 ) * t;
	
			var intPoint = Math.floor( point );
			var weight = point - intPoint;
	
			var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
			var point1 = points[ intPoint ];
			var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];
	
			var interpolate = THREE.CurveUtils.interpolate;
	
			return new THREE.Vector3(
				interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
				interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
				interpolate( point0.z, point1.z, point2.z, point3.z, weight )
			);
	
		}
	
	);
	
	// File:src/extras/curves/CatmullRomCurve3.js
	
	/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */
	
	THREE.CatmullRomCurve3 = ( function() {
	
		var
			tmp = new THREE.Vector3(),
			px = new CubicPoly(),
			py = new CubicPoly(),
			pz = new CubicPoly();
	
		/*
		Based on an optimized c++ solution in
		 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
		 - http://ideone.com/NoEbVM
	
		This CubicPoly class could be used for reusing some variables and calculations,
		but for three.js curve use, it could be possible inlined and flatten into a single function call
		which can be placed in CurveUtils.
		*/
	
		function CubicPoly() {
	
		}
	
		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {
	
			this.c0 = x0;
			this.c1 = t0;
			this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			this.c3 = 2 * x0 - 2 * x1 + t0 + t1;
	
		};
	
		CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {
	
			// compute tangents when parameterized in [t1,t2]
			var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;
	
			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;
	
			// initCubicPoly
			this.init( x1, x2, t1, t2 );
	
		};
	
		// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
		CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {
	
			this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );
	
		};
	
		CubicPoly.prototype.calc = function( t ) {
	
			var t2 = t * t;
			var t3 = t2 * t;
			return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;
	
		};
	
		// Subclass Three.js curve
		return THREE.Curve.create(
	
			function ( p /* array of Vector3 */ ) {
	
				this.points = p || [];
	
			},
	
			function ( t ) {
	
				var points = this.points,
					point, intPoint, weight, l;
	
				l = points.length;
	
				if ( l < 2 ) console.log( 'duh, you need at least 2 points' );
	
				point = ( l - 1 ) * t;
				intPoint = Math.floor( point );
				weight = point - intPoint;
	
				if ( weight === 0 && intPoint === l - 1 ) {
	
					intPoint = l - 2;
					weight = 1;
	
				}
	
				var p0, p1, p2, p3;
	
				if ( intPoint === 0 ) {
	
					// extrapolate first point
					tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
					p0 = tmp;
	
				} else {
	
					p0 = points[ intPoint - 1 ];
	
				}
	
				p1 = points[ intPoint ];
				p2 = points[ intPoint + 1 ];
	
				if ( intPoint + 2 < l ) {
	
					p3 = points[ intPoint + 2 ]
	
				} else {
	
					// extrapolate last point
					tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 2 ] );
					p3 = tmp;
	
				}
	
				if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {
	
					// init Centripetal / Chordal Catmull-Rom
					var pow = this.type === 'chordal' ? 0.5 : 0.25;
					var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
					var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
					var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );
	
					// safety check for repeated points
					if ( dt1 < 1e-4 ) dt1 = 1.0;
					if ( dt0 < 1e-4 ) dt0 = dt1;
					if ( dt2 < 1e-4 ) dt2 = dt1;
	
					px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
					py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
					pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );
	
				} else if ( this.type === 'catmullrom' ) {
	
					var tension = this.tension !== undefined ? this.tension : 0.5;
					px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
					py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
					pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );
	
				}
	
				var v = new THREE.Vector3(
					px.calc( weight ),
					py.calc( weight ),
					pz.calc( weight )
				);
	
				return v;
	
			}
	
		);
	
	} )();
	
	// File:src/extras/curves/ClosedSplineCurve3.js
	
	/**************************************************************
	 *	Closed Spline 3D curve
	 **************************************************************/
	
	
	THREE.ClosedSplineCurve3 = THREE.Curve.create(
	
		function ( points /* array of Vector3 */ ) {
	
			this.points = ( points == undefined ) ? [] : points;
	
		},
	
		function ( t ) {
	
			var points = this.points;
			var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1
	
			var intPoint = Math.floor( point );
			var weight = point - intPoint;
	
			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;
	
			var point0 = points[ ( intPoint - 1 ) % points.length ];
			var point1 = points[ ( intPoint     ) % points.length ];
			var point2 = points[ ( intPoint + 1 ) % points.length ];
			var point3 = points[ ( intPoint + 2 ) % points.length ];
	
			var interpolate = THREE.CurveUtils.interpolate;
	
			return new THREE.Vector3(
				interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
				interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
				interpolate( point0.z, point1.z, point2.z, point3.z, weight )
			);
	
		}
	
	);
	
	// File:src/extras/geometries/BoxGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
	 */
	
	THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'BoxGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};
	
		this.widthSegments = widthSegments || 1;
		this.heightSegments = heightSegments || 1;
		this.depthSegments = depthSegments || 1;
	
		var scope = this;
	
		var width_half = width / 2;
		var height_half = height / 2;
		var depth_half = depth / 2;
	
		buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
		buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
		buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
		buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
		buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
		buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz
	
		function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {
	
			var w, ix, iy,
			gridX = scope.widthSegments,
			gridY = scope.heightSegments,
			width_half = width / 2,
			height_half = height / 2,
			offset = scope.vertices.length;
	
			if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {
	
				w = 'z';
	
			} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {
	
				w = 'y';
				gridY = scope.depthSegments;
	
			} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {
	
				w = 'x';
				gridX = scope.depthSegments;
	
			}
	
			var gridX1 = gridX + 1,
			gridY1 = gridY + 1,
			segment_width = width / gridX,
			segment_height = height / gridY,
			normal = new THREE.Vector3();
	
			normal[ w ] = depth > 0 ? 1 : - 1;
	
			for ( iy = 0; iy < gridY1; iy ++ ) {
	
				for ( ix = 0; ix < gridX1; ix ++ ) {
	
					var vector = new THREE.Vector3();
					vector[ u ] = ( ix * segment_width - width_half ) * udir;
					vector[ v ] = ( iy * segment_height - height_half ) * vdir;
					vector[ w ] = depth;
	
					scope.vertices.push( vector );
	
				}
	
			}
	
			for ( iy = 0; iy < gridY; iy ++ ) {
	
				for ( ix = 0; ix < gridX; ix ++ ) {
	
					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;
	
					var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
					var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
					var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
					var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );
	
					var face = new THREE.Face3( a + offset, b + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;
	
					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );
	
					face = new THREE.Face3( b + offset, c + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;
	
					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );
	
				}
	
			}
	
		}
	
		this.mergeVertices();
	
	};
	
	THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;
	
	THREE.BoxGeometry.prototype.clone = function () {
	
		var parameters = this.parameters;
	
		return new THREE.BoxGeometry(
			parameters.width,
			parameters.height,
			parameters.depth,
			parameters.widthSegments,
			parameters.heightSegments,
			parameters.depthSegments
		);
	
	};
	
	THREE.CubeGeometry = THREE.BoxGeometry; // backwards compatibility
	
	// File:src/extras/geometries/CircleGeometry.js
	
	/**
	 * @author hughes
	 */
	
	THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'CircleGeometry';
	
		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		this.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
	
	};
	
	THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;
	
	THREE.CircleGeometry.prototype.clone = function () {
	
		var parameters = this.parameters;
	
		return new THREE.CircleGeometry(
			parameters.radius,
			parameters.segments,
			parameters.thetaStart,
			parameters.thetaLength
		);
	
	};
	
	// File:src/extras/geometries/CircleBufferGeometry.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	THREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'CircleBufferGeometry';
	
		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		radius = radius || 50;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
		var vertices = segments + 2;
	
		var positions = new Float32Array( vertices * 3 );
		var normals = new Float32Array( vertices * 3 );
		var uvs = new Float32Array( vertices * 2 );
	
		// center data is already zero, but need to set a few extras
		normals[ 2 ] = 1.0;
		uvs[ 0 ] = 0.5;
		uvs[ 1 ] = 0.5;
	
		for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {
	
			var segment = thetaStart + s / segments * thetaLength;
	
			positions[ i ] = radius * Math.cos( segment );
			positions[ i + 1 ] = radius * Math.sin( segment );
	
			normals[ i + 2 ] = 1; // normal z
	
			uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
			uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;
	
		}
	
		var indices = [];
	
		for ( var i = 1; i <= segments; i ++ ) {
	
			indices.push( i, i + 1, 0 );
	
		}
	
		this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;
	
	THREE.CircleBufferGeometry.prototype.clone = function () {
	
		var parameters = this.parameters;
	
		return new THREE.CircleBufferGeometry(
			parameters.radius,
			parameters.segments,
			parameters.thetaStart,
			parameters.thetaLength
		);
	
	};
	
	// File:src/extras/geometries/CylinderGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'CylinderGeometry';
	
		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		radiusTop = radiusTop !== undefined ? radiusTop : 20;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
		height = height !== undefined ? height : 100;
	
		radialSegments = radialSegments || 8;
		heightSegments = heightSegments || 1;
	
		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;
	
		var heightHalf = height / 2;
	
		var x, y, vertices = [], uvs = [];
	
		for ( y = 0; y <= heightSegments; y ++ ) {
	
			var verticesRow = [];
			var uvsRow = [];
	
			var v = y / heightSegments;
			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;
	
			for ( x = 0; x <= radialSegments; x ++ ) {
	
				var u = x / radialSegments;
	
				var vertex = new THREE.Vector3();
				vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
				vertex.y = - v * height + heightHalf;
				vertex.z = radius * Math.cos( u * thetaLength + thetaStart );
	
				this.vertices.push( vertex );
	
				verticesRow.push( this.vertices.length - 1 );
				uvsRow.push( new THREE.Vector2( u, 1 - v ) );
	
			}
	
			vertices.push( verticesRow );
			uvs.push( uvsRow );
	
		}
	
		var tanTheta = ( radiusBottom - radiusTop ) / height;
		var na, nb;
	
		for ( x = 0; x < radialSegments; x ++ ) {
	
			if ( radiusTop !== 0 ) {
	
				na = this.vertices[ vertices[ 0 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();
	
			} else {
	
				na = this.vertices[ vertices[ 1 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();
	
			}
	
			na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
			nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();
	
			for ( y = 0; y < heightSegments; y ++ ) {
	
				var v1 = vertices[ y ][ x ];
				var v2 = vertices[ y + 1 ][ x ];
				var v3 = vertices[ y + 1 ][ x + 1 ];
				var v4 = vertices[ y ][ x + 1 ];
	
				var n1 = na.clone();
				var n2 = na.clone();
				var n3 = nb.clone();
				var n4 = nb.clone();
	
				var uv1 = uvs[ y ][ x ].clone();
				var uv2 = uvs[ y + 1 ][ x ].clone();
				var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
				var uv4 = uvs[ y ][ x + 1 ].clone();
	
				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );
	
				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );
	
			}
	
		}
	
		// top cap
	
		if ( openEnded === false && radiusTop > 0 ) {
	
			this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );
	
			for ( x = 0; x < radialSegments; x ++ ) {
	
				var v1 = vertices[ 0 ][ x ];
				var v2 = vertices[ 0 ][ x + 1 ];
				var v3 = this.vertices.length - 1;
	
				var n1 = new THREE.Vector3( 0, 1, 0 );
				var n2 = new THREE.Vector3( 0, 1, 0 );
				var n3 = new THREE.Vector3( 0, 1, 0 );
	
				var uv1 = uvs[ 0 ][ x ].clone();
				var uv2 = uvs[ 0 ][ x + 1 ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 0 );
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 1 ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );
	
			}
	
		}
	
		// bottom cap
	
		if ( openEnded === false && radiusBottom > 0 ) {
	
			this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );
	
			for ( x = 0; x < radialSegments; x ++ ) {
	
				var v1 = vertices[ heightSegments ][ x + 1 ];
				var v2 = vertices[ heightSegments ][ x ];
				var v3 = this.vertices.length - 1;
	
				var n1 = new THREE.Vector3( 0, - 1, 0 );
				var n2 = new THREE.Vector3( 0, - 1, 0 );
				var n3 = new THREE.Vector3( 0, - 1, 0 );
	
				var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
				var uv2 = uvs[ heightSegments ][ x ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 1 );
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 2 ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );
	
			}
	
		}
	
		this.computeFaceNormals();
	
	};
	
	THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;
	
	THREE.CylinderGeometry.prototype.clone = function () {
	
		var parameters = this.parameters;
	
		return new THREE.CylinderGeometry(
			parameters.radiusTop,
			parameters.radiusBottom,
			parameters.height,
			parameters.radialSegments,
			parameters.heightSegments,
			parameters.openEnded,
			parameters.thetaStart,
			parameters.thetaLength
		);
	
	};
	
	// File:src/extras/geometries/EdgesGeometry.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.EdgesGeometry = function ( geometry, thresholdAngle ) {
	
		THREE.BufferGeometry.call( this );
	
		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;
	
		var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );
	
		var edge = [ 0, 0 ], hash = {};
	
		function sortFunction( a, b ) {
	
			return a - b;
	
		}
	
		var keys = [ 'a', 'b', 'c' ];
	
		var geometry2;
	
		if ( geometry instanceof THREE.BufferGeometry ) {
	
			geometry2 = new THREE.Geometry();
			geometry2.fromBufferGeometry( geometry );
	
		} else {
	
			geometry2 = geometry.clone();
	
		}
	
		geometry2.mergeVertices();
		geometry2.computeFaceNormals();
	
		var vertices = geometry2.vertices;
		var faces = geometry2.faces;
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			var face = faces[ i ];
	
			for ( var j = 0; j < 3; j ++ ) {
	
				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );
	
				var key = edge.toString();
	
				if ( hash[ key ] === undefined ) {
	
					hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
	
				} else {
	
					hash[ key ].face2 = i;
	
				}
	
			}
	
		}
	
		var coords = [];
	
		for ( var key in hash ) {
	
			var h = hash[ key ];
	
			if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {
	
				var vertex = vertices[ h.vert1 ];
				coords.push( vertex.x );
				coords.push( vertex.y );
				coords.push( vertex.z );
	
				vertex = vertices[ h.vert2 ];
				coords.push( vertex.x );
				coords.push( vertex.y );
				coords.push( vertex.z );
	
			}
	
		}
	
		this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );
	
	};
	
	THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;
	
	// File:src/extras/geometries/ExtrudeGeometry.js
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
	 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
	 *
	 *  uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/
	
	THREE.ExtrudeGeometry = function ( shapes, options ) {
	
		if ( typeof( shapes ) === "undefined" ) {
	
			shapes = [];
			return;
	
		}
	
		THREE.Geometry.call( this );
	
		this.type = 'ExtrudeGeometry';
	
		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];
	
		this.addShapeList( shapes, options );
	
		this.computeFaceNormals();
	
		// can't really use automatic vertex normals
		// as then front and back sides get smoothed too
		// should do separate smoothing just for sides
	
		//this.computeVertexNormals();
	
		//console.log( "took", ( Date.now() - startTime ) );
	
	};
	
	THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;
	
	THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
	
		var sl = shapes.length;
	
		for ( var s = 0; s < sl; s ++ ) {
	
			var shape = shapes[ s ];
			this.addShape( shape, options );
	
		}
	
	};
	
	THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {
	
		var amount = options.amount !== undefined ? options.amount : 100;
	
		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
	
		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false
	
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
		var steps = options.steps !== undefined ? options.steps : 1;
	
		var extrudePath = options.extrudePath;
		var extrudePts, extrudeByPath = false;
	
		// Use default WorldUVGenerator if no UV generators are specified.
		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
	
		var splineTube, binormal, normal, position2;
		if ( extrudePath ) {
	
			extrudePts = extrudePath.getSpacedPoints( steps );
	
			extrudeByPath = true;
			bevelEnabled = false; // bevels not supported for path extrusion
	
			// SETUP TNB variables
	
			// Reuse TNB from TubeGeomtry for now.
			// TODO1 - have a .isClosed in spline?
	
			splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );
	
			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
	
			binormal = new THREE.Vector3();
			normal = new THREE.Vector3();
			position2 = new THREE.Vector3();
	
		}
	
		// Safeguards if bevels are not enabled
	
		if ( ! bevelEnabled ) {
	
			bevelSegments = 0;
			bevelThickness = 0;
			bevelSize = 0;
	
		}
	
		// Variables initialization
	
		var ahole, h, hl; // looping of holes
		var scope = this;
	
		var shapesOffset = this.vertices.length;
	
		var shapePoints = shape.extractPoints( curveSegments );
	
		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;
	
		var reverse = ! THREE.ShapeUtils.isClockWise( vertices );
	
		if ( reverse ) {
	
			vertices = vertices.reverse();
	
			// Maybe we should also check if holes are in the opposite direction, just to be safe ...
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
	
				if ( THREE.ShapeUtils.isClockWise( ahole ) ) {
	
					holes[ h ] = ahole.reverse();
	
				}
	
			}
	
			reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!
	
		}
	
	
		var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );
	
		/* Vertices */
	
		var contour = vertices; // vertices has all points but contour has only points of circumference
	
		for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
			ahole = holes[ h ];
	
			vertices = vertices.concat( ahole );
	
		}
	
	
		function scalePt2 ( pt, vec, size ) {
	
			if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );
	
			return vec.clone().multiplyScalar( size ).add( pt );
	
		}
	
		var b, bs, t, z,
			vert, vlen = vertices.length,
			face, flen = faces.length;
	
	
		// Find directions for point movement
	
	
		function getBevelVec( inPt, inPrev, inNext ) {
	
			// computes for inPt the corresponding point inPt' on a new contour
			//   shifted by 1 unit (length of normalized vector) to the left
			// if we walk along contour clockwise, this new contour is outside the old one
			//
			// inPt' is the intersection of the two lines parallel to the two
			//  adjacent edges of inPt at a distance of 1 unit on the left side.
	
			var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt
	
			// good reading for geometry algorithms (here: line-line intersection)
			// http://geomalgorithms.com/a05-_intersect-1.html
	
			var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
			var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
	
			var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
	
			// check for collinear edges
			var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
			if ( Math.abs( collinear0 ) > Number.EPSILON ) {
	
				// not collinear
	
				// length of vectors for normalizing
	
				var v_prev_len = Math.sqrt( v_prev_lensq );
				var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
	
				// shift adjacent points by unit vectors to the left
	
				var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
				var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
	
				var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
				var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
	
				// scaling factor for v_prev to intersection point
	
				var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
						  ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
				// vector from inPt to intersection point
	
				v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
				v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
	
				// Don't normalize!, otherwise sharp corners become ugly
				//  but prevent crazy spikes
				var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
				if ( v_trans_lensq <= 2 ) {
	
					return	new THREE.Vector2( v_trans_x, v_trans_y );
	
				} else {
	
					shrink_by = Math.sqrt( v_trans_lensq / 2 );
	
				}
	
			} else {
	
				// handle special case of collinear edges
	
				var direction_eq = false;		// assumes: opposite
				if ( v_prev_x > Number.EPSILON ) {
	
					if ( v_next_x > Number.EPSILON ) {
	
						direction_eq = true;
	
					}
	
				} else {
	
					if ( v_prev_x < - Number.EPSILON ) {
	
						if ( v_next_x < - Number.EPSILON ) {
	
							direction_eq = true;
	
						}
	
					} else {
	
						if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {
	
							direction_eq = true;
	
						}
	
					}
	
				}
	
				if ( direction_eq ) {
	
					// console.log("Warning: lines are a straight sequence");
					v_trans_x = - v_prev_y;
					v_trans_y =  v_prev_x;
					shrink_by = Math.sqrt( v_prev_lensq );
	
				} else {
	
					// console.log("Warning: lines are a straight spike");
					v_trans_x = v_prev_x;
					v_trans_y = v_prev_y;
					shrink_by = Math.sqrt( v_prev_lensq / 2 );
	
				}
	
			}
	
			return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );
	
		}
	
	
		var contourMovements = [];
	
		for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
			if ( j === il ) j = 0;
			if ( k === il ) k = 0;
	
			//  (j)---(i)---(k)
			// console.log('i,j,k', i, j , k)
	
			contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );
	
		}
	
		var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
	
		for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
			ahole = holes[ h ];
	
			oneHoleMovements = [];
	
			for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
				if ( j === il ) j = 0;
				if ( k === il ) k = 0;
	
				//  (j)---(i)---(k)
				oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );
	
			}
	
			holesMovements.push( oneHoleMovements );
			verticesMovements = verticesMovements.concat( oneHoleMovements );
	
		}
	
	
		// Loop bevelSegments, 1 for the front, 1 for the back
	
		for ( b = 0; b < bevelSegments; b ++ ) {
	
			//for ( b = bevelSegments; b > 0; b -- ) {
	
			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
	
			//z = bevelThickness * t;
			bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved
			//bs = bevelSize * t; // linear
	
			// contract shape
	
			for ( i = 0, il = contour.length; i < il; i ++ ) {
	
				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
	
				v( vert.x, vert.y,  - z );
	
			}
	
			// expand holes
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];
	
				for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
					v( vert.x, vert.y,  - z );
	
				}
	
			}
	
		}
	
		bs = bevelSize;
	
		// Back facing vertices
	
		for ( i = 0; i < vlen; i ++ ) {
	
			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
			if ( ! extrudeByPath ) {
	
				v( vert.x, vert.y, 0 );
	
			} else {
	
				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
	
				normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );
	
				position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );
	
				v( position2.x, position2.y, position2.z );
	
			}
	
		}
	
		// Add stepped vertices...
		// Including front facing vertices
	
		var s;
	
		for ( s = 1; s <= steps; s ++ ) {
	
			for ( i = 0; i < vlen; i ++ ) {
	
				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
				if ( ! extrudeByPath ) {
	
					v( vert.x, vert.y, amount / steps * s );
	
				} else {
	
					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
	
					normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );
	
					position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );
	
					v( position2.x, position2.y, position2.z );
	
				}
	
			}
	
		}
	
	
		// Add bevel segments planes
	
		//for ( b = 1; b <= bevelSegments; b ++ ) {
		for ( b = bevelSegments - 1; b >= 0; b -- ) {
	
			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
			//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
			bs = bevelSize * Math.sin ( t * Math.PI / 2 );
	
			// contract shape
	
			for ( i = 0, il = contour.length; i < il; i ++ ) {
	
				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				v( vert.x, vert.y,  amount + z );
	
			}
	
			// expand holes
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];
	
				for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
					if ( ! extrudeByPath ) {
	
						v( vert.x, vert.y,  amount + z );
	
					} else {
	
						v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );
	
					}
	
				}
	
			}
	
		}
	
		/* Faces */
	
		// Top and bottom faces
	
		buildLidFaces();
	
		// Sides faces
	
		buildSideFaces();
	
	
		/////  Internal functions
	
		function buildLidFaces() {
	
			if ( bevelEnabled ) {
	
				var layer = 0; // steps + 1
				var offset = vlen * layer;
	
				// Bottom faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );
	
				}
	
				layer = steps + bevelSegments * 2;
				offset = vlen * layer;
	
				// Top faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );
	
				}
	
			} else {
	
				// Bottom faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 2 ], face[ 1 ], face[ 0 ] );
	
				}
	
				// Top faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );
	
				}
	
			}
	
		}
	
		// Create faces for the z-sides of the shape
	
		function buildSideFaces() {
	
			var layeroffset = 0;
			sidewalls( contour, layeroffset );
			layeroffset += contour.length;
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
				sidewalls( ahole, layeroffset );
	
				//, true
				layeroffset += ahole.length;
	
			}
	
		}
	
		function sidewalls( contour, layeroffset ) {
	
			var j, k;
			i = contour.length;
	
			while ( -- i >= 0 ) {
	
				j = i;
				k = i - 1;
				if ( k < 0 ) k = contour.length - 1;
	
				//console.log('b', i,j, i-1, k,vertices.length);
	
				var s = 0, sl = steps  + bevelSegments * 2;
	
				for ( s = 0; s < sl; s ++ ) {
	
					var slen1 = vlen * s;
					var slen2 = vlen * ( s + 1 );
	
					var a = layeroffset + j + slen1,
						b = layeroffset + k + slen1,
						c = layeroffset + k + slen2,
						d = layeroffset + j + slen2;
	
					f4( a, b, c, d, contour, s, sl, j, k );
	
				}
	
			}
	
		}
	
	
		function v( x, y, z ) {
	
			scope.vertices.push( new THREE.Vector3( x, y, z ) );
	
		}
	
		function f3( a, b, c ) {
	
			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
	
			scope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );
	
			var uvs = uvgen.generateTopUV( scope, a, b, c );
	
			scope.faceVertexUvs[ 0 ].push( uvs );
	
		}
	
		function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {
	
			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
			d += shapesOffset;
	
			scope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );
			scope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );
	
			var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );
	
			scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
			scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );
	
		}
	
	};
	
	THREE.ExtrudeGeometry.WorldUVGenerator = {
	
		generateTopUV: function ( geometry, indexA, indexB, indexC ) {
	
			var vertices = geometry.vertices;
	
			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];
	
			return [
				new THREE.Vector2( a.x, a.y ),
				new THREE.Vector2( b.x, b.y ),
				new THREE.Vector2( c.x, c.y )
			];
	
		},
	
		generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {
	
			var vertices = geometry.vertices;
	
			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];
			var d = vertices[ indexD ];
	
			if ( Math.abs( a.y - b.y ) < 0.01 ) {
	
				return [
					new THREE.Vector2( a.x, 1 - a.z ),
					new THREE.Vector2( b.x, 1 - b.z ),
					new THREE.Vector2( c.x, 1 - c.z ),
					new THREE.Vector2( d.x, 1 - d.z )
				];
	
			} else {
	
				return [
					new THREE.Vector2( a.y, 1 - a.z ),
					new THREE.Vector2( b.y, 1 - b.z ),
					new THREE.Vector2( c.y, 1 - c.z ),
					new THREE.Vector2( d.y, 1 - d.z )
				];
	
			}
	
		}
	};
	
	// File:src/extras/geometries/ShapeGeometry.js
	
	/**
	 * @author jonobr1 / http://jonobr1.com
	 *
	 * Creates a one-sided polygonal geometry from a path shape. Similar to
	 * ExtrudeGeometry.
	 *
	 * parameters = {
	 *
	 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
	 *
	 *	material: <int> // material index for front and back faces
	 *	uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/
	
	THREE.ShapeGeometry = function ( shapes, options ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'ShapeGeometry';
	
		if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];
	
		this.addShapeList( shapes, options );
	
		this.computeFaceNormals();
	
	};
	
	THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;
	
	/**
	 * Add an array of shapes to THREE.ShapeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {
	
		for ( var i = 0, l = shapes.length; i < l; i ++ ) {
	
			this.addShape( shapes[ i ], options );
	
		}
	
		return this;
	
	};
	
	/**
	 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {
	
		if ( options === undefined ) options = {};
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
		var material = options.material;
		var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
	
		//
	
		var i, l, hole;
	
		var shapesOffset = this.vertices.length;
		var shapePoints = shape.extractPoints( curveSegments );
	
		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;
	
		var reverse = ! THREE.ShapeUtils.isClockWise( vertices );
	
		if ( reverse ) {
	
			vertices = vertices.reverse();
	
			// Maybe we should also check if holes are in the opposite direction, just to be safe...
	
			for ( i = 0, l = holes.length; i < l; i ++ ) {
	
				hole = holes[ i ];
	
				if ( THREE.ShapeUtils.isClockWise( hole ) ) {
	
					holes[ i ] = hole.reverse();
	
				}
	
			}
	
			reverse = false;
	
		}
	
		var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );
	
		// Vertices
	
		for ( i = 0, l = holes.length; i < l; i ++ ) {
	
			hole = holes[ i ];
			vertices = vertices.concat( hole );
	
		}
	
		//
	
		var vert, vlen = vertices.length;
		var face, flen = faces.length;
	
		for ( i = 0; i < vlen; i ++ ) {
	
			vert = vertices[ i ];
	
			this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );
	
		}
	
		for ( i = 0; i < flen; i ++ ) {
	
			face = faces[ i ];
	
			var a = face[ 0 ] + shapesOffset;
			var b = face[ 1 ] + shapesOffset;
			var c = face[ 2 ] + shapesOffset;
	
			this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
			this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );
	
		}
	
	};
	
	// File:src/extras/geometries/LatheGeometry.js
	
	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://clara.io
	 */
	
	// points - to create a closed torus, one must use a set of points 
	//    like so: [ a, b, c, d, a ], see first is the same as last.
	// segments - the number of circumference segments to create
	// phiStart - the starting radian
	// phiLength - the radian (0 to 2*PI) range of the lathed section
	//    2*pi is a closed lathe, less than 2PI is a portion.
	
	THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'LatheGeometry';
	
		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};
	
		segments = segments || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || 2 * Math.PI;
	
		var inversePointLength = 1.0 / ( points.length - 1 );
		var inverseSegments = 1.0 / segments;
	
		for ( var i = 0, il = segments; i <= il; i ++ ) {
	
			var phi = phiStart + i * inverseSegments * phiLength;
	
			var c = Math.cos( phi ),
				s = Math.sin( phi );
	
			for ( var j = 0, jl = points.length; j < jl; j ++ ) {
	
				var pt = points[ j ];
	
				var vertex = new THREE.Vector3();
	
				vertex.x = c * pt.x - s * pt.y;
				vertex.y = s * pt.x + c * pt.y;
				vertex.z = pt.z;
	
				this.vertices.push( vertex );
	
			}
	
		}
	
		var np = points.length;
	
		for ( var i = 0, il = segments; i < il; i ++ ) {
	
			for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {
	
				var base = j + np * i;
				var a = base;
				var b = base + np;
				var c = base + 1 + np;
				var d = base + 1;
	
				var u0 = i * inverseSegments;
				var v0 = j * inversePointLength;
				var u1 = u0 + inverseSegments;
				var v1 = v0 + inversePointLength;
	
				this.faces.push( new THREE.Face3( a, b, d ) );
	
				this.faceVertexUvs[ 0 ].push( [
	
					new THREE.Vector2( u0, v0 ),
					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u0, v1 )
	
				] );
	
				this.faces.push( new THREE.Face3( b, c, d ) );
	
				this.faceVertexUvs[ 0 ].push( [
	
					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u1, v1 ),
					new THREE.Vector2( u0, v1 )
	
				] );
	
	
			}
	
		}
	
		this.mergeVertices();
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;
	
	// File:src/extras/geometries/PlaneGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */
	
	THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'PlaneGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};
	
		this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
	
	};
	
	THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;
	
	THREE.PlaneGeometry.prototype.clone = function () {
	
		var parameters = this.parameters;
	
		return new THREE.PlaneGeometry(
			parameters.width,
			parameters.height,
			parameters.widthSegments,
			parameters.heightSegments
		);
	
	};
	
	// File:src/extras/geometries/PlaneBufferGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */
	
	THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'PlaneBufferGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};
	
		var width_half = width / 2;
		var height_half = height / 2;
	
		var gridX = Math.floor( widthSegments ) || 1;
		var gridY = Math.floor( heightSegments ) || 1;
	
		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;
	
		var segment_width = width / gridX;
		var segment_height = height / gridY;
	
		var vertices = new Float32Array( gridX1 * gridY1 * 3 );
		var normals = new Float32Array( gridX1 * gridY1 * 3 );
		var uvs = new Float32Array( gridX1 * gridY1 * 2 );
	
		var offset = 0;
		var offset2 = 0;
	
		for ( var iy = 0; iy < gridY1; iy ++ ) {
	
			var y = iy * segment_height - height_half;
	
			for ( var ix = 0; ix < gridX1; ix ++ ) {
	
				var x = ix * segment_width - width_half;
	
				vertices[ offset ] = x;
				vertices[ offset + 1 ] = - y;
	
				normals[ offset + 2 ] = 1;
	
				uvs[ offset2 ] = ix / gridX;
				uvs[ offset2 + 1 ] = 1 - ( iy / gridY );
	
				offset += 3;
				offset2 += 2;
	
			}
	
		}
	
		offset = 0;
	
		var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );
	
		for ( var iy = 0; iy < gridY; iy ++ ) {
	
			for ( var ix = 0; ix < gridX; ix ++ ) {
	
				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;
	
				indices[ offset ] = a;
				indices[ offset + 1 ] = b;
				indices[ offset + 2 ] = d;
	
				indices[ offset + 3 ] = b;
				indices[ offset + 4 ] = c;
				indices[ offset + 5 ] = d;
	
				offset += 6;
	
			}
	
		}
	
		this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
	
	};
	
	THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;
	
	THREE.PlaneBufferGeometry.prototype.clone = function () {
	
		var parameters = this.parameters;
	
		return new THREE.PlaneBufferGeometry(
			parameters.width,
			parameters.height,
			parameters.widthSegments,
			parameters.heightSegments
		);
	
	};
	
	// File:src/extras/geometries/RingGeometry.js
	
	/**
	 * @author Kaleb Murphy
	 */
	
	THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'RingGeometry';
	
		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		innerRadius = innerRadius || 0;
		outerRadius = outerRadius || 50;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;
	
		var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
	
		for ( i = 0; i < phiSegments + 1; i ++ ) {
	
			// concentric circles inside ring
	
			for ( o = 0; o < thetaSegments + 1; o ++ ) {
	
				// number of segments per circle
	
				var vertex = new THREE.Vector3();
				var segment = thetaStart + o / thetaSegments * thetaLength;
				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );
	
				this.vertices.push( vertex );
				uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
	
			}
	
			radius += radiusStep;
	
		}
	
		var n = new THREE.Vector3( 0, 0, 1 );
	
		for ( i = 0; i < phiSegments; i ++ ) {
	
			// concentric circles inside ring
	
			var thetaSegment = i * ( thetaSegments + 1 );
	
			for ( o = 0; o < thetaSegments ; o ++ ) {
	
				// number of segments per circle
	
				var segment = o + thetaSegment;
	
				var v1 = segment;
				var v2 = segment + thetaSegments + 1;
				var v3 = segment + thetaSegments + 2;
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );
	
				v1 = segment;
				v2 = segment + thetaSegments + 2;
				v3 = segment + 1;
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );
	
			}
	
		}
	
		this.computeFaceNormals();
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;
	
	THREE.RingGeometry.prototype.clone = function () {
	
		var parameters = this.parameters;
	
		return new THREE.RingGeometry(
			parameters.innerRadius,
			parameters.outerRadius,
			parameters.thetaSegments,
			parameters.phiSegments,
			parameters.thetaStart,
			parameters.thetaLength
		);
	
	};
	
	// File:src/extras/geometries/SphereGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'SphereGeometry';
	
		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
	
	};
	
	THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;
	
	THREE.SphereGeometry.prototype.clone = function () {
	
		var parameters = this.parameters;
	
		return new THREE.SphereGeometry(
			parameters.radius,
			parameters.widthSegments,
			parameters.heightSegments,
			parameters.phiStart,
			parameters.phiLength,
			parameters.thetaStart,
			parameters.thetaLength
		);
	
	};
	
	// File:src/extras/geometries/SphereBufferGeometry.js
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * based on THREE.SphereGeometry
	 */
	
	THREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
		THREE.BufferGeometry.call( this );
	
		this.type = 'SphereBufferGeometry';
	
		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		radius = radius || 50;
	
		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );
	
		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
	
		var thetaEnd = thetaStart + thetaLength;
	
		var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );
	
		var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );
	
		var index = 0, vertices = [], normal = new THREE.Vector3();
	
		for ( var y = 0; y <= heightSegments; y ++ ) {
	
			var verticesRow = [];
	
			var v = y / heightSegments;
	
			for ( var x = 0; x <= widthSegments; x ++ ) {
	
				var u = x / widthSegments;
	
				var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				var py = radius * Math.cos( thetaStart + v * thetaLength );
				var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
	
				normal.set( px, py, pz ).normalize();
	
				positions.setXYZ( index, px, py, pz );
				normals.setXYZ( index, normal.x, normal.y, normal.z );
				uvs.setXY( index, u, 1 - v );
	
				verticesRow.push( index );
	
				index ++;
	
			}
	
			vertices.push( verticesRow );
	
		}
	
		var indices = [];
	
		for ( var y = 0; y < heightSegments; y ++ ) {
	
			for ( var x = 0; x < widthSegments; x ++ ) {
	
				var v1 = vertices[ y ][ x + 1 ];
				var v2 = vertices[ y ][ x ];
				var v3 = vertices[ y + 1 ][ x ];
				var v4 = vertices[ y + 1 ][ x + 1 ];
	
				if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
				if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );
	
			}
	
		}
	
		this.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );
		this.addAttribute( 'position', positions );
		this.addAttribute( 'normal', normals );
		this.addAttribute( 'uv', uvs );
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;
	
	THREE.SphereBufferGeometry.prototype.clone = function () {
	
		var parameters = this.parameters;
	
		return new THREE.SphereBufferGeometry(
			parameters.radius,
			parameters.widthSegments,
			parameters.heightSegments,
			parameters.phiStart,
			parameters.phiLength,
			parameters.thetaStart,
			parameters.thetaLength
		);
	
	};
	
	// File:src/extras/geometries/TorusGeometry.js
	
	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
	 */
	
	THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'TorusGeometry';
	
		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};
	
		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 8;
		tubularSegments = tubularSegments || 6;
		arc = arc || Math.PI * 2;
	
		var center = new THREE.Vector3(), uvs = [], normals = [];
	
		for ( var j = 0; j <= radialSegments; j ++ ) {
	
			for ( var i = 0; i <= tubularSegments; i ++ ) {
	
				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;
	
				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
	
				var vertex = new THREE.Vector3();
				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );
	
				this.vertices.push( vertex );
	
				uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
				normals.push( vertex.clone().sub( center ).normalize() );
	
			}
	
		}
	
		for ( var j = 1; j <= radialSegments; j ++ ) {
	
			for ( var i = 1; i <= tubularSegments; i ++ ) {
	
				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;
	
				var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );
	
				face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );
	
			}
	
		}
	
		this.computeFaceNormals();
	
	};
	
	THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;
	
	THREE.TorusGeometry.prototype.clone = function () {
	
		var parameters = this.parameters;
	
		return new THREE.TorusGeometry(
			parameters.radius,
			parameters.tube,
			parameters.radialSegments,
			parameters.tubularSegments,
			parameters.arc
		);
	
	};
	
	// File:src/extras/geometries/TorusKnotGeometry.js
	
	/**
	 * @author oosmoxiecode
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
	 */
	
	THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'TorusKnotGeometry';
	
		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			p: p,
			q: q,
			heightScale: heightScale
		};
	
		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 64;
		tubularSegments = tubularSegments || 8;
		p = p || 2;
		q = q || 3;
		heightScale = heightScale || 1;
	
		var grid = new Array( radialSegments );
		var tang = new THREE.Vector3();
		var n = new THREE.Vector3();
		var bitan = new THREE.Vector3();
	
		for ( var i = 0; i < radialSegments; ++ i ) {
	
			grid[ i ] = new Array( tubularSegments );
			var u = i / radialSegments * 2 * p * Math.PI;
			var p1 = getPos( u, q, p, radius, heightScale );
			var p2 = getPos( u + 0.01, q, p, radius, heightScale );
			tang.subVectors( p2, p1 );
			n.addVectors( p2, p1 );
	
			bitan.crossVectors( tang, n );
			n.crossVectors( bitan, tang );
			bitan.normalize();
			n.normalize();
	
			for ( var j = 0; j < tubularSegments; ++ j ) {
	
				var v = j / tubularSegments * 2 * Math.PI;
				var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				var cy = tube * Math.sin( v );
	
				var pos = new THREE.Vector3();
				pos.x = p1.x + cx * n.x + cy * bitan.x;
				pos.y = p1.y + cx * n.y + cy * bitan.y;
				pos.z = p1.z + cx * n.z + cy * bitan.z;
	
				grid[ i ][ j ] = this.vertices.push( pos ) - 1;
	
			}
	
		}
	
		for ( var i = 0; i < radialSegments; ++ i ) {
	
			for ( var j = 0; j < tubularSegments; ++ j ) {
	
				var ip = ( i + 1 ) % radialSegments;
				var jp = ( j + 1 ) % tubularSegments;
	
				var a = grid[ i ][ j ];
				var b = grid[ ip ][ j ];
				var c = grid[ ip ][ jp ];
				var d = grid[ i ][ jp ];
	
				var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
				var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
				var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
				var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );
	
				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );
	
				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );
	
			}
	
		}
	
		this.computeFaceNormals();
		this.computeVertexNormals();
	
		function getPos( u, in_q, in_p, radius, heightScale ) {
	
			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = in_q / in_p * u;
			var cs = Math.cos( quOverP );
	
			var tx = radius * ( 2 + cs ) * 0.5 * cu;
			var ty = radius * ( 2 + cs ) * su * 0.5;
			var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;
	
			return new THREE.Vector3( tx, ty, tz );
	
		}
	
	};
	
	THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;
	
	THREE.TorusKnotGeometry.prototype.clone = function () {
	
		var parameters = this.parameters;
	
		return new THREE.TorusKnotGeometry(
			parameters.radius,
			parameters.tube,
			parameters.radialSegments,
			parameters.tubularSegments,
			parameters.p,
			parameters.q,
			parameters.heightScale
		);
	
	};
	
	// File:src/extras/geometries/TubeGeometry.js
	
	/**
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 *
	 * Modified from the TorusKnotGeometry by @oosmoxiecode
	 *
	 * Creates a tube which extrudes along a 3d spline
	 *
	 * Uses parallel transport frames as described in
	 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	 */
	
	THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'TubeGeometry';
	
		this.parameters = {
			path: path,
			segments: segments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed,
			taper: taper
		};
	
		segments = segments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;
		taper = taper || THREE.TubeGeometry.NoTaper;
	
		var grid = [];
	
		var scope = this,
	
			tangent,
			normal,
			binormal,
	
			numpoints = segments + 1,
	
			u, v, r,
	
			cx, cy,
			pos, pos2 = new THREE.Vector3(),
			i, j,
			ip, jp,
			a, b, c, d,
			uva, uvb, uvc, uvd;
	
		var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
			tangents = frames.tangents,
			normals = frames.normals,
			binormals = frames.binormals;
	
		// proxy internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;
	
		function vert( x, y, z ) {
	
			return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;
	
		}
	
		// construct the grid
	
		for ( i = 0; i < numpoints; i ++ ) {
	
			grid[ i ] = [];
	
			u = i / ( numpoints - 1 );
	
			pos = path.getPointAt( u );
	
			tangent = tangents[ i ];
			normal = normals[ i ];
			binormal = binormals[ i ];
	
			r = radius * taper( u );
	
			for ( j = 0; j < radialSegments; j ++ ) {
	
				v = j / radialSegments * 2 * Math.PI;
	
				cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				cy = r * Math.sin( v );
	
				pos2.copy( pos );
				pos2.x += cx * normal.x + cy * binormal.x;
				pos2.y += cx * normal.y + cy * binormal.y;
				pos2.z += cx * normal.z + cy * binormal.z;
	
				grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );
	
			}
	
		}
	
	
		// construct the mesh
	
		for ( i = 0; i < segments; i ++ ) {
	
			for ( j = 0; j < radialSegments; j ++ ) {
	
				ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
				jp = ( j + 1 ) % radialSegments;
	
				a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
				b = grid[ ip ][ j ];
				c = grid[ ip ][ jp ];
				d = grid[ i ][ jp ];
	
				uva = new THREE.Vector2( i / segments, j / radialSegments );
				uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
				uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
				uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );
	
				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );
	
				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );
	
			}
	
		}
	
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
	THREE.TubeGeometry.prototype.clone = function() {
	
		return new this.constructor( this.parameters.path,
			this.parameters.segments, this.parameters.radius, this.parameters.radialSegments,
			this.parameters.closed, this.parameters.taper
		);
	
	};
	
	THREE.TubeGeometry.NoTaper = function ( u ) {
	
		return 1;
	
	};
	
	THREE.TubeGeometry.SinusoidalTaper = function ( u ) {
	
		return Math.sin( Math.PI * u );
	
	};
	
	// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
	THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {
	
		var	normal = new THREE.Vector3(),
	
			tangents = [],
			normals = [],
			binormals = [],
	
			vec = new THREE.Vector3(),
			mat = new THREE.Matrix4(),
	
			numpoints = segments + 1,
			theta,
			smallest,
	
			tx, ty, tz,
			i, u;
	
	
		// expose internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;
	
		// compute the tangent vectors for each segment on the path
	
		for ( i = 0; i < numpoints; i ++ ) {
	
			u = i / ( numpoints - 1 );
	
			tangents[ i ] = path.getTangentAt( u );
			tangents[ i ].normalize();
	
		}
	
		initialNormal3();
	
		/*
		function initialNormal1(lastBinormal) {
			// fixed start binormal. Has dangers of 0 vectors
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
			normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
		}
	
		function initialNormal2() {
	
			// This uses the Frenet-Serret formula for deriving binormal
			var t2 = path.getTangentAt( epsilon );
	
			normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
			binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );
	
			normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	
		}
		*/
	
		function initialNormal3() {
	
			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the smallest tangent xyz component
	
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			smallest = Number.MAX_VALUE;
			tx = Math.abs( tangents[ 0 ].x );
			ty = Math.abs( tangents[ 0 ].y );
			tz = Math.abs( tangents[ 0 ].z );
	
			if ( tx <= smallest ) {
	
				smallest = tx;
				normal.set( 1, 0, 0 );
	
			}
	
			if ( ty <= smallest ) {
	
				smallest = ty;
				normal.set( 0, 1, 0 );
	
			}
	
			if ( tz <= smallest ) {
	
				normal.set( 0, 0, 1 );
	
			}
	
			vec.crossVectors( tangents[ 0 ], normal ).normalize();
	
			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
	
		}
	
	
		// compute the slowly-varying normal and binormal vectors for each segment on the path
	
		for ( i = 1; i < numpoints; i ++ ) {
	
			normals[ i ] = normals[ i - 1 ].clone();
	
			binormals[ i ] = binormals[ i - 1 ].clone();
	
			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );
	
			if ( vec.length() > Number.EPSILON ) {
	
				vec.normalize();
	
				theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors
	
				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );
	
			}
	
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
		}
	
	
		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
	
		if ( closed ) {
	
			theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
			theta /= ( numpoints - 1 );
	
			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {
	
				theta = - theta;
	
			}
	
			for ( i = 1; i < numpoints; i ++ ) {
	
				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
			}
	
		}
	
	};
	
	// File:src/extras/geometries/PolyhedronGeometry.js
	
	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'PolyhedronGeometry';
	
		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};
	
		radius = radius || 1;
		detail = detail || 0;
	
		var that = this;
	
		for ( var i = 0, l = vertices.length; i < l; i += 3 ) {
	
			prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );
	
		}
	
		var p = this.vertices;
	
		var faces = [];
	
		for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {
	
			var v1 = p[ indices[ i ] ];
			var v2 = p[ indices[ i + 1 ] ];
			var v3 = p[ indices[ i + 2 ] ];
	
			faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );
	
		}
	
		var centroid = new THREE.Vector3();
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			subdivide( faces[ i ], detail );
	
		}
	
	
		// Handle case when face straddles the seam
	
		for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {
	
			var uvs = this.faceVertexUvs[ 0 ][ i ];
	
			var x0 = uvs[ 0 ].x;
			var x1 = uvs[ 1 ].x;
			var x2 = uvs[ 2 ].x;
	
			var max = Math.max( x0, x1, x2 );
			var min = Math.min( x0, x1, x2 );
	
			if ( max > 0.9 && min < 0.1 ) {
	
				// 0.9 is somewhat arbitrary
	
				if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
				if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
				if ( x2 < 0.2 ) uvs[ 2 ].x += 1;
	
			}
	
		}
	
	
		// Apply radius
	
		for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {
	
			this.vertices[ i ].multiplyScalar( radius );
	
		}
	
	
		// Merge vertices
	
		this.mergeVertices();
	
		this.computeFaceNormals();
	
		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	
		// Project vector onto sphere's surface
	
		function prepare( vector ) {
	
			var vertex = vector.normalize().clone();
			vertex.index = that.vertices.push( vertex ) - 1;
	
			// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.
	
			var u = azimuth( vector ) / 2 / Math.PI + 0.5;
			var v = inclination( vector ) / Math.PI + 0.5;
			vertex.uv = new THREE.Vector2( u, 1 - v );
	
			return vertex;
	
		}
	
	
		// Approximate a curved face with recursively sub-divided triangles.
	
		function make( v1, v2, v3, materialIndex ) {
	
			var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );
			that.faces.push( face );
	
			centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );
	
			var azi = azimuth( centroid );
	
			that.faceVertexUvs[ 0 ].push( [
				correctUV( v1.uv, v1, azi ),
				correctUV( v2.uv, v2, azi ),
				correctUV( v3.uv, v3, azi )
			] );
	
		}
	
	
		// Analytically subdivide a face to the required detail level.
	
		function subdivide( face, detail ) {
	
			var cols = Math.pow( 2, detail );
			var a = prepare( that.vertices[ face.a ] );
			var b = prepare( that.vertices[ face.b ] );
			var c = prepare( that.vertices[ face.c ] );
			var v = [];
	
			var materialIndex = face.materialIndex;
	
			// Construct all of the vertices for this subdivision.
	
			for ( var i = 0 ; i <= cols; i ++ ) {
	
				v[ i ] = [];
	
				var aj = prepare( a.clone().lerp( c, i / cols ) );
				var bj = prepare( b.clone().lerp( c, i / cols ) );
				var rows = cols - i;
	
				for ( var j = 0; j <= rows; j ++ ) {
	
					if ( j === 0 && i === cols ) {
	
						v[ i ][ j ] = aj;
	
					} else {
	
						v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );
	
					}
	
				}
	
			}
	
			// Construct all of the faces.
	
			for ( var i = 0; i < cols ; i ++ ) {
	
				for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {
	
					var k = Math.floor( j / 2 );
	
					if ( j % 2 === 0 ) {
	
						make(
							v[ i ][ k + 1 ],
							v[ i + 1 ][ k ],
							v[ i ][ k ],
							materialIndex
						);
	
					} else {
	
						make(
							v[ i ][ k + 1 ],
							v[ i + 1 ][ k + 1 ],
							v[ i + 1 ][ k ],
							materialIndex
						);
	
					}
	
				}
	
			}
	
		}
	
	
		// Angle around the Y axis, counter-clockwise when looking from above.
	
		function azimuth( vector ) {
	
			return Math.atan2( vector.z, - vector.x );
	
		}
	
	
		// Angle above the XZ plane.
	
		function inclination( vector ) {
	
			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );
	
		}
	
	
		// Texture fixing helper. Spheres have some odd behaviours.
	
		function correctUV( uv, vector, azimuth ) {
	
			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
			return uv.clone();
	
		}
	
	
	};
	
	THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;
	
	THREE.PolyhedronGeometry.prototype.clone = function () {
	
		var parameters = this.parameters;
	
		return new THREE.PolyhedronGeometry(
			parameters.vertices,
			parameters.indices,
			parameters.radius,
			parameters.detail
		);
	
	};
	
	// File:src/extras/geometries/DodecahedronGeometry.js
	
	/**
	 * @author Abe Pazos / https://hamoid.com
	 */
	
	THREE.DodecahedronGeometry = function ( radius, detail ) {
	
		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;
	
		var vertices = [
	
			// (±1, ±1, ±1)
			- 1, - 1, - 1,    - 1, - 1,  1,
			- 1,  1, - 1,    - 1,  1,  1,
			 1, - 1, - 1,     1, - 1,  1,
			 1,  1, - 1,     1,  1,  1,
	
			// (0, ±1/φ, ±φ)
			 0, - r, - t,     0, - r,  t,
			 0,  r, - t,     0,  r,  t,
	
			// (±1/φ, ±φ, 0)
			- r, - t,  0,    - r,  t,  0,
			 r, - t,  0,     r,  t,  0,
	
			// (±φ, 0, ±1/φ)
			- t,  0, - r,     t,  0, - r,
			- t,  0,  r,     t,  0,  r
		];
	
		var indices = [
			 3, 11,  7,      3,  7, 15,      3, 15, 13,
			 7, 19, 17,      7, 17,  6,      7,  6, 15,
			17,  4,  8,     17,  8, 10,     17, 10,  6,
			 8,  0, 16,      8, 16,  2,      8,  2, 10,
			 0, 12,  1,      0,  1, 18,      0, 18, 16,
			 6, 10,  2,      6,  2, 13,      6, 13, 15,
			 2, 16, 18,      2, 18,  3,      2,  3, 13,
			18,  1,  9,     18,  9, 11,     18, 11,  3,
			 4, 14, 12,      4, 12,  0,      4,  0,  8,
			11,  9,  5,     11,  5, 19,     11, 19,  7,
			19,  5, 14,     19, 14,  4,     19,  4, 17,
			 1, 12, 14,      1, 14,  5,      1,  5,  9
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'DodecahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	};
	
	THREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;
	
	THREE.DodecahedronGeometry.prototype.clone = function () {
	
		var parameters = this.parameters;
	
		return new THREE.DodecahedronGeometry(
			parameters.radius,
			parameters.detail
		);
	
	};
	
	// File:src/extras/geometries/IcosahedronGeometry.js
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.IcosahedronGeometry = function ( radius, detail ) {
	
		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	
		var vertices = [
			- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
			 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
			 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
		];
	
		var indices = [
			 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
			 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
			 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
			 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'IcosahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	};
	
	THREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;
	
	THREE.IcosahedronGeometry.prototype.clone = function () {
	
		var parameters = this.parameters;
	
		return new THREE.IcosahedronGeometry(
			parameters.radius,
			parameters.detail
		);
	
	};
	
	// File:src/extras/geometries/OctahedronGeometry.js
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.OctahedronGeometry = function ( radius, detail ) {
	
		var vertices = [
			1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
		];
	
		var indices = [
			0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'OctahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	};
	
	THREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;
	
	THREE.OctahedronGeometry.prototype.clone = function () {
	
		var parameters = this.parameters;
	
		return new THREE.OctahedronGeometry(
			parameters.radius,
			parameters.detail
		);
	
	};
	
	// File:src/extras/geometries/TetrahedronGeometry.js
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.TetrahedronGeometry = function ( radius, detail ) {
	
		var vertices = [
			 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
		];
	
		var indices = [
			 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'TetrahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	};
	
	THREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;
	
	THREE.TetrahedronGeometry.prototype.clone = function () {
	
		var parameters = this.parameters;
	
		return new THREE.TetrahedronGeometry(
			parameters.radius,
			parameters.detail
		);
	
	};
	
	// File:src/extras/geometries/ParametricGeometry.js
	
	/**
	 * @author zz85 / https://github.com/zz85
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 *
	 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
	 *
	 */
	
	THREE.ParametricGeometry = function ( func, slices, stacks ) {
	
		THREE.Geometry.call( this );
	
		this.type = 'ParametricGeometry';
	
		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};
	
		var verts = this.vertices;
		var faces = this.faces;
		var uvs = this.faceVertexUvs[ 0 ];
	
		var i, j, p;
		var u, v;
	
		var sliceCount = slices + 1;
	
		for ( i = 0; i <= stacks; i ++ ) {
	
			v = i / stacks;
	
			for ( j = 0; j <= slices; j ++ ) {
	
				u = j / slices;
	
				p = func( u, v );
				verts.push( p );
	
			}
	
		}
	
		var a, b, c, d;
		var uva, uvb, uvc, uvd;
	
		for ( i = 0; i < stacks; i ++ ) {
	
			for ( j = 0; j < slices; j ++ ) {
	
				a = i * sliceCount + j;
				b = i * sliceCount + j + 1;
				c = ( i + 1 ) * sliceCount + j + 1;
				d = ( i + 1 ) * sliceCount + j;
	
				uva = new THREE.Vector2( j / slices, i / stacks );
				uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
				uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
				uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );
	
				faces.push( new THREE.Face3( a, b, d ) );
				uvs.push( [ uva, uvb, uvd ] );
	
				faces.push( new THREE.Face3( b, c, d ) );
				uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );
	
			}
	
		}
	
		// console.log(this);
	
		// magic bullet
		// var diff = this.mergeVertices();
		// console.log('removed ', diff, ' vertices by merging');
	
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;
	
	// File:src/extras/geometries/WireframeGeometry.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.WireframeGeometry = function ( geometry ) {
	
		THREE.BufferGeometry.call( this );
	
		var edge = [ 0, 0 ], hash = {};
	
		function sortFunction( a, b ) {
	
			return a - b;
	
		}
	
		var keys = [ 'a', 'b', 'c' ];
	
		if ( geometry instanceof THREE.Geometry ) {
	
			var vertices = geometry.vertices;
			var faces = geometry.faces;
			var numEdges = 0;
	
			// allocate maximal size
			var edges = new Uint32Array( 6 * faces.length );
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				for ( var j = 0; j < 3; j ++ ) {
	
					edge[ 0 ] = face[ keys[ j ] ];
					edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
					edge.sort( sortFunction );
	
					var key = edge.toString();
	
					if ( hash[ key ] === undefined ) {
	
						edges[ 2 * numEdges ] = edge[ 0 ];
						edges[ 2 * numEdges + 1 ] = edge[ 1 ];
						hash[ key ] = true;
						numEdges ++;
	
					}
	
				}
	
			}
	
			var coords = new Float32Array( numEdges * 2 * 3 );
	
			for ( var i = 0, l = numEdges; i < l; i ++ ) {
	
				for ( var j = 0; j < 2; j ++ ) {
	
					var vertex = vertices[ edges [ 2 * i + j ] ];
	
					var index = 6 * i + 3 * j;
					coords[ index + 0 ] = vertex.x;
					coords[ index + 1 ] = vertex.y;
					coords[ index + 2 ] = vertex.z;
	
				}
	
			}
	
			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );
	
		} else if ( geometry instanceof THREE.BufferGeometry ) {
	
			if ( geometry.index !== null ) {
	
				// Indexed BufferGeometry
	
				var indices = geometry.index.array;
				var vertices = geometry.attributes.position;
				var drawcalls = geometry.drawcalls;
				var numEdges = 0;
	
				if ( drawcalls.length === 0 ) {
	
					geometry.addGroup( 0, indices.length );
	
				}
	
				// allocate maximal size
				var edges = new Uint32Array( 2 * indices.length );
	
				for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {
	
					var drawcall = drawcalls[ o ];
	
					var start = drawcall.start;
					var count = drawcall.count;
	
					for ( var i = start, il = start + count; i < il; i += 3 ) {
	
						for ( var j = 0; j < 3; j ++ ) {
	
							edge[ 0 ] = indices[ i + j ];
							edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
							edge.sort( sortFunction );
	
							var key = edge.toString();
	
							if ( hash[ key ] === undefined ) {
	
								edges[ 2 * numEdges ] = edge[ 0 ];
								edges[ 2 * numEdges + 1 ] = edge[ 1 ];
								hash[ key ] = true;
								numEdges ++;
	
							}
	
						}
	
					}
	
				}
	
				var coords = new Float32Array( numEdges * 2 * 3 );
	
				for ( var i = 0, l = numEdges; i < l; i ++ ) {
	
					for ( var j = 0; j < 2; j ++ ) {
	
						var index = 6 * i + 3 * j;
						var index2 = edges[ 2 * i + j ];
	
						coords[ index + 0 ] = vertices.getX( index2 );
						coords[ index + 1 ] = vertices.getY( index2 );
						coords[ index + 2 ] = vertices.getZ( index2 );
	
					}
	
				}
	
				this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );
	
			} else {
	
				// non-indexed BufferGeometry
	
				var vertices = geometry.attributes.position.array;
				var numEdges = vertices.length / 3;
				var numTris = numEdges / 3;
	
				var coords = new Float32Array( numEdges * 2 * 3 );
	
				for ( var i = 0, l = numTris; i < l; i ++ ) {
	
					for ( var j = 0; j < 3; j ++ ) {
	
						var index = 18 * i + 6 * j;
	
						var index1 = 9 * i + 3 * j;
						coords[ index + 0 ] = vertices[ index1 ];
						coords[ index + 1 ] = vertices[ index1 + 1 ];
						coords[ index + 2 ] = vertices[ index1 + 2 ];
	
						var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
						coords[ index + 3 ] = vertices[ index2 ];
						coords[ index + 4 ] = vertices[ index2 + 1 ];
						coords[ index + 5 ] = vertices[ index2 + 2 ];
	
					}
	
				}
	
				this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );
	
			}
	
		}
	
	};
	
	THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;
	
	// File:src/extras/helpers/AxisHelper.js
	
	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AxisHelper = function ( size ) {
	
		size = size || 1;
	
		var vertices = new Float32Array( [
			0, 0, 0,  size, 0, 0,
			0, 0, 0,  0, size, 0,
			0, 0, 0,  0, 0, size
		] );
	
		var colors = new Float32Array( [
			1, 0, 0,  1, 0.6, 0,
			0, 1, 0,  0.6, 1, 0,
			0, 0, 1,  0, 0.6, 1
		] );
	
		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
	
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );
	
		THREE.LineSegments.call( this, geometry, material );
	
	};
	
	THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;
	
	// File:src/extras/helpers/ArrowHelper.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://clara.io
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */
	
	THREE.ArrowHelper = ( function () {
	
		var lineGeometry = new THREE.Geometry();
		lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );
	
		var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.translate( 0, - 0.5, 0 );
	
		return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {
	
			// dir is assumed to be normalized
	
			THREE.Object3D.call( this );
	
			if ( color === undefined ) color = 0xffff00;
			if ( length === undefined ) length = 1;
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
			this.position.copy( origin );
			
			if ( headLength < length ) {
				this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
				this.line.matrixAutoUpdate = false;
				this.add( this.line );
			}
	
			this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );
	
			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );
	
		}
	
	}() );
	
	THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;
	
	THREE.ArrowHelper.prototype.setDirection = ( function () {
	
		var axis = new THREE.Vector3();
		var radians;
	
		return function setDirection( dir ) {
	
			// dir is assumed to be normalized
	
			if ( dir.y > 0.99999 ) {
	
				this.quaternion.set( 0, 0, 0, 1 );
	
			} else if ( dir.y < - 0.99999 ) {
	
				this.quaternion.set( 1, 0, 0, 0 );
	
			} else {
	
				axis.set( dir.z, 0, - dir.x ).normalize();
	
				radians = Math.acos( dir.y );
	
				this.quaternion.setFromAxisAngle( axis, radians );
	
			}
	
		};
	
	}() );
	
	THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {
	
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
		if ( headLength < length ){
			this.line.scale.set( 1, length - headLength, 1 );
			this.line.updateMatrix();
		}
	
		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();
	
	};
	
	THREE.ArrowHelper.prototype.setColor = function ( color ) {
	
		if ( this.line !== undefined ) this.line.material.color.set( color );
		this.cone.material.color.set( color );
	
	};
	
	// File:src/extras/helpers/BoxHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.BoxHelper = function ( object ) {
	
		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		var positions = new Float32Array( 8 * 3 );
	
		var geometry = new THREE.BufferGeometry();
		geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
	
		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );
	
		if ( object !== undefined ) {
	
			this.update( object );
	
		}
	
	};
	
	THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;
	
	THREE.BoxHelper.prototype.update = ( function () {
	
		var box = new THREE.Box3();
	
		return function ( object ) {
	
			box.setFromObject( object );
	
			if ( box.empty() ) return;
	
			var min = box.min;
			var max = box.max;
	
			/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/
	
			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/
	
			var position = this.geometry.attributes.position;
			var array = position.array;
	
			array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
			array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
			array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
			array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;
	
			position.needsUpdate = true;
	
			this.geometry.computeBoundingSphere();
	
		}
	
	} )();
	
	// File:src/extras/helpers/BoundingBoxHelper.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	// a helper to show the world-axis-aligned bounding box for an object
	
	THREE.BoundingBoxHelper = function ( object, hex ) {
	
		var color = ( hex !== undefined ) ? hex : 0x888888;
	
		this.object = object;
	
		this.box = new THREE.Box3();
	
		THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );
	
	};
	
	THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;
	
	THREE.BoundingBoxHelper.prototype.update = function () {
	
		this.box.setFromObject( this.object );
	
		this.box.size( this.scale );
	
		this.box.center( this.position );
	
	};
	
	// File:src/extras/helpers/CameraHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */
	
	THREE.CameraHelper = function ( camera ) {
	
		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );
	
		var pointMap = {};
	
		// colors
	
		var hexFrustum = 0xffaa00;
		var hexCone = 0xff0000;
		var hexUp = 0x00aaff;
		var hexTarget = 0xffffff;
		var hexCross = 0x333333;
	
		// near
	
		addLine( "n1", "n2", hexFrustum );
		addLine( "n2", "n4", hexFrustum );
		addLine( "n4", "n3", hexFrustum );
		addLine( "n3", "n1", hexFrustum );
	
		// far
	
		addLine( "f1", "f2", hexFrustum );
		addLine( "f2", "f4", hexFrustum );
		addLine( "f4", "f3", hexFrustum );
		addLine( "f3", "f1", hexFrustum );
	
		// sides
	
		addLine( "n1", "f1", hexFrustum );
		addLine( "n2", "f2", hexFrustum );
		addLine( "n3", "f3", hexFrustum );
		addLine( "n4", "f4", hexFrustum );
	
		// cone
	
		addLine( "p", "n1", hexCone );
		addLine( "p", "n2", hexCone );
		addLine( "p", "n3", hexCone );
		addLine( "p", "n4", hexCone );
	
		// up
	
		addLine( "u1", "u2", hexUp );
		addLine( "u2", "u3", hexUp );
		addLine( "u3", "u1", hexUp );
	
		// target
	
		addLine( "c", "t", hexTarget );
		addLine( "p", "c", hexCross );
	
		// cross
	
		addLine( "cn1", "cn2", hexCross );
		addLine( "cn3", "cn4", hexCross );
	
		addLine( "cf1", "cf2", hexCross );
		addLine( "cf3", "cf4", hexCross );
	
		function addLine( a, b, hex ) {
	
			addPoint( a, hex );
			addPoint( b, hex );
	
		}
	
		function addPoint( id, hex ) {
	
			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( hex ) );
	
			if ( pointMap[ id ] === undefined ) {
	
				pointMap[ id ] = [];
	
			}
	
			pointMap[ id ].push( geometry.vertices.length - 1 );
	
		}
	
		THREE.LineSegments.call( this, geometry, material );
	
		this.camera = camera;
		this.camera.updateProjectionMatrix();
	
		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.pointMap = pointMap;
	
		this.update();
	
	};
	
	THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;
	
	THREE.CameraHelper.prototype.update = function () {
	
		var geometry, pointMap;
	
		var vector = new THREE.Vector3();
		var camera = new THREE.Camera();
	
		function setPoint( point, x, y, z ) {
	
			vector.set( x, y, z ).unproject( camera );
	
			var points = pointMap[ point ];
	
			if ( points !== undefined ) {
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					geometry.vertices[ points[ i ] ].copy( vector );
	
				}
	
			}
	
		}
	
		return function () {
	
			geometry = this.geometry;
			pointMap = this.pointMap;
	
			var w = 1, h = 1;
	
			// we need just camera projection matrix
			// world matrix must be identity
	
			camera.projectionMatrix.copy( this.camera.projectionMatrix );
	
			// center / target
	
			setPoint( "c", 0, 0, - 1 );
			setPoint( "t", 0, 0,  1 );
	
			// near
	
			setPoint( "n1", - w, - h, - 1 );
			setPoint( "n2",   w, - h, - 1 );
			setPoint( "n3", - w,   h, - 1 );
			setPoint( "n4",   w,   h, - 1 );
	
			// far
	
			setPoint( "f1", - w, - h, 1 );
			setPoint( "f2",   w, - h, 1 );
			setPoint( "f3", - w,   h, 1 );
			setPoint( "f4",   w,   h, 1 );
	
			// up
	
			setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
			setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
			setPoint( "u3",         0, h * 2,   - 1 );
	
			// cross
	
			setPoint( "cf1", - w,   0, 1 );
			setPoint( "cf2",   w,   0, 1 );
			setPoint( "cf3",   0, - h, 1 );
			setPoint( "cf4",   0,   h, 1 );
	
			setPoint( "cn1", - w,   0, - 1 );
			setPoint( "cn2",   w,   0, - 1 );
			setPoint( "cn3",   0, - h, - 1 );
			setPoint( "cn4",   0,   h, - 1 );
	
			geometry.verticesNeedUpdate = true;
	
		};
	
	}();
	
	// File:src/extras/helpers/DirectionalLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.DirectionalLightHelper = function ( light, size ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		size = size || 1;
	
		var geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3( - size,   size, 0 ),
			new THREE.Vector3(   size,   size, 0 ),
			new THREE.Vector3(   size, - size, 0 ),
			new THREE.Vector3( - size, - size, 0 ),
			new THREE.Vector3( - size,   size, 0 )
		);
	
		var material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		this.lightPlane = new THREE.Line( geometry, material );
		this.add( this.lightPlane );
	
		geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3(),
			new THREE.Vector3()
		);
	
		material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		this.targetLine = new THREE.Line( geometry, material );
		this.add( this.targetLine );
	
		this.update();
	
	};
	
	THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;
	
	THREE.DirectionalLightHelper.prototype.dispose = function () {
	
		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();
	
	};
	
	THREE.DirectionalLightHelper.prototype.update = function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var v3 = new THREE.Vector3();
	
		return function () {
	
			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );
	
			this.lightPlane.lookAt( v3 );
			this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
			this.targetLine.geometry.vertices[ 1 ].copy( v3 );
			this.targetLine.geometry.verticesNeedUpdate = true;
			this.targetLine.material.color.copy( this.lightPlane.material.color );
	
		};
	
	}();
	
	// File:src/extras/helpers/EdgesHelper.js
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @param object THREE.Mesh whose geometry will be used
	 * @param hex line color
	 * @param thresholdAngle the minimum angle (in degrees),
	 * between the face normals of adjacent faces,
	 * that is required to render an edge. A value of 10 means
	 * an edge is only rendered if the angle is at least 10 degrees.
	 */
	
	THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {
	
		var color = ( hex !== undefined ) ? hex : 0xffffff;
	
		THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );
	
		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	
	};
	
	THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;
	
	// File:src/extras/helpers/FaceNormalsHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {
	
		// FaceNormalsHelper only supports THREE.Geometry
	
		this.object = object;
	
		this.size = ( size !== undefined ) ? size : 1;
	
		var color = ( hex !== undefined ) ? hex : 0xffff00;
	
		var width = ( linewidth !== undefined ) ? linewidth : 1;
	
		//
	
		var nNormals = 0;
	
		var objGeometry = this.object.geometry;
	
		if ( objGeometry instanceof THREE.Geometry ) {
	
			nNormals = objGeometry.faces.length;
	
		} else {
	
			console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );
	
		}
	
		//
	
		var geometry = new THREE.BufferGeometry();
	
		var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );
	
		geometry.addAttribute( 'position', positions );
	
		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );
	
		//
	
		this.matrixAutoUpdate = false;
		this.update();
	
	};
	
	THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;
	
	THREE.FaceNormalsHelper.prototype.update = ( function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var normalMatrix = new THREE.Matrix3();
	
		return function update() {
	
			this.object.updateMatrixWorld( true );
	
			normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
			var matrixWorld = this.object.matrixWorld;
	
			var position = this.geometry.attributes.position;
	
			//
	
			var objGeometry = this.object.geometry;
	
			var vertices = objGeometry.vertices;
	
			var faces = objGeometry.faces;
	
			var idx = 0;
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				var normal = face.normal;
	
				v1.copy( vertices[ face.a ] )
					.add( vertices[ face.b ] )
					.add( vertices[ face.c ] )
					.divideScalar( 3 )
					.applyMatrix4( matrixWorld );
	
				v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
				position.setXYZ( idx, v1.x, v1.y, v1.z );
	
				idx = idx + 1;
	
				position.setXYZ( idx, v2.x, v2.y, v2.z );
	
				idx = idx + 1;
	
			}
	
			position.needsUpdate = true;
	
			return this;
	
		}
	
	}() );
	
	// File:src/extras/helpers/GridHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.GridHelper = function ( size, step ) {
	
		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );
	
		this.color1 = new THREE.Color( 0x444444 );
		this.color2 = new THREE.Color( 0x888888 );
	
		for ( var i = - size; i <= size; i += step ) {
	
			geometry.vertices.push(
				new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
				new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
			);
	
			var color = i === 0 ? this.color1 : this.color2;
	
			geometry.colors.push( color, color, color, color );
	
		}
	
		THREE.LineSegments.call( this, geometry, material );
	
	};
	
	THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.GridHelper.prototype.constructor = THREE.GridHelper;
	
	THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {
	
		this.color1.set( colorCenterLine );
		this.color2.set( colorGrid );
	
		this.geometry.colorsNeedUpdate = true;
	
	};
	
	// File:src/extras/helpers/HemisphereLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.HemisphereLightHelper = function ( light, sphereSize ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.colors = [ new THREE.Color(), new THREE.Color() ];
	
		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		geometry.rotateX( - Math.PI / 2 );
	
		for ( var i = 0, il = 8; i < il; i ++ ) {
	
			geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];
	
		}
	
		var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );
	
		this.lightSphere = new THREE.Mesh( geometry, material );
		this.add( this.lightSphere );
	
		this.update();
	
	};
	
	THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;
	
	THREE.HemisphereLightHelper.prototype.dispose = function () {
	
		this.lightSphere.geometry.dispose();
		this.lightSphere.material.dispose();
	
	};
	
	THREE.HemisphereLightHelper.prototype.update = function () {
	
		var vector = new THREE.Vector3();
	
		return function () {
	
			this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
			this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );
	
			this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
			this.lightSphere.geometry.colorsNeedUpdate = true;
	
		}
	
	}();
	
	// File:src/extras/helpers/PointLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.PointLightHelper = function ( light, sphereSize ) {
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		THREE.Mesh.call( this, geometry, material );
	
		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
	
		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
	
		var d = light.distance;
	
		if ( d === 0.0 ) {
	
			this.lightDistance.visible = false;
	
		} else {
	
			this.lightDistance.scale.set( d, d, d );
	
		}
	
		this.add( this.lightDistance );
		*/
	
	};
	
	THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;
	
	THREE.PointLightHelper.prototype.dispose = function () {
	
		this.geometry.dispose();
		this.material.dispose();
	
	};
	
	THREE.PointLightHelper.prototype.update = function () {
	
		this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		/*
		var d = this.light.distance;
	
		if ( d === 0.0 ) {
	
			this.lightDistance.visible = false;
	
		} else {
	
			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );
	
		}
		*/
	
	};
	
	// File:src/extras/helpers/SkeletonHelper.js
	
	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 */
	
	THREE.SkeletonHelper = function ( object ) {
	
		this.bones = this.getBoneList( object );
	
		var geometry = new THREE.Geometry();
	
		for ( var i = 0; i < this.bones.length; i ++ ) {
	
			var bone = this.bones[ i ];
	
			if ( bone.parent instanceof THREE.Bone ) {
	
				geometry.vertices.push( new THREE.Vector3() );
				geometry.vertices.push( new THREE.Vector3() );
				geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
				geometry.colors.push( new THREE.Color( 0, 1, 0 ) );
	
			}
	
		}
	
		geometry.dynamic = true;
	
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );
	
		THREE.LineSegments.call( this, geometry, material );
	
		this.root = object;
	
		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.update();
	
	};
	
	
	THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;
	
	THREE.SkeletonHelper.prototype.getBoneList = function( object ) {
	
		var boneList = [];
	
		if ( object instanceof THREE.Bone ) {
	
			boneList.push( object );
	
		}
	
		for ( var i = 0; i < object.children.length; i ++ ) {
	
			boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );
	
		}
	
		return boneList;
	
	};
	
	THREE.SkeletonHelper.prototype.update = function () {
	
		var geometry = this.geometry;
	
		var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );
	
		var boneMatrix = new THREE.Matrix4();
	
		var j = 0;
	
		for ( var i = 0; i < this.bones.length; i ++ ) {
	
			var bone = this.bones[ i ];
	
			if ( bone.parent instanceof THREE.Bone ) {
	
				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
				geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );
	
				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
				geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );
	
				j += 2;
	
			}
	
		}
	
		geometry.verticesNeedUpdate = true;
	
		geometry.computeBoundingSphere();
	
	};
	
	// File:src/extras/helpers/SpotLightHelper.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.SpotLightHelper = function ( light ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );
	
		geometry.translate( 0, - 0.5, 0 );
		geometry.rotateX( - Math.PI / 2 );
	
		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	
		this.cone = new THREE.Mesh( geometry, material );
		this.add( this.cone );
	
		this.update();
	
	};
	
	THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;
	
	THREE.SpotLightHelper.prototype.dispose = function () {
	
		this.cone.geometry.dispose();
		this.cone.material.dispose();
	
	};
	
	THREE.SpotLightHelper.prototype.update = function () {
	
		var vector = new THREE.Vector3();
		var vector2 = new THREE.Vector3();
	
		return function () {
	
			var coneLength = this.light.distance ? this.light.distance : 10000;
			var coneWidth = coneLength * Math.tan( this.light.angle );
	
			this.cone.scale.set( coneWidth, coneWidth, coneLength );
	
			vector.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );
	
			this.cone.lookAt( vector2.sub( vector ) );
	
			this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
		};
	
	}();
	
	// File:src/extras/helpers/VertexNormalsHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {
	
		this.object = object;
	
		this.size = ( size !== undefined ) ? size : 1;
	
		var color = ( hex !== undefined ) ? hex : 0xff0000;
	
		var width = ( linewidth !== undefined ) ? linewidth : 1;
	
		//
	
		var nNormals = 0;
	
		var objGeometry = this.object.geometry;
	
		if ( objGeometry instanceof THREE.Geometry ) {
	
			nNormals = objGeometry.faces.length * 3;
	
		} else if ( objGeometry instanceof THREE.BufferGeometry ) {
	
			nNormals = objGeometry.attributes.normal.count
	
		}
	
		//
	
		var geometry = new THREE.BufferGeometry();
	
		var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );
	
		geometry.addAttribute( 'position', positions );
	
		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );
	
		//
	
		this.matrixAutoUpdate = false;
	
		this.update();
	
	};
	
	THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;
	
	THREE.VertexNormalsHelper.prototype.update = ( function () {
	
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var normalMatrix = new THREE.Matrix3();
	
		return function update() {
	
			var keys = [ 'a', 'b', 'c' ];
	
			this.object.updateMatrixWorld( true );
	
			normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
			var matrixWorld = this.object.matrixWorld;
	
			var position = this.geometry.attributes.position;
	
			//
	
			var objGeometry = this.object.geometry;
	
			if ( objGeometry instanceof THREE.Geometry ) {
	
				var vertices = objGeometry.vertices;
	
				var faces = objGeometry.faces;
	
				var idx = 0;
	
				for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
					var face = faces[ i ];
	
					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
						var vertex = vertices[ face[ keys[ j ] ] ];
	
						var normal = face.vertexNormals[ j ];
	
						v1.copy( vertex ).applyMatrix4( matrixWorld );
	
						v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
						position.setXYZ( idx, v1.x, v1.y, v1.z );
	
						idx = idx + 1;
	
						position.setXYZ( idx, v2.x, v2.y, v2.z );
	
						idx = idx + 1;
	
					}
	
				}
	
			} else if ( objGeometry instanceof THREE.BufferGeometry ) {
	
				var objPos = objGeometry.attributes.position;
	
				var objNorm = objGeometry.attributes.normal;
	
				var idx = 0;
	
				// for simplicity, ignore index and drawcalls, and render every normal
	
				for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {
	
					v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );
	
					v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );
	
					v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
					position.setXYZ( idx, v1.x, v1.y, v1.z );
	
					idx = idx + 1;
	
					position.setXYZ( idx, v2.x, v2.y, v2.z );
	
					idx = idx + 1;
	
				}
	
			}
	
			position.needsUpdate = true;
	
			return this;
	
		}
	
	}() );
	
	// File:src/extras/helpers/WireframeHelper.js
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.WireframeHelper = function ( object, hex ) {
	
		var color = ( hex !== undefined ) ? hex : 0xffffff;
	
		THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );
	
		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	
	};
	
	THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;
	
	// File:src/extras/objects/ImmediateRenderObject.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.ImmediateRenderObject = function ( material ) {
	
		THREE.Object3D.call( this );
	
		this.material = material;
		this.render = function ( renderCallback ) {};
	
	};
	
	THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;
	
	// File:src/extras/objects/MorphBlendMesh.js
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.MorphBlendMesh = function( geometry, material ) {
	
		THREE.Mesh.call( this, geometry, material );
	
		this.animationsMap = {};
		this.animationsList = [];
	
		// prepare default animation
		// (all frames played together in 1 second)
	
		var numFrames = this.geometry.morphTargets.length;
	
		var name = "__default";
	
		var startFrame = 0;
		var endFrame = numFrames - 1;
	
		var fps = numFrames / 1;
	
		this.createAnimation( name, startFrame, endFrame, fps );
		this.setAnimationWeight( name, 1 );
	
	};
	
	THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;
	
	THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {
	
		var animation = {
	
			start: start,
			end: end,
	
			length: end - start + 1,
	
			fps: fps,
			duration: ( end - start ) / fps,
	
			lastFrame: 0,
			currentFrame: 0,
	
			active: false,
	
			time: 0,
			direction: 1,
			weight: 1,
	
			directionBackwards: false,
			mirroredLoop: false
	
		};
	
		this.animationsMap[ name ] = animation;
		this.animationsList.push( animation );
	
	};
	
	THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {
	
		var pattern = /([a-z]+)_?(\d+)/;
	
		var firstAnimation, frameRanges = {};
	
		var geometry = this.geometry;
	
		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {
	
			var morph = geometry.morphTargets[ i ];
			var chunks = morph.name.match( pattern );
	
			if ( chunks && chunks.length > 1 ) {
	
				var name = chunks[ 1 ];
	
				if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };
	
				var range = frameRanges[ name ];
	
				if ( i < range.start ) range.start = i;
				if ( i > range.end ) range.end = i;
	
				if ( ! firstAnimation ) firstAnimation = name;
	
			}
	
		}
	
		for ( var name in frameRanges ) {
	
			var range = frameRanges[ name ];
			this.createAnimation( name, range.start, range.end, fps );
	
		}
	
		this.firstAnimation = firstAnimation;
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.direction = 1;
			animation.directionBackwards = false;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.direction = - 1;
			animation.directionBackwards = true;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.fps = fps;
			animation.duration = ( animation.end - animation.start ) / animation.fps;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.duration = duration;
			animation.fps = ( animation.end - animation.start ) / animation.duration;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.weight = weight;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.time = time;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {
	
		var time = 0;
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			time = animation.time;
	
		}
	
		return time;
	
	};
	
	THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {
	
		var duration = - 1;
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			duration = animation.duration;
	
		}
	
		return duration;
	
	};
	
	THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.time = 0;
			animation.active = true;
	
		} else {
	
			console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.active = false;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.update = function ( delta ) {
	
		for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {
	
			var animation = this.animationsList[ i ];
	
			if ( ! animation.active ) continue;
	
			var frameTime = animation.duration / animation.length;
	
			animation.time += animation.direction * delta;
	
			if ( animation.mirroredLoop ) {
	
				if ( animation.time > animation.duration || animation.time < 0 ) {
	
					animation.direction *= - 1;
	
					if ( animation.time > animation.duration ) {
	
						animation.time = animation.duration;
						animation.directionBackwards = true;
	
					}
	
					if ( animation.time < 0 ) {
	
						animation.time = 0;
						animation.directionBackwards = false;
	
					}
	
				}
	
			} else {
	
				animation.time = animation.time % animation.duration;
	
				if ( animation.time < 0 ) animation.time += animation.duration;
	
			}
	
			var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
			var weight = animation.weight;
	
			if ( keyframe !== animation.currentFrame ) {
	
				this.morphTargetInfluences[ animation.lastFrame ] = 0;
				this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;
	
				this.morphTargetInfluences[ keyframe ] = 0;
	
				animation.lastFrame = animation.currentFrame;
				animation.currentFrame = keyframe;
	
			}
	
			var mix = ( animation.time % frameTime ) / frameTime;
	
			if ( animation.directionBackwards ) mix = 1 - mix;
	
			if ( animation.currentFrame !== animation.lastFrame ) {
	
				this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
				this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;
	
			} else {
	
				this.morphTargetInfluences[ animation.currentFrame ] = weight;
	
			}
	
		}
	
	};
	
	
	// Export the THREE object for **Node.js**, with
	// backwards-compatibility for the old `require()` API. If we're in
	// the browser, add `_` as a global object via a string identifier,
	// for Closure Compiler "advanced" mode.
	if (true) {
	  if (typeof module !== 'undefined' && module.exports) {
	    exports = module.exports = THREE;
	  }
	  exports.THREE = THREE;
	} else {
	  this['THREE'] = THREE;
	}


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypes
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(11);
	var ReactPropTypeLocationNames = __webpack_require__(33);
	
	var emptyFunction = __webpack_require__(24);
	var getIteratorFn = __webpack_require__(117);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	function createChainableTypeChecker(validate) {
	  function checkType(isRequired, props, propName, componentName, location, propFullName) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!ReactElement.isValidElement(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
	    });
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (propValue === expectedValues[i]) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
	    });
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName) == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	
	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }
	
	      return true;
	    default:
	      return false;
	  }
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue;
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return '<<anonymous>>';
	  }
	  return propValue.constructor.name;
	}
	
	module.exports = ReactPropTypes;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  if (false) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(438);


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _admin = __webpack_require__(72);
	
	var _admin2 = _interopRequireDefault(_admin);
	
	var _app = __webpack_require__(73);
	
	var _app2 = _interopRequireDefault(_app);
	
	var _game = __webpack_require__(75);
	
	var _game2 = _interopRequireDefault(_game);
	
	var _choregraphy = __webpack_require__(74);
	
	var _choregraphy2 = _interopRequireDefault(_choregraphy);
	
	var _moves = __webpack_require__(76);
	
	var _moves2 = _interopRequireDefault(_moves);
	
	var _steps = __webpack_require__(79);
	
	var _steps2 = _interopRequireDefault(_steps);
	
	var _pads = __webpack_require__(77);
	
	var _pads2 = _interopRequireDefault(_pads);
	
	var _scores = __webpack_require__(78);
	
	var _scores2 = _interopRequireDefault(_scores);
	
	var _tuto = __webpack_require__(80);
	
	var _tuto2 = _interopRequireDefault(_tuto);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = Object.assign({}, _admin2.default, _app2.default, _game2.default, _choregraphy2.default, _moves2.default, _steps2.default, _pads2.default, _scores2.default, _tuto2.default);

/***/ },
/* 7 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Object.assign
	 */
	
	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign
	
	'use strict';
	
	function assign(target, sources) {
	  if (target == null) {
	    throw new TypeError('Object.assign target cannot be null or undefined');
	  }
	
	  var to = Object(target);
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
	    var nextSource = arguments[nextIndex];
	    if (nextSource == null) {
	      continue;
	    }
	
	    var from = Object(nextSource);
	
	    // We don't currently support accessors nor proxies. Therefore this
	    // copy cannot throw. If we ever supported this then we must handle
	    // exceptions and side-effects. We don't support symbols so they won't
	    // be transferred.
	
	    for (var key in from) {
	      if (hasOwnProperty.call(from, key)) {
	        to[key] = from[key];
	      }
	    }
	  }
	
	  return to;
	}
	
	module.exports = assign;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule warning
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(24);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (false) {
	  warning = function (condition, format) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }
	
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  if (false) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 *  Copyright (c) 2014-2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  global.Immutable = factory();
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;
	
	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }
	
	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }
	
	
	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }
	
	
	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }
	
	
	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }
	
	
	
	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }
	
	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }
	
	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }
	
	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }
	
	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }
	
	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;
	
	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;
	
	
	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	
	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';
	
	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;
	
	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};
	
	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };
	
	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }
	
	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }
	
	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}
	
	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }
	
	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }
	
	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^32−1.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }
	
	  function returnTrue() {
	    return true;
	  }
	
	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }
	
	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }
	
	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }
	
	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }
	
	  /* global Symbol */
	
	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;
	
	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';
	
	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
	
	
	  function Iterator(next) {
	      this.next = next;
	    }
	
	    Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };
	
	
	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;
	
	  Iterator.prototype.inspect =
	  Iterator.prototype.toSource = function () { return this.toString(); }
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };
	
	
	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }
	
	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }
	
	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }
	
	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }
	
	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }
	
	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }
	
	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }
	
	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }
	
	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };
	
	    Seq.prototype.toSeq = function() {
	      return this;
	    };
	
	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };
	
	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };
	
	    // abstract __iterateUncached(fn, reverse)
	
	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };
	
	    // abstract __iteratorUncached(type, reverse)
	
	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };
	
	
	
	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }
	
	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };
	
	
	
	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }
	
	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };
	
	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };
	
	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };
	
	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };
	
	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };
	
	
	
	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }
	
	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };
	
	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };
	
	
	
	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;
	
	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
	
	  Seq.prototype[IS_SEQ_SENTINEL] = true;
	
	
	
	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }
	
	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };
	
	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };
	
	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };
	
	
	
	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }
	
	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };
	
	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };
	
	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };
	
	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };
	
	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }
	
	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };
	
	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };
	
	
	
	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }
	
	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	
	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };
	
	
	
	
	  // # pragma Helper functions
	
	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }
	
	  var EMPTY_SEQ;
	
	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }
	
	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }
	
	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }
	
	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }
	
	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }
	
	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }
	
	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }
	
	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }
	
	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }
	
	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }
	
	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }
	
	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }
	
	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }
	
	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }
	
	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }
	
	    var notAssociative = !isAssociative(a);
	
	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }
	
	    var flipped = false;
	
	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }
	
	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });
	
	    return allEqual && a.size === bSize;
	  }
	
	  createClass(Repeat, IndexedSeq);
	
	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }
	
	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };
	
	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };
	
	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };
	
	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };
	
	    Repeat.prototype.reverse = function() {
	      return this;
	    };
	
	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };
	
	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };
	
	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };
	
	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };
	
	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };
	
	
	  var EMPTY_REPEAT;
	
	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }
	
	  createClass(Range, IndexedSeq);
	
	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }
	
	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step > 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };
	
	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };
	
	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };
	
	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };
	
	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };
	
	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };
	
	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };
	
	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };
	
	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };
	
	
	  var EMPTY_RANGE;
	
	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }
	
	
	  createClass(KeyedCollection, Collection);function KeyedCollection() {}
	
	  createClass(IndexedCollection, Collection);function IndexedCollection() {}
	
	  createClass(SetCollection, Collection);function SetCollection() {}
	
	
	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;
	
	  var imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };
	
	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }
	
	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }
	
	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }
	
	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }
	
	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }
	
	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }
	
	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }
	
	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }
	
	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }
	
	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }
	
	    return hash;
	  }
	
	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;
	
	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());
	
	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }
	
	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }
	
	  var objHashUID = 0;
	
	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }
	
	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};
	
	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }
	
	  createClass(Map, KeyedCollection);
	
	    // @pragma Construction
	
	    function Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) && !isOrdered(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }
	
	    Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };
	
	    // @pragma Access
	
	    Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };
	
	    // @pragma Modification
	
	    Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };
	
	    Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };
	
	    Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };
	
	    Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };
	
	    Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };
	
	    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };
	
	    Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };
	
	    // @pragma Composition
	
	    Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };
	
	    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };
	
	    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };
	
	    Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger, arguments);
	    };
	
	    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	    };
	
	    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };
	
	    Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };
	
	    Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };
	
	    // @pragma Mutability
	
	    Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };
	
	    Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };
	
	    Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };
	
	    Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };
	
	    Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };
	
	    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };
	
	    Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };
	
	
	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }
	
	  Map.isMap = isMap;
	
	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
	
	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;
	
	
	  // #pragma Trie Nodes
	
	
	
	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }
	
	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };
	
	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	
	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;
	
	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }
	
	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);
	
	      if (removed && entries.length === 1) {
	        return; // undefined
	      }
	
	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);
	
	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }
	
	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }
	
	      return new ArrayMapNode(ownerID, newEntries);
	    };
	
	
	
	
	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }
	
	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };
	
	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;
	
	      if (!exists && value === NOT_SET) {
	        return this;
	      }
	
	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	
	      if (newNode === node) {
	        return this;
	      }
	
	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }
	
	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }
	
	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);
	
	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }
	
	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };
	
	
	
	
	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }
	
	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };
	
	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];
	
	      if (removed && !node) {
	        return this;
	      }
	
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }
	
	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);
	
	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }
	
	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };
	
	
	
	
	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }
	
	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };
	
	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	
	      var removed = value === NOT_SET;
	
	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }
	
	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;
	
	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }
	
	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);
	
	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);
	
	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }
	
	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }
	
	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };
	
	
	
	
	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }
	
	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };
	
	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }
	
	      SetRef(didAlter);
	
	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }
	
	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }
	
	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };
	
	
	
	  // #pragma Iterators
	
	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }
	
	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }
	
	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }
	
	  createClass(MapIterator, Iterator);
	
	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }
	
	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };
	
	
	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }
	
	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }
	
	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }
	
	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }
	
	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }
	
	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }
	
	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }
	
	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }
	
	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	
	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);
	
	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }
	
	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }
	
	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }
	
	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }
	
	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }
	
	  function deepMerger(existing, value, key) {
	    return existing && existing.mergeDeep && isIterable(value) ?
	      existing.mergeDeep(value) :
	      is(existing, value) ? existing : value;
	  }
	
	  function deepMergerWith(merger) {
	    return function(existing, value, key)  {
	      if (existing && existing.mergeDeepWith && isIterable(value)) {
	        return existing.mergeDeepWith(merger, value);
	      }
	      var nextValue = merger(existing, value, key);
	      return is(existing, nextValue) ? existing : nextValue;
	    };
	  }
	
	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }
	
	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }
	
	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }
	
	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }
	
	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }
	
	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }
	
	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
	
	  createClass(List, IndexedCollection);
	
	    // @pragma Construction
	
	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }
	
	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };
	
	    // @pragma Access
	
	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };
	
	    // @pragma Modification
	
	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };
	
	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };
	
	    List.prototype.insert = function(index, value) {
	      return this.splice(index, 0, value);
	    };
	
	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };
	
	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };
	
	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };
	
	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };
	
	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };
	
	    // @pragma Composition
	
	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };
	
	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };
	
	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger, arguments);
	    };
	
	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMergerWith(merger), iters);
	    };
	
	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };
	
	    // @pragma Iteration
	
	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };
	
	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };
	
	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };
	
	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };
	
	
	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }
	
	  List.isList = isList;
	
	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
	
	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;
	
	
	
	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }
	
	    // TODO: seems like these methods are very similar
	
	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };
	
	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }
	
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	          return this;
	        }
	      }
	
	      var editable = editableVNode(this, ownerID);
	      editable.array.splice(sizeIndex + 1);
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };
	
	
	
	  var DONE = {};
	
	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;
	
	    return iterateNodeOrLeaf(list._root, list._level, 0);
	
	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }
	
	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }
	
	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }
	
	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }
	
	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }
	
	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);
	
	    if (index !== index) {
	      return list;
	    }
	
	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }
	
	    index += list._origin;
	
	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }
	
	    if (!didAlter.value) {
	      return list;
	    }
	
	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }
	
	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }
	
	    var newNode;
	
	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }
	
	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }
	
	    SetRef(didAlter);
	
	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }
	
	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }
	
	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }
	
	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }
	
	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }
	
	    var newLevel = list._level;
	    var newRoot = list._root;
	
	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }
	
	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);
	
	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }
	
	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
	
	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }
	
	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }
	
	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
	
	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;
	
	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }
	
	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }
	
	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }
	
	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }
	
	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }
	
	  createClass(OrderedMap, Map);
	
	    // @pragma Construction
	
	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }
	
	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };
	
	    // @pragma Access
	
	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };
	
	    // @pragma Modification
	
	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };
	
	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };
	
	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };
	
	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };
	
	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };
	
	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };
	
	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };
	
	
	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }
	
	  OrderedMap.isOrderedMap = isOrderedMap;
	
	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
	
	
	
	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }
	
	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }
	
	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }
	
	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }
	
	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };
	
	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };
	
	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };
	
	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };
	
	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };
	
	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };
	
	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };
	
	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }
	
	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };
	
	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };
	
	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };
	
	
	
	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }
	
	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };
	
	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };
	
	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };
	
	
	
	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }
	
	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };
	
	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };
	
	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };
	
	
	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;
	
	
	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }
	
	
	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }
	
	
	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue) 
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }
	
	
	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }
	
	
	  function countByFactory(iterable, grouper, context) {
	    var groups = Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }
	
	
	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }
	
	
	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;
	
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	
	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }
	
	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);
	
	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }
	
	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }
	
	    var sliceSeq = makeSequence(iterable);
	
	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;
	
	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }
	
	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };
	
	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }
	
	    return sliceSeq;
	  }
	
	
	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c) 
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }
	
	
	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }
	
	
	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});
	
	    if (iters.length === 0) {
	      return iterable;
	    }
	
	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }
	
	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }
	
	
	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }
	
	
	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }
	
	
	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k) 
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }
	
	
	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }
	
	
	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }
	
	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }
	
	
	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }
	
	
	  // #pragma Helper Functions
	
	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }
	
	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }
	
	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }
	
	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }
	
	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }
	
	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }
	
	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }
	
	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }
	
	  createClass(Record, KeyedCollection);
	
	    function Record(defaultValues, name) {
	      var hasInitialized;
	
	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = Map(values);
	      };
	
	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;
	
	      return RecordType;
	    }
	
	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };
	
	    // @pragma Access
	
	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };
	
	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };
	
	    // @pragma Modification
	
	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };
	
	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };
	
	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };
	
	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };
	
	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };
	
	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };
	
	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };
	
	
	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;
	
	
	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }
	
	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }
	
	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }
	
	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }
	
	  createClass(Set, SetCollection);
	
	    // @pragma Construction
	
	    function Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) && !isOrdered(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }
	
	    Set.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };
	
	    Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };
	
	    // @pragma Access
	
	    Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };
	
	    // @pragma Modification
	
	    Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };
	
	    Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };
	
	    Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };
	
	    // @pragma Composition
	
	    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };
	
	    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };
	
	    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };
	
	    Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };
	
	    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };
	
	    Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };
	
	    Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };
	
	    Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };
	
	    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };
	
	    Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };
	
	    Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };
	
	
	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }
	
	  Set.isSet = isSet;
	
	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
	
	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;
	
	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;
	
	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }
	
	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }
	
	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }
	
	  createClass(OrderedSet, Set);
	
	    // @pragma Construction
	
	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }
	
	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };
	
	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };
	
	
	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }
	
	  OrderedSet.isOrderedSet = isOrderedSet;
	
	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
	
	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;
	
	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }
	
	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }
	
	  createClass(Stack, IndexedCollection);
	
	    // @pragma Construction
	
	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }
	
	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };
	
	    // @pragma Access
	
	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };
	
	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };
	
	    // @pragma Modification
	
	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };
	
	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };
	
	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };
	
	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };
	
	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };
	
	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };
	
	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };
	
	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };
	
	    // @pragma Mutability
	
	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };
	
	    // @pragma Iteration
	
	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };
	
	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };
	
	
	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }
	
	  Stack.isStack = isStack;
	
	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
	
	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;
	
	
	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }
	
	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }
	
	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }
	
	  Iterable.Iterator = Iterator;
	
	  mixin(Iterable, {
	
	    // ### Conversion to other types
	
	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },
	
	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },
	
	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },
	
	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },
	
	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },
	
	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },
	
	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },
	
	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },
	
	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },
	
	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },
	
	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	
	    // ### Common JavaScript methods and properties
	
	    toString: function() {
	      return '[Iterable]';
	    },
	
	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },
	
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },
	
	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },
	
	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },
	
	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },
	
	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },
	
	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },
	
	    findEntry: function(predicate, context) {
	      var found;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },
	
	    findLastEntry: function(predicate, context) {
	      return this.toSeq().reverse().findEntry(predicate, context);
	    },
	
	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },
	
	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },
	
	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },
	
	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },
	
	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },
	
	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },
	
	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },
	
	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },
	
	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },
	
	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },
	
	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },
	
	
	    // ### More sequential methods
	
	    butLast: function() {
	      return this.slice(0, -1);
	    },
	
	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },
	
	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },
	
	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },
	
	    equals: function(other) {
	      return deepEqual(this, other);
	    },
	
	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },
	
	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },
	
	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },
	
	    first: function() {
	      return this.find(returnTrue);
	    },
	
	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },
	
	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },
	
	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },
	
	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },
	
	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },
	
	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },
	
	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },
	
	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },
	
	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },
	
	    isSuperset: function(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },
	
	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },
	
	    last: function() {
	      return this.toSeq().reverse().first();
	    },
	
	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },
	
	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },
	
	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },
	
	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },
	
	    rest: function() {
	      return this.slice(1);
	    },
	
	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },
	
	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },
	
	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },
	
	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },
	
	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },
	
	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },
	
	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },
	
	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },
	
	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },
	
	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },
	
	
	    // ### Hashable Object
	
	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }
	
	
	    // ### Internal
	
	    // abstract __iterate(fn, reverse)
	
	    // abstract __iterator(type, reverse)
	  });
	
	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	
	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;
	
	  // Temporary warning about using length
	  (function () {
	    try {
	      Object.defineProperty(IterablePrototype, 'length', {
	        get: function () {
	          if (!Iterable.noLengthWarning) {
	            var stack;
	            try {
	              throw new Error();
	            } catch (error) {
	              stack = error.stack;
	            }
	            if (stack.indexOf('_wrapObject') === -1) {
	              console && console.warn && console.warn(
	                'iterable.length has been deprecated, '+
	                'use iterable.size or iterable.count(). '+
	                'This warning will become a silent error in a future version. ' +
	                stack
	              );
	              return this.size;
	            }
	          }
	        }
	      });
	    } catch (e) {}
	  })();
	
	
	
	  mixin(KeyedIterable, {
	
	    // ### More sequential methods
	
	    flip: function() {
	      return reify(this, flipFactory(this));
	    },
	
	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },
	
	    findLastKey: function(predicate, context) {
	      return this.toSeq().reverse().findKey(predicate, context);
	    },
	
	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },
	
	    lastKeyOf: function(searchValue) {
	      return this.findLastKey(function(value ) {return is(value, searchValue)});
	    },
	
	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },
	
	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    }
	
	  });
	
	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};
	
	
	
	  mixin(IndexedIterable, {
	
	    // ### Conversion to other types
	
	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },
	
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },
	
	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },
	
	    indexOf: function(searchValue) {
	      var key = this.toKeyedSeq().keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },
	
	    lastIndexOf: function(searchValue) {
	      var key = this.toKeyedSeq().reverse().keyOf(searchValue);
	      return key === undefined ? -1 : key;
	
	      // var index =
	      // return this.toSeq().reverse().indexOf(searchValue);
	    },
	
	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },
	
	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },
	
	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },
	
	
	    // ### More collection methods
	
	    findLastIndex: function(predicate, context) {
	      var key = this.toKeyedSeq().findLastKey(predicate, context);
	      return key === undefined ? -1 : key;
	    },
	
	    first: function() {
	      return this.get(0);
	    },
	
	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },
	
	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },
	
	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },
	
	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },
	
	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },
	
	    last: function() {
	      return this.get(-1);
	    },
	
	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },
	
	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },
	
	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }
	
	  });
	
	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	
	  mixin(SetIterable, {
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },
	
	    includes: function(value) {
	      return this.has(value);
	    },
	
	
	    // ### More sequential methods
	
	    keySeq: function() {
	      return this.valueSeq();
	    }
	
	  });
	
	  SetIterable.prototype.has = IterablePrototype.includes;
	
	
	  // Mixin subclasses
	
	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);
	
	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);
	
	
	  // #pragma Helper functions
	
	  function keyMapper(v, k) {
	    return k;
	  }
	
	  function entryMapper(v, k) {
	    return [k, v];
	  }
	
	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }
	
	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }
	
	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : value;
	  }
	
	  function defaultZipper() {
	    return arrCopy(arguments);
	  }
	
	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }
	
	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }
	
	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xCC9E2D51);
	    h = imul(h << 15 | h >>> -15, 0x1B873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }
	
	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }
	
	  var Immutable = {
	
	    Iterable: Iterable,
	
	    Seq: Seq,
	    Collection: Collection,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,
	
	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,
	
	    is: is,
	    fromJS: fromJS
	
	  };
	
	  return Immutable;
	
	}));

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElement
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(19);
	
	var assign = __webpack_require__(7);
	var canDefineProperty = __webpack_require__(65);
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	/**
	 * Base constructor for all React elements. This is only used to make this
	 * work with a dynamic instanceof check. Nothing should live on this prototype.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (false) {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._source = source;
	    }
	    Object.freeze(element.props);
	    Object.freeze(element);
	  }
	
	  return element;
	};
	
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    ref = config.ref === undefined ? null : config.ref;
	    key = config.key === undefined ? null : '' + config.key;
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (typeof props[propName] === 'undefined') {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
	  var newElement = ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, newProps);
	
	  if (false) {
	    // If the key on the original is valid, then the clone is valid
	    newElement._store.validated = oldElement._store.validated;
	  }
	
	  return newElement;
	};
	
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (config.ref !== undefined) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (config.key !== undefined) {
	      key = '' + config.key;
	    }
	    // Remaining properties override existing props
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	module.exports = ReactElement;

/***/ },
/* 12 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ExecutionEnvironment
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _React3Instance = __webpack_require__(98);
	
	var _React3Instance2 = _interopRequireDefault(_React3Instance);
	
	var _ReactPropTypeLocations = __webpack_require__(44);
	
	var _ReactPropTypeLocations2 = _interopRequireDefault(_ReactPropTypeLocations);
	
	var _ReactPropTypeLocationNames = __webpack_require__(33);
	
	var _ReactPropTypeLocationNames2 = _interopRequireDefault(_ReactPropTypeLocationNames);
	
	var _warning = __webpack_require__(30);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _events = __webpack_require__(492);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var EventEmitter = _events2.default.EventEmitter;
	
	/**
	 * @abstract
	 */
	
	var THREEElementDescriptor = function () {
	  function THREEElementDescriptor(react3RendererInstance) {
	    _classCallCheck(this, THREEElementDescriptor);
	
	    this.react3RendererInstance = react3RendererInstance;
	    this.propUpdates = {};
	    this.propDeletes = {};
	    this._initialOnly = {};
	    this._updateInitial = [];
	    this._simpleProperties = [];
	
	    this.propTypes = {};
	
	    this._hasName = false;
	  }
	
	  _createClass(THREEElementDescriptor, [{
	    key: 'hasEvent',
	    value: function hasEvent(name) {
	      this._hasEvents = true;
	
	      this.hasProp(name, {
	        type: _ReactPropTypes2.default.func,
	        updateInitial: true,
	        update: function update(threeObject, callback) {
	          threeObject.userData._eventCallbacks[name] = callback;
	        },
	
	        default: null
	      });
	    }
	  }, {
	    key: 'removeProp',
	    value: function removeProp(name) {
	      (0, _invariant2.default)(this.propTypes.hasOwnProperty(name), 'The property %s has not been defined', name);
	
	      var simpleIndex = this._simpleProperties.indexOf(name);
	      if (simpleIndex !== -1) {
	        this._simpleProperties.splice(simpleIndex, 1);
	      }
	
	      delete this.propTypes[name];
	      delete this.propDeletes[name];
	      delete this.propUpdates[name];
	
	      var updateInitialIndex = this._updateInitial.indexOf(name);
	      if (updateInitialIndex !== -1) {
	        this._updateInitial.splice(updateInitialIndex, 1);
	      }
	
	      delete this._initialOnly[name];
	    }
	  }, {
	    key: 'hasProp',
	    value: function hasProp(name, info) {
	      var _this = this;
	
	      (0, _invariant2.default)(info.hasOwnProperty('type'), 'The information should include a `type` property');
	      (0, _invariant2.default)(!this.propTypes.hasOwnProperty(name) || info.override, 'The property %s has already been defined', name);
	
	      if (info.override) {
	        // clean up simple prop
	        var simpleIndex = this._simpleProperties.indexOf(name);
	        if (simpleIndex !== -1) {
	          this._simpleProperties.splice(simpleIndex, 1);
	        }
	      }
	
	      this.propTypes[name] = info.type;
	
	      if (info.hasOwnProperty('simple')) {
	        this.registerSimpleProperties([name]);
	
	        if (info.hasOwnProperty('default')) {
	          this.propDeletes[name] = function (threeObject) {
	            _this.propUpdates[name](threeObject, info.default, true);
	          };
	        }
	      } else {
	        if (info.hasOwnProperty('update')) {
	          this.propUpdates[name] = info.update;
	        }
	
	        if (info.hasOwnProperty('default')) {
	          (0, _invariant2.default)(info.hasOwnProperty('update'), 'The information should include a `update` property ' + 'if it has a `default` property');
	
	          this.propDeletes[name] = function (threeObject) {
	            info.update(threeObject, info.default, true);
	          };
	        }
	
	        if (info.hasOwnProperty('remove')) {
	          (0, _invariant2.default)(!info.hasOwnProperty('default'), 'The information should not include ' + 'both of `default` and `remove` properties');
	          this.propDeletes[name] = function (threeObject) {
	            info.update(threeObject, info.default);
	          };
	        }
	
	        if (info.hasOwnProperty('updateInitial')) {
	          (0, _invariant2.default)(info.hasOwnProperty('update'), 'The information should include a ' + '`update` property if it has a`updateInitial` property');
	
	          if (this._updateInitial.indexOf(name) === -1) {
	            this._updateInitial.push(name);
	          }
	        }
	
	        if (!!info.initialOnly) {
	          (0, _invariant2.default)(info.hasOwnProperty('updateInitial'), 'The information should include a ' + '`updateInitial` property if it has an `initialOnly` property');
	        }
	
	        this._initialOnly[name] = info.initialOnly;
	      }
	    }
	  }, {
	    key: 'hasName',
	    value: function hasName() {
	      var _this2 = this;
	
	      this._hasName = true;
	
	      this.hasProp('name', {
	        type: _ReactPropTypes2.default.string,
	        update: function update(threeObject, name) {
	          _this2._updateName(threeObject, name);
	        },
	        default: ''
	      });
	    }
	  }, {
	    key: '_updateName',
	    value: function _updateName(threeObject, nextName) {
	      var oldName = threeObject.name;
	
	      threeObject.name = nextName;
	
	      threeObject.userData.events.emit('rename', {
	        oldName: oldName,
	        nextName: nextName
	      });
	
	      var markup = threeObject.userData.markup;
	
	      if (markup._rootInstance) {
	        markup._rootInstance.objectRenamed(threeObject, oldName, nextName);
	      }
	    }
	  }, {
	    key: 'placeRemountTrigger',
	    value: function placeRemountTrigger(threeObject, triggerRemount) {
	      threeObject.userData._triggerRemount = triggerRemount;
	    }
	  }, {
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      var _this3 = this;
	
	      // do nothing for now
	
	      var eventsForObject = new EventEmitter();
	
	      if (this._hasName && props.name) {
	        threeObject.name = props.name;
	      }
	
	      if (this._hasEvents) {
	        threeObject.userData._eventCallbacks = {};
	      }
	
	      // pass down resources
	
	      eventsForObject.on('resource.added', function (data) {
	        var childrenMarkup = threeObject.userData.markup.childrenMarkup;
	
	        var increasedDistance = _extends({}, data, {
	          distance: data.distance + 1
	        });
	
	        childrenMarkup.forEach(function (childMarkup) {
	          return childMarkup.threeObject.userData.events.emit('resource.added', increasedDistance);
	        });
	      });
	
	      eventsForObject.on('resource.removed', function (data) {
	        var childrenMarkup = threeObject.userData.markup.childrenMarkup;
	
	        var increasedDistance = _extends({}, data, {
	          distance: data.distance + 1
	        });
	
	        childrenMarkup.forEach(function (childMarkup) {
	          return childMarkup.threeObject.userData.events.emit('resource.removed', increasedDistance);
	        });
	      });
	
	      threeObject.userData.events = eventsForObject;
	      threeObject.userData._descriptor = this;
	
	      this._updateInitial.forEach(function (propertyName) {
	        if (props.hasOwnProperty(propertyName)) {
	          _this3.propUpdates[propertyName](threeObject, props[propertyName], true);
	        } else {
	          _this3.propUpdates[propertyName](threeObject, undefined, false);
	        }
	      });
	
	      this._simpleProperties.forEach(function (propertyName) {
	        if (props.hasOwnProperty(propertyName)) {
	          threeObject[propertyName] = props[propertyName];
	        }
	      });
	    }
	  }, {
	    key: 'construct',
	    value: function construct(props) {
	      // eslint-disable-line no-unused-vars
	      (0, _invariant2.default)(false, 'Missing constructor!');
	    }
	
	    // noinspection JSUnusedLocalSymbols
	
	  }, {
	    key: 'addChildren',
	    value: function addChildren(threeObject, children) {
	      // eslint-disable-line no-unused-vars
	      (0, _invariant2.default)(false, 'Cannot add children to ' + this.constructor.name + '!');
	    }
	
	    // noinspection JSUnusedLocalSymbols
	
	  }, {
	    key: 'addChild',
	    value: function addChild(threeObject, child, mountIndex) {
	      // eslint-disable-line no-unused-vars
	      (0, _invariant2.default)(false, 'Cannot add child to ' + this.constructor.name + '!');
	    }
	  }, {
	    key: 'moveChild',
	    value: function moveChild() {
	      (0, _invariant2.default)(false, 'Cannot move children in ' + this.constructor.name + '!');
	    }
	  }, {
	    key: 'removeChild',
	    value: function removeChild(threeObject, child) {
	      // eslint-disable-line no-unused-vars
	      (0, _invariant2.default)(false, 'Cannot remove children in ' + this.constructor.name + '!');
	    }
	  }, {
	    key: 'setParent',
	    value: function setParent(threeObject, parentObject3D) {
	      var parentMarkup = parentObject3D.userData.markup;
	
	      if (parentMarkup && parentMarkup._rootInstance) {
	        parentMarkup._rootInstance.objectMounted(threeObject);
	      }
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount(threeObject) {// eslint-disable-line no-unused-vars
	
	    }
	  }, {
	    key: 'unmount',
	    value: function unmount(threeObject) {
	      var markup = threeObject.userData.markup;
	
	      if (markup._rootInstance) {
	        markup._rootInstance.objectRemoved(threeObject);
	      }
	
	      if (this._hasEvents) {
	        delete threeObject.userData._eventCallbacks;
	      }
	
	      threeObject.userData.events.emit('dispose', {
	        object: threeObject
	      });
	
	      threeObject.userData.events.removeAllListeners();
	    }
	  }, {
	    key: 'removedFromParent',
	    value: function removedFromParent(threeObject) {
	      delete threeObject.userData.events;
	    }
	
	    // noinspection JSUnusedLocalSymbols
	
	  }, {
	    key: 'deleteProperty',
	    value: function deleteProperty(threeObject, propKey) {
	      // eslint-disable-line no-unused-vars
	      if (this.propDeletes[propKey]) {
	        this.propDeletes[propKey](threeObject);
	      } else if (false) {
	        (0, _warning2.default)(false, 'Cannot delete property %s from ' + this.constructor.name, propKey);
	      }
	    }
	  }, {
	    key: 'updateProperty',
	    value: function updateProperty(threeObject, propKey, nextProp) {
	      if (!this._initialOnly[propKey]) {
	        if (this.propUpdates[propKey]) {
	          this.propUpdates[propKey](threeObject, nextProp, true);
	        } else {
	          (0, _warning2.default)(false, 'updating prop ' + propKey + ' ( ' + nextProp + ' ) for ' + this.constructor.name);
	          this.triggerRemount(threeObject);
	        }
	      } else {
	        this.triggerRemount(threeObject);
	      }
	    }
	  }, {
	    key: 'highlight',
	    value: function highlight(threeObject) {// eslint-disable-line no-unused-vars
	      // no highlighting by default!
	    }
	  }, {
	    key: 'hideHighlight',
	    value: function hideHighlight(threeObject) {} // eslint-disable-line no-unused-vars
	    // no highlighting by default!
	
	    /**
	     * @protected
	     * @param names
	     */
	
	  }, {
	    key: 'useSimpleUpdates',
	    value: function useSimpleUpdates(names) {
	      for (var index = 0; index < names.length; ++index) {
	        var propName = names[index];
	        this.propUpdates[propName] = this._updateSimple.bind(this, propName);
	      }
	    }
	  }, {
	    key: '_updateSimple',
	    value: function _updateSimple(propName, threeObject, propValue) {
	      threeObject[propName] = propValue;
	    }
	  }, {
	    key: 'registerSimpleProperties',
	    value: function registerSimpleProperties(propertyNames) {
	      var _this4 = this;
	
	      propertyNames.forEach(function (propName) {
	        if (_this4._simpleProperties.indexOf(propName) === -1) {
	          _this4._simpleProperties.push(propName);
	        }
	      });
	
	      this.useSimpleUpdates(propertyNames);
	    }
	  }, {
	    key: 'getBoundingBoxes',
	    value: function getBoundingBoxes(threeObject) {
	      // eslint-disable-line no-unused-vars
	      return [];
	    }
	  }, {
	    key: 'triggerRemount',
	    value: function triggerRemount(threeObject) {
	      threeObject.userData._triggerRemount();
	
	      delete threeObject.userData._triggerRemount;
	    }
	  }, {
	    key: 'beginPropertyUpdates',
	    value: function beginPropertyUpdates(threeObject) {// eslint-disable-line no-unused-vars
	    }
	  }, {
	    key: 'completePropertyUpdates',
	    value: function completePropertyUpdates(threeObject) {// eslint-disable-line no-unused-vars
	    }
	  }, {
	    key: 'beginChildUpdates',
	    value: function beginChildUpdates(threeObject) {// eslint-disable-line no-unused-vars
	    }
	  }, {
	    key: 'completeChildUpdates',
	    value: function completeChildUpdates(threeObject) {// eslint-disable-line no-unused-vars
	    }
	  }]);
	
	  return THREEElementDescriptor;
	}();
	
	if (false) {
	  (function () {
	    // @see ReactElementValidator
	
	    var loggedTypeFailures = {};
	
	    var getDeclarationErrorAddendum = function getDeclarationErrorAddendum(owner) {
	      if (owner) {
	        var name = owner.getName();
	        if (name) {
	          return ' Check the render method of `' + name + '`.';
	        }
	      }
	      return '';
	    };
	
	    /**
	     * Assert that the props are valid
	     * @private
	     */
	    var _checkPropTypes = function _checkPropTypes(componentName, propTypes, props, location, owner) {
	      var propNames = Object.keys(props);
	      for (var i = 0; i < propNames.length; ++i) {
	        var propName = propNames[i];
	
	        if (propName === 'children') {
	          continue;
	        }
	
	        if (!propTypes.hasOwnProperty(propName)) {
	          var errorMessage = 'Foreign prop ' + propName + ' found in ' + componentName + '.';
	
	          if (!(errorMessage in loggedTypeFailures)) {
	            var addendum = getDeclarationErrorAddendum(owner);
	
	            // Only monitor this failure once because there tends to be a lot of the
	            // same error.
	            loggedTypeFailures[errorMessage] = true;
	
	            (0, _warning2.default)(false, '' + errorMessage + addendum);
	          }
	        }
	      }
	
	      var propTypeNames = Object.keys(propTypes);
	      for (var i = 0; i < propTypeNames.length; ++i) {
	        var propName = propTypeNames[i];
	
	        var error = undefined;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          if (typeof propTypes[propName] !== 'function') {
	            if (process.env.NODE_ENV !== 'production') {
	              (0, _invariant2.default)(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', _ReactPropTypeLocationNames2.default[location], propName);
	            } else {
	              (0, _invariant2.default)(false);
	            }
	          }
	          error = propTypes[propName](props, propName, componentName, location);
	        } catch (ex) {
	          error = ex;
	        }
	
	        (0, _warning2.default)(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', _ReactPropTypeLocationNames2.default[location], propName, typeof error === 'undefined' ? 'undefined' : _typeof(error));
	
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;
	
	          var addendum = getDeclarationErrorAddendum(owner);
	          (0, _warning2.default)(false, 'Failed propType: %s%s', error.message, addendum);
	        }
	      }
	    };
	
	    THREEElementDescriptor.prototype.checkPropTypes = function checkPropTypes(name, owner, props) {
	      _checkPropTypes(name, this.propTypes, props, _ReactPropTypeLocations2.default.prop, owner);
	    };
	  })();
	}
	
	module.exports = THREEElementDescriptor;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMount
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(35);
	var ReactBrowserEventEmitter = __webpack_require__(61);
	var ReactCurrentOwner = __webpack_require__(19);
	var ReactDOMFeatureFlags = __webpack_require__(256);
	var ReactElement = __webpack_require__(11);
	var ReactEmptyComponentRegistry = __webpack_require__(111);
	var ReactInstanceHandles = __webpack_require__(31);
	var ReactInstanceMap = __webpack_require__(32);
	var ReactMarkupChecksum = __webpack_require__(264);
	var ReactPerf = __webpack_require__(20);
	var ReactReconciler = __webpack_require__(23);
	var ReactUpdateQueue = __webpack_require__(45);
	var ReactUpdates = __webpack_require__(18);
	
	var assign = __webpack_require__(7);
	var emptyObject = __webpack_require__(47);
	var containsNode = __webpack_require__(278);
	var instantiateReactComponent = __webpack_require__(118);
	var invariant = __webpack_require__(4);
	var setInnerHTML = __webpack_require__(67);
	var shouldUpdateReactComponent = __webpack_require__(68);
	var validateDOMNesting = __webpack_require__(121);
	var warning = __webpack_require__(8);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var nodeCache = {};
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);
	
	/** Mapping from reactRootID to React component instance. */
	var instancesByReactRootID = {};
	
	/** Mapping from reactRootID to `container` nodes. */
	var containersByReactRootID = {};
	
	if (false) {
	  /** __DEV__-only mapping from reactRootID to root elements. */
	  var rootElementsByReactRootID = {};
	}
	
	// Used to store breadth-first search state in findComponentRoot.
	var findComponentRootReusableArray = [];
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	/**
	 * @param {DOMElement} container DOM element that may contain a React component.
	 * @return {?string} A "reactRoot" ID, if a React component is rendered.
	 */
	function getReactRootID(container) {
	  var rootElement = getReactRootElementInContainer(container);
	  return rootElement && ReactMount.getID(rootElement);
	}
	
	/**
	 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
	 * element can return its control whose name or ID equals ATTR_NAME. All
	 * DOM nodes support `getAttributeNode` but this can also get called on
	 * other objects so just return '' if we're given something other than a
	 * DOM node (such as window).
	 *
	 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
	 * @return {string} ID of the supplied `domNode`.
	 */
	function getID(node) {
	  var id = internalGetID(node);
	  if (id) {
	    if (nodeCache.hasOwnProperty(id)) {
	      var cached = nodeCache[id];
	      if (cached !== node) {
	        !!isValid(cached, id) ?  false ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;
	
	        nodeCache[id] = node;
	      }
	    } else {
	      nodeCache[id] = node;
	    }
	  }
	
	  return id;
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Sets the React-specific ID of the given node.
	 *
	 * @param {DOMElement} node The DOM node whose ID will be set.
	 * @param {string} id The value of the ID attribute.
	 */
	function setID(node, id) {
	  var oldID = internalGetID(node);
	  if (oldID !== id) {
	    delete nodeCache[oldID];
	  }
	  node.setAttribute(ATTR_NAME, id);
	  nodeCache[id] = node;
	}
	
	/**
	 * Finds the node with the supplied React-generated DOM ID.
	 *
	 * @param {string} id A React-generated DOM ID.
	 * @return {DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNode(id) {
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}
	
	/**
	 * Finds the node with the supplied public React instance.
	 *
	 * @param {*} instance A public React instance.
	 * @return {?DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNodeFromInstance(instance) {
	  var id = ReactInstanceMap.get(instance)._rootNodeID;
	  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {
	    return null;
	  }
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}
	
	/**
	 * A node is "valid" if it is contained by a currently mounted container.
	 *
	 * This means that the node does not have to be contained by a document in
	 * order to be considered valid.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @param {string} id The expected ID of the node.
	 * @return {boolean} Whether the node is contained by a mounted container.
	 */
	function isValid(node, id) {
	  if (node) {
	    !(internalGetID(node) === id) ?  false ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;
	
	    var container = ReactMount.findReactContainerForID(id);
	    if (container && containsNode(container, node)) {
	      return true;
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Causes the cache to forget about one React-specific ID.
	 *
	 * @param {string} id The ID to forget.
	 */
	function purgeID(id) {
	  delete nodeCache[id];
	}
	
	var deepestNodeSoFar = null;
	function findDeepestCachedAncestorImpl(ancestorID) {
	  var ancestor = nodeCache[ancestorID];
	  if (ancestor && isValid(ancestor, ancestorID)) {
	    deepestNodeSoFar = ancestor;
	  } else {
	    // This node isn't populated in the cache, so presumably none of its
	    // descendants are. Break out of the loop.
	    return false;
	  }
	}
	
	/**
	 * Return the deepest cached node whose ID is a prefix of `targetID`.
	 */
	function findDeepestCachedAncestor(targetID) {
	  deepestNodeSoFar = null;
	  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);
	
	  var foundNode = deepestNodeSoFar;
	  deepestNodeSoFar = null;
	  return foundNode;
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
	  if (ReactDOMFeatureFlags.useCreateElement) {
	    context = assign({}, context);
	    if (container.nodeType === DOC_NODE_TYPE) {
	      context[ownerDocumentContextKey] = container;
	    } else {
	      context[ownerDocumentContextKey] = container.ownerDocument;
	    }
	  }
	  if (false) {
	    if (context === emptyObject) {
	      context = {};
	    }
	    var tag = container.nodeName.toLowerCase();
	    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
	  }
	  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
	  componentInstance._renderedComponent._topLevelWrapper = componentInstance;
	  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* forceHTML */shouldReuseMarkup);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container) {
	  ReactReconciler.unmountComponent(instance);
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(node) {
	  var reactRootID = getReactRootID(node);
	  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;
	}
	
	/**
	 * Returns the first (deepest) ancestor of a node which is rendered by this copy
	 * of React.
	 */
	function findFirstReactDOMImpl(node) {
	  // This node might be from another React instance, so we make sure not to
	  // examine the node cache here
	  for (; node && node.parentNode !== node; node = node.parentNode) {
	    if (node.nodeType !== 1) {
	      // Not a DOMElement, therefore not a React component
	      continue;
	    }
	    var nodeID = internalGetID(node);
	    if (!nodeID) {
	      continue;
	    }
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	
	    // If containersByReactRootID contains the container we find by crawling up
	    // the tree, we know that this instance of React rendered the node.
	    // nb. isValid's strategy (with containsNode) does not work because render
	    // trees may be nested and we don't want a false positive in that case.
	    var current = node;
	    var lastID;
	    do {
	      lastID = internalGetID(current);
	      current = current.parentNode;
	      if (current == null) {
	        // The passed-in node has been detached from the container it was
	        // originally rendered into.
	        return null;
	      }
	    } while (lastID !== reactRootID);
	
	    if (current === containersByReactRootID[reactRootID]) {
	      return node;
	    }
	  }
	  return null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var TopLevelWrapper = function () {};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (false) {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  // this.props is actually a ReactElement
	  return this.props;
	};
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	
	  TopLevelWrapper: TopLevelWrapper,
	
	  /** Exposed for debugging purposes **/
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function (container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function (prevComponent, nextElement, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    if (false) {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
	    }
	
	    return prevComponent;
	  },
	
	  /**
	   * Register a component into the instance map and starts scroll value
	   * monitoring
	   * @param {ReactComponent} nextComponent component instance to render
	   * @param {DOMElement} container container to render into
	   * @return {string} reactRoot ID prefix
	   */
	  _registerComponent: function (nextComponent, container) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ?  false ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	
	    var reactRootID = ReactMount.registerContainer(container);
	    instancesByReactRootID[reactRootID] = nextComponent;
	    return reactRootID;
	  },
	
	  /**
	   * Render a new component into the DOM.
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	     false ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
	
	    var componentInstance = instantiateReactComponent(nextElement, null);
	    var reactRootID = ReactMount._registerComponent(componentInstance, container);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);
	
	    if (false) {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
	    }
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && parentComponent._reactInternalInstance != null) ?  false ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !ReactElement.isValidElement(nextElement) ?  false ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;
	
	     false ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;
	
	    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);
	
	    var prevComponent = instancesByReactRootID[getReactRootID(container)];
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function (nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Registers a container node into which React components will be rendered.
	   * This also creates the "reactRoot" ID that will be assigned to the element
	   * rendered within.
	   *
	   * @param {DOMElement} container DOM element to register as a container.
	   * @return {string} The "reactRoot" ID of elements rendered within.
	   */
	  registerContainer: function (container) {
	    var reactRootID = getReactRootID(container);
	    if (reactRootID) {
	      // If one exists, make sure it is a valid "reactRoot" ID.
	      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
	    }
	    if (!reactRootID) {
	      // No valid "reactRoot" ID found, create one.
	      reactRootID = ReactInstanceHandles.createReactRootID();
	    }
	    containersByReactRootID[reactRootID] = container;
	    return reactRootID;
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function (container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	     false ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
	
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ?  false ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;
	
	    var reactRootID = getReactRootID(container);
	    var component = instancesByReactRootID[reactRootID];
	    if (!component) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var containerID = internalGetID(container);
	      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);
	
	      if (false) {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;
	      }
	
	      return false;
	    }
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
	    delete instancesByReactRootID[reactRootID];
	    delete containersByReactRootID[reactRootID];
	    if (false) {
	      delete rootElementsByReactRootID[reactRootID];
	    }
	    return true;
	  },
	
	  /**
	   * Finds the container DOM element that contains React component to which the
	   * supplied DOM `id` belongs.
	   *
	   * @param {string} id The ID of an element rendered by a React component.
	   * @return {?DOMElement} DOM element that contains the `id`.
	   */
	  findReactContainerForID: function (id) {
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
	    var container = containersByReactRootID[reactRootID];
	
	    if (false) {
	      var rootElement = rootElementsByReactRootID[reactRootID];
	      if (rootElement && rootElement.parentNode !== container) {
	        process.env.NODE_ENV !== 'production' ? warning(
	        // Call internalGetID here because getID calls isValid which calls
	        // findReactContainerForID (this function).
	        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
	        var containerChild = container.firstChild;
	        if (containerChild && reactRootID === internalGetID(containerChild)) {
	          // If the container has a new child with the same ID as the old
	          // root element, then rootElementsByReactRootID[reactRootID] is
	          // just stale and needs to be updated. The case that deserves a
	          // warning is when the container is empty.
	          rootElementsByReactRootID[reactRootID] = containerChild;
	        } else {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;
	        }
	      }
	    }
	
	    return container;
	  },
	
	  /**
	   * Finds an element rendered by React with the supplied ID.
	   *
	   * @param {string} id ID of a DOM node in the React component.
	   * @return {DOMElement} Root DOM node of the React component.
	   */
	  findReactNodeByID: function (id) {
	    var reactRoot = ReactMount.findReactContainerForID(id);
	    return ReactMount.findComponentRoot(reactRoot, id);
	  },
	
	  /**
	   * Traverses up the ancestors of the supplied node to find a node that is a
	   * DOM representation of a React component rendered by this copy of React.
	   *
	   * @param {*} node
	   * @return {?DOMEventTarget}
	   * @internal
	   */
	  getFirstReactDOM: function (node) {
	    return findFirstReactDOMImpl(node);
	  },
	
	  /**
	   * Finds a node with the supplied `targetID` inside of the supplied
	   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
	   * quickly.
	   *
	   * @param {DOMEventTarget} ancestorNode Search from this root.
	   * @pararm {string} targetID ID of the DOM representation of the component.
	   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
	   * @internal
	   */
	  findComponentRoot: function (ancestorNode, targetID) {
	    var firstChildren = findComponentRootReusableArray;
	    var childIndex = 0;
	
	    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
	
	    if (false) {
	      // This will throw on the next line; give an early warning
	      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\'t find the root component node for data-reactid value ' + '`%s`. If you\'re seeing this message, it probably means that ' + 'you\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;
	    }
	
	    firstChildren[0] = deepestAncestor.firstChild;
	    firstChildren.length = 1;
	
	    while (childIndex < firstChildren.length) {
	      var child = firstChildren[childIndex++];
	      var targetChild;
	
	      while (child) {
	        var childID = ReactMount.getID(child);
	        if (childID) {
	          // Even if we find the node we're looking for, we finish looping
	          // through its siblings to ensure they're cached so that we don't have
	          // to revisit this node again. Otherwise, we make n^2 calls to getID
	          // when visiting the many children of a single node in order.
	
	          if (targetID === childID) {
	            targetChild = child;
	          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
	            // If we find a child whose ID is an ancestor of the given ID,
	            // then we can be sure that we only want to search the subtree
	            // rooted at this child, so we can throw out the rest of the
	            // search state.
	            firstChildren.length = childIndex = 0;
	            firstChildren.push(child.firstChild);
	          }
	        } else {
	          // If this child had no ID, then there's a chance that it was
	          // injected automatically by the browser, as when a `<table>`
	          // element sprouts an extra `<tbody>` child as a side effect of
	          // `.innerHTML` parsing. Optimistically continue down this
	          // branch, but not before examining the other siblings.
	          firstChildren.push(child.firstChild);
	        }
	
	        child = child.nextSibling;
	      }
	
	      if (targetChild) {
	        // Emptying firstChildren/findComponentRootReusableArray is
	        // not necessary for correctness, but it helps the GC reclaim
	        // any nodes that were left at the end of the search.
	        firstChildren.length = 0;
	
	        return targetChild;
	      }
	    }
	
	    firstChildren.length = 0;
	
	     true ?  false ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
	  },
	
	  _mountImageIntoNode: function (markup, container, shouldReuseMarkup, transaction) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ?  false ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (false) {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ?  false ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;
	
	        if (false) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ?  false ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      container.appendChild(markup);
	    } else {
	      setInnerHTML(container, markup);
	    }
	  },
	
	  ownerDocumentContextKey: ownerDocumentContextKey,
	
	  /**
	   * React ID utilities.
	   */
	
	  getReactRootID: getReactRootID,
	
	  getID: getID,
	
	  setID: setID,
	
	  getNode: getNode,
	
	  getNodeFromInstance: getNodeFromInstance,
	
	  isValid: isValid,
	
	  purgeID: purgeID
	};
	
	ReactPerf.measureMethods(ReactMount, 'ReactMount', {
	  _renderNewRootComponent: '_renderNewRootComponent',
	  _mountImageIntoNode: '_mountImageIntoNode'
	});
	
	module.exports = ReactMount;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Provider = __webpack_require__(346);
	var connect = __webpack_require__(347);
	
	module.exports = { Provider: Provider, connect: connect };

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _class;
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _THREEElementDescriptor = __webpack_require__(13);
	
	var _THREEElementDescriptor2 = _interopRequireDefault(_THREEElementDescriptor);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _resource = __webpack_require__(60);
	
	var _resource2 = _interopRequireDefault(_resource);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var GeometryDescriptorBase = (0, _resource2.default)(_class = function (_THREEElementDescript) {
	  _inherits(GeometryDescriptorBase, _THREEElementDescript);
	
	  function GeometryDescriptorBase(react3RendererInstance) {
	    _classCallCheck(this, GeometryDescriptorBase);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(GeometryDescriptorBase).call(this, react3RendererInstance));
	
	    _this.hasProp('dynamic', {
	      type: _ReactPropTypes2.default.bool,
	      update: function update(threeObject, dynamic) {
	        threeObject.dynamic = !!dynamic;
	      },
	
	      default: false
	    });
	
	    _this.hasName();
	    return _this;
	  }
	
	  _createClass(GeometryDescriptorBase, [{
	    key: 'setParent',
	    value: function setParent(geometry, parentObject3D) {
	      (0, _invariant2.default)(parentObject3D instanceof _three2.default.Mesh || parentObject3D instanceof _three2.default.Points || parentObject3D instanceof _three2.default.Line, 'Parent is not a mesh');
	      (0, _invariant2.default)(parentObject3D.geometry === undefined, 'Parent already has a geometry');
	
	      _get(Object.getPrototypeOf(GeometryDescriptorBase.prototype), 'setParent', this).call(this, geometry, parentObject3D);
	
	      parentObject3D.geometry = geometry;
	    }
	  }, {
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      // ensure the userData is created
	      threeObject.userData = _extends({}, threeObject.userData);
	
	      if (props.hasOwnProperty('dynamic')) {
	        threeObject.dynamic = !!props.dynamic;
	      }
	
	      threeObject.userData._remountAfterPropsUpdate = false;
	
	      _get(Object.getPrototypeOf(GeometryDescriptorBase.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	    }
	  }, {
	    key: 'unmount',
	    value: function unmount(geometry) {
	      var parent = geometry.userData.markup.parentMarkup.threeObject;
	
	      // could either be a resource description or an actual geometry
	      if (parent instanceof _three2.default.Mesh || parent instanceof _three2.default.Points) {
	        if (parent.geometry === geometry) {
	          parent.geometry = undefined;
	        }
	      }
	
	      geometry.dispose();
	
	      _get(Object.getPrototypeOf(GeometryDescriptorBase.prototype), 'unmount', this).call(this, geometry);
	    }
	  }, {
	    key: 'highlight',
	    value: function highlight(threeObject) {
	      var ownerMesh = threeObject.userData.markup.parentMarkup.threeObject;
	      threeObject.userData.events.emit('highlight', {
	        uuid: threeObject.uuid,
	        boundingBoxFunc: function boundingBoxFunc() {
	          var boundingBox = new _three2.default.Box3();
	
	          boundingBox.setFromObject(ownerMesh);
	
	          return [boundingBox];
	        }
	      });
	    }
	  }, {
	    key: 'getBoundingBoxes',
	    value: function getBoundingBoxes(threeObject) {
	      var ownerMesh = threeObject.userData.markup.parentMarkup.threeObject;
	
	      var boundingBox = new _three2.default.Box3();
	
	      boundingBox.setFromObject(ownerMesh);
	
	      return [boundingBox];
	    }
	  }, {
	    key: 'hideHighlight',
	    value: function hideHighlight(threeObject) {
	      threeObject.userData.events.emit('hideHighlight');
	    }
	  }]);
	
	  return GeometryDescriptorBase;
	}(_THREEElementDescriptor2.default)) || _class;
	
	module.exports = GeometryDescriptorBase;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _ReactPropTypeLocationNames = __webpack_require__(33);
	
	var _ReactPropTypeLocationNames2 = _interopRequireDefault(_ReactPropTypeLocationNames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!(propValue.constructor && (propValue.constructor.name || propValue.constructor.displayName))) {
	    return '<<anonymous>>';
	  }
	  return propValue.constructor.name || propValue.constructor.displayName;
	}
	
	var ANONYMOUS = '<<anonymous>>';
	
	function createChainableTypeChecker(validate) {
	  function checkType(isRequired, props, propName, _componentName, location, _propFullName) {
	    var componentName = _componentName || ANONYMOUS;
	    var propFullName = _propFullName || propName;
	    if (props[propName] === null) {
	      var locationName = _ReactPropTypeLocationNames2.default[location];
	      if (isRequired) {
	        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	      return null;
	    }
	
	    return validate(props, propName, componentName, location, propFullName);
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  var originalInstanceOf = _ReactPropTypes2.default.instanceOf(expectedClass);
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var originalResult = originalInstanceOf(props, propName, componentName, location, propFullName);
	
	    if (originalResult !== null) {
	      var locationName = _ReactPropTypeLocationNames2.default[location];
	      var expectedClassName = expectedClass.name || expectedClass.displayName || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	
	    return originalResult;
	  }
	
	  var typeChecker = createChainableTypeChecker(validate);
	
	  var _type = '' + (expectedClass.displayName || expectedClass.name || expectedClass._type || expectedClass);
	
	  typeChecker.toString = function () {
	    return '```' + ' ' + _type + ' ' + '```';
	  };
	
	  typeChecker.isRequired.toString = function () {
	    return typeChecker.toString() + ' *' + '```' + ' required ' + '```' + '*';
	  };
	
	  typeChecker.displayName = _type;
	  typeChecker.isRequired.displayName = _type;
	
	  return typeChecker;
	}
	
	module.exports = createInstanceTypeChecker;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdates
	 */
	
	'use strict';
	
	var CallbackQueue = __webpack_require__(103);
	var PooledClass = __webpack_require__(27);
	var ReactPerf = __webpack_require__(20);
	var ReactReconciler = __webpack_require__(23);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(7);
	var invariant = __webpack_require__(4);
	
	var dirtyComponents = [];
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ?  false ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
	}
	
	var NESTED_UPDATES = {
	  initialize: function () {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function () {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function () {
	    this.callbackQueue.reset();
	  },
	  close: function () {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);
	}
	
	assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function () {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function (method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ?  false ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function () {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setProps, setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ?  false ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function (ReconcileTransaction) {
	    !ReconcileTransaction ?  false ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function (_batchingStrategy) {
	    !_batchingStrategy ?  false ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ?  false ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ?  false ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;

/***/ },
/* 19 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCurrentOwner
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPerf
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * ReactPerf is a general AOP system designed to measure performance. This
	 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
	 */
	var ReactPerf = {
	  /**
	   * Boolean to enable/disable measurement. Set to false by default to prevent
	   * accidental logging and perf loss.
	   */
	  enableMeasure: false,
	
	  /**
	   * Holds onto the measure function in use. By default, don't measure
	   * anything, but we'll override this if we inject a measure function.
	   */
	  storedMeasure: _noMeasure,
	
	  /**
	   * @param {object} object
	   * @param {string} objectName
	   * @param {object<string>} methodNames
	   */
	  measureMethods: function (object, objectName, methodNames) {
	    if (false) {
	      for (var key in methodNames) {
	        if (!methodNames.hasOwnProperty(key)) {
	          continue;
	        }
	        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
	      }
	    }
	  },
	
	  /**
	   * Use this to wrap methods you want to measure. Zero overhead in production.
	   *
	   * @param {string} objName
	   * @param {string} fnName
	   * @param {function} func
	   * @return {function}
	   */
	  measure: function (objName, fnName, func) {
	    if (false) {
	      var measuredFunc = null;
	      var wrapper = function () {
	        if (ReactPerf.enableMeasure) {
	          if (!measuredFunc) {
	            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
	          }
	          return measuredFunc.apply(this, arguments);
	        }
	        return func.apply(this, arguments);
	      };
	      wrapper.displayName = objName + '_' + fnName;
	      return wrapper;
	    }
	    return func;
	  },
	
	  injection: {
	    /**
	     * @param {function} measure
	     */
	    injectMeasure: function (measure) {
	      ReactPerf.storedMeasure = measure;
	    }
	  }
	};
	
	/**
	 * Simply passes through the measured function, without measuring it.
	 *
	 * @param {string} objName
	 * @param {string} fnName
	 * @param {function} func
	 * @return {function}
	 */
	function _noMeasure(objName, fnName, func) {
	  return func;
	}
	
	module.exports = ReactPerf;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _class;
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _THREEElementDescriptor = __webpack_require__(13);
	
	var _THREEElementDescriptor2 = _interopRequireDefault(_THREEElementDescriptor);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _resource = __webpack_require__(60);
	
	var _resource2 = _interopRequireDefault(_resource);
	
	var _ResourceReference = __webpack_require__(41);
	
	var _ResourceReference2 = _interopRequireDefault(_ResourceReference);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _propTypeInstanceOf = __webpack_require__(17);
	
	var _propTypeInstanceOf2 = _interopRequireDefault(_propTypeInstanceOf);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MaterialDescriptorBase = (0, _resource2.default)(_class = function (_THREEElementDescript) {
	  _inherits(MaterialDescriptorBase, _THREEElementDescript);
	
	  function MaterialDescriptorBase(react3Instance) {
	    _classCallCheck(this, MaterialDescriptorBase);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MaterialDescriptorBase).call(this, react3Instance));
	
	    _this._invalidChild = function (child) {
	      return _this.invalidChildInternal(child);
	    };
	
	    _this.hasProp('slot', {
	      type: _ReactPropTypes2.default.string,
	      updateInitial: true,
	      update: function update(threeObject, slot, hasProperty) {
	        if (hasProperty) {
	          threeObject.userData._materialSlot = slot;
	        } else {
	          threeObject.userData._materialSlot = 'material';
	        }
	      },
	      default: 'material'
	    });
	
	    _this.hasProp('transparent', {
	      type: _ReactPropTypes2.default.bool,
	      simple: true
	    });
	
	    _this.hasProp('alphaTest', {
	      type: _ReactPropTypes2.default.number,
	      updateInitial: true,
	      update: function update(threeObject, alphaTest) {
	        threeObject.alphaTest = alphaTest;
	        threeObject.needsUpdate = true;
	      }
	    });
	
	    _this.hasProp('side', {
	      type: _ReactPropTypes2.default.oneOf([_three2.default.FrontSide, _three2.default.BackSide, _three2.default.DoubleSide]),
	      updateInitial: true,
	      update: function update(threeObject, side) {
	        threeObject.side = side;
	      },
	      default: undefined
	    });
	
	    _this.hasProp('opacity', {
	      type: _ReactPropTypes2.default.number,
	      simple: true
	    });
	
	    _this.hasProp('visible', {
	      type: _ReactPropTypes2.default.bool,
	      simple: true,
	      default: true
	    });
	
	    _this._colors = [];
	    return _this;
	  }
	
	  _createClass(MaterialDescriptorBase, [{
	    key: 'getMaterialDescription',
	    value: function getMaterialDescription(props) {
	      var materialDescription = {};
	
	      this._colors.forEach(function (colorPropName) {
	        if (props.hasOwnProperty(colorPropName)) {
	          materialDescription[colorPropName] = props[colorPropName];
	        }
	      });
	
	      if (props.hasOwnProperty('side')) {
	        materialDescription.side = props.side;
	      }
	
	      return materialDescription;
	    }
	  }, {
	    key: 'hasColor',
	    value: function hasColor() {
	      var propName = arguments.length <= 0 || arguments[0] === undefined ? 'color' : arguments[0];
	      var defaultVal = arguments.length <= 1 || arguments[1] === undefined ? 0xffffff : arguments[1];
	
	      if (false) {
	        (0, _invariant2.default)(this._colors.indexOf(propName) === -1, 'This color is already defined for %s.', this.constructor.name);
	      }
	
	      this._colors.push(propName);
	
	      this.hasProp(propName, {
	        type: _ReactPropTypes2.default.oneOfType([(0, _propTypeInstanceOf2.default)(_three2.default.Color), _ReactPropTypes2.default.number, _ReactPropTypes2.default.string]),
	        update: function update(threeObject, value) {
	          threeObject[propName].set(value);
	        },
	        default: defaultVal
	      });
	    }
	  }, {
	    key: 'hasWireframe',
	    value: function hasWireframe() {
	      this.hasProp('wireframe', {
	        type: _ReactPropTypes2.default.bool,
	        simple: true,
	        default: false
	      });
	
	      this.hasProp('wireframeLinewidth', {
	        type: _ReactPropTypes2.default.number,
	        simple: true,
	        default: 1
	      });
	    }
	  }, {
	    key: 'construct',
	    value: function construct() {
	      return new _three2.default.Material({});
	    }
	  }, {
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      threeObject.userData = _extends({}, threeObject.userData);
	
	      _get(Object.getPrototypeOf(MaterialDescriptorBase.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	    }
	  }, {
	    key: 'setParent',
	    value: function setParent(material, parentObject3D) {
	      (0, _invariant2.default)(parentObject3D instanceof _three2.default.Mesh || parentObject3D instanceof _three2.default.Points || parentObject3D instanceof _three2.default.Line, 'Parent is not a mesh');
	      (0, _invariant2.default)(parentObject3D[material.userData._materialSlot] === undefined || parentObject3D[material.userData._materialSlot] === null, 'Parent already has a ' + material.userData._materialSlot + ' defined');
	      _get(Object.getPrototypeOf(MaterialDescriptorBase.prototype), 'setParent', this).call(this, material, parentObject3D);
	
	      parentObject3D[material.userData._materialSlot] = material;
	    }
	  }, {
	    key: 'unmount',
	    value: function unmount(material) {
	      var parent = material.userData.markup.parentMarkup.threeObject;
	
	      // could either be a resource description or an actual material
	      if (parent instanceof _three2.default.Mesh || parent instanceof _three2.default.Points) {
	        var slot = material.userData._materialSlot;
	
	        if (parent[slot] === material) {
	          // TODO: set material slot to null rather than undefined
	
	          parent[slot] = undefined;
	        }
	      }
	
	      material.dispose();
	
	      _get(Object.getPrototypeOf(MaterialDescriptorBase.prototype), 'unmount', this).call(this, material);
	    }
	  }, {
	    key: 'highlight',
	    value: function highlight(threeObject) {
	      var ownerMesh = threeObject.userData.markup.parentMarkup.threeObject;
	      threeObject.userData.events.emit('highlight', {
	        uuid: threeObject.uuid,
	        boundingBoxFunc: function boundingBoxFunc() {
	          var boundingBox = new _three2.default.Box3();
	
	          boundingBox.setFromObject(ownerMesh);
	
	          return [boundingBox];
	        }
	      });
	    }
	  }, {
	    key: 'getBoundingBoxes',
	    value: function getBoundingBoxes(threeObject) {
	      var boundingBox = new _three2.default.Box3();
	
	      boundingBox.setFromObject(threeObject.userData.markup.parentMarkup.threeObject);
	
	      return [boundingBox];
	    }
	  }, {
	    key: 'hideHighlight',
	    value: function hideHighlight(threeObject) {
	      threeObject.userData.events.emit('hideHighlight');
	    }
	  }, {
	    key: 'addChildren',
	    value: function addChildren(threeObject, children) {
	      (0, _invariant2.default)(children.filter(this._invalidChild).length === 0, 'Mesh children can only be materials or geometries!');
	    }
	  }, {
	    key: 'addChild',
	    value: function addChild(threeObject, child) {
	      this.addChildren(threeObject, [child]);
	    }
	  }, {
	    key: 'moveChild',
	    value: function moveChild() {
	      // doesn't matter
	    }
	  }, {
	    key: 'removeChild',
	    value: function removeChild() {
	      // doesn't matter
	    }
	  }, {
	    key: 'invalidChildInternal',
	    value: function invalidChildInternal(child) {
	      var invalid = !(child instanceof _three2.default.Texture || child instanceof _ResourceReference2.default);
	
	      return invalid;
	    }
	  }]);
	
	  return MaterialDescriptorBase;
	}(_THREEElementDescriptor2.default)) || _class;
	
	module.exports = MaterialDescriptorBase;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _THREEElementDescriptor = __webpack_require__(13);
	
	var _THREEElementDescriptor2 = _interopRequireDefault(_THREEElementDescriptor);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _propTypeInstanceOf = __webpack_require__(17);
	
	var _propTypeInstanceOf2 = _interopRequireDefault(_propTypeInstanceOf);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _arrayMove(array, oldIndex, newIndex) {
	  array.splice(newIndex, 0, array.splice(oldIndex, 1)[0]);
	}
	
	var Object3DDescriptor = function (_THREEElementDescript) {
	  _inherits(Object3DDescriptor, _THREEElementDescript);
	
	  function Object3DDescriptor(react3Instance) {
	    _classCallCheck(this, Object3DDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Object3DDescriptor).call(this, react3Instance));
	
	    _this.hasName();
	
	    function copyUpdate(propName) {
	      return function (threeObject, value) {
	        threeObject[propName].copy(value);
	      };
	    }
	
	    _this.hasProp('position', {
	      type: (0, _propTypeInstanceOf2.default)(_three2.default.Vector3),
	      update: function update(threeObject, position) {
	        threeObject.position.copy(position);
	
	        if (threeObject.userData._lookAt) {
	          threeObject.lookAt(threeObject.userData._lookAt);
	        }
	      },
	
	      default: new _three2.default.Vector3()
	    });
	
	    _this.hasProp('rotation', {
	      type: (0, _propTypeInstanceOf2.default)(_three2.default.Euler),
	      update: function update(threeObject, rotation) {
	        threeObject.rotation.copy(rotation);
	      },
	
	      default: new _three2.default.Euler()
	    });
	
	    _this.hasProp('quaternion', {
	      type: (0, _propTypeInstanceOf2.default)(_three2.default.Quaternion),
	      update: copyUpdate('quaternion'),
	      default: new _three2.default.Quaternion()
	    });
	
	    _this.hasProp('scale', {
	      type: (0, _propTypeInstanceOf2.default)(_three2.default.Vector3),
	      update: copyUpdate('scale'),
	      default: new _three2.default.Vector3(1, 1, 1)
	    });
	
	    _this.hasProp('lookAt', {
	      type: (0, _propTypeInstanceOf2.default)(_three2.default.Vector3),
	      update: function update(threeObject, lookAt) {
	        threeObject.userData._lookAt = lookAt;
	
	        if (!!lookAt) {
	          threeObject.lookAt(lookAt);
	        }
	      },
	
	      default: undefined
	    });
	
	    ['frustumCulled', 'visible'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.bool,
	        simple: true,
	        default: true
	      });
	    });
	
	    _this.hasProp('renderOrder', {
	      type: _ReactPropTypes2.default.number,
	      simple: true
	    });
	
	    _this.hasProp('castShadow', {
	      type: _ReactPropTypes2.default.bool,
	      simple: true,
	      default: false
	    });
	
	    _this.hasProp('receiveShadow', {
	      type: _ReactPropTypes2.default.bool,
	      updateInitial: true,
	      update: function update(threeObject, receiveShadow) {
	        threeObject.receiveShadow = receiveShadow;
	
	        if (threeObject.material) {
	          threeObject.material.needsUpdate = true;
	        }
	      },
	
	      default: false
	    });
	    return _this;
	  }
	
	  _createClass(Object3DDescriptor, [{
	    key: 'construct',
	    value: function construct() {
	      return new _three2.default.Object3D();
	    }
	  }, {
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(Object3DDescriptor.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	
	      if (props.position) {
	        threeObject.position.copy(props.position);
	      }
	
	      if (props.scale) {
	        threeObject.scale.copy(props.scale);
	      }
	
	      if (props.rotation) {
	        threeObject.rotation.copy(props.rotation);
	      }
	
	      if (props.quaternion) {
	        threeObject.quaternion.copy(props.quaternion);
	      }
	
	      if (props.lookAt) {
	        threeObject.userData._lookAt = props.lookAt;
	        threeObject.lookAt(props.lookAt);
	      }
	    }
	
	    /**
	     * @param threeObject
	     * @param {Array} children
	     */
	
	  }, {
	    key: 'addChildren',
	    value: function addChildren(threeObject, children) {
	      children.forEach(function (child) {
	        threeObject.add(child);
	      });
	    }
	  }, {
	    key: 'addChild',
	    value: function addChild(threeObject, child, mountIndex) {
	      threeObject.add(child);
	
	      this.moveChild(threeObject, child, mountIndex, threeObject.children.length - 1);
	    }
	
	    /**
	     * @param {THREE.Object3D} threeObject
	     * @param child
	     */
	
	  }, {
	    key: 'removeChild',
	    value: function removeChild(threeObject, child) {
	      threeObject.remove(child);
	    }
	  }, {
	    key: 'moveChild',
	    value: function moveChild(threeObject, childObject, toIndex, lastIndex) {
	      // eslint-disable-line no-unused-vars
	      if (false) {
	        (0, _invariant2.default)(toIndex >= 0 && threeObject.children.length > toIndex, 'Cannot move a child to that index');
	      }
	      _arrayMove(threeObject.children, threeObject.children.indexOf(childObject), toIndex);
	    }
	  }, {
	    key: 'highlight',
	    value: function highlight(threeObject) {
	      var _this2 = this;
	
	      threeObject.userData.events.emit('highlight', {
	        uuid: threeObject.uuid,
	        boundingBoxFunc: function boundingBoxFunc() {
	          return _this2.getBoundingBoxes(threeObject);
	        }
	      });
	    }
	  }, {
	    key: 'getBoundingBoxes',
	    value: function getBoundingBoxes(threeObject) {
	      var boundingBox = new _three2.default.Box3();
	
	      boundingBox.setFromObject(threeObject);
	
	      return [boundingBox];
	    }
	  }, {
	    key: 'hideHighlight',
	    value: function hideHighlight(threeObject) {
	      threeObject.userData.events.emit('hideHighlight');
	    }
	  }]);
	
	  return Object3DDescriptor;
	}(_THREEElementDescriptor2.default);
	
	module.exports = Object3DDescriptor;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconciler
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(454);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (internalInstance, rootID, transaction, context) {
	    var markup = internalInstance.mountComponent(rootID, transaction, context);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    return markup;
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (internalInstance) {
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent();
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function (internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (internalInstance, transaction) {
	    internalInstance.performUpdateIfNecessary(transaction);
	  }
	
	};
	
	module.exports = ReactReconciler;

/***/ },
/* 24 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyFunction
	 */
	
	"use strict";
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	function emptyFunction() {}
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @abstract
	 */
	
	var ShapeAction = function () {
	  function ShapeAction() {
	    _classCallCheck(this, ShapeAction);
	
	    this.uuid = _three2.default.Math.generateUUID();
	
	    this.userData = {};
	  }
	
	  _createClass(ShapeAction, [{
	    key: 'performAction',
	    value: function performAction(shape) {// eslint-disable-line no-unused-vars
	      // to be done by subclasses
	    }
	  }]);
	
	  return ShapeAction;
	}();
	
	module.exports = ShapeAction;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventConstants
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(70);
	
	var PropagationPhases = keyMirror({ bubbled: null, captured: null });
	
	/**
	 * Types of raw signals from the browser caught at the top level.
	 */
	var topLevelTypes = keyMirror({
	  topAbort: null,
	  topBlur: null,
	  topCanPlay: null,
	  topCanPlayThrough: null,
	  topChange: null,
	  topClick: null,
	  topCompositionEnd: null,
	  topCompositionStart: null,
	  topCompositionUpdate: null,
	  topContextMenu: null,
	  topCopy: null,
	  topCut: null,
	  topDoubleClick: null,
	  topDrag: null,
	  topDragEnd: null,
	  topDragEnter: null,
	  topDragExit: null,
	  topDragLeave: null,
	  topDragOver: null,
	  topDragStart: null,
	  topDrop: null,
	  topDurationChange: null,
	  topEmptied: null,
	  topEncrypted: null,
	  topEnded: null,
	  topError: null,
	  topFocus: null,
	  topInput: null,
	  topKeyDown: null,
	  topKeyPress: null,
	  topKeyUp: null,
	  topLoad: null,
	  topLoadedData: null,
	  topLoadedMetadata: null,
	  topLoadStart: null,
	  topMouseDown: null,
	  topMouseMove: null,
	  topMouseOut: null,
	  topMouseOver: null,
	  topMouseUp: null,
	  topPaste: null,
	  topPause: null,
	  topPlay: null,
	  topPlaying: null,
	  topProgress: null,
	  topRateChange: null,
	  topReset: null,
	  topScroll: null,
	  topSeeked: null,
	  topSeeking: null,
	  topSelectionChange: null,
	  topStalled: null,
	  topSubmit: null,
	  topSuspend: null,
	  topTextInput: null,
	  topTimeUpdate: null,
	  topTouchCancel: null,
	  topTouchEnd: null,
	  topTouchMove: null,
	  topTouchStart: null,
	  topVolumeChange: null,
	  topWaiting: null,
	  topWheel: null
	});
	
	var EventConstants = {
	  topLevelTypes: topLevelTypes,
	  PropagationPhases: PropagationPhases
	};
	
	module.exports = EventConstants;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PooledClass
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(4);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ?  false ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances (optional).
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;

/***/ },
/* 28 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyOf
	 */
	
	/**
	 * Allows extraction of a minified key. Let's the build system minify keys
	 * without losing the ability to dynamically use key strings as values
	 * themselves. Pass in an object with a single key/val pair and it will return
	 * you the string key of that single record. Suppose you want to grab the
	 * value for a key 'className' inside of an object. Key/val minification may
	 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
	 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
	 * reuse those resolutions.
	 */
	"use strict";
	
	var keyOf = function (oneKeyObj) {
	  var key;
	  for (key in oneKeyObj) {
	    if (!oneKeyObj.hasOwnProperty(key)) {
	      continue;
	    }
	    return key;
	  }
	  return null;
	};
	
	module.exports = keyOf;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _THREEElementDescriptor = __webpack_require__(13);
	
	var _THREEElementDescriptor2 = _interopRequireDefault(_THREEElementDescriptor);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _HoleAction = __webpack_require__(241);
	
	var _HoleAction2 = _interopRequireDefault(_HoleAction);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ShapeActionDescriptorBase = function (_THREEElementDescript) {
	  _inherits(ShapeActionDescriptorBase, _THREEElementDescript);
	
	  function ShapeActionDescriptorBase() {
	    _classCallCheck(this, ShapeActionDescriptorBase);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(ShapeActionDescriptorBase).apply(this, arguments));
	  }
	
	  _createClass(ShapeActionDescriptorBase, [{
	    key: 'setParent',
	    value: function setParent(threeObject, parentObject3D) {
	      (0, _invariant2.default)(parentObject3D instanceof _three2.default.Path || parentObject3D instanceof _HoleAction2.default, 'Shape action commands (%s) can only be added to shapes, paths or holes.', this.constructor.name);
	
	      _get(Object.getPrototypeOf(ShapeActionDescriptorBase.prototype), 'setParent', this).call(this, threeObject, parentObject3D);
	    }
	  }, {
	    key: 'highlight',
	    value: function highlight(threeObject) {
	      var parentObject = threeObject.userData.markup.parentMarkup.threeObject;
	
	      parentObject.userData._descriptor.highlight(parentObject);
	    }
	  }, {
	    key: 'getBoundingBoxes',
	    value: function getBoundingBoxes(threeObject) {
	      var parentObject = threeObject.userData.markup.parentMarkup.threeObject;
	
	      return parentObject.userData._descriptor.getBoundingBoxes(parentObject);
	    }
	  }]);
	
	  return ShapeActionDescriptorBase;
	}(_THREEElementDescriptor2.default);
	
	module.exports = ShapeActionDescriptorBase;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(426);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (false) {
	  warning = function (condition, format) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }
	
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceHandles
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactRootIndex = __webpack_require__(270);
	
	var invariant = __webpack_require__(4);
	
	var SEPARATOR = '.';
	var SEPARATOR_LENGTH = SEPARATOR.length;
	
	/**
	 * Maximum depth of traversals before we consider the possibility of a bad ID.
	 */
	var MAX_TREE_DEPTH = 10000;
	
	/**
	 * Creates a DOM ID prefix to use when mounting React components.
	 *
	 * @param {number} index A unique integer
	 * @return {string} React root ID.
	 * @internal
	 */
	function getReactRootIDString(index) {
	  return SEPARATOR + index.toString(36);
	}
	
	/**
	 * Checks if a character in the supplied ID is a separator or the end.
	 *
	 * @param {string} id A React DOM ID.
	 * @param {number} index Index of the character to check.
	 * @return {boolean} True if the character is a separator or end of the ID.
	 * @private
	 */
	function isBoundary(id, index) {
	  return id.charAt(index) === SEPARATOR || index === id.length;
	}
	
	/**
	 * Checks if the supplied string is a valid React DOM ID.
	 *
	 * @param {string} id A React DOM ID, maybe.
	 * @return {boolean} True if the string is a valid React DOM ID.
	 * @private
	 */
	function isValidID(id) {
	  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
	}
	
	/**
	 * Checks if the first ID is an ancestor of or equal to the second ID.
	 *
	 * @param {string} ancestorID
	 * @param {string} descendantID
	 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
	 * @internal
	 */
	function isAncestorIDOf(ancestorID, descendantID) {
	  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
	}
	
	/**
	 * Gets the parent ID of the supplied React DOM ID, `id`.
	 *
	 * @param {string} id ID of a component.
	 * @return {string} ID of the parent, or an empty string.
	 * @private
	 */
	function getParentID(id) {
	  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
	}
	
	/**
	 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
	 * supplied `destinationID`. If they are equal, the ID is returned.
	 *
	 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
	 * @param {string} destinationID ID of the destination node.
	 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
	 * @private
	 */
	function getNextDescendantID(ancestorID, destinationID) {
	  !(isValidID(ancestorID) && isValidID(destinationID)) ?  false ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
	  !isAncestorIDOf(ancestorID, destinationID) ?  false ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
	  if (ancestorID === destinationID) {
	    return ancestorID;
	  }
	  // Skip over the ancestor and the immediate separator. Traverse until we hit
	  // another separator or we reach the end of `destinationID`.
	  var start = ancestorID.length + SEPARATOR_LENGTH;
	  var i;
	  for (i = start; i < destinationID.length; i++) {
	    if (isBoundary(destinationID, i)) {
	      break;
	    }
	  }
	  return destinationID.substr(0, i);
	}
	
	/**
	 * Gets the nearest common ancestor ID of two IDs.
	 *
	 * Using this ID scheme, the nearest common ancestor ID is the longest common
	 * prefix of the two IDs that immediately preceded a "marker" in both strings.
	 *
	 * @param {string} oneID
	 * @param {string} twoID
	 * @return {string} Nearest common ancestor ID, or the empty string if none.
	 * @private
	 */
	function getFirstCommonAncestorID(oneID, twoID) {
	  var minLength = Math.min(oneID.length, twoID.length);
	  if (minLength === 0) {
	    return '';
	  }
	  var lastCommonMarkerIndex = 0;
	  // Use `<=` to traverse until the "EOL" of the shorter string.
	  for (var i = 0; i <= minLength; i++) {
	    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
	      lastCommonMarkerIndex = i;
	    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
	      break;
	    }
	  }
	  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
	  !isValidID(longestCommonID) ?  false ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
	  return longestCommonID;
	}
	
	/**
	 * Traverses the parent path between two IDs (either up or down). The IDs must
	 * not be the same, and there must exist a parent path between them. If the
	 * callback returns `false`, traversal is stopped.
	 *
	 * @param {?string} start ID at which to start traversal.
	 * @param {?string} stop ID at which to end traversal.
	 * @param {function} cb Callback to invoke each ID with.
	 * @param {*} arg Argument to invoke the callback with.
	 * @param {?boolean} skipFirst Whether or not to skip the first node.
	 * @param {?boolean} skipLast Whether or not to skip the last node.
	 * @private
	 */
	function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
	  start = start || '';
	  stop = stop || '';
	  !(start !== stop) ?  false ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
	  var traverseUp = isAncestorIDOf(stop, start);
	  !(traverseUp || isAncestorIDOf(start, stop)) ?  false ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
	  // Traverse from `start` to `stop` one depth at a time.
	  var depth = 0;
	  var traverse = traverseUp ? getParentID : getNextDescendantID;
	  for (var id = start;; /* until break */id = traverse(id, stop)) {
	    var ret;
	    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
	      ret = cb(id, traverseUp, arg);
	    }
	    if (ret === false || id === stop) {
	      // Only break //after// visiting `stop`.
	      break;
	    }
	    !(depth++ < MAX_TREE_DEPTH) ?  false ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;
	  }
	}
	
	/**
	 * Manages the IDs assigned to DOM representations of React components. This
	 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
	 * order to simulate events).
	 *
	 * @internal
	 */
	var ReactInstanceHandles = {
	
	  /**
	   * Constructs a React root ID
	   * @return {string} A React root ID.
	   */
	  createReactRootID: function () {
	    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
	  },
	
	  /**
	   * Constructs a React ID by joining a root ID with a name.
	   *
	   * @param {string} rootID Root ID of a parent component.
	   * @param {string} name A component's name (as flattened children).
	   * @return {string} A React ID.
	   * @internal
	   */
	  createReactID: function (rootID, name) {
	    return rootID + name;
	  },
	
	  /**
	   * Gets the DOM ID of the React component that is the root of the tree that
	   * contains the React component with the supplied DOM ID.
	   *
	   * @param {string} id DOM ID of a React component.
	   * @return {?string} DOM ID of the React component that is the root.
	   * @internal
	   */
	  getReactRootIDFromNodeID: function (id) {
	    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
	      var index = id.indexOf(SEPARATOR, 1);
	      return index > -1 ? id.substr(0, index) : id;
	    }
	    return null;
	  },
	
	  /**
	   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	   * should would receive a `mouseEnter` or `mouseLeave` event.
	   *
	   * NOTE: Does not invoke the callback on the nearest common ancestor because
	   * nothing "entered" or "left" that element.
	   *
	   * @param {string} leaveID ID being left.
	   * @param {string} enterID ID being entered.
	   * @param {function} cb Callback to invoke on each entered/left ID.
	   * @param {*} upArg Argument to invoke the callback with on left IDs.
	   * @param {*} downArg Argument to invoke the callback with on entered IDs.
	   * @internal
	   */
	  traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {
	    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
	    if (ancestorID !== leaveID) {
	      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
	    }
	    if (ancestorID !== enterID) {
	      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
	    }
	  },
	
	  /**
	   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseTwoPhase: function (targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, false);
	      traverseParentPath(targetID, '', cb, arg, false, true);
	    }
	  },
	
	  /**
	   * Same as `traverseTwoPhase` but skips the `targetID`.
	   */
	  traverseTwoPhaseSkipTarget: function (targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, true);
	      traverseParentPath(targetID, '', cb, arg, true, true);
	    }
	  },
	
	  /**
	   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
	   * example, passing `.0.$row-0.1` would result in `cb` getting called
	   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseAncestors: function (targetID, cb, arg) {
	    traverseParentPath('', targetID, cb, arg, true, false);
	  },
	
	  getFirstCommonAncestorID: getFirstCommonAncestorID,
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _getNextDescendantID: getNextDescendantID,
	
	  isAncestorIDOf: isAncestorIDOf,
	
	  SEPARATOR: SEPARATOR
	
	};
	
	module.exports = ReactInstanceHandles;

/***/ },
/* 32 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceMap
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function (key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function (key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function (key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function (key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocationNames
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (false) {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(27);
	
	var assign = __webpack_require__(7);
	var emptyFunction = __webpack_require__(24);
	var warning = __webpack_require__(8);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function (event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 */
	function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  this.dispatchConfig = dispatchConfig;
	  this.dispatchMarker = dispatchMarker;
	  this.nativeEvent = nativeEvent;
	  this.target = nativeEventTarget;
	  this.currentTarget = nativeEventTarget;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      this[propName] = nativeEvent[propName];
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	}
	
	assign(SyntheticEvent.prototype, {
	
	  preventDefault: function () {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `preventDefault` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function () {
	    var event = this.nativeEvent;
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `stopPropagation` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else {
	      event.cancelBubble = true;
	    }
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function () {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function () {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      this[propName] = null;
	    }
	    this.dispatchConfig = null;
	    this.dispatchMarker = null;
	    this.nativeEvent = null;
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var prototype = Object.create(Super.prototype);
	  assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMProperty
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(4);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_ATTRIBUTE: 0x1,
	  MUST_USE_PROPERTY: 0x2,
	  HAS_SIDE_EFFECTS: 0x4,
	  HAS_BOOLEAN_VALUE: 0x8,
	  HAS_NUMERIC_VALUE: 0x10,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function (domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ?  false ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	
	      !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ?  false ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ?  false ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ?  false ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;
	
	      if (false) {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (false) {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	var defaultValueCache = {};
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseAttribute:
	   *   Whether the property must be accessed and mutated using `*Attribute()`.
	   *   (This includes anything that fails `<propName> in <element>`.)
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasSideEffects:
	   *   Whether or not setting a value causes side effects such as triggering
	   *   resources to be loaded or text selection changes. If true, we read from
	   *   the DOM before updating to ensure that the value is only set if it has
	   *   changed.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   * @type {Object}
	   */
	  getPossibleStandardName:  false ? {} : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function (attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  /**
	   * Returns the default property value for a DOM property (i.e., not an
	   * attribute). Most default values are '' or false, but not all. Worse yet,
	   * some (in particular, `type`) vary depending on the type of element.
	   *
	   * TODO: Is it better to grab all the possible properties when creating an
	   * element to avoid having to create the same element twice?
	   */
	  getDefaultValueForProperty: function (nodeName, prop) {
	    var nodeDefaults = defaultValueCache[nodeName];
	    var testElement;
	    if (!nodeDefaults) {
	      defaultValueCache[nodeName] = nodeDefaults = {};
	    }
	    if (!(prop in nodeDefaults)) {
	      testElement = document.createElement(nodeName);
	      nodeDefaults[prop] = testElement[prop];
	    }
	    return nodeDefaults[prop];
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(49);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(127);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(126);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(125);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(48);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(50);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (false) {
	  (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2["default"];
	exports.combineReducers = _combineReducers2["default"];
	exports.bindActionCreators = _bindActionCreators2["default"];
	exports.applyMiddleware = _applyMiddleware2["default"];
	exports.compose = _compose2["default"];

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.checkStatus = exports.launchRecap = exports.launchRank = exports.launchPlay = undefined;
	
	var _constants = __webpack_require__(6);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	var _choregraphy = __webpack_require__(282);
	
	var _steps = __webpack_require__(133);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var launchIdle = undefined;
	var launchIntro = undefined;
	var launchTuto = undefined;
	var launchWait = undefined;
	var launchWarning = undefined;
	var launchLoad = undefined;
	var launchPlay = undefined;
	var launchRecap = undefined;
	var launchSave = undefined;
	var launchRank = undefined;
	var launchEnd = undefined;
	var checkStatus = undefined;
	
	launchIdle = function launchIdle() {
		return function (dispatch, getState) {
			clearTimeout(getState().game.get('timeout'));
			dispatch({
				type: _constants2.default.GAME_IDLE
			});
		};
	};
	
	launchIntro = function launchIntro() {
		return function (dispatch, getState) {
			var introTimeout = setTimeout(function () {
				dispatch(launchTuto());
			}, _constants2.default.GAME_INTRO_DURATION);
			dispatch({
				type: _constants2.default.GAME_INTRO,
				timeout: introTimeout
			});
		};
	};
	
	launchTuto = function launchTuto() {
		return function (dispatch, getState) {
			dispatch((0, _steps.resetSteps)());
			dispatch((0, _choregraphy.startTutoChoregraphy)());
			dispatch((0, _steps.setTutoStepsTimeouts)());
			var tutoFinishTime = (0, _choregraphy.getChoregraphyEndTime)(getState().dance.get('moves')) - _constants2.default.TUTO_FORWARD_TIME - _constants2.default.MOVE_DURATION;
			var tutoTimeout = setTimeout(function () {
				dispatch((0, _steps.resetSteps)());
				dispatch((0, _choregraphy.resetChoregraphy)());
				dispatch(launchWait());
				dispatch(checkStatus());
			}, tutoFinishTime);
			dispatch({
				type: _constants2.default.GAME_TUTO,
				time: Date.now() - _constants2.default.TUTO_FORWARD_TIME,
				timeout: tutoTimeout
			});
		};
	};
	
	launchWait = function launchWait() {
		return function (dispatch, getState) {
			var state = getState();
			clearTimeout(state.game.get('timeout'));
			var waitTimeout = setTimeout(function () {
				dispatch({
					type: _constants2.default.GAME_IDLE
				});
			}, _constants2.default.GAME_WAIT_DURATION);
			dispatch({
				type: _constants2.default.GAME_WAIT,
				timeout: waitTimeout
			});
		};
	};
	
	launchWarning = function launchWarning() {
		return function (dispatch, getState) {
			clearTimeout(getState().game.get('timeout'));
			var warningTimeout = setTimeout(function () {
				dispatch(launchLoad());
			}, _constants2.default.GAME_WARNING_DURATION);
			dispatch({
				type: _constants2.default.GAME_WARNING,
				timeout: warningTimeout
			});
		};
	};
	
	launchLoad = function launchLoad() {
		return function (dispatch, getState) {
			var loadTimeout = setTimeout(function () {
				dispatch(launchPlay());
			}, _constants2.default.GAME_LOAD_DURATION);
			dispatch({
				type: _constants2.default.GAME_LOAD,
				timeout: loadTimeout
			});
		};
	};
	
	exports.launchPlay = launchPlay = function launchPlay() {
		return function (dispatch, getState) {
			dispatch((0, _steps.resetSteps)());
			dispatch((0, _choregraphy.startChoregraphy)());
			var playEndTime = (0, _choregraphy.getChoregraphyEndTime)(getState().dance.get('moves'));
			var playTimeout = setTimeout(function () {
				dispatch((0, _steps.resetSteps)());
				dispatch(launchRecap());
			}, playEndTime);
			dispatch({
				type: _constants2.default.GAME_PLAY,
				time: Date.now(),
				timeout: playTimeout
			});
		};
	};
	
	exports.launchRecap = launchRecap = function launchRecap() {
		return function (dispatch, getState) {
			var recapTimeout = setTimeout(function () {
				dispatch(launchSave());
			}, _constants2.default.GAME_RECAP_DURATION);
			dispatch({
				type: _constants2.default.GAME_RECAP,
				timeout: recapTimeout
			});
		};
	};
	
	launchSave = function launchSave() {
		return function (dispatch, getState) {
			clearTimeout(getState().game.get('timeout'));
			var saveTimeout = setTimeout(function () {
				dispatch(launchIdle());
			}, _constants2.default.GAME_SAVE_DURATION);
			dispatch({
				type: _constants2.default.GAME_SAVE,
				timeout: saveTimeout
			});
		};
	};
	
	exports.launchRank = launchRank = function launchRank() {
		return function (dispatch, getState) {
			clearTimeout(getState().game.get('timeout'));
			var rankTimeout = setTimeout(function () {
				dispatch(launchEnd());
			}, _constants2.default.GAME_RANK_DURATION);
			dispatch({
				type: _constants2.default.GAME_RANK,
				timeout: rankTimeout
			});
		};
	};
	
	launchEnd = function launchEnd() {
		return function (dispatch, getState) {
			clearTimeout(getState().game.get('timeout'));
			var endTimeout = setTimeout(function () {
				dispatch(launchIdle());
				dispatch((0, _choregraphy.resetChoregraphy)());
			}, _constants2.default.GAME_END_DURATION);
			dispatch({
				type: _constants2.default.GAME_END,
				timeout: endTimeout
			});
		};
	};
	
	var leftAndRight = ['left', 'right'];
	
	var areLeftAndRightDown = function areLeftAndRightDown(pads) {
		return leftAndRight.every(function (dir) {
			return pads.get(dir) === 'down';
		});
	};
	var isLeftOrRightUp = function isLeftOrRightUp(pads) {
		return leftAndRight.some(function (dir) {
			return pads.get(dir) === 'up';
		});
	};
	
	var isLeftOrRight = /left|right/;
	
	exports.checkStatus = checkStatus = function checkStatus(direction) {
		return function (dispatch, getState) {
			var state = getState();
			var status = state.game.get('status');
			var pads = state.pads;
			if (status === 'idle' && pads.includes('down')) {
				dispatch(launchIntro());
			} else if (direction && !direction.match(isLeftOrRight)) {
				return;
			}
			if (status === 'wait' && areLeftAndRightDown(pads)) {
				dispatch(launchWarning());
				return;
			}
			if ((status === 'warning' || status === 'load') && isLeftOrRightUp(pads)) {
				dispatch(launchWait());
				return;
			}
			if (direction !== 'right' || pads.get('right') !== 'down') {
				return;
			}
			if (status === 'recap') {
				dispatch(launchSave());
			}
			if (status === 'save') {
				dispatch(launchSave());
			}
			if (status === 'rank') {
				dispatch(launchEnd());
			}
			if (status === 'end') {
				dispatch(launchIdle());
			}
		};
	};
	
	exports.launchPlay = launchPlay;
	exports.launchRank = launchRank;
	exports.launchRecap = launchRecap;
	exports.checkStatus = checkStatus;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _directionKeys = __webpack_require__(81);
	
	var directionKeys = _interopRequireWildcard(_directionKeys);
	
	var _moduleHot = __webpack_require__(83);
	
	var moduleHot = _interopRequireWildcard(_moduleHot);
	
	var _immutable = __webpack_require__(82);
	
	var immutable = _interopRequireWildcard(_immutable);
	
	var _scaleBody = __webpack_require__(84);
	
	var scaleBody = _interopRequireWildcard(_scaleBody);
	
	var _statsCounter = __webpack_require__(85);
	
	var statsCounter = _interopRequireWildcard(_statsCounter);
	
	var _store = __webpack_require__(86);
	
	var store = _interopRequireWildcard(_store);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	exports.default = Object.assign({}, directionKeys, moduleHot, immutable, scaleBody, statsCounter, store);

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.getPerformance = undefined;
	
	var _reselect = __webpack_require__(130);
	
	var performanceTable = {
		ok: {
			score: 1,
			comboAddition: 1
		},
		good: {
			score: 2,
			comboAddition: 2
		},
		excellent: {
			score: 4,
			comboAddition: 4
		},
		fail: {
			score: 0,
			comboAddition: null
		},
		miss: {
			score: 0,
			comboAddition: null
		}
	};
	
	var getCommentedEvents = function getCommentedEvents(events) {
		return events.filter(function (event) {
			return typeof event.comment === 'string';
		});
	};
	
	var sortEventsChronologically = function sortEventsChronologically(events) {
		return events.sort(function (event1, event2) {
			return event1.commentTime - event2.commentTime;
		});
	};
	
	var getSnapshots = function getSnapshots(directionsComments) {
		var snapshots = {};
		Object.keys(directionsComments).forEach(function (direction) {
			var comment = directionsComments[direction];
			snapshots[direction] = {
				lastComment: comment.last,
				commentCount: comment[comment.last]
			};
		});
		return snapshots;
	};
	
	var getPerformances = function getPerformances(events) {
		var combo = 1;
		var score = 0;
		var progression = 0;
		var comments = {
			ok: 0,
			good: 0,
			excellent: 0,
			fail: 0,
			miss: 0,
			last: events.size > 0 ? events.last().comment : ''
		};
		var directionsComments = {
			left: { ok: 0, good: 0, excellent: 0, fail: 0, miss: 0, last: '' },
			top: { ok: 0, good: 0, excellent: 0, fail: 0, miss: 0, last: '' },
			bottom: { ok: 0, good: 0, excellent: 0, fail: 0, miss: 0, last: '' },
			right: { ok: 0, good: 0, excellent: 0, fail: 0, miss: 0, last: '' }
		};
		events.forEach(function (event, index) {
			var comboAddition = performanceTable[event.comment].comboAddition;
			combo = comboAddition ? combo + comboAddition : 1;
			score += performanceTable[event.comment].score * combo;
			progression += performanceTable[event.comment].score;
			comments[event.comment]++;
			directionsComments[event.direction][event.comment]++;
			directionsComments[event.direction].last = event.comment;
		});
		var snapshots = getSnapshots(directionsComments);
		return {
			combo: combo,
			score: score,
			progression: progression,
			comments: comments,
			snapshots: snapshots
		};
	};
	
	var getDance = function getDance(state) {
		return state.dance;
	};
	
	var getPerformance = exports.getPerformance = (0, _reselect.createSelector)([getDance], function (dance) {
		var scoringMoves = getCommentedEvents(dance.get('moves'));
		var scoringSteps = getCommentedEvents(dance.get('steps'));
		var scoringEvents = scoringMoves.concat(scoringSteps);
		var orderedEvents = sortEventsChronologically(scoringEvents);
		return getPerformances(orderedEvents);
	});

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _common = __webpack_require__(311);
	
	var common = _interopRequireWildcard(_common);
	
	var _rbfi = __webpack_require__(312);
	
	var rbfi = _interopRequireWildcard(_rbfi);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	exports.default = Object.assign({}, common, rbfi);

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ResourceReference = function ResourceReference(resourceId) {
	  _classCallCheck(this, ResourceReference);
	
	  this.uuid = _three2.default.Math.generateUUID();
	
	  this.resourceId = resourceId;
	  this.userData = {};
	};
	
	module.exports = ResourceReference;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginHub
	 */
	
	'use strict';
	
	var EventPluginRegistry = __webpack_require__(251);
	var EventPluginUtils = __webpack_require__(435);
	var ReactErrorUtils = __webpack_require__(261);
	
	var accumulateInto = __webpack_require__(272);
	var forEachAccumulated = __webpack_require__(274);
	var invariant = __webpack_require__(4);
	var warning = __webpack_require__(8);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function (event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function (e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function (e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	/**
	 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
	 *   hierarchy given ids of the logical DOM elements involved.
	 */
	var InstanceHandle = null;
	
	function validateInstanceHandle() {
	  var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
	   false ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
	}
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {object} InjectedMount
	     * @public
	     */
	    injectMount: EventPluginUtils.injection.injectMount,
	
	    /**
	     * @param {object} InjectedInstanceHandle
	     * @public
	     */
	    injectInstanceHandle: function (InjectedInstanceHandle) {
	      InstanceHandle = InjectedInstanceHandle;
	      if (false) {
	        validateInstanceHandle();
	      }
	    },
	
	    getInstanceHandle: function () {
	      if (false) {
	        validateInstanceHandle();
	      }
	      return InstanceHandle;
	    },
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
	
	  registrationNameModules: EventPluginRegistry.registrationNameModules,
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {?function} listener The callback to store.
	   */
	  putListener: function (id, registrationName, listener) {
	    !(typeof listener === 'function') ?  false ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(false) : undefined;
	
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[id] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(id, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function (id, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    return bankForRegistrationName && bankForRegistrationName[id];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function (id, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(id, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      delete bankForRegistrationName[id];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {string} id ID of the DOM element.
	   */
	  deleteAllListeners: function (id) {
	    for (var registrationName in listenerBank) {
	      if (!listenerBank[registrationName][id]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(id, registrationName);
	      }
	
	      delete listenerBank[registrationName][id];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function (events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function (simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ?  false ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function () {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function () {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPropagators
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(26);
	var EventPluginHub = __webpack_require__(42);
	
	var warning = __webpack_require__(8);
	
	var accumulateInto = __webpack_require__(272);
	var forEachAccumulated = __webpack_require__(274);
	
	var PropagationPhases = EventConstants.PropagationPhases;
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(id, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(id, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(domID, upwards, event) {
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;
	  }
	  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
	  var listener = listenerAtPhase(domID, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(id, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(id, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event.dispatchMarker, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
	  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocations
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(70);
	
	var ReactPropTypeLocations = keyMirror({
	  prop: null,
	  context: null,
	  childContext: null
	});
	
	module.exports = ReactPropTypeLocations;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdateQueue
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(19);
	var ReactElement = __webpack_require__(11);
	var ReactInstanceMap = __webpack_require__(32);
	var ReactUpdates = __webpack_require__(18);
	
	var assign = __webpack_require__(7);
	var invariant = __webpack_require__(4);
	var warning = __webpack_require__(8);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (false) {
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;
	    }
	    return null;
	  }
	
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    if (false) {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {
	    !(typeof callback === 'function') ?  false ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function (internalInstance, callback) {
	    !(typeof callback === 'function') ?  false ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function (publicInstance, partialProps) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);
	  },
	
	  enqueueSetPropsInternal: function (internalInstance, partialProps) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ?  false ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
	
	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    var props = assign({}, element.props, partialProps);
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
	
	    enqueueUpdate(topLevelWrapper);
	  },
	
	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function (publicInstance, props) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);
	  },
	
	  enqueueReplacePropsInternal: function (internalInstance, props) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ?  false ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
	
	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
	
	    enqueueUpdate(topLevelWrapper);
	  },
	
	  enqueueElementInternal: function (internalInstance, newElement) {
	    internalInstance._pendingElement = newElement;
	    enqueueUpdate(internalInstance);
	  }
	
	};
	
	module.exports = ReactUpdateQueue;

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticUIEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(34);
	
	var getEventTarget = __webpack_require__(116);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function (event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target != null && target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function (event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyObject
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (false) {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;

/***/ },
/* 48 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing functions from right to
	 * left. For example, compose(f, g, h) is identical to arg => f(g(h(arg))).
	 */
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  return function () {
	    if (funcs.length === 0) {
	      return arguments.length <= 0 ? undefined : arguments[0];
	    }
	
	    var last = funcs[funcs.length - 1];
	    var rest = funcs.slice(0, -1);
	
	    return rest.reduceRight(function (composed, f) {
	      return f(composed);
	    }, last.apply(undefined, arguments));
	  };
	}

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports["default"] = createStore;
	
	var _isPlainObject = __webpack_require__(51);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};
	
	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [initialState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, initialState, enhancer) {
	  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = initialState;
	    initialState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, initialState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = initialState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all states changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2["default"])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  };
	}

/***/ },
/* 50 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that you can use this stack
	    // to find the callsite that caused this warning to fire.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var isHostObject = __webpack_require__(128),
	    isObjectLike = __webpack_require__(129);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = Function.prototype.toString;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/** Built-in value references. */
	var getPrototypeOf = Object.getPrototypeOf;
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
	    return false;
	  }
	  var proto = objectProto;
	  if (typeof value.constructor == 'function') {
	    proto = getPrototypeOf(value);
	  }
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = proto.constructor;
	  return (typeof Ctor == 'function' &&
	    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
	}
	
	module.exports = isPlainObject;


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames2 = __webpack_require__(54);
	
	var _classnames3 = _interopRequireDefault(_classnames2);
	
	var _css = __webpack_require__(325);
	
	var _css2 = _interopRequireDefault(_css);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Text = function (_Component) {
		_inherits(Text, _Component);
	
		function Text() {
			_classCallCheck(this, Text);
	
			return _possibleConstructorReturn(this, Object.getPrototypeOf(Text).apply(this, arguments));
		}
	
		_createClass(Text, [{
			key: 'render',
			value: function render() {
				var _classnames;
	
				var thisClass = (0, _classnames3.default)((_classnames = {}, _defineProperty(_classnames, _css2.default.shade, true), _defineProperty(_classnames, this.props.className, true), _classnames));
				return _react2.default.createElement(
					'div',
					{ className: thisClass },
					_react2.default.createElement(
						'div',
						null,
						this.props.children
					),
					_react2.default.createElement(
						'div',
						null,
						this.props.children
					)
				);
			}
		}]);
	
		return Text;
	}(_react.Component);

	exports.default = Text;

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.getSpriteOffset = exports.getTranslation = exports.getPosition = undefined;
	
	var _constants = __webpack_require__(6);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var TARGET_DISTANCE_FROM_TOP = 100;
	var MOVE_DISTANCE_FROM_BOTTOM = 0;
	var DISTANCE_FROM_MOVE_TO_TARGET = _constants2.default.APP_HEIGHT - TARGET_DISTANCE_FROM_TOP - MOVE_DISTANCE_FROM_BOTTOM;
	
	var arcadeWidth = _constants2.default.APP_WIDTH / 4;
	var originalXPosition = {
		left: -arcadeWidth,
		top: arcadeWidth / -3,
		bottom: arcadeWidth / 3,
		right: arcadeWidth
	};
	
	var originalYPosition = {
		target: _constants2.default.APP_HEIGHT / 2 - TARGET_DISTANCE_FROM_TOP,
		move: _constants2.default.APP_HEIGHT / -2 + MOVE_DISTANCE_FROM_BOTTOM
	};
	
	var getPosition = exports.getPosition = function getPosition(type, direction, moveShowTime, gameTime) {
		return new _three2.default.Vector3(originalXPosition[direction], originalYPosition[type], 0);
	};
	
	var getTranslation = exports.getTranslation = function getTranslation(y, moveShowTime, gameTime) {
		return originalYPosition.move - y + (gameTime - moveShowTime) / _constants2.default.MOVE_DURATION * DISTANCE_FROM_MOVE_TO_TARGET;
	};
	
	var getSpriteOffset = exports.getSpriteOffset = function getSpriteOffset(tileIndex, hTiles, vTiles) {
		var tileColumn = tileIndex % hTiles;
		var tileRow = vTiles - 1 - Math.floor(tileIndex / hTiles);
		return new _three2.default.Vector2(tileColumn / hTiles, tileRow / vTiles);
	};

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */
	
	(function () {
		'use strict';
	
		var hasOwn = {}.hasOwnProperty;
	
		function classNames () {
			var classes = [];
	
			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;
	
				var argType = typeof arg;
	
				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}
	
			return classes.join(' ');
		}
	
		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp, _class2, _temp2;
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ReactEmptyComponent = __webpack_require__(110);
	
	var _ReactEmptyComponent2 = _interopRequireDefault(_ReactEmptyComponent);
	
	var _ReactElement = __webpack_require__(11);
	
	var _ReactElement2 = _interopRequireDefault(_ReactElement);
	
	var _ReactInstanceMap = __webpack_require__(32);
	
	var _ReactInstanceMap2 = _interopRequireDefault(_ReactInstanceMap);
	
	var _ReactEmptyComponentRegistry = __webpack_require__(111);
	
	var _ReactEmptyComponentRegistry2 = _interopRequireDefault(_ReactEmptyComponentRegistry);
	
	var _ReactInstanceHandles = __webpack_require__(31);
	
	var _ReactInstanceHandles2 = _interopRequireDefault(_ReactInstanceHandles);
	
	var _ReactReconciler = __webpack_require__(23);
	
	var _ReactReconciler2 = _interopRequireDefault(_ReactReconciler);
	
	var _ReactUpdates = __webpack_require__(18);
	
	var _ReactUpdates2 = _interopRequireDefault(_ReactUpdates);
	
	var _ReactCurrentOwner = __webpack_require__(19);
	
	var _ReactCurrentOwner2 = _interopRequireDefault(_ReactCurrentOwner);
	
	var _ReactUpdateQueue = __webpack_require__(45);
	
	var _ReactUpdateQueue2 = _interopRequireDefault(_ReactUpdateQueue);
	
	var _ReactComponent2 = __webpack_require__(62);
	
	var _ReactComponent3 = _interopRequireDefault(_ReactComponent2);
	
	var _ReactInjection = __webpack_require__(262);
	
	var _ReactInjection2 = _interopRequireDefault(_ReactInjection);
	
	var _ReactReconcileTransaction = __webpack_require__(269);
	
	var _ReactReconcileTransaction2 = _interopRequireDefault(_ReactReconcileTransaction);
	
	var _ReactDefaultBatchingStrategy = __webpack_require__(109);
	
	var _ReactDefaultBatchingStrategy2 = _interopRequireDefault(_ReactDefaultBatchingStrategy);
	
	var _traverseAllChildren = __webpack_require__(69);
	
	var _traverseAllChildren2 = _interopRequireDefault(_traverseAllChildren);
	
	var _shouldUpdateReactComponent = __webpack_require__(68);
	
	var _shouldUpdateReactComponent2 = _interopRequireDefault(_shouldUpdateReactComponent);
	
	var _emptyObject = __webpack_require__(248);
	
	var _emptyObject2 = _interopRequireDefault(_emptyObject);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _warning = __webpack_require__(30);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _React3Instance = __webpack_require__(98);
	
	var _React3Instance2 = _interopRequireDefault(_React3Instance);
	
	var _EventDispatcher = __webpack_require__(425);
	
	var _EventDispatcher2 = _interopRequireDefault(_EventDispatcher);
	
	var _InternalComponent = __webpack_require__(354);
	
	var _InternalComponent2 = _interopRequireDefault(_InternalComponent);
	
	var _ElementDescriptorContainer = __webpack_require__(353);
	
	var _ElementDescriptorContainer2 = _interopRequireDefault(_ElementDescriptorContainer);
	
	var _React3CompositeComponentWrapper = __webpack_require__(239);
	
	var _React3CompositeComponentWrapper2 = _interopRequireDefault(_React3CompositeComponentWrapper);
	
	var _idPropertyName = __webpack_require__(247);
	
	var _idPropertyName2 = _interopRequireDefault(_idPropertyName);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var SEPARATOR = _ReactInstanceHandles2.default.SEPARATOR;
	
	var getDeclarationErrorAddendum = undefined;
	
	if (false) {
	  // prop type helpers
	  // the warnings for propTypes will not say <anonymous>.
	  // Some performance is sacrificed for this.
	
	  // TODO: could have an env variable to disable this?
	  if (!_three2.default._renamed) {
	    _three2.default._renamed = true;
	
	    _three2.default.Vector2.displayName = 'THREE.Vector2';
	    _three2.default.Vector3.displayName = 'THREE.Vector3';
	    _three2.default.Quaternion.displayName = 'THREE.Quaternion';
	    _three2.default.Color.displayName = 'THREE.Color';
	    _three2.default.Shape.displayName = 'THREE.Shape';
	    _three2.default.Euler.displayName = 'THREE.Euler';
	    _three2.default.Fog.displayName = 'THREE.Fog';
	  }
	
	  getDeclarationErrorAddendum = function getDeclarationErrorAddendum(owner) {
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' Check the render method of `' + name + '`.';
	      }
	    }
	    return '';
	  };
	}
	
	/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	
	var TopLevelWrapper = (_temp = _class = function (_ReactComponent) {
	  _inherits(TopLevelWrapper, _ReactComponent);
	
	  function TopLevelWrapper() {
	    _classCallCheck(this, TopLevelWrapper);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(TopLevelWrapper).apply(this, arguments));
	  }
	
	  _createClass(TopLevelWrapper, [{
	    key: 'render',
	    value: function render() {
	      return this.props;
	    }
	  }]);
	
	  return TopLevelWrapper;
	}(_ReactComponent3.default), _class.isReactClass = {}, _class.displayName = 'TopLevelWrapper', _temp);
	
	function unmountComponentInternal(instance) {
	  _ReactReconciler2.default.unmountComponent(instance);
	}
	
	function internalGetID(markup) {
	  return markup && markup[_idPropertyName2.default] || '';
	}
	
	/**
	 * @param {THREE.Object3D|HTMLCanvasElement} container That may contain
	 * a React component
	 * @return {?*} The markup that may have the reactRoot ID, or null.
	 */
	function getReactRootMarkupInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  // in ReactMount this is container.firstChild.
	
	  return container.userData && container.userData.markup && container.userData.markup.childrenMarkup[0] || null;
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	var React3Renderer = (_temp2 = _class2 = function () {
	  _createClass(React3Renderer, [{
	    key: 'updateChildren',
	
	    /**
	     * @see ReactChildReconciler.updateChildren
	     *
	     * Updates the rendered children and returns a new set of children.
	     *
	     * @param {?object} prevChildren Previously initialized set of children.
	     * @param {?object} nextChildren Nested child maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @param {object} context
	     * @return {?object} A new set of child instances.
	     * @internal
	     */
	    value: function updateChildren(prevChildren, nextChildren, transaction, context) {
	      // We currently don't have a way to track moves here but if we use iterators
	      // instead of for..in we can zip the iterators and check if an item has
	      // moved.
	      // TODO: If nothing has changed, return the prevChildren object so that we
	      // can quickly bailout.
	      if (!nextChildren && !prevChildren) {
	        return null;
	      }
	
	      if (!!nextChildren) {
	        var nextChildrenKeys = Object.keys(nextChildren);
	
	        for (var i = 0; i < nextChildrenKeys.length; ++i) {
	          var childName = nextChildrenKeys[i];
	
	          var prevChild = prevChildren && prevChildren[childName];
	          var prevElement = prevChild && prevChild._currentElement;
	          var nextElement = nextChildren[childName];
	          if (prevChild !== null && prevChild !== undefined && (0, _shouldUpdateReactComponent2.default)(prevElement, nextElement)) {
	            _ReactReconciler2.default.receiveComponent(prevChild, nextElement, transaction, context);
	
	            if (prevChild._forceRemountOfComponent) {
	              _ReactReconciler2.default.unmountComponent(prevChild, childName);
	              nextChildren[childName] = this.instantiateReactComponent(nextElement, null);
	            } else {
	              nextChildren[childName] = prevChild;
	            }
	          } else {
	            if (prevChild) {
	              _ReactReconciler2.default.unmountComponent(prevChild, childName);
	            }
	            // The child must be instantiated before it's mounted.
	            nextChildren[childName] = this.instantiateReactComponent(nextElement, null);
	          }
	        }
	      }
	
	      if (!!prevChildren) {
	        // Unmount children that are no longer present.
	        var prevChildrenKeys = Object.keys(prevChildren);
	        for (var i = 0; i < prevChildrenKeys.length; ++i) {
	          var childName = prevChildrenKeys[i];
	
	          if (!(nextChildren && nextChildren.hasOwnProperty(childName))) {
	            _ReactReconciler2.default.unmountComponent(prevChildren[childName]);
	          }
	        }
	      }
	
	      return nextChildren;
	    }
	
	    /**
	     * @param instance
	     * @returns {*} Markup
	     */
	
	  }, {
	    key: 'getMarkupFromInstance',
	    value: function getMarkupFromInstance(instance) {
	      var id = _ReactInstanceMap2.default.get(instance)._rootNodeID;
	
	      if (_ReactEmptyComponentRegistry2.default.isNullComponentID(id)) {
	        return null;
	      }
	
	      if (!this.markupCache.hasOwnProperty(id) || !this.isValid(this.markupCache[id], id)) {
	        this.markupCache[id] = this.findMarkupByID(id);
	      }
	
	      return this.markupCache[id];
	    }
	  }, {
	    key: 'getElementDescriptor',
	    value: function getElementDescriptor(name) {
	      return this.threeElementDescriptors[name];
	    }
	  }], [{
	    key: 'findTHREEObject',
	
	    /**
	     * Returns the THREE.js object rendered by this element.
	     *
	     * @param {React.Component|THREE.Object3D|HTMLCanvasElement} componentOrElement
	     * @return {?THREE.Object3D} The root node of this element.
	     */
	    value: function findTHREEObject(componentOrElement) {
	      if (false) {
	        var owner = _ReactCurrentOwner2.default.current;
	        if (owner !== null) {
	          if (process.env.NODE_ENV !== 'production') {
	            (0, _warning2.default)(owner._warnedAboutRefsInRender, '%s is accessing findTHREEObject inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component');
	          }
	          owner._warnedAboutRefsInRender = true;
	        }
	      }
	
	      if (componentOrElement === null) {
	        return null;
	      }
	
	      if (componentOrElement instanceof _three2.default.Object3D || componentOrElement instanceof HTMLCanvasElement) {
	        return componentOrElement;
	      }
	
	      if (_ReactInstanceMap2.default.has(componentOrElement)) {
	        var instance = _ReactInstanceMap2.default.get(componentOrElement);
	
	        return instance._react3RendererInstance.getMarkupFromInstance(componentOrElement).threeObject;
	      }
	
	      if (!(componentOrElement.render === null || typeof componentOrElement.render !== 'function')) {
	        if (false) {
	          (0, _invariant2.default)(false, 'Component (with keys: %s) contains `render` method ' + 'but is not mounted', Object.keys(componentOrElement));
	        } else {
	          (0, _invariant2.default)(false);
	        }
	      }
	
	      if (false) {
	        (0, _invariant2.default)(false, 'Element appears to be neither ReactComponent, ' + 'a THREE.js object, nor a HTMLCanvasElement (keys: %s)', Object.keys(componentOrElement));
	      } else {
	        (0, _invariant2.default)(false);
	      }
	    }
	    // to be used by modules e.g. mouse input ( see examples )
	
	  }]);
	
	  function React3Renderer() {
	    var _this2 = this;
	
	    _classCallCheck(this, React3Renderer);
	
	    this.findDeepestCachedAncestorImpl = function (ancestorID) {
	      var ancestorMarkup = _this2.markupCache[ancestorID];
	      if (ancestorMarkup && _this2.isValid(ancestorMarkup, ancestorID)) {
	        _this2.deepestContainerSoFar = ancestorMarkup.threeObject;
	      } else {
	        // This node isn't populated in the cache, so presumably none of its
	        // descendants are. Break out of the loop.
	        return false;
	      }
	    };
	
	    this.instantiateChild = function (childInstances, child, name) {
	      // We found a component instance.
	      var keyUnique = childInstances[name] === undefined;
	      if (false) {
	        (0, _warning2.default)(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name);
	      }
	      if (child !== null && keyUnique) {
	        childInstances[name] = _this2.instantiateReactComponent(child, null);
	      }
	    };
	
	    this.findNodeHandle = function (instance) {
	      var markup = _this2.getMarkup(instance._rootNodeID);
	
	      _this2._highlightCache = markup;
	      return _this2._highlightElement;
	    };
	
	    this.nativeTagToRootNodeID = function () {
	      // console.log('wat');
	      // debugger;
	      // invariant(false, 'Wat!');
	      return null;
	    };
	
	    this.mountRootComponent = function (componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
	      // if (process.env.NODE_ENV !== 'production') {
	      // if (context === emptyObject) {
	      //   context = {};
	      // }
	      // const tag = container.nodeName.toLowerCase();
	      // context[validateDOMNesting.ancestorInfoContextKey] =
	      //   validateDOMNesting.updatedAncestorInfo(null, tag, null);
	      // }
	
	      var markup = _ReactReconciler2.default.mountComponent(componentInstance, rootID, transaction, context);
	      componentInstance._renderedComponent._topLevelWrapper = componentInstance;
	      _this2._mountRootImage(markup, container, shouldReuseMarkup, transaction);
	    };
	
	    this.batchedMountRootComponent = function (componentInstance, rootID, container, shouldReuseMarkup, context) {
	      var transaction = _ReactUpdates2.default.ReactReconcileTransaction.getPooled();
	      transaction.perform(_this2.mountRootComponent, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
	      _ReactUpdates2.default.ReactReconcileTransaction.release(transaction);
	    };
	
	    this._instancesByReactRootID = {};
	    this.containersByReactRootID = {};
	    if (false) {
	      this.rootMarkupsByReactRootID = {};
	    }
	    this.findComponentRootReusableArray = [];
	    this.markupCache = {};
	    this.deepestContainerSoFar = null;
	    this.nextMountID = 1;
	    this.nextReactRootIndex = 0;
	
	    this.threeElementDescriptors = new _ElementDescriptorContainer2.default(this).descriptors;
	
	    this._highlightElement = document.createElement('div');
	    this._highlightCache = null;
	
	    if (("production") !== 'production' || ({"NODE_ENV":"production"}).ENABLE_REACT_ADDON_HOOKS === 'true') {
	      this._agent = null;
	
	      this._onHideHighlightFromInspector = function () {
	        if (_this2._highlightCache && _this2._highlightCache.threeObject.userData.react3internalComponent) {
	          var internalComponent = _this2._highlightCache.threeObject.userData.react3internalComponent;
	
	          internalComponent.hideHighlight();
	
	          _this2._highlightCache = null;
	        }
	      };
	
	      this._onHighlightFromInspector = function (highlightInfo) {
	        if (highlightInfo.node === _this2._highlightElement) {
	          if (_this2._highlightCache && _this2._highlightCache.threeObject.userData.react3internalComponent) {
	            var internalComponent = _this2._highlightCache.threeObject.userData.react3internalComponent;
	
	            internalComponent.highlightComponent();
	          }
	        }
	      };
	
	      this._hookAgent = function (agent) {
	        _this2._agent = agent;
	
	        // agent.on('startInspecting', (...args) => {
	        //   console.log('start inspecting?', args);
	        // });
	        // agent.on('setSelection', (...args) => {
	        //   console.log('set selection?', args);
	        // });
	        // agent.on('selected', (...args) => {
	        //   console.log('selected?', args);
	        // });
	        agent.on('highlight', _this2._onHighlightFromInspector);
	        agent.on('hideHighlight', _this2._onHideHighlightFromInspector);
	        // agent.on('highlightMany', (...args) => {
	        //   console.log('highlightMany?', args);
	        // });
	      };
	
	      // this._scene = new THREE.Scene();
	
	      // Inject the runtime into a devtools global hook regardless of browser.
	      // Allows for debugging when the hook is injected on the page.
	      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	        this._devToolsRendererDefinition = {
	          CurrentOwner: _ReactCurrentOwner2.default,
	          InstanceHandles: _ReactInstanceHandles2.default,
	          Mount: this,
	          Reconciler: _ReactReconciler2.default,
	          TextComponent: _InternalComponent2.default
	        };
	
	        var rendererListener = function rendererListener(info) {
	          _this2._reactDevtoolsRendererId = info.id;
	          _this2._rendererListenerCleanup();
	
	          delete _this2._rendererListenerCleanup;
	        };
	
	        this._rendererListenerCleanup = __REACT_DEVTOOLS_GLOBAL_HOOK__.sub('renderer', rendererListener);
	        __REACT_DEVTOOLS_GLOBAL_HOOK__.inject(this._devToolsRendererDefinition);
	
	        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.reactDevtoolsAgent !== 'undefined' && __REACT_DEVTOOLS_GLOBAL_HOOK__.reactDevtoolsAgent) {
	          var agent = __REACT_DEVTOOLS_GLOBAL_HOOK__.reactDevtoolsAgent;
	          this._hookAgent(agent);
	        } else {
	          this._devtoolsCallbackCleanup = __REACT_DEVTOOLS_GLOBAL_HOOK__.sub('react-devtools', function (agent) {
	            _this2._devtoolsCallbackCleanup();
	
	            _this2._hookAgent(agent);
	          });
	        }
	      }
	    }
	  }
	
	  _createClass(React3Renderer, [{
	    key: 'findDeepestCachedAncestor',
	
	    /**
	     * Return the deepest cached node whose ID is a prefix of `targetID`.
	     */
	    value: function findDeepestCachedAncestor(targetID) {
	      this.deepestContainerSoFar = null;
	
	      _ReactInstanceHandles2.default.traverseAncestors(targetID, this.findDeepestCachedAncestorImpl);
	
	      var foundAncestor = this.deepestContainerSoFar;
	      this.deepestContainerSoFar = null;
	      return foundAncestor;
	    }
	  }, {
	    key: 'instantiateChildren',
	    value: function instantiateChildren(nestedChildNodes) {
	      if (nestedChildNodes === null) {
	        return null;
	      }
	
	      var childInstances = {};
	
	      (0, _traverseAllChildren2.default)(nestedChildNodes, this.instantiateChild, childInstances);
	
	      return childInstances;
	    }
	  }, {
	    key: 'containsChild',
	    value: function containsChild(container, markup) {
	      var childrenMarkup = container.userData.markup.childrenMarkup;
	      for (var i = 0; i < childrenMarkup.length; i++) {
	        if (childrenMarkup[i] === markup) {
	          return true;
	        }
	      }
	
	      return false;
	    }
	  }, {
	    key: 'isValid',
	    value: function isValid(markup, id) {
	      if (markup) {
	        if (internalGetID(markup) !== id) {
	          if (false) {
	            (0, _invariant2.default)(false, 'React3Renderer: Unexpected modification of `%s`', _idPropertyName2.default);
	          } else {
	            (0, _invariant2.default)(false);
	          }
	        }
	
	        var container = this.findContainerForID(id);
	
	        // if (container && container.markup === markup) {
	        //  return true;
	        // }
	
	        if (container && this.containsChild(container, markup)) {
	          return true;
	        }
	      }
	
	      return false;
	    }
	
	    /**
	     * Finds the container that contains React component to which the
	     * supplied `id` belongs.
	     *
	     * @param {string} id The ID of an element rendered by a React component.
	     * @return {?THREE.Object3D|HTMLCanvasElement} The container that contains the `id`.
	     */
	
	  }, {
	    key: 'findContainerForID',
	    value: function findContainerForID(id) {
	      var reactRootID = _ReactInstanceHandles2.default.getReactRootIDFromNodeID(id);
	      var container = this.containersByReactRootID[reactRootID];
	
	      if (false) {
	        var rootMarkup = this.rootMarkupsByReactRootID[reactRootID];
	        if (rootMarkup) {
	          if (!rootMarkup.parentMarkup || rootMarkup.parentMarkup.threeObject !== container) {
	            if (process.env.NODE_ENV !== 'production') {
	              (0, _warning2.default)(
	              // Call internalGetID here because getID calls isValid which calls
	              // findThreeObjectForID (this function).
	              internalGetID(rootMarkup) === reactRootID, 'React3Renderer: Root element ID differed from reactRootID.');
	            }
	
	            var containerChildMarkup = container.userData && container.userData.markup && container.userData.markup.childrenMarkup[0];
	            if (containerChildMarkup && reactRootID === internalGetID(containerChildMarkup)) {
	              // If the container has a new child with the same ID as the old
	              // root element, then rootUserDatasByReactRootID[reactRootID] is
	              // just stale and needs to be updated. The case that deserves a
	              // warning is when the container is empty.
	              this.rootMarkupsByReactRootID[reactRootID] = containerChildMarkup;
	            } else {
	              if (process.env.NODE_ENV !== 'production') {
	                (0, _warning2.default)(false, 'React3Renderer: Root element has been removed from its original ' + 'container. New container: %s', rootMarkup.parentNode);
	              }
	            }
	          }
	        }
	      }
	
	      return container;
	    }
	  }, {
	    key: 'getMarkup',
	    value: function getMarkup(id) {
	      if (!this.markupCache.hasOwnProperty(id) || !this.isValid(this.markupCache[id], id)) {
	        this.markupCache[id] = this.findMarkupByID(id);
	      }
	      return this.markupCache[id];
	    }
	
	    // DO NOT RENAME
	    // used by react devtools!
	
	    // used by react devtools
	
	  }, {
	    key: 'findMarkupByID',
	
	    /**
	     * Finds an element rendered by React with the supplied ID.
	     *
	     * @param {string} id ID of a markup in the React component.
	     * @return {THREE.Object3D} Root THREE.Object3D of the React component.
	     */
	    value: function findMarkupByID(id) {
	      var container = this.findContainerForID(id);
	      return this.findComponentRoot(container, id);
	    }
	  }, {
	    key: 'findComponentRoot',
	    value: function findComponentRoot(ancestorContainer, targetID) {
	      var firstMarkupList = this.findComponentRootReusableArray;
	      var childIndex = 0;
	
	      var deepestAncestorContainer = this.findDeepestCachedAncestor(targetID) || ancestorContainer;
	
	      firstMarkupList[0] = deepestAncestorContainer.userData.markup.childrenMarkup[0];
	      firstMarkupList.length = 1;
	
	      while (childIndex < firstMarkupList.length) {
	        var childMarkup = firstMarkupList[childIndex++];
	        var targetChildMarkup = undefined;
	
	        while (childMarkup) {
	          var childID = this.getID(childMarkup);
	          if (childID) {
	            // Even if we find the node we're looking for, we finish looping
	            // through its siblings to ensure they're cached so that we don't have
	            // to revisit this node again. Otherwise, we make n^2 calls to getID
	            // when visiting the many children of a single node in order.
	
	            if (targetID === childID) {
	              targetChildMarkup = childMarkup;
	            } else if (_ReactInstanceHandles2.default.isAncestorIDOf(childID, targetID)) {
	              // If we find a child whose ID is an ancestor of the given ID,
	              // then we can be sure that we only want to search the subtree
	              // rooted at this child, so we can throw out the rest of the
	              // search state.
	              firstMarkupList.length = childIndex = 0;
	              firstMarkupList.push(childMarkup.childrenMarkup[0]);
	            }
	          } else {
	            (0, _invariant2.default)(false);
	            // debugger;
	            // If this child had no ID, then there's a chance that it was
	            // injected automatically by the browser, as when a `<table>`
	            // element sprouts an extra `<tbody>` child as a side effect of
	            // `.innerHTML` parsing. Optimistically continue down this
	            // branch, but not before examining the other siblings.
	            firstMarkupList.push(childMarkup.childrenMarkup[0]);
	          }
	
	          // if childMarkup doesn't exist it may have been unmounted
	          var childParentMarkup = childMarkup && childMarkup.parentMarkup;
	          // if parentMarkup doesn't exist it could be a root (or unmounted)
	          var ownerChildrenMarkups = childParentMarkup && childParentMarkup.childrenMarkup;
	
	          if (ownerChildrenMarkups) {
	            var indexInParent = ownerChildrenMarkups.indexOf(childMarkup);
	
	            (0, _invariant2.default)(indexInParent !== -1, 'Could not find child markup`s index in parent');
	
	            childMarkup = ownerChildrenMarkups.length > indexInParent && ownerChildrenMarkups[indexInParent + 1] || null;
	          } else {
	            childMarkup = null;
	          }
	        }
	
	        if (targetChildMarkup) {
	          // Emptying firstMarkupList/findComponentRootReusableArray is
	          // not necessary for correctness, but it helps the GC reclaim
	          // any nodes that were left at the end of the search.
	          firstMarkupList.length = 0;
	
	          return targetChildMarkup;
	        }
	      }
	
	      firstMarkupList.length = 0;
	
	      if (false) {
	        (0, _invariant2.default)(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the THREE.js environment was unexpectedly mutated (e.g., by a plugin). ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, this.getID(ancestorContainer.userData.markup));
	      } else {
	        (0, _invariant2.default)(false);
	      }
	    }
	
	    /**
	     * Mounts this component and inserts it into the THREE.js environment.
	     *
	     * @param {ReactComponent} componentInstance The instance to mount.
	     * @param {string} rootID markup ID of the root node.
	     * @param {THREE.Object3D|HTMLCanvasElement} container to mount into.
	     * @param {ReactReconcileTransaction} transaction
	     * @param {boolean} shouldReuseMarkup If true, do not insert markup
	     * @param {any} context
	     */
	
	  }, {
	    key: '_mountRootImage',
	    value: function _mountRootImage(rootImage, container) {
	      // if (!(container && (container.nodeType === ELEMENT_NODE_TYPE
	      //   || container.nodeType === DOC_NODE_TYPE
	      //   || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE))) {
	      //   if (process.env.NODE_ENV !== 'production') {
	      //     invariant(false, 'mountRootComponent(...): Target container is not valid.');
	      //   } else {
	      //     invariant(false);
	      //   }
	      // }
	
	      // TODO try to do server-side rendering for THREE
	      // ( can write a scene into json or something :D )
	      // if (shouldReuseMarkup) {
	      //   const rootElement = getReactRootMarkupInContainer(container);
	      //   if (ReactMarkupChecksum.canReuseMarkup(rootImage, rootElement)) {
	      //     return;
	      //   }
	      //
	      //   const checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	      //   rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	      //
	      //   const rootMarkup = rootElement.outerHTML;
	      //   rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	      //
	      //   const diffIndex = firstDifferenceIndex(rootImage, rootMarkup);
	      //   const difference = ' (client) ' +
	      //     rootImage.substring(diffIndex - 20, diffIndex + 20)
	      //     + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	      //
	      //   !(container.nodeType !== DOC_NODE_TYPE) ?
	      //     process.env.NODE_ENV !== 'production' ?
	      //       invariant(false,
	      //         'You\'re trying to render a component to the document using '
	      //         + 'server rendering but the checksum was invalid. This usually '
	      //         + 'means you rendered a different component type or props on '
	      //         + 'the client from the one on the server, or your render() '
	      //         + 'methods are impure. React cannot handle this case due to '
	      //         + 'cross-browser quirks by rendering at the document root. You '
	      //         + 'should look for environment dependent code in your components '
	      //         + 'and ensure the props are the same client and server side:\n%s',
	      //        difference) : invariant(false) : undefined;
	      //
	      //   if (process.env.NODE_ENV !== 'production') {
	      //     process.env.NODE_ENV !== 'production' ?
	      //       warning(false, 'React attempted to reuse rootImage in a container but the '
	      //       + 'checksum was invalid. This generally means that you are '
	      //       + 'using server rendering and the rootImage generated on the '
	      //       + 'server was not what the client was expecting. React injected '
	      //       + 'new rootImage to compensate which works but you have lost many '
	      //       + 'of the benefits of server rendering. Instead, figure out '
	      //       + 'why the rootImage being generated is different on the client '
	      //       + 'or server:\n%s', difference) : undefined;
	      //   }
	      // }
	
	      // if (!(container.nodeType !== DOC_NODE_TYPE)) {
	      //   if (process.env.NODE_ENV !== 'production') {
	      //     invariant(false,
	      //       'You\'re trying to render a component to the document but '
	      //       + 'you didn\'t use server rendering. We can\'t do this '
	      //       + 'without using server rendering due to cross-browser quirks. '
	      //       + 'See React.renderToString() for server rendering.');
	      //   } else {
	      //     invariant(false);
	      //   }
	      // }
	
	      // console.log('setting inner html!?', rootImage);
	
	      if (!container.userData) {
	        // it has to be a HTMLCanvasElement I guess?
	        (0, _invariant2.default)(container instanceof HTMLCanvasElement, 'The root container can only be a THREE.js object ' + '(with an userData property) or HTMLCanvasElement.');
	        container.userData = {
	          _createdByReact3: true
	        };
	      }
	
	      var rootMarkup = {
	        threeObject: container,
	        parentMarkup: null,
	        childrenMarkup: [rootImage],
	        toJSON: function toJSON() {
	          return '---MARKUP---';
	        }
	      };
	
	      Object.assign(container.userData, {
	        object3D: container,
	        toJSON: function toJSON() {
	          return '---USERDATA---';
	        },
	        markup: rootMarkup
	      });
	
	      rootImage.parentMarkup = rootMarkup;
	
	      var descriptorForChild = this.threeElementDescriptors[rootImage.elementType];
	      descriptorForChild.setParent(rootImage.threeObject, rootMarkup.threeObject);
	
	      // all objects now added can be marked as added to scene now!
	
	      var instance = rootImage.threeObject;
	
	      (0, _invariant2.default)(instance instanceof _React3Instance2.default, 'Invalid root component type found');
	
	      instance.mountedIntoRoot();
	    }
	
	    /**
	     * Batched mount.
	     *
	     * @param {ReactComponent} componentInstance The instance to mount.
	     * @param {string} rootID markup ID of the root node.
	     * @param {THREE.Object3D|HTMLCanvasElement} container THREE Object
	     *   or HTMLCanvasElement to mount into.
	     * @param {boolean} shouldReuseMarkup If true, do not insert markup
	     * @param {any} context
	     */
	
	  }, {
	    key: 'render',
	
	    /**
	     *
	     * @param nextElement A react element
	     * @param container A canvas or a THREE.js object
	     * @param callback The callback function
	     * @returns {*}
	     */
	    value: function render(nextElement, container, callback) {
	      return this._renderSubtreeIntoContainer(null, nextElement, container, callback);
	    }
	  }, {
	    key: '_renderSubtreeIntoContainer',
	    value: function _renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	      if (!_ReactElement2.default.isValidElement(nextElement)) {
	        if (false) {
	          if (typeof nextElement === 'string') {
	            (0, _invariant2.default)(false, 'React.render(): Invalid component element.%s', ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.');
	          } else if (typeof nextElement === 'function') {
	            (0, _invariant2.default)(false, 'React.render(): Invalid component element.%s', ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.');
	          } else if (nextElement !== null && nextElement.props !== undefined) {
	            (0, _invariant2.default)(false, 'React.render(): Invalid component element.%s', ' This may be caused by unintentionally loading two independent ' + 'copies of React.');
	          } else {
	            (0, _invariant2.default)(false, 'React.render(): Invalid component element.%s', '');
	          }
	        } else {
	          (0, _invariant2.default)(false);
	        }
	      }
	
	      var nextWrappedElement = new _ReactElement2.default(TopLevelWrapper, null, null, null, null, null, nextElement);
	
	      var prevComponent = this._instancesByReactRootID[this.getReactRootID(container)];
	
	      if (prevComponent) {
	        var prevWrappedElement = prevComponent._currentElement;
	        var prevElement = prevWrappedElement.props;
	        if ((0, _shouldUpdateReactComponent2.default)(prevElement, nextElement)) {
	          return this._updateRootComponent(prevComponent, nextWrappedElement, container, callback)._renderedComponent.getPublicInstance();
	        }
	
	        this.unmountComponentAtNode(container);
	      }
	
	      // aka first child
	      var reactRootMarkup = getReactRootMarkupInContainer(container);
	      var containerHasReactMarkup = reactRootMarkup && internalGetID(reactRootMarkup);
	
	      // if (process.env.NODE_ENV !== 'production') {
	      //   if (!containerHasReactMarkup || reactRootMarkup.nextSibling) {
	      //     let rootElementSibling = reactRootMarkup;
	      //     while (rootElementSibling) {
	      //       if (this.isRenderedByReact(rootElementSibling)) {
	      //         if (process.env.NODE_ENV !== 'production') {
	      //           warning(false,
	      //             'render(): Target node has markup rendered by React, but there '
	      //             + 'are unrelated nodes as well. This is most commonly caused by '
	      //             + 'white-space inserted around server-rendered markup.');
	      //         }
	      //         break;
	      //       }
	      //
	      //       rootElementSibling = rootElementSibling.nextSibling;
	      //     }
	      //   }
	      // }
	
	      var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;
	
	      var component = undefined;
	      if (parentComponent === null) {
	        // no context
	        component = this._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, _emptyObject2.default)._renderedComponent.getPublicInstance();
	      } else {
	        // yes context
	        component = this._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context))._renderedComponent.getPublicInstance();
	      }
	
	      if (callback) {
	        callback.call(component);
	      }
	
	      return component;
	    }
	  }, {
	    key: 'dispose',
	    value: function dispose() {
	      var rootIds = Object.keys(this.containersByReactRootID);
	
	      for (var i = 0; i < rootIds.length; ++i) {
	        this.unmountComponentAtNode(this.containersByReactRootID[rootIds[i]]);
	      }
	
	      delete this._instancesByReactRootID;
	      delete this.containersByReactRootID;
	      if (false) {
	        delete this.rootMarkupsByReactRootID;
	      }
	      delete this.findComponentRootReusableArray;
	      delete this.markupCache;
	      delete this.deepestContainerSoFar;
	      delete this._highlightElement;
	      this.nextMountID = 1;
	      this.nextReactRootIndex = 0;
	
	      if (("production") !== 'production' || ({"NODE_ENV":"production"}).ENABLE_REACT_ADDON_HOOKS === 'true') {
	        if (this._devtoolsCallbackCleanup) {
	          this._devtoolsCallbackCleanup();
	
	          delete this._devtoolsCallbackCleanup;
	        }
	
	        if (this._rendererListenerCleanup) {
	          this._rendererListenerCleanup();
	
	          delete this._rendererListenerCleanup;
	        }
	
	        if (this._devToolsRendererDefinition) {
	          if (this._agent) {
	            this._agent.onUnmounted(this._devToolsRendererDefinition);
	            this._agent.removeListener('highlight', this._onHighlightFromInspector);
	            this._agent.removeListener('hideHighlight', this._onHideHighlightFromInspector);
	          }
	
	          if (this._reactDevtoolsRendererId) {
	            delete __REACT_DEVTOOLS_GLOBAL_HOOK__._renderers[this._reactDevtoolsRendererId];
	            delete this._reactDevtoolsRendererId;
	          }
	
	          delete this._devToolsRendererDefinition;
	          delete this._agent;
	        }
	
	        delete this._onHighlightFromInspector;
	        delete this._onHideHighlightFromInspector;
	        delete this._hookAgent;
	      }
	    }
	  }, {
	    key: '_updateRootComponent',
	    value: function _updateRootComponent(prevComponent, nextElement, container, callback) {
	      // this.scrollMonitor(container, function () {
	      _ReactUpdateQueue2.default.enqueueElementInternal(prevComponent, nextElement);
	      if (callback) {
	        _ReactUpdateQueue2.default.enqueueCallbackInternal(prevComponent, callback);
	      }
	      // });
	
	      if (false) {
	        // Record the root element in case it later gets transplanted.
	        this.rootMarkupsByReactRootID[this.getReactRootID(container)] = getReactRootMarkupInContainer(container);
	      }
	
	      return prevComponent;
	    }
	  }, {
	    key: 'unmountComponentAtNode',
	    value: function unmountComponentAtNode(container) {
	      // Various parts of our code (such as ReactCompositeComponent's
	      // _renderValidatedComponent) assume that calls to render aren't nested;
	      // verify that that's the case. (Strictly speaking, unmounting won't cause a
	      // render but we still don't expect to be in a render call here.)
	
	      if (false) {
	        (0, _warning2.default)(_ReactCurrentOwner2.default.current === null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', _ReactCurrentOwner2.default.current && _ReactCurrentOwner2.default.current.getName() || 'ReactCompositeComponent');
	      }
	
	      var reactRootID = this.getReactRootID(container);
	      var component = this._instancesByReactRootID[reactRootID];
	      if (!component) {
	        return false;
	      }
	
	      _ReactUpdates2.default.batchedUpdates(unmountComponentInternal, component, container);
	      delete this._instancesByReactRootID[reactRootID];
	      delete this.containersByReactRootID[reactRootID];
	
	      if (false) {
	        delete this.rootMarkupsByReactRootID[reactRootID];
	      }
	
	      if (container && container.userData && container.userData._createdByReact3) {
	        delete container.userData;
	      }
	
	      return true;
	    }
	
	    /**
	     * @param {THREE.Object3D|HTMLCanvasElement} container THREE Object
	     *   or HTML Canvas Element that may contain a React component.
	     * @return {?string} A "reactRoot" ID, if a React component is rendered.
	     */
	
	  }, {
	    key: 'getReactRootID',
	    value: function getReactRootID(container) {
	      var rootMarkup = getReactRootMarkupInContainer(container);
	      return rootMarkup && this.getID(rootMarkup);
	    }
	  }, {
	    key: 'instantiateReactComponent',
	    value: function instantiateReactComponent(elementToInstantiate) {
	      // console.log('instantiating react component', elementToInstantiate);
	      var instance = undefined;
	
	      var node = elementToInstantiate;
	
	      if (node === null || node === false) {
	        node = new _ReactEmptyComponent2.default(this.instantiateReactComponent);
	      } else if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object') {
	        var element = node;
	        if (!(element && (typeof element.type === 'function' || typeof element.type === 'string'))) {
	          if (false) {
	            if (element.type === null) {
	              (0, _invariant2.default)(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type, getDeclarationErrorAddendum(element._owner));
	            } else {
	              (0, _invariant2.default)(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', _typeof(element.type), getDeclarationErrorAddendum(element._owner));
	            }
	          } else {
	            (0, _invariant2.default)(false);
	          }
	        }
	
	        // Special case string values
	        if (typeof element.type === 'string') {
	          // console.log('string value string value', element);
	
	          instance = new _InternalComponent2.default(element, this);
	
	          // instance = ReactNativeComponent.createInternalComponent(element);
	        } else if (isInternalComponentType(element.type)) {
	            // This is temporarily available for custom components that are not string
	            // representations. I.e. ART. Once those are updated to use the string
	            // representation, we can drop this code path.
	            var Constructor = element.type;
	
	            instance = new Constructor(element);
	
	            console.log('internal component type'); // eslint-disable-line
	          } else {
	              instance = new _React3CompositeComponentWrapper2.default(this);
	            }
	      } else if (typeof node === 'string' || typeof node === 'number') {
	        if (false) {
	          (0, _invariant2.default)(false, 'Encountered invalid React node of type %s : %s', typeof node === 'undefined' ? 'undefined' : _typeof(node), node);
	        } else {
	          (0, _invariant2.default)(false);
	        }
	      } else {
	        if (false) {
	          (0, _invariant2.default)(false, 'Encountered invalid React node of type %s', typeof node === 'undefined' ? 'undefined' : _typeof(node));
	        } else {
	          (0, _invariant2.default)(false);
	        }
	      }
	
	      if (false) {
	        (0, _warning2.default)(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.');
	      }
	
	      // Sets up the instance. This can probably just move into the constructor now.
	      instance.construct(node);
	
	      // These two fields are used by the DOM and ART diffing algorithms
	      // respectively. Instead of using expandos on components, we should be
	      // storing the state needed by the diffing algorithms elsewhere.
	      instance._mountIndex = 0;
	      instance._mountImage = null;
	
	      if (false) {
	        instance._isOwnerNecessary = false;
	        instance._warnedAboutRefsInRender = false;
	      }
	
	      // Internal instances should fully constructed at this point, so they should
	      // not get any new fields added to them at this point.
	      if (false) {
	        if (Object.preventExtensions) {
	          Object.preventExtensions(instance);
	        }
	      }
	
	      return instance;
	    }
	
	    /**
	     *
	     * @param nextElement
	     * @param {THREE.Object3D | HTMLCanvasElement} container
	     * @param shouldReuseMarkup
	     * @param context
	     * @returns {*}
	     * @private
	     */
	
	  }, {
	    key: '_renderNewRootComponent',
	    value: function _renderNewRootComponent(nextElement, container, shouldReuseMarkup, context) {
	      // Various parts of our code (such as ReactCompositeComponent's
	      // _renderValidatedComponent) assume that calls to render aren't nested;
	      // verify that that's the case.
	      if (false) {
	        (0, _warning2.default)(_ReactCurrentOwner2.default.current === null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', _ReactCurrentOwner2.default.current && _ReactCurrentOwner2.default.current.getName() || 'ReactCompositeComponent');
	      }
	
	      var componentInstance = this.instantiateReactComponent(nextElement);
	      var reactRootID = this._registerComponent(componentInstance, container);
	
	      // The initial render is synchronous but any updates that happen during
	      // rendering, in componentWillMount or componentDidMount, will be batched
	      // according to the current batching strategy.
	
	      if (!_ReactUpdates2.default.ReactReconcileTransaction) {
	        // If the ReactReconcileTransaction has not been injected
	        // let's just use the defaults from ReactMount.
	        _ReactInjection2.default.Updates.injectReconcileTransaction(_ReactReconcileTransaction2.default);
	        _ReactInjection2.default.Updates.injectBatchingStrategy(_ReactDefaultBatchingStrategy2.default);
	      }
	
	      _ReactUpdates2.default.batchedUpdates(this.batchedMountRootComponent, componentInstance, reactRootID, container, shouldReuseMarkup, context);
	
	      if (false) {
	        // Record the root element in case it later gets transplanted.
	        this.rootMarkupsByReactRootID[reactRootID] = getReactRootMarkupInContainer(container);
	      }
	
	      return componentInstance;
	    }
	  }, {
	    key: '_registerComponent',
	    value: function _registerComponent(nextComponent, container) {
	      // if (!(container &&
	      //   (container.nodeType === ELEMENT_NODE_TYPE
	      //    || container.nodeType === DOC_NODE_TYPE
	      //    || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE))) {
	      //   if (process.env.NODE_ENV !== 'production') {
	      //     invariant(false, '_registerComponent(...): Target container is not a DOM element.');
	      //   } else {
	      //     invariant(false);
	      //   }
	      // }
	
	      // ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	
	      var reactRootID = this.registerContainer(container);
	      this._instancesByReactRootID[reactRootID] = nextComponent;
	      return reactRootID;
	    }
	
	    /**
	     * Registers a container node into which React components will be rendered.
	     * This also creates the "reactRoot" ID that will be assigned to the element
	     * rendered within.
	     *
	     * @param {THREE.Object3D|HTMLCanvasElement} container to register as a container.
	     * @return {string} The "reactRoot" ID of elements rendered within.
	     */
	
	  }, {
	    key: 'registerContainer',
	    value: function registerContainer(container) {
	      var reactRootID = this.getReactRootID(container);
	      if (reactRootID) {
	        // If one exists, make sure it is a valid "reactRoot" ID.
	        reactRootID = _ReactInstanceHandles2.default.getReactRootIDFromNodeID(reactRootID);
	      }
	      if (!reactRootID) {
	        // No valid "reactRoot" ID found, create one.
	        reactRootID = '' + SEPARATOR + this.createReactRootID();
	      }
	      this.containersByReactRootID[reactRootID] = container;
	      return reactRootID;
	    }
	  }, {
	    key: 'createReactRootID',
	    value: function createReactRootID() {
	      return this.nextReactRootIndex++;
	    }
	  }, {
	    key: 'getID',
	    value: function getID(markup) {
	      var id = internalGetID(markup);
	      if (id) {
	        var cached = this.markupCache[id];
	        if (!!cached) {
	          if (cached !== markup) {
	            if (!!this.isValid(cached, id)) {
	              if (false) {
	                (0, _invariant2.default)(false, 'React3Renderer: Two valid but unequal nodes with the same `%s`: %s', _idPropertyName2.default, id);
	              } else {
	                (0, _invariant2.default)(false);
	              }
	            }
	
	            this.markupCache[id] = markup;
	          }
	        } else {
	          this.markupCache[id] = markup;
	        }
	      }
	
	      return id;
	    }
	  }]);
	
	  return React3Renderer;
	}(), _class2.eventDispatcher = new _EventDispatcher2.default(), _temp2);
	
	module.exports = React3Renderer;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Uniform = function () {
	  function Uniform() {
	    _classCallCheck(this, Uniform);
	
	    this.userData = {};
	    this.name = null;
	    this.value = null;
	    this.type = null;
	    this.uuid = _three2.default.Math.generateUUID();
	  }
	
	  _createClass(Uniform, [{
	    key: 'setValue',
	    value: function setValue(value) {
	      this.value = value;
	
	      this.userData.events.emit('valueChanged', value);
	    }
	  }]);
	
	  return Uniform;
	}();
	
	module.exports = Uniform;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _GeometryDescriptorBase = __webpack_require__(16);
	
	var _GeometryDescriptorBase2 = _interopRequireDefault(_GeometryDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var PolyhedronGeometryDescriptorBase = function (_GeometryDescriptorBa) {
	  _inherits(PolyhedronGeometryDescriptorBase, _GeometryDescriptorBa);
	
	  function PolyhedronGeometryDescriptorBase(react3RendererInstance) {
	    _classCallCheck(this, PolyhedronGeometryDescriptorBase);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PolyhedronGeometryDescriptorBase).call(this, react3RendererInstance));
	
	    ['radius', 'detail'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number.isRequired,
	        update: _this.triggerRemount,
	        default: undefined
	      });
	    });
	    return _this;
	  }
	
	  return PolyhedronGeometryDescriptorBase;
	}(_GeometryDescriptorBase2.default);
	
	module.exports = PolyhedronGeometryDescriptorBase;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _Object3DDescriptor2 = __webpack_require__(22);
	
	var _Object3DDescriptor3 = _interopRequireDefault(_Object3DDescriptor2);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _warning = __webpack_require__(30);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _propTypeInstanceOf = __webpack_require__(17);
	
	var _propTypeInstanceOf2 = _interopRequireDefault(_propTypeInstanceOf);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var LightDescriptorBase = function (_Object3DDescriptor) {
	  _inherits(LightDescriptorBase, _Object3DDescriptor);
	
	  function LightDescriptorBase(react3Instance) {
	    _classCallCheck(this, LightDescriptorBase);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(LightDescriptorBase).call(this, react3Instance));
	
	    _this._hasColor = false;
	
	    if (false) {
	      _this._warnedAboutLightMaterialUpdate = false;
	    }
	
	    _this.hasProp('updatesRefreshAllMaterials', {
	      type: _ReactPropTypes2.default.bool,
	      updateInitial: true,
	      update: function update(threeObject, updatesRefreshAllMaterials) {
	        threeObject.userData._updatesRefreshAllMaterials = updatesRefreshAllMaterials;
	      },
	
	      default: false
	    });
	
	    _this.hasProp('shadowBias', {
	      type: _ReactPropTypes2.default.number,
	      simple: true,
	      default: 0
	    });
	
	    _this.hasProp('shadowDarkness', {
	      type: _ReactPropTypes2.default.number,
	      simple: true,
	      default: 0.5
	    });
	
	    ['shadowMapWidth', 'shadowMapHeight'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number,
	        updateInitial: true,
	        update: function update(threeObject, value, hasProp) {
	          if (hasProp) {
	            threeObject[propName] = value;
	          }
	        },
	
	        default: 512
	      });
	    });
	
	    _this.hasProp('shadowCameraNear', {
	      type: _ReactPropTypes2.default.number,
	      updateInitial: true,
	      update: function update(threeObject, value, hasProp) {
	        if (hasProp) {
	          threeObject.shadow.camera.near = value;
	        }
	        // threeObject.shadow.camera.updateProjectionMatrix();
	      },
	
	      default: 50
	    });
	
	    _this.hasProp('shadowCameraFar', {
	      type: _ReactPropTypes2.default.number,
	      updateInitial: true,
	      update: function update(threeObject, value, hasProp) {
	        if (hasProp) {
	          threeObject.shadow.camera.far = value;
	        }
	        // threeObject.shadow.camera.updateProjectionMatrix();
	      },
	
	      default: 5000
	    });
	
	    _this.hasProp('castShadow', {
	      override: true,
	      type: _ReactPropTypes2.default.bool,
	      update: _this.triggerRemount,
	      default: false
	    });
	    return _this;
	  }
	
	  _createClass(LightDescriptorBase, [{
	    key: 'hasColor',
	    value: function hasColor() {
	      this._hasColor = true;
	
	      this.hasProp('color', {
	        type: _ReactPropTypes2.default.oneOfType([(0, _propTypeInstanceOf2.default)(_three2.default.Color), _ReactPropTypes2.default.number, _ReactPropTypes2.default.string]),
	        update: function update(threeObject, newColor) {
	          threeObject.color.set(newColor);
	        },
	
	        default: 0xffffff
	      });
	    }
	  }, {
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(LightDescriptorBase.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	
	      if (props.hasOwnProperty('castShadow')) {
	        threeObject.castShadow = props.castShadow;
	      }
	    }
	  }, {
	    key: 'unmount',
	    value: function unmount(threeObject) {
	      this.updateAllMaterials(threeObject);
	
	      _get(Object.getPrototypeOf(LightDescriptorBase.prototype), 'unmount', this).call(this, threeObject);
	    }
	  }, {
	    key: 'setParent',
	    value: function setParent(threeObject, parentObject3d) {
	      _get(Object.getPrototypeOf(LightDescriptorBase.prototype), 'setParent', this).call(this, threeObject, parentObject3d);
	
	      this.updateAllMaterials(threeObject);
	    }
	  }, {
	    key: 'updateAllMaterials',
	    value: function updateAllMaterials(threeObject) {
	      var rootInstance = threeObject.userData.markup._rootInstance;
	      if (rootInstance && !rootInstance._willUnmount) {
	        if (false) {
	          if (!this._warnedAboutLightMaterialUpdate && !threeObject.userData._updatesRefreshAllMaterials) {
	            var owner = threeObject.userData.react3internalComponent._currentElement._owner;
	
	            var elementType = threeObject.userData.react3internalComponent._elementType;
	
	            (0, _warning2.default)(this._warnedAboutLightMaterialUpdate, LightDescriptorBase.getDynamicWarningMessage(elementType, owner));
	            this._warnedAboutLightMaterialUpdate = true;
	          }
	        }
	
	        rootInstance.allMaterialsNeedUpdate();
	      }
	    }
	  }], [{
	    key: 'getDynamicWarningMessage',
	    value: function getDynamicWarningMessage(elementType, owner) {
	      return '<' + elementType + '/> has been updated which triggered a refresh of all materials.\n  This is a potentially expensive operation.\n  This can happen when you add or remove a light, or add or remove any component\n  before any lights without keys e.g.\n  <object3d>\n    {/* new or removed component here */}\n    <ambientLight/>\n  </object3d>, or update some properties of lights.\n\n  If you would like to add components, you should either add the components\n  after the lights (recommended), e.g.\n  <object3d>\n    <ambientLight/>\n    {/* new or removed component here */}\n  </object3d>, or add a \'key\' property to the lights e.g.\n  <object3d>\n    {/* new or removed component here */}\n    <ambientLight key="light"/>\n  </object3d>.\n\n  If you have modified a light\'s properties e.g. toggled castShadow,\n  the materials need to be rebuilt as well.\n\n  To acknowledge and remove this message, please add the property \'updatesRefreshAllMaterials\'\n    to <' + elementType + '/> inside the render() of ' + (owner && owner.getName() || 'a component') + '.\n\n  For more information, visit https://github.com/mrdoob/threejs/wiki/Updates .';
	    }
	  }]);
	
	  return LightDescriptorBase;
	}(_Object3DDescriptor3.default);
	
	module.exports = LightDescriptorBase;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _THREEElementDescriptor = __webpack_require__(13);
	
	var _THREEElementDescriptor2 = _interopRequireDefault(_THREEElementDescriptor);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ResourceReference = __webpack_require__(41);
	
	var _ResourceReference2 = _interopRequireDefault(_ResourceReference);
	
	var _React3Renderer = __webpack_require__(55);
	
	var _React3Renderer2 = _interopRequireDefault(_React3Renderer);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ResourceDescriptorBase = function (_THREEElementDescript) {
	  _inherits(ResourceDescriptorBase, _THREEElementDescript);
	
	  function ResourceDescriptorBase(react3RendererInstance) {
	    _classCallCheck(this, ResourceDescriptorBase);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ResourceDescriptorBase).call(this, react3RendererInstance));
	
	    _this._addedIntoRoot = function (threeObject) {
	      var currentParentMarkup = threeObject.userData.markup.parentMarkup;
	
	      var distance = 0;
	
	      while (currentParentMarkup) {
	        var parentResources = currentParentMarkup.threeObject.userData._resources;
	
	        if (parentResources) {
	          var resourceId = threeObject.resourceId;
	          var resourceInParent = parentResources.resourceMap[resourceId];
	
	          if (resourceInParent) {
	            _this._addResource(threeObject, {
	              id: resourceId,
	              distance: distance,
	              resource: resourceInParent
	            });
	          }
	        }
	
	        distance++;
	        currentParentMarkup = currentParentMarkup.threeObject.userData.markup.parentMarkup;
	      }
	
	      _this._updateResource(threeObject);
	    };
	
	    _this.hasProp('resourceId', {
	      type: _ReactPropTypes2.default.string.isRequired,
	      update: _this.triggerRemount,
	      default: ''
	    });
	    return _this;
	  }
	
	  _createClass(ResourceDescriptorBase, [{
	    key: 'construct',
	    value: function construct(props) {
	      (0, _invariant2.default)(props.hasOwnProperty('resourceId'), 'A resource type must have a property named "resourceId"!');
	
	      return new _ResourceReference2.default(props.resourceId);
	    }
	  }, {
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(ResourceDescriptorBase.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	
	      threeObject.userData.resourceMap = [];
	      threeObject.userData._eventCleanupQueue = [];
	      threeObject.userData._chosenResource = undefined;
	      threeObject.userData._debug = props.debug || false;
	
	      threeObject.userData.events.once('addedIntoRoot', this._addedIntoRoot);
	    }
	  }, {
	    key: 'unmount',
	    value: function unmount(threeObject) {
	      threeObject.userData._eventCleanupQueue.forEach(function (cleanup) {
	        cleanup();
	      });
	
	      delete threeObject.userData._eventCleanupQueue;
	      delete threeObject.userData.resourceMap;
	
	      this.updateChosenResource(threeObject, null);
	
	      _get(Object.getPrototypeOf(ResourceDescriptorBase.prototype), 'unmount', this).call(this, threeObject);
	    }
	  }, {
	    key: 'updateChosenResource',
	    value: function updateChosenResource(threeObject, chosenResource) {
	      var oldResource = threeObject.userData._chosenResource;
	      if (oldResource !== chosenResource) {
	        threeObject.userData._chosenResource = chosenResource;
	
	        this.resourceUpdated(threeObject, chosenResource, oldResource);
	      }
	    }
	  }, {
	    key: 'setParent',
	    value: function setParent(threeObject, parentObject3D) {
	      var existingValueInSlot = parentObject3D[threeObject.userData._propertySlot];
	      (0, _invariant2.default)(existingValueInSlot === undefined || existingValueInSlot === null, 'Parent already has a ' + threeObject.userData._propertySlot + ' defined');
	      (0, _invariant2.default)(threeObject.userData._eventCleanupQueue.length === 0, 'Changing parents?');
	
	      _get(Object.getPrototypeOf(ResourceDescriptorBase.prototype), 'setParent', this).call(this, threeObject, parentObject3D);
	
	      var currentParentMarkup = parentObject3D.userData.markup;
	
	      var onResourceAdded = this._onResourceAdded.bind(this, threeObject);
	      var onResourceRemoved = this._onResourceRemoved.bind(this, threeObject);
	
	      var parentEvents = currentParentMarkup.threeObject.userData.events;
	      parentEvents.on('resource.added', onResourceAdded);
	      parentEvents.on('resource.removed', onResourceRemoved);
	
	      threeObject.userData._eventCleanupQueue.push(function () {
	        parentEvents.removeListener('resource.added', onResourceAdded);
	        parentEvents.removeListener('resource.removed', onResourceRemoved);
	      });
	    }
	  }, {
	    key: '_onResourceAdded',
	    value: function _onResourceAdded(threeObject, resourceInfo) {
	      if (threeObject.resourceId !== resourceInfo.id) {
	        return;
	      }
	
	      this._addResource(threeObject, resourceInfo);
	
	      this._updateResource(threeObject);
	    }
	  }, {
	    key: '_addResource',
	    value: function _addResource(threeObject, resourceInfo) {
	      var resourceMap = threeObject.userData.resourceMap;
	
	      var i = undefined;
	
	      for (i = 0; i < resourceMap.length; ++i) {
	        if (resourceMap[i].distance === resourceInfo.distance) {
	          if (resourceMap[i].resource !== resourceInfo.resource) {
	            resourceMap[i].resource = resourceInfo.resource;
	          }
	
	          return;
	        }
	
	        if (resourceMap[i].distance > resourceInfo.distance) {
	          break;
	        }
	      }
	
	      resourceMap.splice(i, 0, {
	        distance: resourceInfo.distance,
	        resource: resourceInfo.resource
	      });
	    }
	  }, {
	    key: '_onResourceRemoved',
	    value: function _onResourceRemoved(threeObject, resourceInfo) {
	      if (threeObject.resourceId !== resourceInfo.id) {
	        return;
	      }
	
	      var resourceMap = threeObject.userData.resourceMap;
	
	      for (var i = 0; i < resourceMap.length; ++i) {
	        if (resourceMap[i].distance === resourceInfo.distance) {
	          if (resourceMap[i].resource === resourceInfo.resource) {
	            resourceMap.splice(i, 1);
	
	            this._updateResource(threeObject);
	          }
	          return;
	        }
	      }
	
	      (0, _invariant2.default)(false, 'This resource was not in this map?');
	    }
	  }, {
	    key: 'applyToSlot',
	    value: function applyToSlot(threeObject, parentObject, newResource) {
	      var propertySlot = threeObject.userData._propertySlot;
	      parentObject[propertySlot] = newResource;
	    }
	  }, {
	    key: 'resourceUpdated',
	    value: function resourceUpdated(threeObject, newResource, oldResource) {
	      var parentObject = threeObject.userData.markup.parentMarkup && threeObject.userData.markup.parentMarkup.threeObject || undefined;
	
	      if (parentObject) {
	        this.applyToSlot(threeObject, parentObject, newResource);
	
	        if (newResource === null) {
	          // invariant(false, 'Could not find resource named ' + threeObject.resourceId);
	        } else {
	            newResource.userData._references.push(parentObject);
	          }
	
	        if (oldResource) {
	          var removalIndex = oldResource.userData._references.indexOf(parentObject);
	
	          (0, _invariant2.default)(removalIndex !== -1, 'Bad reference count for resource');
	
	          oldResource.userData._references.splice(removalIndex, 1);
	        }
	      }
	    }
	  }, {
	    key: '_updateResource',
	    value: function _updateResource(threeObject) {
	      var resourceMap = threeObject.userData.resourceMap;
	
	      var chosenResource = null;
	
	      if (resourceMap.length > 0) {
	        chosenResource = resourceMap[0].resource;
	      }
	
	      this.updateChosenResource(threeObject, chosenResource);
	    }
	  }, {
	    key: 'highlight',
	    value: function highlight(threeObject) {
	      var ownerObject = threeObject.userData.markup.parentMarkup.threeObject;
	      ownerObject.userData._descriptor.highlight(ownerObject);
	    }
	  }, {
	    key: 'hideHighlight',
	    value: function hideHighlight(threeObject) {
	      var ownerObject = threeObject.userData.markup.parentMarkup.threeObject;
	      ownerObject.userData._descriptor.hideHighlight(ownerObject);
	    }
	  }]);
	
	  return ResourceDescriptorBase;
	}(_THREEElementDescriptor2.default);
	
	module.exports = ResourceDescriptorBase;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _ResourceContainer = __webpack_require__(99);
	
	var _ResourceContainer2 = _interopRequireDefault(_ResourceContainer);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _warning = __webpack_require__(30);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _THREEElementDescriptor = __webpack_require__(13);
	
	var _THREEElementDescriptor2 = _interopRequireDefault(_THREEElementDescriptor);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * Resource decorator.
	 * Allows descriptors to be slotted into the <resources/> component.
	 *
	 * @param descriptor The descriptor to be patched
	 * @returns {ResourceDescriptor} the modified descriptor class
	 */
	function resource(descriptor) {
	  var _class, _temp;
	
	  var ResourceDescriptor = (_temp = _class = function (_descriptor) {
	    _inherits(ResourceDescriptor, _descriptor);
	
	    function ResourceDescriptor(react3RendererInstance) {
	      _classCallCheck(this, ResourceDescriptor);
	
	      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ResourceDescriptor).call(this, react3RendererInstance));
	
	      _this.isResource = true;
	
	      _this.hasProp('resourceId', {
	        type: _ReactPropTypes2.default.string,
	        updateInitial: true,
	        initialOnly: true,
	        update: function update(threeObject, resourceId, hasProp) {
	          if (hasProp) {
	            threeObject.userData._resourceId = resourceId;
	
	            if (!threeObject.userData._hasReferences) {
	              threeObject.userData._hasReferences = true;
	              threeObject.userData._references = [];
	            }
	          }
	        },
	        default: ''
	      });
	      return _this;
	    }
	
	    // used for docs
	
	    _createClass(ResourceDescriptor, [{
	      key: 'applyInitialProps',
	      value: function applyInitialProps(threeObject, props) {
	        _get(Object.getPrototypeOf(ResourceDescriptor.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	      }
	    }, {
	      key: 'setParent',
	      value: function setParent(threeObject, parentObject3D) {
	        if (parentObject3D instanceof _ResourceContainer2.default) {
	          if (false) {
	            (0, _invariant2.default)(!!threeObject.userData._resourceId, 'All resources inside <resources> should have the "resourceId" property. ' + 'Current resource: <${threeObject.userData.react3internalComponent._elementType}>');
	          } else {
	            (0, _invariant2.default)(!!threeObject.userData._resourceId);
	          }
	
	          // still let it be mounted to root
	          _THREEElementDescriptor2.default.prototype.setParent.call(this, threeObject, parentObject3D);
	        } else {
	          if (false) {
	            (0, _warning2.default)(!threeObject.userData._resourceId, 'Found <' + threeObject.userData.react3internalComponent._elementType + '> ' + 'with a resourceId property, ' + 'but it was not placed within a <resources/> element.');
	          }
	          _get(Object.getPrototypeOf(ResourceDescriptor.prototype), 'setParent', this).call(this, threeObject, parentObject3D);
	        }
	      }
	    }, {
	      key: 'highlight',
	      value: function highlight(threeObject) {
	        if (!!threeObject.userData._resourceId) {
	          // it's a resource. Let's highlight all references.
	          threeObject.userData.events.emit('highlight', {
	            uuid: threeObject.uuid,
	            boundingBoxFunc: function boundingBoxFunc() {
	              return threeObject.userData._references.reduce(function (boxes, objectWithReference) {
	                var boxesForReference = objectWithReference.userData._descriptor.getBoundingBoxes(objectWithReference);
	                if (false) {
	                  (0, _invariant2.default)(boxesForReference.length > 0, 'No boxes found for resource.');
	                } else {
	                  (0, _invariant2.default)(boxesForReference.length > 0);
	                }
	                return boxes.concat(boxesForReference);
	              }, []);
	            }
	          });
	        } else {
	          return _get(Object.getPrototypeOf(ResourceDescriptor.prototype), 'highlight', this).call(this, threeObject);
	        }
	      }
	    }, {
	      key: 'hideHighlight',
	      value: function hideHighlight(threeObject) {
	        if (!!threeObject.userData._resourceId) {
	          threeObject.userData.events.emit('hideHighlight');
	        } else {
	          return _get(Object.getPrototypeOf(ResourceDescriptor.prototype), 'hideHighlight', this).call(this, threeObject);
	        }
	      }
	    }]);
	
	    return ResourceDescriptor;
	  }(descriptor), _class.displayName = '' + (descriptor.displayName || descriptor.name), _temp);
	
	  return ResourceDescriptor;
	}
	
	module.exports = resource;

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserEventEmitter
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(26);
	var EventPluginHub = __webpack_require__(42);
	var EventPluginRegistry = __webpack_require__(251);
	var ReactEventEmitterMixin = __webpack_require__(450);
	var ReactPerf = __webpack_require__(20);
	var ViewportMetrics = __webpack_require__(271);
	
	var assign = __webpack_require__(7);
	var isEventSupported = __webpack_require__(119);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function (ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function (enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function () {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function (registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    var topLevelTypes = EventConstants.topLevelTypes;
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === topLevelTypes.topWheel) {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === topLevelTypes.topScroll) {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening[topLevelTypes.topBlur] = true;
	          isListening[topLevelTypes.topFocus] = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function () {
	    if (!isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  },
	
	  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
	
	  registrationNameModules: EventPluginHub.registrationNameModules,
	
	  putListener: EventPluginHub.putListener,
	
	  getListener: EventPluginHub.getListener,
	
	  deleteListener: EventPluginHub.deleteListener,
	
	  deleteAllListeners: EventPluginHub.deleteAllListeners
	
	});
	
	ReactPerf.measureMethods(ReactBrowserEventEmitter, 'ReactBrowserEventEmitter', {
	  putListener: 'putListener',
	  deleteListener: 'deleteListener'
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponent
	 */
	
	'use strict';
	
	var ReactNoopUpdateQueue = __webpack_require__(268);
	
	var canDefineProperty = __webpack_require__(65);
	var emptyObject = __webpack_require__(47);
	var invariant = __webpack_require__(4);
	var warning = __webpack_require__(8);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ?  false ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
	  }
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (false) {
	  var deprecatedAPIs = {
	    getDOMNode: ['getDOMNode', 'Use ReactDOM.findDOMNode(component) instead.'],
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceProps: ['replaceProps', 'Instead, call render again at the top level.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
	    setProps: ['setProps', 'Instead, call render again at the top level.']
	  };
	  var defineDeprecationWarning = function (methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function () {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticMouseEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(46);
	var ViewportMetrics = __webpack_require__(271);
	
	var getEventModifierState = __webpack_require__(115);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function (event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function (event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function (event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function (event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Transaction
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(4);
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var Mixin = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function () {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function () {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function (method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ?  false ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function (startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function (startIndex) {
	    !this.isInTransaction() ?  false ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	var Transaction = {
	
	  Mixin: Mixin,
	
	  /**
	   * Token to look for to determine if an error occurred.
	   */
	  OBSERVED_ERROR: {}
	
	};
	
	module.exports = Transaction;

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule canDefineProperty
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (false) {
	  try {
	    Object.defineProperty({}, 'x', { get: function () {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;

/***/ },
/* 66 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule escapeTextContentForBrowser
	 */
	
	'use strict';
	
	var ESCAPE_LOOKUP = {
	  '&': '&amp;',
	  '>': '&gt;',
	  '<': '&lt;',
	  '"': '&quot;',
	  '\'': '&#x27;'
	};
	
	var ESCAPE_REGEX = /[&><"']/g;
	
	function escaper(match) {
	  return ESCAPE_LOOKUP[match];
	}
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  return ('' + text).replace(ESCAPE_REGEX, escaper);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setInnerHTML
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(12);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = function (node, html) {
	  node.innerHTML = html;
	};
	
	// Win8 apps: Allow all html to be inserted
	if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	  setInnerHTML = function (node, html) {
	    MSApp.execUnsafeLocalFunction(function () {
	      node.innerHTML = html;
	    });
	  };
	}
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function (node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	}
	
	module.exports = setInnerHTML;

/***/ },
/* 68 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shouldUpdateReactComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement;
	  var nextType = typeof nextElement;
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	  return false;
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule traverseAllChildren
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(19);
	var ReactElement = __webpack_require__(11);
	var ReactInstanceHandles = __webpack_require__(31);
	
	var getIteratorFn = __webpack_require__(117);
	var invariant = __webpack_require__(4);
	var warning = __webpack_require__(8);
	
	var SEPARATOR = ReactInstanceHandles.SEPARATOR;
	var SUBSEPARATOR = ':';
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var userProvidedKeyEscaperLookup = {
	  '=': '=0',
	  '.': '=1',
	  ':': '=2'
	};
	
	var userProvidedKeyEscapeRegex = /[=.:]/g;
	
	var didWarnAboutMaps = false;
	
	function userProvidedKeyEscaper(match) {
	  return userProvidedKeyEscaperLookup[match];
	}
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  if (component && component.key != null) {
	    // Explicit key
	    return wrapUserProvidedKey(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * Escape a component key so that it is safe to use in a reactid.
	 *
	 * @param {*} text Component key to be escaped.
	 * @return {string} An escaped string.
	 */
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
	}
	
	/**
	 * Wrap a `key` value explicitly provided by the user to distinguish it from
	 * implicitly-generated keys generated by a component's index in its parent.
	 *
	 * @param {string} key Value of a user-provided `key` attribute
	 * @return {string}
	 */
	function wrapUserProvidedKey(key) {
	  return '$' + escapeUserProvidedKey(key);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (false) {
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (false) {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ?  false ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : undefined;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyMirror
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(4);
	
	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function (obj) {
	  var ret = {};
	  var key;
	  !(obj instanceof Object && !Array.isArray(obj)) ?  false ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};
	
	module.exports = keyMirror;

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.saveRecord = saveRecord;
	exports.loadRecords = loadRecords;
	exports.clearRecords = clearRecords;
	
	var _constants = __webpack_require__(6);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	var _game = __webpack_require__(37);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function saveRecord(data) {
		return function (dispatch, getState) {
			dispatch({
				type: _constants2.default.RECORD,
				time: data.time,
				name: data.name,
				player: data.player,
				score: data.score,
				comments: data.comments
			});
			var serializedRecords = JSON.stringify(getState().records.toArray());
			localStorage.setItem('records', serializedRecords);
			dispatch((0, _game.launchRank)());
		};
	}
	
	function loadRecords() {
		return function (dispatch, getState) {
			var parsedRecords = JSON.parse(localStorage.getItem('records'));
			dispatch({
				type: _constants2.default.RECORDS_LOADED,
				records: parsedRecords
			});
		};
	}
	
	function clearRecords() {
		return function (dispatch, getState) {
			localStorage.removeItem('records');
			dispatch({
				type: _constants2.default.RECORDS_RESET
			});
		};
	}

/***/ },
/* 72 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = {
		ADMIN_VISIBLE: 'ADMIN_VISIBLE',
		ADMIN_INVISIBLE: 'ADMIN_INVISIBLE',
		ADMIN_MUTED: 'ADMIN_MUTED'
	};

/***/ },
/* 73 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = {
		APP_WIDTH: 1920,
		APP_HEIGHT: 1080
	};

/***/ },
/* 74 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = {
		CHOREGRAPHY: 'CHOREGRAPHY',
		CHOREGRAPHY_RESET: 'CHOREGRAPHY_RESET'
	};

/***/ },
/* 75 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = {
		GAME_IDLE: 'GAME_IDLE',
		GAME_INTRO: 'GAME_INTRO',
		GAME_TUTO: 'GAME_TUTO',
		GAME_WAIT: 'GAME_WAIT',
		GAME_WARNING: 'GAME_WARNING',
		GAME_LOAD: 'GAME_LOAD',
		GAME_PLAY: 'GAME_PLAY',
		GAME_RECAP: 'GAME_RECAP',
		GAME_SAVE: 'GAME_SAVE',
		GAME_RANK: 'GAME_RANK',
		GAME_END: 'GAME_END',
		GAME_INTRO_DURATION: 3000,
		GAME_WAIT_DURATION: 10000,
		GAME_WARNING_DURATION: 5000,
		GAME_LOAD_DURATION: 3000,
		GAME_RECAP_DURATION: 15000,
		GAME_SAVE_DURATION: 30000,
		GAME_RANK_DURATION: 15000,
		GAME_END_DURATION: 15000
	};

/***/ },
/* 76 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = {
		MOVES_TIMEOUTS: 'MOVES_TIMEOUTS',
		MOVE_SHOW: 'MOVE_SHOW',
		MOVE_COMMENTABLE: 'MOVE_COMMENTABLE',
		MOVE_HIDE: 'MOVE_HIDE',
		MOVE_UNCOMMENTABLE: 'MOVE_UNCOMMENTABLE',
		MOVES_END_DELAY: 1000,
		MOVE_DURATION: 4000,
		MOVE_TOLERANCE_OK: 200,
		MOVE_TOLERANCE_GOOD: 100,
		MOVE_TOLERANCE_EXCELLENT: 50
	};

/***/ },
/* 77 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = {
		PAD: 'PAD'
	};

/***/ },
/* 78 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = {
		RECORD: 'RECORD',
		RECORDS_LOADED: 'RECORDS_LOADED',
		RECORDS_RESET: 'RECORDS_RESET'
	};

/***/ },
/* 79 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = {
		STEP: 'STEP',
		STEPS_RESET: 'STEPS_RESET'
	};

/***/ },
/* 80 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = {
		TUTO_FORWARD_TIME: 6000,
		TUTO_END_TIME: 11000,
		TUTO_STEP_ONE_TIME: 7850,
		TUTO_STEP_ONE_DIRECTION: 'top',
		TUTO_STEP_TWO_TIME: 10100,
		TUTO_STEP_TWO_DIRECTION: 'left'
	};

/***/ },
/* 81 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.listenToDirectionKeys = listenToDirectionKeys;
	var mapKeyCodeToDirection = function mapKeyCodeToDirection(keyCode) {
		var value = undefined;
		switch (keyCode) {
			case '37':
				value = 'left';
				break;
			case '38':
				value = 'top';
				break;
			case '39':
				value = 'right';
				break;
			case '40':
				value = 'bottom';
				break;
			default:
				value = '';
		}
		return value;
	};
	
	var directionsRegExp = /left|top|right|bottom/;
	
	function listenToDirectionKeys(cb) {
		var isKeyDown = {
			left: false,
			top: false,
			right: false,
			bottom: false
		};
	
		var onKeyDown = function onKeyDown(e) {
			var direction = mapKeyCodeToDirection(e.keyCode.toString());
			if (direction.match(directionsRegExp)) {
				e.stopPropagation();
				e.preventDefault();
				if (!isKeyDown[direction]) {
					isKeyDown[direction] = true;
					cb('keydown', direction);
				}
			}
		};
	
		var onKeyUp = function onKeyUp(e) {
			var direction = mapKeyCodeToDirection(e.keyCode.toString());
			if (direction.match(directionsRegExp)) {
				e.stopPropagation();
				e.preventDefault();
				isKeyDown[direction] = false;
				cb('keyup', direction);
			}
		};
	
		if (document) {
			var body = document.querySelector('body');
			body.removeEventListener('keyup', onKeyUp);
			body.removeEventListener('keydown', onKeyDown);
			body.addEventListener('keyup', onKeyUp);
			body.addEventListener('keydown', onKeyDown);
		}
	}

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.installImmutablejsDevtools = undefined;
	
	var _immutablejsDevtools = __webpack_require__(95);
	
	var installImmutablejsDevtools = exports.installImmutablejsDevtools = _immutablejsDevtools.install;

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	var moduleHotAccept = exports.moduleHotAccept = function moduleHotAccept(middlewares) {
		if (false) {
			module.hot.accept();
		}
	};
	
	// https://github.com/rackt/react-redux/releases/tag/v2.0.0
	var replaceReducerOnHotReload = exports.replaceReducerOnHotReload = function replaceReducerOnHotReload(store) {
		if (false) {
			if (module.hot) {
				module.hot.accept('../reducers', function () {
					var nextRootReducer = require('../reducers/index');
					store.replaceReducer(nextRootReducer);
				});
			}
		}
	};

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.scaleBody = undefined;
	
	var _constants = __webpack_require__(6);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var scaleBody = exports.scaleBody = function scaleBody() {
		var scaleThisBody = function scaleThisBody() {
			var ratio = Math.min(window.innerWidth / _constants2.default.APP_WIDTH, window.innerHeight / _constants2.default.APP_HEIGHT);
			document.body.style.transform = 'scale(' + ratio + ')';
		};
		if (document) {
			window.addEventListener('resize', scaleThisBody);
		}
		scaleThisBody();
	};

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.addStatsCounter = undefined;
	
	var _stats = __webpack_require__(131);
	
	var _stats2 = _interopRequireDefault(_stats);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var addStatsCounter = exports.addStatsCounter = function addStatsCounter() {
		var stats = new _stats2.default();
		Object.assign(stats.domElement.style, {
			position: 'absolute',
			left: '0px',
			top: '0px'
		});
		document.body.appendChild(stats.domElement);
		var update = function update() {
			stats.update();
			requestAnimationFrame(update);
		};
		requestAnimationFrame(update);
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.addLoggerToMiddlewares = undefined;
	
	var _reduxLogger = __webpack_require__(123);
	
	var _reduxLogger2 = _interopRequireDefault(_reduxLogger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var addLoggerToMiddlewares = exports.addLoggerToMiddlewares = function addLoggerToMiddlewares(middlewares) {
		if (false) {
			var logger = (0, _reduxLogger2.default)({ collapsed: true });
			middlewares.push(logger);
		}
	};

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.admin = admin;
	
	var _immutable = __webpack_require__(10);
	
	var _constants = __webpack_require__(6);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultState = (0, _immutable.Map)([['visible', false], ['muted', true]]);
	
	function admin() {
		var state = arguments.length <= 0 || arguments[0] === undefined ? defaultState : arguments[0];
		var action = arguments[1];
	
		switch (action.type) {
			case _constants2.default.ADMIN_VISIBLE:
				return state.set('visible', true);
			case _constants2.default.ADMIN_INVISIBLE:
				return state.set('visible', false);
			case _constants2.default.ADMIN_MUTED:
				return state.set('muted', action.muted);
			default:
				return state;
		}
	}

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.choregraphy = choregraphy;
	
	var _immutable = __webpack_require__(10);
	
	var _constants = __webpack_require__(6);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultState = (0, _immutable.Map)([['name', null], ['time', null]]);
	
	function choregraphy() {
		var state = arguments.length <= 0 || arguments[0] === undefined ? defaultState : arguments[0];
		var action = arguments[1];
	
		switch (action.type) {
			case _constants2.default.CHOREGRAPHY:
				return state.set('name', action.name);
			case _constants2.default.CHOREGRAPHY_RESET:
				return defaultState;
			case _constants2.default.GAME_TUTO:
				return state.set('time', action.time);
			case _constants2.default.GAME_PLAY:
				return state.set('time', action.time);
			default:
				return state;
		}
	}

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.dance = dance;
	
	var _immutable = __webpack_require__(10);
	
	var _constants = __webpack_require__(6);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultState = (0, _immutable.Map)([['moves', (0, _immutable.List)([])], ['steps', (0, _immutable.List)([])]]);
	
	var initMoves = function initMoves(state, action) {
		return state.set('moves', (0, _immutable.List)(action.moves.map(function (move) {
			return Object.assign({}, move, {
				visible: false,
				commentable: false
			});
		})));
	};
	
	var setVisibility = function setVisibility(state, index, visible) {
		return state.set('moves', state.get('moves').update(index, function (move) {
			return Object.assign({}, move, { visible: visible });
		}));
	};
	
	var setCommentable = function setCommentable(state, index) {
		return state.set('moves', state.get('moves').update(index, function (move) {
			return Object.assign({}, move, {
				commentable: true
			});
		}));
	};
	
	var setUncommentable = function setUncommentable(state, index) {
		if (!state.get('moves').get(index).commentable) return state;
		return state.set('moves', state.get('moves').update(index, function (move) {
			return Object.assign({}, move, {
				commentable: false,
				comment: 'miss',
				commentTime: move.time + _constants2.default.MOVE_TOLERANCE_OK
			});
		}));
	};
	
	var setMovesTimeouts = function setMovesTimeouts(state, action) {
		return state.set('moves', state.get('moves').map(function (move, index) {
			return Object.assign({}, move, action.timeouts[index]);
		}));
	};
	
	var getFirstCommentableMoveIndex = function getFirstCommentableMoveIndex(moves, action) {
		var commentableMoveEntry = moves.findEntry(function (move) {
			return move.commentable && move.direction === action.direction && Math.abs(move.time - action.time) <= _constants2.default.MOVE_TOLERANCE_OK;
		});
		if (!commentableMoveEntry) return null;
		return commentableMoveEntry[0];
	};
	
	var getMoveComment = function getMoveComment(moveTime, stepTime) {
		var timeDifference = Math.abs(moveTime - stepTime);
		if (timeDifference <= _constants2.default.MOVE_TOLERANCE_EXCELLENT) {
			return 'excellent';
		} else if (timeDifference <= _constants2.default.MOVE_TOLERANCE_GOOD) {
			return 'good';
		} else if (timeDifference <= _constants2.default.MOVE_TOLERANCE_OK) {
			return 'ok';
		}
	};
	
	var handleStep = function handleStep(state, action) {
		var firstCommentableMoveIndex = getFirstCommentableMoveIndex(state.get('moves'), action);
		if (typeof firstCommentableMoveIndex !== 'number') {
			return state.set('steps', state.get('steps').push({
				direction: action.direction,
				comment: 'fail',
				commentTime: action.time
			}));
		}
		return state.set('moves', state.get('moves').update(firstCommentableMoveIndex, function (move) {
			return Object.assign({}, move, {
				commentable: false,
				comment: getMoveComment(move.time, action.time),
				commentTime: action.time
			});
		}));
	};
	
	function dance() {
		var state = arguments.length <= 0 || arguments[0] === undefined ? defaultState : arguments[0];
		var action = arguments[1];
	
		switch (action.type) {
			case _constants2.default.CHOREGRAPHY:
				return initMoves(state, action);
			case _constants2.default.MOVE_SHOW:
				return setVisibility(state, action.index, true);
			case _constants2.default.MOVE_COMMENTABLE:
				return setCommentable(state, action.index);
			case _constants2.default.MOVE_HIDE:
				return setVisibility(state, action.index, false);
			case _constants2.default.MOVE_UNCOMMENTABLE:
				return setUncommentable(state, action.index);
			case _constants2.default.MOVES_TIMEOUTS:
				return setMovesTimeouts(state, action);
			case _constants2.default.CHOREGRAPHY_RESET:
				return state.set('moves', (0, _immutable.List)([]));
			case _constants2.default.STEP:
				return handleStep(state, action);
			case _constants2.default.STEPS_RESET:
				return state.set('steps', (0, _immutable.List)([]));
			default:
				return state;
		}
	}

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.game = game;
	
	var _immutable = __webpack_require__(10);
	
	var _constants = __webpack_require__(6);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultState = (0, _immutable.Map)([['status', 'idle'], ['timeout', null]]);
	
	function game() {
		var state = arguments.length <= 0 || arguments[0] === undefined ? defaultState : arguments[0];
		var action = arguments[1];
	
		switch (action.type) {
			case _constants2.default.GAME_IDLE:
				return state.set('status', 'idle');
			case _constants2.default.GAME_INTRO:
				return state.set('status', 'intro').set('timeout', action.timeout);
			case _constants2.default.GAME_TUTO:
				return state.set('status', 'tuto').set('timeout', action.timeout);
			case _constants2.default.GAME_WAIT:
				return state.set('status', 'wait').set('timeout', action.timeout);
			case _constants2.default.GAME_WARNING:
				return state.set('status', 'warning').set('timeout', action.timeout);
			case _constants2.default.GAME_LOAD:
				return state.set('status', 'load').set('timeout', action.timeout);
			case _constants2.default.GAME_PLAY:
				return state.set('status', 'play').set('timeout', action.timeout);
			case _constants2.default.GAME_RECAP:
				return state.set('status', 'recap').set('timeout', action.timeout);
			case _constants2.default.GAME_SAVE:
				return state.set('status', 'save').set('timeout', action.timeout);
			case _constants2.default.GAME_RANK:
				return state.set('status', 'rank').set('timeout', action.timeout);
			case _constants2.default.GAME_END:
				return state.set('status', 'end').set('timeout', action.timeout);
			default:
				return state;
		}
	}

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _redux = __webpack_require__(36);
	
	var _admin = __webpack_require__(87);
	
	var _game = __webpack_require__(90);
	
	var _pads = __webpack_require__(92);
	
	var _choregraphy = __webpack_require__(88);
	
	var _dance = __webpack_require__(89);
	
	var _records = __webpack_require__(93);
	
	var rootReducer = (0, _redux.combineReducers)({
		admin: _admin.admin,
		game: _game.game,
		pads: _pads.pads,
		choregraphy: _choregraphy.choregraphy,
		dance: _dance.dance,
		records: _records.records
	});
	
	exports.default = rootReducer;

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.pads = pads;
	
	var _immutable = __webpack_require__(10);
	
	var _constants = __webpack_require__(6);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultState = (0, _immutable.Map)([['left', null], ['top', null], ['right', null], ['bottom', null]]);
	
	function pads() {
		var state = arguments.length <= 0 || arguments[0] === undefined ? defaultState : arguments[0];
		var action = arguments[1];
	
		switch (action.type) {
			case _constants2.default.PAD:
				return state.set(action.direction, action.upOrDown);
			default:
				return state;
		}
	}

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.records = records;
	
	var _immutable = __webpack_require__(10);
	
	var _constants = __webpack_require__(6);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var getDefaultState = function getDefaultState() {
		return (0, _immutable.List)([]);
	};
	
	function records() {
		var state = arguments.length <= 0 || arguments[0] === undefined ? getDefaultState() : arguments[0];
		var action = arguments[1];
	
		switch (action.type) {
			case _constants2.default.RECORD:
				return state.push({
					time: action.time,
					name: action.name,
					player: action.player,
					score: action.score,
					comments: action.comments
				});
			case _constants2.default.RECORDS_LOADED:
				return (0, _immutable.List)(action.records);
			case _constants2.default.RECORDS_RESET:
				return getDefaultState();
			default:
				return state;
		}
	}

/***/ },
/* 94 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	var slave = new Worker('slave.js');
	
	var listenToSlave = exports.listenToSlave = function listenToSlave() {
		return function (dispatch, getState) {
			var onSlaveMessage = function onSlaveMessage(event) {
				var data = JSON.parse(event.data);
				requestAnimationFrame(function () {
					if (data.function === 'dispatch') {
						dispatch(data.action);
					}
				});
			};
			slave.addEventListener('message', onSlaveMessage);
		};
	};
	
	var sendToSlave = exports.sendToSlave = function sendToSlave(message) {
		slave.postMessage(JSON.stringify(message));
	};
	
	var dispatchToSlave = exports.dispatchToSlave = function dispatchToSlave(actionArg) {
		var message = { function: 'dispatch', action: actionArg };
		sendToSlave(message);
	};

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	const formatters = __webpack_require__(96);
	let isInstalled = false;
	
	module.exports = {install};
	
	function install () {
	  if (typeof window === undefined || isInstalled === true) {return;}
	
	  window.devtoolsFormatters = window.devtoolsFormatters || [];
	  window.devtoolsFormatters.push({
	
	    header(obj) {
	      if (!(obj && obj.toJS)) return;
	
	      if (obj.__IS_NESTED__) return formatters.formatHeaderAsTitle(obj.value);
	      if (obj.size >= 100) return formatters.formatHeaderAsSummary(obj.slice(0, 99));
	
	      return formatters.formatHeaderInFull(obj);
	    },
	
	    hasBody(obj) {
	      return obj && obj.toJS && (obj.size >= 100 || obj.__IS_NESTED__);
	    },
	
	    body(obj) {
	      return formatters.formatBody(obj.__IS_NESTED__ ? obj.value : obj);
	    }
	
	  });
	
	  isInstalled = true;
	}


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	const Immutable = __webpack_require__(10);
	
	module.exports = {
	  formatHeaderInFull,
	  formatHeaderAsSummary,
	  formatHeaderAsTitle,
	  formatBody
	};
	
	function formatHeaderInFull (obj) {
	  const collection = collections.find((collection) => collection.validate(obj))
	  return collection.renderInlineFull(collection.name(obj), obj);
	}
	
	function formatHeaderAsSummary (obj) {
	  const collection = collections.find((collection) => collection.validate(obj))
	  return collection.renderInlinePartial(collection.name(obj), obj);
	}
	
	function formatHeaderAsTitle (obj) {
	  const collection = collections.find((collection) => collection.validate(obj))
	  return collection.renderTitle(collection.name(obj), obj);
	}
	
	function formatBody (obj) {
	  const collection = collections.find((collection) => collection.validate(obj));
	  return collection.renderBody(obj);
	}
	
	const collections = [
	  {
	    name: () => 'List',
	    validate: Immutable.List.isList,
	    renderBody: renderFullBody,
	    renderInlineFull: renderInlineFullList,
	    renderInlinePartial: renderTitleList,
	    renderTitle: renderTitleList
	  },
	
	  {
	    name: (record) => record._name || record.constructor.name || 'Record',
	    validate: (record) => record instanceof Immutable.Record,
	    renderBody: renderFullBody,
	    renderInlineFull: renderInlineFullMap,
	    renderInlinePartial: renderTitleMap,
	    renderTitle: renderTitleMap
	  },
	
	  {
	    name: () => 'OrderedMap',
	    validate: Immutable.OrderedMap.isOrderedMap,
	    renderBody: renderFullBody,
	    renderInlineFull: renderInlineFullMap,
	    renderInlinePartial: renderInlinePartialMap,
	    renderTitle: renderTitleMap
	  },
	
	  {
	    name: () => 'Map',
	    validate: (obj) => Immutable.Map.isMap(obj),
	    renderBody: renderFullBody,
	    renderInlineFull: renderInlineFullMap,
	    renderInlinePartial: renderInlinePartialMap,
	    renderTitle: renderTitleMap
	  },
	
	  {
	    name: () => 'OrderedSet',
	    validate: Immutable.OrderedSet.isOrderedSet,
	    renderBody: renderFullBody,
	    renderInlineFull: renderInlineFullList,
	    renderInlinePartial: renderTitleList,
	    renderTitle: renderTitleList
	  },
	
	  {
	    name: () => 'Set',
	    validate: Immutable.Set.isSet,
	    renderBody: renderFullBody,
	    renderInlineFull: renderInlineFullList,
	    renderInlinePartial: renderTitleList,
	    renderTitle: renderTitleList
	  },
	
	  {
	    name: () => 'Seq',
	    validate: Immutable.Seq.isSeq,
	    renderBody: renderFullBody,
	    renderInlineFull: renderInlineFullList,
	    renderInlinePartial: renderTitleList,
	    renderTitle: renderTitleList
	  },
	
	  {
	    name: () => 'Stack',
	    validate: Immutable.Stack.isStack,
	    renderBody: renderFullBody,
	    renderInlineFull: renderInlineFullList,
	    renderInlinePartial: renderTitleList,
	    renderTitle: renderTitleList
	  }
	];
	
	function wrap (obj) {
	  return {toJS: true, __IS_NESTED__: true, value: obj};
	}
	
	function isImmutableJS (obj) {
	  return obj && obj.toJS;
	}
	
	function renderInlineFullList (name, list) {
	  return ['span', {style: 'white-space:normal;word-wrap:break-word;'},
	    `${name} [`,
	  ].concat(
	    list.reduce((output, value, index) => {
	      output.push(['object', {object: isImmutableJS(value) ? wrap(value) : value}]);
	      output.push(', ');
	      return output;
	    }, [])
	    .slice(0, -1)
	  )
	  .concat(']');
	}
	
	function renderInlineFullMap (name, map) {
	  return ['span', {style: 'font-style:italic;white-space:normal;word-wrap:break-word;'},
	    `${name} {`,
	  ].concat(
	    map.reduce((output, value, key) => {
	      output.push(['span', {style: 'color:rgb(136, 19, 145);flex-shrink:0;'}, `${key}`])
	      output.push(': ');
	      output.push(['object', {object: isImmutableJS(value) ? wrap(value) : value}]);
	      output.push(', ');
	      return output;
	    }, [])
	    .slice(0, -1)
	  )
	  .concat('}');
	}
	
	function renderTitleList (name, list) {
	  return ['span', {style: 'white-space:normal;word-wrap:break-word;'},
	    ['span', {}, `${name}[${list.size}]`]
	  ];
	}
	
	function renderTitleMap (name) {
	  return ['span', {style: 'white-space:normal;word-wrap:break-word;'},
	    ['span', {}, `${name}`]
	  ];
	}
	
	function renderInlinePartialMap (name, map) {
	  return renderInlineFullMap(name, map)
	    .slice(0, -1)
	    .concat([['span', {}, '…'], '}']);
	}
	
	function renderFullBody (obj) {
	  return obj.reduce((output, value, key) => {
	    output.push(['li', {style: 'text-overflow:ellipsis;white-space:nowrap;overflow:hidden;padding-top:2px;position:relative;min-height:inherit;line-height:12px;-webkit-user-select:text;'},
	      ['span', {style: 'color:rgb(136, 19, 145);flex-shrink:0;'}, `${key}`],
	      ['span', {style: 'flex-shrink:0;'}, ': '],
	      ['object', {object: value}]
	    ]);
	    return output;
	  }, ['ol', {style: 'list-style-type:none;padding-left:12px;margin-top:2px;'}]);
	}


/***/ },
/* 97 */
/***/ function(module, exports) {

	module.exports = extend
	
	function extend() {
	    var target = {}
	
	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i]
	
	        for (var key in source) {
	            if (source.hasOwnProperty(key)) {
	                target[key] = source[key]
	            }
	        }
	    }
	
	    return target
	}


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp, _initialiseProps;
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _warning = __webpack_require__(30);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _Viewport = __webpack_require__(242);
	
	var _Viewport2 = _interopRequireDefault(_Viewport);
	
	var _Module = __webpack_require__(238);
	
	var _Module2 = _interopRequireDefault(_Module);
	
	var _ResourceContainer = __webpack_require__(99);
	
	var _ResourceContainer2 = _interopRequireDefault(_ResourceContainer);
	
	var _ReactUpdates = __webpack_require__(18);
	
	var _ReactUpdates2 = _interopRequireDefault(_ReactUpdates);
	
	var _CameraUtils = __webpack_require__(246);
	
	var _CameraUtils2 = _interopRequireDefault(_CameraUtils);
	
	var _React3Renderer = __webpack_require__(55);
	
	var _React3Renderer2 = _interopRequireDefault(_React3Renderer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var rendererProperties = ['gammaInput', 'gammaOutput'];
	
	var React3DInstance = (_temp = _class = function () {
	  function React3DInstance(props, rendererInstance) {
	    var _this = this;
	
	    _classCallCheck(this, React3DInstance);
	
	    _initialiseProps.call(this);
	
	    var mainCamera = props.mainCamera;
	    var onAnimate = props.onAnimate;
	    var onRecreateCanvas = props.onRecreateCanvas;
	
	    this._parameters = _extends({}, props);
	
	    this._rendererInstance = rendererInstance;
	
	    this._mounted = false;
	    this._willUnmount = false;
	    this._scene = null;
	
	    this._mainCameraName = mainCamera;
	    this._viewports = [];
	    /**
	     * @type {Array.<React3Module>}
	     */
	    this._modules = [];
	
	    this._resourceContainers = [];
	    this._recreateCanvasCallback = onRecreateCanvas;
	
	    this._canvas = null;
	
	    this._onAnimate = onAnimate;
	    this._objectsByUUID = {};
	    this._materials = [];
	    this._geometries = [];
	    this._textures = [];
	    this._objectsByName = {};
	
	    this._lastRenderMode = null;
	
	    this._renderRequest = requestAnimationFrame(this._render);
	
	    this.uuid = _three2.default.Math.generateUUID();
	    this.userData = {};
	
	    if (("production") !== 'production' || ({"NODE_ENV":"production"}).ENABLE_REACT_ADDON_HOOKS === 'true') {
	      this._highlightScene = new _three2.default.Scene();
	
	      this._highlightGeometry = new _three2.default.BoxGeometry(1, 1, 1);
	      this._highlightMaterial = new _three2.default.MeshBasicMaterial({
	        color: 0x0000ff,
	        transparent: true,
	        opacity: 0.4
	      });
	
	      this._highlightObjectId = null;
	      this._getHighlightBoundingBox = null;
	
	      this._hideHighlight = function () {
	        _this._highlightObjectId = null;
	        _this._getHighlightBoundingBox = null;
	      };
	
	      this._objectHighlighted = function (info) {
	        var uuid = info.uuid;
	        var boundingBoxFunc = info.boundingBoxFunc;
	
	        var obj = undefined;
	
	        if (_this._highlightObjectId) {
	          obj = _this._objectsByUUID[_this._highlightObjectId];
	
	          obj.userData.events.removeListener('hideHighlight', _this._hideHighlight);
	        }
	
	        _this._highlightObjectId = uuid;
	        _this._getHighlightBoundingBox = boundingBoxFunc;
	
	        obj = _this._objectsByUUID[uuid];
	
	        obj.userData.events.once('hideHighlight', _this._hideHighlight);
	      };
	    }
	  }
	
	  _createClass(React3DInstance, [{
	    key: '_createRenderer',
	    value: function _createRenderer() {
	      if (!this._canvas) {
	        return;
	      }
	
	      var parameters = this._parameters;
	
	      this._renderer = new _three2.default.WebGLRenderer({
	        canvas: this._canvas,
	        precision: parameters.precision,
	        alpha: parameters.alpha,
	        premultipliedAlpha: parameters.premultipliedAlpha,
	        antialias: parameters.antialias,
	        stencil: parameters.stencil,
	        preserveDrawingBuffer: parameters.preserveDrawingBuffer,
	        depth: parameters.depth,
	        logarithmicDepthBuffer: parameters.logarithmicDepthBuffer
	      });
	
	      var renderer = this._renderer;
	
	      if (parameters.hasOwnProperty('pixelRatio')) {
	        renderer.setPixelRatio(parameters.pixelRatio);
	      }
	
	      if (parameters.hasOwnProperty('sortObjects')) {
	        renderer.sortObjects = parameters.sortObjects;
	      }
	
	      var hasClearColor = parameters.hasOwnProperty('clearColor');
	      var hasClearAlpha = parameters.hasOwnProperty('clearAlpha');
	
	      if (hasClearColor || hasClearAlpha) {
	        var clearColor = undefined;
	
	        if (hasClearColor) {
	          clearColor = parameters.clearColor;
	        } else {
	          clearColor = new _three2.default.Color(0x000000); // default clear color
	        }
	
	        if (hasClearAlpha) {
	          if (false) {
	            (0, _warning2.default)(parameters.alpha === true, 'The `clearAlpha` property' + ' requires the `alpha` property to be `true`.');
	          }
	
	          renderer.setClearColor(clearColor, parameters.clearAlpha);
	        } else {
	          renderer.setClearColor(clearColor);
	        }
	      }
	
	      if (parameters.hasOwnProperty('shadowMapEnabled')) {
	        renderer.shadowMap.enabled = parameters.shadowMapEnabled;
	      }
	
	      if (parameters.hasOwnProperty('shadowMapType')) {
	        renderer.shadowMap.type = parameters.shadowMapType;
	      }
	
	      if (parameters.hasOwnProperty('shadowMapCullFace')) {
	        renderer.shadowMap.cullFace = parameters.shadowMapCullFace;
	      }
	
	      if (parameters.hasOwnProperty('shadowMapDebug')) {
	        renderer.shadowMap.debug = parameters.shadowMapDebug;
	      }
	
	      rendererProperties.forEach(function (propertyName) {
	        if (parameters.hasOwnProperty(propertyName)) {
	          renderer[propertyName] = parameters[propertyName];
	        }
	      });
	
	      renderer.setSize(parameters.width, parameters.height);
	    }
	  }, {
	    key: 'initialize',
	    value: function initialize() {
	      this.userData.events.on('animate', this._callOnAnimate);
	    }
	  }, {
	    key: 'getObjectsByName',
	    value: function getObjectsByName(objectName) {
	      var objectsByName = this._objectsByName[objectName];
	
	      var result = undefined;
	
	      if (objectsByName) {
	        (function () {
	          var idToObjectMap = objectsByName.values;
	          result = Object.keys(idToObjectMap).map(function (name) {
	            return idToObjectMap[name];
	          });
	        })();
	      } else {
	        result = [];
	      }
	
	      return result;
	    }
	  }, {
	    key: 'addAnimateListener',
	    value: function addAnimateListener(callback) {
	      this.userData.events.on('animate', callback);
	    }
	  }, {
	    key: 'removeAnimateListener',
	    value: function removeAnimateListener(callback) {
	      this.userData.events.removeListener('animate', callback);
	    }
	  }, {
	    key: 'addBeforeRenderListener',
	    value: function addBeforeRenderListener(callback) {
	      this.userData.events.on('preRender', callback);
	    }
	  }, {
	    key: 'removeBeforeRenderListener',
	    value: function removeBeforeRenderListener(callback) {
	      this.userData.events.removeListener('preRender', callback);
	    }
	  }, {
	    key: 'addChildren',
	    value: function addChildren(children) {
	      for (var i = 0; i < children.length; ++i) {
	        var child = children[i];
	
	        if (child instanceof _three2.default.Scene) {
	          this.setScene(child);
	        } else if (child instanceof _Viewport2.default) {
	          this.addViewport(child);
	        } else if (child instanceof _Module2.default) {
	          this.addModule(child);
	        } else if (child instanceof _ResourceContainer2.default) {
	          this.addResourceContainer(child);
	        } else {
	          (0, _invariant2.default)(false, 'The react3 component should only contain ' + '<viewport/>s or <scene/>s or <resources/>.');
	        }
	      }
	    }
	  }, {
	    key: 'removeChild',
	    value: function removeChild(child) {
	      if (child instanceof _three2.default.Scene) {
	        if (this._scene === child) {
	          this.setScene(null);
	        }
	      } else if (child instanceof _Viewport2.default) {
	        this.removeViewport(child);
	      } else if (child instanceof _Module2.default) {
	        this.removeModule(child);
	      } else if (child instanceof _ResourceContainer2.default) {
	        this.removeResourceContainer(child);
	      } else {
	        (0, _invariant2.default)(false, 'The react3 component should only contain ' + '<viewport/>s or <scene/>s, <module/>s or <resources/>.');
	      }
	    }
	  }, {
	    key: '_renderScene',
	    value: function _renderScene(camera) {
	      this._renderer.render(this._scene, camera);
	
	      if (("production") !== 'production' || ({"NODE_ENV":"production"}).ENABLE_REACT_ADDON_HOOKS === 'true') {
	        if (this._highlightObjectId !== null) {
	          var boundingBoxes = this._getHighlightBoundingBox();
	
	          var highlightScene = this._highlightScene;
	
	          var diff = highlightScene.children.length - boundingBoxes.length;
	
	          if (diff > 0) {
	            for (var i = 0; i < diff; i++) {
	              highlightScene.remove(highlightScene.children[0]);
	            }
	          } else if (diff < 0) {
	            for (var i = 0; i < -diff; i++) {
	              highlightScene.add(new _three2.default.Mesh(this._highlightGeometry, this._highlightMaterial));
	            }
	          }
	
	          for (var i = 0; i < boundingBoxes.length; ++i) {
	            var boundingBox = boundingBoxes[i];
	
	            var center = boundingBox.min.clone().add(boundingBox.max).multiplyScalar(0.5);
	
	            var size = boundingBox.max.clone().sub(boundingBox.min);
	
	            var highlightCube = highlightScene.children[i];
	
	            highlightCube.position.copy(center);
	            highlightCube.scale.copy(size);
	          }
	
	          var autoClear = this._renderer.autoClear;
	          this._renderer.autoClear = false;
	          this._renderer.render(highlightScene, camera);
	          this._renderer.autoClear = autoClear;
	        }
	      }
	    }
	  }, {
	    key: 'setScene',
	    value: function setScene(scene) {
	      if (false) {
	        (0, _invariant2.default)(!(this._scene && scene), 'There can only be one scene in <react3/>');
	      }
	
	      this._scene = scene;
	    }
	  }, {
	    key: 'addViewport',
	    value: function addViewport(viewport) {
	      this._viewports.push(viewport);
	    }
	  }, {
	    key: 'removeViewport',
	    value: function removeViewport(viewport) {
	      var index = this._viewports.indexOf(viewport);
	      if (false) {
	        (0, _invariant2.default)(index !== -1, 'A viewport has been removed from ' + '<react3/> but it was not present in it...');
	      }
	
	      this._viewports.splice(index, 1);
	    }
	  }, {
	    key: 'addResourceContainer',
	    value: function addResourceContainer(resourceContainer) {
	      this._resourceContainers.push(resourceContainer);
	    }
	  }, {
	    key: 'removeResourceContainer',
	    value: function removeResourceContainer(resourceContainer) {
	      var index = this._resourceContainers.indexOf(resourceContainer);
	      if (false) {
	        (0, _invariant2.default)(index !== -1, 'A resource container has been removed ' + 'from <react3/> but it was not present in it...');
	      }
	
	      this._resourceContainers.splice(index, 1);
	    }
	  }, {
	    key: 'addModule',
	    value: function addModule(module) {
	      this._modules.push(module);
	    }
	  }, {
	    key: 'removeModule',
	    value: function removeModule(module) {
	      var index = this._modules.indexOf(module);
	
	      if (false) {
	        (0, _invariant2.default)(index !== -1, 'A module has been removed from ' + '<react3/> but it was not present in it...');
	      }
	
	      this._modules.splice(index, 1);
	    }
	  }, {
	    key: 'updateWidth',
	    value: function updateWidth(newWidth) {
	      this._parameters.width = newWidth;
	      if (!this._renderer) {
	        return;
	      }
	
	      this._renderer.setSize(this._parameters.width, this._parameters.height);
	    }
	  }, {
	    key: 'updateOnRecreateCanvas',
	    value: function updateOnRecreateCanvas(threeObject, callback) {
	      this._recreateCanvasCallback = callback;
	    }
	  }, {
	    key: 'updateHeight',
	    value: function updateHeight(newHeight) {
	      this._parameters.height = newHeight;
	      if (!this._renderer) {
	        return;
	      }
	
	      this._renderer.setSize(this._parameters.width, this._parameters.height);
	    }
	  }, {
	    key: 'updatePixelRatio',
	    value: function updatePixelRatio(newPixelRatio) {
	      this._parameters.pixelRatio = newPixelRatio;
	      if (!this._renderer) {
	        return;
	      }
	
	      this._renderer.setPixelRatio(newPixelRatio);
	      this._renderer.setSize(this._parameters.width, this._parameters.height);
	    }
	  }, {
	    key: 'updateSortObjects',
	    value: function updateSortObjects(sortObjects) {
	      this._parameters.sortObjects = sortObjects;
	
	      if (!this._renderer) {
	        return;
	      }
	
	      this._renderer.sortObjects = sortObjects;
	    }
	  }, {
	    key: 'updateAntialias',
	    value: function updateAntialias(antialias) {
	      this._parameters.antialias = antialias;
	      // no renderer, this only happens initially or we're about to recreate it anyway.
	      // unless something broke, then we have bigger problems...
	      if (!this._renderer) {
	        return;
	      }
	
	      this.refreshRenderer();
	    }
	  }, {
	    key: 'updatePrecision',
	    value: function updatePrecision(precision) {
	      this._parameters.precision = precision;
	      if (!this._renderer) {
	        return;
	      }
	
	      this.refreshRenderer();
	    }
	  }, {
	    key: 'updateAlpha',
	    value: function updateAlpha(alpha) {
	      this._parameters.alpha = alpha;
	      if (!this._renderer) {
	        return;
	      }
	
	      this.refreshRenderer();
	    }
	  }, {
	    key: 'updatePremultipliedAlpha',
	    value: function updatePremultipliedAlpha(premultipliedAlpha) {
	      this._parameters.premultipliedAlpha = premultipliedAlpha;
	      if (!this._renderer) {
	        return;
	      }
	
	      this.refreshRenderer();
	    }
	  }, {
	    key: 'updateAntialias',
	    value: function updateAntialias(antialias) {
	      this._parameters.antialias = antialias;
	      if (!this._renderer) {
	        return;
	      }
	
	      this.refreshRenderer();
	    }
	  }, {
	    key: 'updateStencil',
	    value: function updateStencil(stencil) {
	      this._parameters.stencil = stencil;
	      if (!this._renderer) {
	        return;
	      }
	
	      this.refreshRenderer();
	    }
	  }, {
	    key: 'updatePreserveDrawingBuffer',
	    value: function updatePreserveDrawingBuffer(preserveDrawingBuffer) {
	      this._parameters.preserveDrawingBuffer = preserveDrawingBuffer;
	      if (!this._renderer) {
	        return;
	      }
	
	      this.refreshRenderer();
	    }
	  }, {
	    key: 'updateDepth',
	    value: function updateDepth(depth) {
	      this._parameters.depth = depth;
	      if (!this._renderer) {
	        return;
	      }
	
	      this.refreshRenderer();
	    }
	  }, {
	    key: 'updateLogarithmicDepthBuffer',
	    value: function updateLogarithmicDepthBuffer(logarithmicDepthBuffer) {
	      this._parameters.logarithmicDepthBuffer = logarithmicDepthBuffer;
	      if (!this._renderer) {
	        return;
	      }
	
	      this.refreshRenderer();
	    }
	  }, {
	    key: 'updateShadowMapEnabled',
	    value: function updateShadowMapEnabled(shadowMapEnabled) {
	      this._parameters.shadowMapEnabled = shadowMapEnabled;
	
	      if (!this._renderer) {
	        return;
	      }
	
	      this._renderer.shadowMap.enabled = shadowMapEnabled;
	      this.allMaterialsNeedUpdate(true);
	    }
	  }, {
	    key: 'updateShadowMapType',
	    value: function updateShadowMapType(shadowMapType) {
	      this._parameters.shadowMapType = shadowMapType;
	
	      if (!this._renderer) {
	        return;
	      }
	
	      this._renderer.shadowMap.type = shadowMapType;
	      this.allMaterialsNeedUpdate(true);
	    }
	  }, {
	    key: 'updateShadowMapCullFace',
	    value: function updateShadowMapCullFace(shadowMapCullFace) {
	      this._parameters.shadowMapCullFace = shadowMapCullFace;
	
	      if (!this._renderer) {
	        return;
	      }
	
	      this._renderer.shadowMap.cullFace = shadowMapCullFace;
	      this.allMaterialsNeedUpdate(true);
	    }
	  }, {
	    key: 'updateShadowMapDebug',
	    value: function updateShadowMapDebug(shadowMapDebug) {
	      this._parameters.shadowMapDebug = shadowMapDebug;
	
	      if (!this._renderer) {
	        return;
	      }
	
	      this._renderer.shadowMap.debug = shadowMapDebug;
	      this.allMaterialsNeedUpdate(true);
	    }
	  }, {
	    key: 'updateCanvas',
	    value: function updateCanvas(canvas) {
	      this._canvas = canvas;
	
	      if (this._renderer) {
	        this.disposeResourcesAndRenderer();
	
	        var contextLossExtension = this._renderer.extensions.get('WEBGL_lose_context');
	        if (contextLossExtension) {
	          // noinspection JSUnresolvedFunction
	          contextLossExtension.loseContext();
	        }
	      }
	
	      this._createRenderer();
	    }
	  }, {
	    key: 'updateGammaInput',
	    value: function updateGammaInput(gammaInput) {
	      this._parameters.gammaInput = gammaInput;
	
	      if (!this._renderer) {
	        return;
	      }
	
	      this._renderer.gammaInput = gammaInput;
	      this.allMaterialsNeedUpdate(true);
	    }
	  }, {
	    key: 'updateGammaOutput',
	    value: function updateGammaOutput(gammaOutput) {
	      this._parameters.gammaOutput = gammaOutput;
	
	      if (!this._renderer) {
	        return;
	      }
	
	      this._renderer.gammaOutput = gammaOutput;
	      this.allMaterialsNeedUpdate(true);
	    }
	  }, {
	    key: 'updateContext',
	    value: function updateContext(context) {
	      this._parameters.context = context;
	    }
	  }, {
	    key: 'updateMainCamera',
	    value: function updateMainCamera(mainCamera) {
	      this._parameters.mainCamera = mainCamera;
	
	      this._mainCameraName = mainCamera;
	    }
	  }, {
	    key: 'updateOnAnimate',
	    value: function updateOnAnimate(onAnimate) {
	      this._parameters.onAnimate = onAnimate;
	
	      this._onAnimate = onAnimate;
	    }
	  }, {
	    key: 'updateClearColor',
	    value: function updateClearColor(clearColor) {
	      this._parameters.clearColor = clearColor;
	
	      if (!this._renderer) {
	        return;
	      }
	
	      if (this._parameters.hasOwnProperty('clearAlpha')) {
	        this._renderer.setClearColor(clearColor, this._parameters.clearAlpha);
	      } else {
	        this._renderer.setClearColor(clearColor);
	      }
	    }
	  }, {
	    key: 'updateClearAlpha',
	    value: function updateClearAlpha(clearAlpha) {
	      var parameters = this._parameters;
	
	      if (clearAlpha === undefined) {
	        delete parameters.clearAlpha;
	      } else {
	        parameters.clearAlpha = clearAlpha;
	      }
	
	      if (!this._renderer) {
	        return;
	      }
	
	      var clearColor = undefined;
	
	      if (parameters.hasOwnProperty('clearColor')) {
	        clearColor = parameters.clearColor;
	      } else {
	        clearColor = new _three2.default.Color(0x000000); // default clear color
	      }
	
	      if (clearAlpha !== undefined) {
	        this._renderer.setClearColor(clearColor, clearAlpha);
	      } else {
	        this._renderer.setClearColor(clearColor);
	      }
	    }
	  }, {
	    key: 'refreshRenderer',
	    value: function refreshRenderer() {
	      var _this2 = this;
	
	      this.disposeResourcesAndRenderer();
	
	      var contextLossExtension = this._renderer.extensions.get('WEBGL_lose_context');
	
	      delete this._renderer;
	
	      this.userData.events.removeListener('animate', this._callOnAnimate);
	      this.userData.events.removeAllListeners();
	
	      cancelAnimationFrame(this._renderRequest);
	
	      if (contextLossExtension && this._canvas) {
	        this._canvas.addEventListener('webglcontextlost', function () {
	          // this should recreate the canvas
	          _this2._recreateCanvasCallback();
	        }, false);
	
	        // noinspection JSUnresolvedFunction
	        contextLossExtension.loseContext();
	      } else {
	        this._recreateCanvasCallback();
	      }
	    }
	  }, {
	    key: 'disposeResourcesAndRenderer',
	    value: function disposeResourcesAndRenderer() {
	      for (var i = 0; i < this._materials.length; ++i) {
	        var material = this._materials[i];
	        material.dispose();
	      }
	
	      for (var i = 0; i < this._geometries.length; ++i) {
	        var geometry = this._geometries[i];
	        geometry.dispose();
	      }
	
	      for (var i = 0; i < this._textures.length; ++i) {
	        var texture = this._textures[i];
	        texture.dispose();
	      }
	
	      this._renderer.dispose();
	    }
	  }, {
	    key: 'willUnmount',
	    value: function willUnmount() {
	      this._willUnmount = true;
	    }
	  }, {
	    key: 'unmount',
	    value: function unmount() {
	      this._mounted = false;
	      cancelAnimationFrame(this._renderRequest);
	
	      this.userData.events.removeListener('animate', this._callOnAnimate);
	      this.userData.events.removeAllListeners();
	      delete this._rendererInstance;
	
	      if (this._renderer) {
	        var contextLossExtension = this._renderer.extensions.get('WEBGL_lose_context');
	
	        if (contextLossExtension) {
	          // noinspection JSUnresolvedFunction
	          contextLossExtension.loseContext();
	        }
	
	        this.disposeResourcesAndRenderer();
	
	        delete this._renderer;
	      }
	
	      delete this._parameters;
	
	      (0, _invariant2.default)(Object.keys(this._objectsByUUID).length === 0, 'Failed to cleanup some child objects for React3DInstance');
	
	      delete this._objectsByUUID;
	      delete this._viewports;
	      delete this._scene;
	
	      if (("production") !== 'production' || ({"NODE_ENV":"production"}).ENABLE_REACT_ADDON_HOOKS === 'true') {
	        delete this._highlightScene;
	        delete this._highlightObjectId;
	        delete this._getHighlightBoundingBox;
	      }
	    }
	  }, {
	    key: 'objectMounted',
	    value: function objectMounted(object) {
	      (0, _invariant2.default)(!this._objectsByUUID[object.uuid], 'There already is an object with this uuid in the react 3d instance.');
	
	      this._objectsByUUID[object.uuid] = object;
	
	      object.userData.markup._rootInstance = this;
	
	      this._addObjectWithName(object.name, object);
	
	      if (("production") !== 'production' || ({"NODE_ENV":"production"}).ENABLE_REACT_ADDON_HOOKS === 'true') {
	        object.userData.events.on('highlight', this._objectHighlighted);
	      }
	
	      object.userData.events.emit('addedIntoRoot', object);
	
	      var current = object;
	
	      var childrenMarkup = current.userData.markup.childrenMarkup;
	
	      if (object instanceof _three2.default.Material) {
	        this._materials.push(object);
	      }
	
	      if (object instanceof _three2.default.Geometry || object instanceof _three2.default.BufferGeometry) {
	        this._geometries.push(object);
	      }
	
	      if (object instanceof _three2.default.Texture) {
	        this._textures.push(object);
	      }
	
	      for (var i = 0; i < childrenMarkup.length; ++i) {
	        var childMarkup = childrenMarkup[i];
	
	        this.objectMounted(childMarkup.threeObject);
	      }
	    }
	  }, {
	    key: 'allMaterialsNeedUpdate',
	    value: function allMaterialsNeedUpdate(dispose) {
	      this._materials.forEach(function (material) {
	        if (dispose) {
	          material.dispose();
	        } else {
	          material.needsUpdate = true;
	        }
	      });
	    }
	  }, {
	    key: 'objectRenamed',
	    value: function objectRenamed(object, oldName, nextName) {
	      this._removeObjectWithName(oldName, object);
	      this._addObjectWithName(nextName, object);
	    }
	  }, {
	    key: '_addObjectWithName',
	    value: function _addObjectWithName(objectName, object) {
	      if (!this._objectsByName[objectName]) {
	        this._objectsByName[objectName] = {
	          count: 0,
	          values: {}
	        };
	      }
	
	      this._objectsByName[objectName].values[object.uuid] = object;
	      this._objectsByName[objectName].count++;
	    }
	  }, {
	    key: '_removeObjectWithName',
	    value: function _removeObjectWithName(objectName, object) {
	      (0, _invariant2.default)(this._objectsByName[objectName] && this._objectsByName[objectName].values[object.uuid] === object, 'The object\'s name changed somehow?\'');
	
	      delete this._objectsByName[objectName].values[object.uuid];
	      this._objectsByName[objectName].count--;
	
	      if (this._objectsByName[objectName].count === 0) {
	        delete this._objectsByName[objectName];
	      }
	    }
	  }, {
	    key: 'objectRemoved',
	    value: function objectRemoved(object) {
	      (0, _invariant2.default)(this._objectsByUUID[object.uuid] === object, 'The removed object does not belong here!?');
	
	      if (("production") !== 'production' || ({"NODE_ENV":"production"}).ENABLE_REACT_ADDON_HOOKS === 'true') {
	        if (this._highlightObjectId === object.uuid) {
	          this._highlightObjectId = null;
	        }
	
	        object.userData.events.removeListener('highlight', this._objectHighlighted);
	        object.userData.events.removeListener('hideHighlight', this._hideHighlight);
	      }
	
	      delete this._objectsByUUID[object.uuid];
	
	      if (object instanceof _three2.default.Material) {
	        this._materials.splice(this._materials.indexOf(object), 1);
	      }
	      if (object instanceof _three2.default.Geometry || object instanceof _three2.default.BufferGeometry) {
	        this._geometries.splice(this._geometries.indexOf(object), 1);
	      }
	      if (object instanceof _three2.default.Texture) {
	        this._textures.splice(this._textures.indexOf(object), 1);
	      }
	
	      this._removeObjectWithName(object.name, object);
	
	      delete object.userData.markup._rootInstance;
	    }
	  }, {
	    key: 'mountedIntoRoot',
	    value: function mountedIntoRoot() {
	      this._mounted = true;
	      this.objectMounted(this);
	    }
	  }]);
	
	  return React3DInstance;
	}(), _initialiseProps = function _initialiseProps() {
	  var _this3 = this;
	
	  this._callOnAnimate = function () {
	    if (_this3._onAnimate) {
	      _ReactUpdates2.default.batchedUpdates(_this3._onAnimate);
	    }
	  };
	
	  this._render = function () {
	    for (var i = 0; i < _this3._modules.length; ++i) {
	      _this3._modules[i].update();
	    }
	
	    _this3._renderRequest = requestAnimationFrame(_this3._render);
	    _this3.userData.events.emit('animate');
	
	    // the scene can be destroyed within the 'animate' event
	    if (!_this3._scene || !_this3._mounted || !_this3._renderer) {
	      return;
	    }
	
	    var mainCamera = null;
	
	    if (_this3._mainCameraName) {
	      var objectsWithMainCameraName = _this3._objectsByName[_this3._mainCameraName];
	
	      if (objectsWithMainCameraName) {
	        if (false) {
	          (0, _warning2.default)(objectsWithMainCameraName.count < 2, 'There are multiple objects with name ' + _this3._mainCameraName);
	        }
	
	        if (objectsWithMainCameraName.count > 0) {
	          var values = objectsWithMainCameraName.values;
	          mainCamera = values[Object.keys(values)[0]];
	        }
	      }
	    }
	
	    if (mainCamera) {
	      if (_this3._lastRenderMode !== 'camera') {
	        _this3._renderer.autoClear = true;
	        _this3._renderer.setViewport(0, 0, _this3._parameters.width, _this3._parameters.height);
	        _this3._lastRenderMode = 'camera';
	      }
	      _CameraUtils2.default.current = mainCamera;
	      _this3.userData.events.emit('preRender');
	      _this3._renderScene(mainCamera);
	      _CameraUtils2.default.current = null;
	    } else if (_this3._viewports.length > 0) {
	      if (_this3._lastRenderMode !== 'viewport') {
	        _this3._renderer.autoClear = false;
	        _this3._lastRenderMode = 'viewport';
	      }
	
	      _this3._renderer.clear();
	      _this3._viewports.forEach(function (viewport) {
	        var viewportCamera = null;
	
	        if (viewport.cameraName) {
	          var objectsWithViewportCameraName = _this3._objectsByName[viewport.cameraName];
	
	          if (objectsWithViewportCameraName) {
	            if (false) {
	              (0, _warning2.default)(objectsWithViewportCameraName.count < 2, 'There are multiple objects with name ' + viewport.cameraName);
	            }
	
	            if (objectsWithViewportCameraName.count > 0) {
	              var values = objectsWithViewportCameraName.values;
	              viewportCamera = values[Object.keys(values)[0]];
	            }
	          }
	        }
	
	        if (!viewportCamera) {
	          return;
	        }
	
	        if (viewport.onBeforeRender) {
	          _ReactUpdates2.default.batchedUpdates(viewport.onBeforeRender);
	        }
	
	        _this3._renderer.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);
	        _CameraUtils2.default.current = viewportCamera;
	        _this3.userData.events.emit('preRender');
	        _this3._renderScene(viewportCamera);
	        _CameraUtils2.default.current = null;
	      });
	    }
	  };
	}, _temp);
	
	module.exports = React3DInstance;

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ResourceContainer = function (_THREE$Object3D) {
	  _inherits(ResourceContainer, _THREE$Object3D);
	
	  function ResourceContainer() {
	    _classCallCheck(this, ResourceContainer);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ResourceContainer).call(this));
	
	    _this.visible = false;
	
	    _this.resourceMap = {};
	    _this.resourceIds = [];
	    return _this;
	  }
	
	  return ResourceContainer;
	}(_three2.default.Object3D);
	
	module.exports = ResourceContainer;

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var UniformContainer = function UniformContainer() {
	  _classCallCheck(this, UniformContainer);
	
	  this.userData = {};
	  this.uniforms = {};
	  this.uuid = _three2.default.Math.generateUUID();
	};
	
	module.exports = UniformContainer;

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _GeometryDescriptorBase = __webpack_require__(16);
	
	var _GeometryDescriptorBase2 = _interopRequireDefault(_GeometryDescriptorBase);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var BufferGeometryDescriptorBase = function (_GeometryDescriptorBa) {
	  _inherits(BufferGeometryDescriptorBase, _GeometryDescriptorBa);
	
	  function BufferGeometryDescriptorBase() {
	    var _Object$getPrototypeO;
	
	    var _temp, _this, _ret;
	
	    _classCallCheck(this, BufferGeometryDescriptorBase);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(BufferGeometryDescriptorBase)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.updateCacheAndReplace = function (propName, threeObject, newValue) {
	      threeObject.userData._propsCache[propName] = newValue;
	      threeObject.userData._wantPropertyOverwrite = true;
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }
	
	  _createClass(BufferGeometryDescriptorBase, [{
	    key: 'beginPropertyUpdates',
	    value: function beginPropertyUpdates(threeObject) {
	      _get(Object.getPrototypeOf(BufferGeometryDescriptorBase.prototype), 'beginPropertyUpdates', this).call(this, threeObject);
	
	      threeObject.userData._wantPropertyOverwrite = false;
	    }
	  }, {
	    key: 'completePropertyUpdates',
	    value: function completePropertyUpdates(threeObject) {
	      _get(Object.getPrototypeOf(BufferGeometryDescriptorBase.prototype), 'completePropertyUpdates', this).call(this, threeObject);
	
	      if (threeObject.userData._wantPropertyOverwrite) {
	        threeObject.userData._wantPropertyOverwrite = false;
	
	        threeObject.copy(this.construct(threeObject.userData._propsCache));
	      }
	    }
	  }, {
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(BufferGeometryDescriptorBase.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	
	      threeObject.userData._propsCache = _extends({}, props);
	    }
	  }]);
	
	  return BufferGeometryDescriptorBase;
	}(_GeometryDescriptorBase2.default);
	
	module.exports = BufferGeometryDescriptorBase;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _Object3DDescriptor2 = __webpack_require__(22);
	
	var _Object3DDescriptor3 = _interopRequireDefault(_Object3DDescriptor2);
	
	var _ResourceReference = __webpack_require__(41);
	
	var _ResourceReference2 = _interopRequireDefault(_ResourceReference);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MeshDescriptor = function (_Object3DDescriptor) {
	  _inherits(MeshDescriptor, _Object3DDescriptor);
	
	  function MeshDescriptor() {
	    var _Object$getPrototypeO;
	
	    var _temp, _this, _ret;
	
	    _classCallCheck(this, MeshDescriptor);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(MeshDescriptor)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this._invalidChild = function (child) {
	      var invalid = !(child instanceof _three2.default.Material || child instanceof _ResourceReference2.default || child instanceof _three2.default.Geometry || child instanceof _three2.default.BufferGeometry);
	
	      return invalid;
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }
	
	  _createClass(MeshDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var geometry = props.hasOwnProperty('geometry') ? props.geometry : undefined;
	      var material = props.hasOwnProperty('material') ? props.material : undefined;
	
	      var mesh = new _three2.default.Mesh(geometry, material);
	
	      if (!geometry) {
	        mesh.geometry.dispose();
	        mesh.geometry = undefined;
	      }
	
	      if (!material) {
	        mesh.material.dispose();
	        mesh.material = undefined;
	      }
	
	      return mesh;
	    }
	  }, {
	    key: 'addChildren',
	    value: function addChildren(threeObject, children) {
	      if (false) {
	        (0, _invariant2.default)(children.filter(this._invalidChild).length === 0, 'Mesh children can only be materials or geometries!');
	      } else {
	        (0, _invariant2.default)(children.filter(this._invalidChild).length === 0, false);
	      }
	    }
	  }, {
	    key: 'addChild',
	    value: function addChild(threeObject, child) {
	      this.addChildren(threeObject, [child]);
	    }
	  }, {
	    key: 'moveChild',
	    value: function moveChild() {
	      // doesn't matter
	    }
	  }]);
	
	  return MeshDescriptor;
	}(_Object3DDescriptor3.default);
	
	module.exports = MeshDescriptor;

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CallbackQueue
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(27);
	
	var assign = __webpack_require__(7);
	var invariant = __webpack_require__(4);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	function CallbackQueue() {
	  this._callbacks = null;
	  this._contexts = null;
	}
	
	assign(CallbackQueue.prototype, {
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	  enqueue: function (callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._contexts = this._contexts || [];
	    this._callbacks.push(callback);
	    this._contexts.push(context);
	  },
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	  notifyAll: function () {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    if (callbacks) {
	      !(callbacks.length === contexts.length) ?  false ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i]);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  },
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	  reset: function () {
	    this._callbacks = null;
	    this._contexts = null;
	  },
	
	  /**
	   * `PooledClass` looks for this.
	   */
	  destructor: function () {
	    this.reset();
	  }
	
	});
	
	PooledClass.addPoolingTo(CallbackQueue);
	
	module.exports = CallbackQueue;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(35);
	var ReactPerf = __webpack_require__(20);
	
	var quoteAttributeValueForBrowser = __webpack_require__(476);
	var warning = __webpack_require__(8);
	
	// Simplified subset
	var VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][\w\.\-]*$/;
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	   false ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	if (false) {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true
	  };
	  var warnedProperties = {};
	
	  var warnUnknownProperty = function (name) {
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return;
	    }
	
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    // For now, only warn when we have a suggested correction. This prevents
	    // logging too much when using transferPropsTo.
	    process.env.NODE_ENV !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
	  };
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function (id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function (node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function (name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    } else if (false) {
	      warnUnknownProperty(name);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function (name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function (node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	      } else if (propertyInfo.mustUseAttribute) {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      } else {
	        var propName = propertyInfo.propertyName;
	        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
	        // property type before comparing; only `value` does and is string.
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
	          // Contrary to `setAttribute`, object properties are properly
	          // `toString`ed by IE8/9.
	          node[propName] = value;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	    } else if (false) {
	      warnUnknownProperty(name);
	    }
	  },
	
	  setValueForAttribute: function (node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function (node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseAttribute) {
	        node.removeAttribute(propertyInfo.attributeName);
	      } else {
	        var propName = propertyInfo.propertyName;
	        var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {
	          node[propName] = defaultValue;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    } else if (false) {
	      warnUnknownProperty(name);
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {
	  setValueForProperty: 'setValueForProperty',
	  setValueForAttribute: 'setValueForAttribute',
	  deleteValueForProperty: 'deleteValueForProperty'
	});
	
	module.exports = DOMPropertyOperations;

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LinkedValueUtils
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactPropTypes = __webpack_require__(3);
	var ReactPropTypeLocations = __webpack_require__(44);
	
	var invariant = __webpack_require__(4);
	var warning = __webpack_require__(8);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ?  false ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ?  false ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ?  false ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
	}
	
	var propTypes = {
	  value: function (props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function (props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: ReactPropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function (tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	         false ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function (inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function (inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function (inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentBrowserEnvironment
	 */
	
	'use strict';
	
	var ReactDOMIDOperations = __webpack_require__(108);
	var ReactMount = __webpack_require__(14);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,
	
	  /**
	   * If a particular environment requires that some resources be cleaned up,
	   * specify this in the injected Mixin. In the DOM, we would likely want to
	   * purge any cached node ID lookups.
	   *
	   * @private
	   */
	  unmountIDFromEnvironment: function (rootNodeID) {
	    ReactMount.purgeID(rootNodeID);
	  }
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentEnvironment
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(4);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable environment dependent cleanup hook. (server vs.
	   * browser etc). Example: A browser system caches DOM nodes based on component
	   * ID and must remove that cache entry when this instance is unmounted.
	   */
	  unmountIDFromEnvironment: null,
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkupByID: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function (environment) {
	      !!injected ?  false ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
	      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
	      ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMIDOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(250);
	var DOMPropertyOperations = __webpack_require__(104);
	var ReactMount = __webpack_require__(14);
	var ReactPerf = __webpack_require__(20);
	
	var invariant = __webpack_require__(4);
	
	/**
	 * Errors for properties that should not be updated with `updatePropertyByID()`.
	 *
	 * @type {object}
	 * @private
	 */
	var INVALID_PROPERTY_ERRORS = {
	  dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
	  style: '`style` must be set using `updateStylesByID()`.'
	};
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a DOM node with new property values. This should only be used to
	   * update DOM properties in `DOMProperty`.
	   *
	   * @param {string} id ID of the node to update.
	   * @param {string} name A valid property name, see `DOMProperty`.
	   * @param {*} value New value of the property.
	   * @internal
	   */
	  updatePropertyByID: function (id, name, value) {
	    var node = ReactMount.getNode(id);
	    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ?  false ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;
	
	    // If we're updating to null or undefined, we should remove the property
	    // from the DOM node instead of inadvertantly setting to a string. This
	    // brings us in line with the same behavior we have on initial render.
	    if (value != null) {
	      DOMPropertyOperations.setValueForProperty(node, name, value);
	    } else {
	      DOMPropertyOperations.deleteValueForProperty(node, name);
	    }
	  },
	
	  /**
	   * Replaces a DOM node that exists in the document with markup.
	   *
	   * @param {string} id ID of child to be replaced.
	   * @param {string} markup Dangerous markup to inject in place of child.
	   * @internal
	   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
	   */
	  dangerouslyReplaceNodeWithMarkupByID: function (id, markup) {
	    var node = ReactMount.getNode(id);
	    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
	  },
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markup List of markup strings.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function (updates, markup) {
	    for (var i = 0; i < updates.length; i++) {
	      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
	    }
	    DOMChildrenOperations.processUpdates(updates, markup);
	  }
	};
	
	ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
	  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
	  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
	});
	
	module.exports = ReactDOMIDOperations;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultBatchingStrategy
	 */
	
	'use strict';
	
	var ReactUpdates = __webpack_require__(18);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(7);
	var emptyFunction = __webpack_require__(24);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function () {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function (callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      callback(a, b, c, d, e);
	    } else {
	      transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponent
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(11);
	var ReactEmptyComponentRegistry = __webpack_require__(111);
	var ReactReconciler = __webpack_require__(23);
	
	var assign = __webpack_require__(7);
	
	var placeholderElement;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponent: function (component) {
	    placeholderElement = ReactElement.createElement(component);
	  }
	};
	
	var ReactEmptyComponent = function (instantiate) {
	  this._currentElement = null;
	  this._rootNodeID = null;
	  this._renderedComponent = instantiate(placeholderElement);
	};
	assign(ReactEmptyComponent.prototype, {
	  construct: function (element) {},
	  mountComponent: function (rootID, transaction, context) {
	    ReactEmptyComponentRegistry.registerNullComponentID(rootID);
	    this._rootNodeID = rootID;
	    return ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, context);
	  },
	  receiveComponent: function () {},
	  unmountComponent: function (rootID, transaction, context) {
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    ReactEmptyComponentRegistry.deregisterNullComponentID(this._rootNodeID);
	    this._rootNodeID = null;
	    this._renderedComponent = null;
	  }
	});
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ },
/* 111 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponentRegistry
	 */
	
	'use strict';
	
	// This registry keeps track of the React IDs of the components that rendered to
	// `null` (in reality a placeholder such as `noscript`)
	var nullComponentIDsRegistry = {};
	
	/**
	 * @param {string} id Component's `_rootNodeID`.
	 * @return {boolean} True if the component is rendered to null.
	 */
	function isNullComponentID(id) {
	  return !!nullComponentIDsRegistry[id];
	}
	
	/**
	 * Mark the component as having rendered to null.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function registerNullComponentID(id) {
	  nullComponentIDsRegistry[id] = true;
	}
	
	/**
	 * Unmark the component as having rendered to null: it renders to something now.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function deregisterNullComponentID(id) {
	  delete nullComponentIDsRegistry[id];
	}
	
	var ReactEmptyComponentRegistry = {
	  isNullComponentID: isNullComponentID,
	  registerNullComponentID: registerNullComponentID,
	  deregisterNullComponentID: deregisterNullComponentID
	};
	
	module.exports = ReactEmptyComponentRegistry;

/***/ },
/* 112 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactVersion
	 */
	
	'use strict';
	
	module.exports = '0.14.6';

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule findDOMNode
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(19);
	var ReactInstanceMap = __webpack_require__(32);
	var ReactMount = __webpack_require__(14);
	
	var invariant = __webpack_require__(4);
	var warning = __webpack_require__(8);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (false) {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	  if (ReactInstanceMap.has(componentOrElement)) {
	    return ReactMount.getNodeFromInstance(componentOrElement);
	  }
	  !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ?  false ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : undefined;
	   true ?  false ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
	}
	
	module.exports = findDOMNode;

/***/ },
/* 114 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventCharCode
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ },
/* 115 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventModifierState
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ },
/* 116 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventTarget
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ },
/* 117 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getIteratorFn
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/* global Symbol */
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule instantiateReactComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactCompositeComponent = __webpack_require__(254);
	var ReactEmptyComponent = __webpack_require__(110);
	var ReactNativeComponent = __webpack_require__(267);
	
	var assign = __webpack_require__(7);
	var invariant = __webpack_require__(4);
	var warning = __webpack_require__(8);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function () {};
	assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = new ReactEmptyComponent(instantiateReactComponent);
	  } else if (typeof node === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ?  false ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactNativeComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	    } else {
	      instance = new ReactCompositeComponentWrapper();
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactNativeComponent.createInstanceForText(node);
	  } else {
	     true ?  false ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : invariant(false) : undefined;
	  }
	
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
	  }
	
	  // Sets up the instance. This can probably just move into the constructor now.
	  instance.construct(node);
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (false) {
	    instance._isOwnerNecessary = false;
	    instance._warnedAboutRefsInRender = false;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (false) {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEventSupported
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(12);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = (eventName in document);
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setTextContent
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(12);
	var escapeTextContentForBrowser = __webpack_require__(66);
	var setInnerHTML = __webpack_require__(67);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function (node, text) {
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function (node, text) {
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule validateDOMNesting
	 */
	
	'use strict';
	
	var assign = __webpack_require__(7);
	var emptyFunction = __webpack_require__(24);
	var warning = __webpack_require__(8);
	
	var validateDOMNesting = emptyFunction;
	
	if (false) {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    parentTag: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function (oldInfo, tag, instance) {
	    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.parentTag = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function (tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	
	      case 'pre':
	      case 'listing':
	
	      case 'table':
	
	      case 'hr':
	
	      case 'xmp':
	
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function (instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    /*eslint-disable space-after-keywords */
	    do {
	      /*eslint-enable space-after-keywords */
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function (childTag, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
	      }
	    }
	  };
	
	  validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;

/***/ },
/* 122 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shallowEqual
	 * @typechecks
	 * 
	 */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var bHasOwnProperty = hasOwnProperty.bind(objB);
	  for (var i = 0; i < keysA.length; i++) {
	    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 123 */
/***/ function(module, exports) {

	"use strict";
	
	var repeat = function repeat(str, times) {
	  return new Array(times + 1).join(str);
	};
	var pad = function pad(num, maxLength) {
	  return repeat("0", maxLength - num.toString().length) + num;
	};
	var formatTime = function formatTime(time) {
	  return " @ " + pad(time.getHours(), 2) + ":" + pad(time.getMinutes(), 2) + ":" + pad(time.getSeconds(), 2) + "." + pad(time.getMilliseconds(), 3);
	};
	
	// Use the new performance api to get better precision if available
	var timer = typeof performance !== "undefined" && typeof performance.now === "function" ? performance : Date;
	
	/**
	 * Creates logger with followed options
	 *
	 * @namespace
	 * @property {object} options - options for logger
	 * @property {string} options.level - console[level]
	 * @property {boolean} options.duration - print duration of each action?
	 * @property {boolean} options.timestamp - print timestamp with each action?
	 * @property {object} options.colors - custom colors
	 * @property {object} options.logger - implementation of the `console` API
	 * @property {boolean} options.logErrors - should errors in action execution be caught, logged, and re-thrown?
	 * @property {boolean} options.collapsed - is group collapsed?
	 * @property {boolean} options.predicate - condition which resolves logger behavior
	 * @property {function} options.stateTransformer - transform state before print
	 * @property {function} options.actionTransformer - transform action before print
	 * @property {function} options.errorTransformer - transform error before print
	 */
	
	function createLogger() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var _options$level = options.level;
	  var level = _options$level === undefined ? "log" : _options$level;
	  var _options$logger = options.logger;
	  var logger = _options$logger === undefined ? window.console : _options$logger;
	  var _options$logErrors = options.logErrors;
	  var logErrors = _options$logErrors === undefined ? true : _options$logErrors;
	  var collapsed = options.collapsed;
	  var predicate = options.predicate;
	  var _options$duration = options.duration;
	  var duration = _options$duration === undefined ? false : _options$duration;
	  var _options$timestamp = options.timestamp;
	  var timestamp = _options$timestamp === undefined ? true : _options$timestamp;
	  var transformer = options.transformer;
	  var _options$stateTransfo = options.stateTransformer;
	  var // deprecated
	  stateTransformer = _options$stateTransfo === undefined ? function (state) {
	    return state;
	  } : _options$stateTransfo;
	  var _options$actionTransf = options.actionTransformer;
	  var actionTransformer = _options$actionTransf === undefined ? function (actn) {
	    return actn;
	  } : _options$actionTransf;
	  var _options$errorTransfo = options.errorTransformer;
	  var errorTransformer = _options$errorTransfo === undefined ? function (error) {
	    return error;
	  } : _options$errorTransfo;
	  var _options$colors = options.colors;
	  var colors = _options$colors === undefined ? {
	    title: function title() {
	      return "#000000";
	    },
	    prevState: function prevState() {
	      return "#9E9E9E";
	    },
	    action: function action() {
	      return "#03A9F4";
	    },
	    nextState: function nextState() {
	      return "#4CAF50";
	    },
	    error: function error() {
	      return "#F20404";
	    }
	  } : _options$colors;
	
	  // exit if console undefined
	
	  if (typeof logger === "undefined") {
	    return function () {
	      return function (next) {
	        return function (action) {
	          return next(action);
	        };
	      };
	    };
	  }
	
	  if (transformer) {
	    console.error("Option 'transformer' is deprecated, use stateTransformer instead");
	  }
	
	  var logBuffer = [];
	  function printBuffer() {
	    logBuffer.forEach(function (logEntry, key) {
	      var started = logEntry.started;
	      var action = logEntry.action;
	      var prevState = logEntry.prevState;
	      var error = logEntry.error;
	      var took = logEntry.took;
	      var nextState = logEntry.nextState;
	
	      var nextEntry = logBuffer[key + 1];
	      if (nextEntry) {
	        nextState = nextEntry.prevState;
	        took = nextEntry.started - started;
	      }
	      // message
	      var formattedAction = actionTransformer(action);
	      var time = new Date(started);
	      var isCollapsed = typeof collapsed === "function" ? collapsed(function () {
	        return nextState;
	      }, action) : collapsed;
	
	      var formattedTime = formatTime(time);
	      var titleCSS = colors.title ? "color: " + colors.title(formattedAction) + ";" : null;
	      var title = "action " + formattedAction.type + (timestamp ? formattedTime : "") + (duration ? " in " + took.toFixed(2) + " ms" : "");
	
	      // render
	      try {
	        if (isCollapsed) {
	          if (colors.title) logger.groupCollapsed("%c " + title, titleCSS);else logger.groupCollapsed(title);
	        } else {
	          if (colors.title) logger.group("%c " + title, titleCSS);else logger.group(title);
	        }
	      } catch (e) {
	        logger.log(title);
	      }
	
	      if (colors.prevState) logger[level]("%c prev state", "color: " + colors.prevState(prevState) + "; font-weight: bold", prevState);else logger[level]("prev state", prevState);
	
	      if (colors.action) logger[level]("%c action", "color: " + colors.action(formattedAction) + "; font-weight: bold", formattedAction);else logger[level]("action", formattedAction);
	
	      if (error) {
	        if (colors.error) logger[level]("%c error", "color: " + colors.error(error, prevState) + "; font-weight: bold", error);else logger[level]("error", error);
	      }
	
	      if (colors.nextState) logger[level]("%c next state", "color: " + colors.nextState(nextState) + "; font-weight: bold", nextState);else logger[level]("next state", nextState);
	
	      try {
	        logger.groupEnd();
	      } catch (e) {
	        logger.log("—— log end ——");
	      }
	    });
	    logBuffer.length = 0;
	  }
	
	  return function (_ref) {
	    var getState = _ref.getState;
	    return function (next) {
	      return function (action) {
	        // exit early if predicate function returns false
	        if (typeof predicate === "function" && !predicate(getState, action)) {
	          return next(action);
	        }
	
	        var logEntry = {};
	        logBuffer.push(logEntry);
	
	        logEntry.started = timer.now();
	        logEntry.prevState = stateTransformer(getState());
	        logEntry.action = action;
	
	        var returnedValue = undefined;
	        if (logErrors) {
	          try {
	            returnedValue = next(action);
	          } catch (e) {
	            logEntry.error = errorTransformer(e);
	          }
	        } else {
	          returnedValue = next(action);
	        }
	
	        logEntry.took = timer.now() - logEntry.started;
	        logEntry.nextState = stateTransformer(getState());
	
	        printBuffer();
	
	        if (logEntry.error) throw logEntry.error;
	        return returnedValue;
	      };
	    };
	  };
	}
	
	module.exports = createLogger;

/***/ },
/* 124 */
/***/ function(module, exports) {

	'use strict';
	
	function thunkMiddleware(_ref) {
	  var dispatch = _ref.dispatch;
	  var getState = _ref.getState;
	
	  return function (next) {
	    return function (action) {
	      return typeof action === 'function' ? action(dispatch, getState) : next(action);
	    };
	  };
	}
	
	module.exports = thunkMiddleware;

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.__esModule = true;
	exports["default"] = applyMiddleware;
	
	var _compose = __webpack_require__(48);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, initialState, enhancer) {
	      var store = createStore(reducer, initialState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 126 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = combineReducers;
	
	var _createStore = __webpack_require__(49);
	
	var _isPlainObject = __webpack_require__(51);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(50);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Reducer "' + key + '" returned undefined handling ' + actionName + '. ' + 'To ignore an action, you must explicitly return the previous state.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2["default"])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key);
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];
	
	    if (sanityError) {
	      throw sanityError;
	    }
	
	    if (false) {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
	      if (warningMessage) {
	        (0, _warning2["default"])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}

/***/ },
/* 128 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	module.exports = isHostObject;


/***/ },
/* 129 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 130 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.defaultMemoize = defaultMemoize;
	exports.createSelectorCreator = createSelectorCreator;
	exports.createSelector = createSelector;
	exports.createStructuredSelector = createStructuredSelector;
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }
	
	function defaultEqualityCheck(a, b) {
	  return a === b;
	}
	
	function defaultMemoize(func) {
	  var equalityCheck = arguments.length <= 1 || arguments[1] === undefined ? defaultEqualityCheck : arguments[1];
	
	  var lastArgs = null;
	  var lastResult = null;
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    if (lastArgs !== null && lastArgs.length === args.length && args.every(function (value, index) {
	      return equalityCheck(value, lastArgs[index]);
	    })) {
	      return lastResult;
	    }
	    lastArgs = args;
	    lastResult = func.apply(undefined, args);
	    return lastResult;
	  };
	}
	
	function getDependencies(funcs) {
	  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;
	
	  if (!dependencies.every(function (dep) {
	    return typeof dep === 'function';
	  })) {
	    var dependencyTypes = dependencies.map(function (dep) {
	      return typeof dep;
	    }).join(', ');
	    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));
	  }
	
	  return dependencies;
	}
	
	function createSelectorCreator(memoize) {
	  for (var _len2 = arguments.length, memoizeOptions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	    memoizeOptions[_key2 - 1] = arguments[_key2];
	  }
	
	  return function () {
	    for (var _len3 = arguments.length, funcs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	      funcs[_key3] = arguments[_key3];
	    }
	
	    var recomputations = 0;
	    var resultFunc = funcs.pop();
	    var dependencies = getDependencies(funcs);
	
	    var memoizedResultFunc = memoize.apply(undefined, [function () {
	      recomputations++;
	      return resultFunc.apply(undefined, arguments);
	    }].concat(memoizeOptions));
	
	    var selector = function selector(state, props) {
	      for (var _len4 = arguments.length, args = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
	        args[_key4 - 2] = arguments[_key4];
	      }
	
	      var params = dependencies.map(function (dependency) {
	        return dependency.apply(undefined, [state, props].concat(args));
	      });
	      return memoizedResultFunc.apply(undefined, _toConsumableArray(params));
	    };
	
	    selector.recomputations = function () {
	      return recomputations;
	    };
	    return selector;
	  };
	}
	
	function createSelector() {
	  return createSelectorCreator(defaultMemoize).apply(undefined, arguments);
	}
	
	function createStructuredSelector(selectors) {
	  var selectorCreator = arguments.length <= 1 || arguments[1] === undefined ? createSelector : arguments[1];
	
	  if (typeof selectors !== 'object') {
	    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));
	  }
	  var objectKeys = Object.keys(selectors);
	  return selectorCreator(objectKeys.map(function (key) {
	    return selectors[key];
	  }), function () {
	    for (var _len5 = arguments.length, values = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	      values[_key5] = arguments[_key5];
	    }
	
	    return values.reduce(function (composition, value, index) {
	      composition[objectKeys[index]] = value;
	      return composition;
	    }, {});
	  });
	}

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	var Stats = function () {
	
		var startTime = Date.now(), prevTime = startTime;
		var ms = 0, msMin = Infinity, msMax = 0;
		var fps = 0, fpsMin = Infinity, fpsMax = 0;
		var frames = 0, mode = 0;
	
		var container = document.createElement( 'div' );
		container.id = 'stats';
		container.addEventListener( 'mousedown', function ( event ) { event.preventDefault(); setMode( ++ mode % 2 ) }, false );
		container.style.cssText = 'width:80px;opacity:0.9;cursor:pointer';
	
		var fpsDiv = document.createElement( 'div' );
		fpsDiv.id = 'fps';
		fpsDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#002';
		container.appendChild( fpsDiv );
	
		var fpsText = document.createElement( 'div' );
		fpsText.id = 'fpsText';
		fpsText.style.cssText = 'color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
		fpsText.innerHTML = 'FPS';
		fpsDiv.appendChild( fpsText );
	
		var fpsGraph = document.createElement( 'div' );
		fpsGraph.id = 'fpsGraph';
		fpsGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0ff';
		fpsDiv.appendChild( fpsGraph );
	
		while ( fpsGraph.children.length < 74 ) {
	
			var bar = document.createElement( 'span' );
			bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#113';
			fpsGraph.appendChild( bar );
	
		}
	
		var msDiv = document.createElement( 'div' );
		msDiv.id = 'ms';
		msDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#020;display:none';
		container.appendChild( msDiv );
	
		var msText = document.createElement( 'div' );
		msText.id = 'msText';
		msText.style.cssText = 'color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
		msText.innerHTML = 'MS';
		msDiv.appendChild( msText );
	
		var msGraph = document.createElement( 'div' );
		msGraph.id = 'msGraph';
		msGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0f0';
		msDiv.appendChild( msGraph );
	
		while ( msGraph.children.length < 74 ) {
	
			var bar = document.createElement( 'span' );
			bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#131';
			msGraph.appendChild( bar );
	
		}
	
		var setMode = function ( value ) {
	
			mode = value;
	
			switch ( mode ) {
	
				case 0:
					fpsDiv.style.display = 'block';
					msDiv.style.display = 'none';
					break;
				case 1:
					fpsDiv.style.display = 'none';
					msDiv.style.display = 'block';
					break;
			}
	
		};
	
		var updateGraph = function ( dom, value ) {
	
			var child = dom.appendChild( dom.firstChild );
			child.style.height = value + 'px';
	
		};
	
		return {
	
			REVISION: 12,
	
			domElement: container,
	
			setMode: setMode,
	
			begin: function () {
	
				startTime = Date.now();
	
			},
	
			end: function () {
	
				var time = Date.now();
	
				ms = time - startTime;
				msMin = Math.min( msMin, ms );
				msMax = Math.max( msMax, ms );
	
				msText.textContent = ms + ' MS (' + msMin + '-' + msMax + ')';
				updateGraph( msGraph, Math.min( 30, 30 - ( ms / 200 ) * 30 ) );
	
				frames ++;
	
				if ( time > prevTime + 1000 ) {
	
					fps = Math.round( ( frames * 1000 ) / ( time - prevTime ) );
					fpsMin = Math.min( fpsMin, fps );
					fpsMax = Math.max( fpsMax, fps );
	
					fpsText.textContent = fps + ' FPS (' + fpsMin + '-' + fpsMax + ')';
					updateGraph( fpsGraph, Math.min( 30, 30 - ( fps / 100 ) * 30 ) );
	
					prevTime = time;
					frames = 0;
	
				}
	
				return time;
	
			},
	
			update: function () {
	
				startTime = this.end();
	
			}
	
		}
	
	};
	
	if ( true ) {
	
		module.exports = Stats;
	
	}

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.toggleMuted = exports.listenToClicks = undefined;
	
	var _constants = __webpack_require__(6);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var toggleAdmin = function toggleAdmin() {
		return function (dispatch, getState) {
			if (getState().admin.get('visible')) {
				dispatch({ type: _constants2.default.ADMIN_INVISIBLE });
			} else {
				dispatch({ type: _constants2.default.ADMIN_VISIBLE });
			}
		};
	};
	
	var listenToClicks = exports.listenToClicks = function listenToClicks() {
		return function (dispatch, getState) {
			if (!document) return;
			document.querySelector('body').addEventListener('click', function (e) {
				if (e.x < 100 && e.y < 100) {
					dispatch(toggleAdmin());
				}
			});
		};
	};
	
	var toggleMuted = exports.toggleMuted = function toggleMuted() {
		return function (dispatch, getState) {
			dispatch({
				type: _constants2.default.ADMIN_MUTED,
				muted: !getState().admin.get('muted')
			});
		};
	};

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.dispatchStep = dispatchStep;
	exports.resetSteps = resetSteps;
	exports.setTutoStepsTimeouts = setTutoStepsTimeouts;
	
	var _constants = __webpack_require__(6);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function dispatchStep(direction) {
		return function (dispatch, getState) {
			var state = getState();
			var time = Date.now() - state.choregraphy.get('time');
			dispatch({
				type: _constants2.default.STEP,
				direction: direction,
				time: time
			});
		};
	}
	
	function resetSteps() {
		return function (dispatch, getState) {
			dispatch({
				type: _constants2.default.STEPS_RESET
			});
		};
	}
	
	function setTutoStepsTimeouts() {
		return function (dispatch, getState) {
			setTimeout(function () {
				dispatch(dispatchStep(_constants2.default.TUTO_STEP_ONE_DIRECTION));
			}, _constants2.default.TUTO_STEP_ONE_TIME - _constants2.default.TUTO_FORWARD_TIME);
			setTimeout(function () {
				dispatch(dispatchStep(_constants2.default.TUTO_STEP_TWO_DIRECTION));
			}, _constants2.default.TUTO_STEP_TWO_TIME - _constants2.default.TUTO_FORWARD_TIME);
		};
	}

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.getMaximumComments = exports.getMaximumProgression = exports.getVisibleMoves = undefined;
	
	var _reselect = __webpack_require__(130);
	
	var getMoves = function getMoves(state) {
		return state.dance.get('moves');
	};
	
	var getVisibleMoves = exports.getVisibleMoves = (0, _reselect.createSelector)([getMoves], function (moves) {
		return moves.filter(function (move) {
			return move.visible;
		});
	});
	
	var getMaximumProgression = exports.getMaximumProgression = (0, _reselect.createSelector)([getMoves], function (moves) {
		return moves.size * 4;
	});
	
	var getMaximumComments = exports.getMaximumComments = (0, _reselect.createSelector)([getMoves], function (moves) {
		return moves.size;
	});

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.getSortedRecords = undefined;
	
	var _reselect = __webpack_require__(130);
	
	var getRecords = function getRecords(state) {
		return state.records;
	};
	
	var getSortedRecords = exports.getSortedRecords = (0, _reselect.createSelector)([getRecords], function (records) {
		return records.sort(function (record1, record2) {
			return record1.score < record2.score ? 1 : -1;
		});
	});

/***/ },
/* 136 */,
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : afrikaans (af)
	//! author : Werner Mollentze : https://github.com/wernerm
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var af = moment.defineLocale('af', {
	        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
	        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
	        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
	        meridiemParse: /vm|nm/i,
	        isPM : function (input) {
	            return /^nm$/i.test(input);
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower ? 'vm' : 'VM';
	            } else {
	                return isLower ? 'nm' : 'NM';
	            }
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Vandag om] LT',
	            nextDay : '[Môre om] LT',
	            nextWeek : 'dddd [om] LT',
	            lastDay : '[Gister om] LT',
	            lastWeek : '[Laas] dddd [om] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'oor %s',
	            past : '%s gelede',
	            s : '\'n paar sekondes',
	            m : '\'n minuut',
	            mm : '%d minute',
	            h : '\'n uur',
	            hh : '%d ure',
	            d : '\'n dag',
	            dd : '%d dae',
	            M : '\'n maand',
	            MM : '%d maande',
	            y : '\'n jaar',
	            yy : '%d jaar'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Röling : https://github.com/jjupiter
	        },
	        week : {
	            dow : 1, // Maandag is die eerste dag van die week.
	            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
	        }
	    });
	
	    return af;
	
	}));

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Moroccan Arabic (ar-ma)
	//! author : ElFadili Yassine : https://github.com/ElFadiliY
	//! author : Abdel Said : https://github.com/abdelsaid
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ar_ma = moment.defineLocale('ar-ma', {
	        months : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
	        monthsShort : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
	        weekdays : 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort : 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[اليوم على الساعة] LT',
	            nextDay: '[غدا على الساعة] LT',
	            nextWeek: 'dddd [على الساعة] LT',
	            lastDay: '[أمس على الساعة] LT',
	            lastWeek: 'dddd [على الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'في %s',
	            past : 'منذ %s',
	            s : 'ثوان',
	            m : 'دقيقة',
	            mm : '%d دقائق',
	            h : 'ساعة',
	            hh : '%d ساعات',
	            d : 'يوم',
	            dd : '%d أيام',
	            M : 'شهر',
	            MM : '%d أشهر',
	            y : 'سنة',
	            yy : '%d سنوات'
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ar_ma;
	
	}));

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic Saudi Arabia (ar-sa)
	//! author : Suhail Alkowaileet : https://github.com/xsoh
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '١',
	        '2': '٢',
	        '3': '٣',
	        '4': '٤',
	        '5': '٥',
	        '6': '٦',
	        '7': '٧',
	        '8': '٨',
	        '9': '٩',
	        '0': '٠'
	    }, numberMap = {
	        '١': '1',
	        '٢': '2',
	        '٣': '3',
	        '٤': '4',
	        '٥': '5',
	        '٦': '6',
	        '٧': '7',
	        '٨': '8',
	        '٩': '9',
	        '٠': '0'
	    };
	
	    var ar_sa = moment.defineLocale('ar-sa', {
	        months : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        monthsShort : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /ص|م/,
	        isPM : function (input) {
	            return 'م' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ص';
	            } else {
	                return 'م';
	            }
	        },
	        calendar : {
	            sameDay: '[اليوم على الساعة] LT',
	            nextDay: '[غدا على الساعة] LT',
	            nextWeek: 'dddd [على الساعة] LT',
	            lastDay: '[أمس على الساعة] LT',
	            lastWeek: 'dddd [على الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'في %s',
	            past : 'منذ %s',
	            s : 'ثوان',
	            m : 'دقيقة',
	            mm : '%d دقائق',
	            h : 'ساعة',
	            hh : '%d ساعات',
	            d : 'يوم',
	            dd : '%d أيام',
	            M : 'شهر',
	            MM : '%d أشهر',
	            y : 'سنة',
	            yy : '%d سنوات'
	        },
	        preparse: function (string) {
	            return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
	                return numberMap[match];
	            }).replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '،');
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ar_sa;
	
	}));

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale  : Tunisian Arabic (ar-tn)
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ar_tn = moment.defineLocale('ar-tn', {
	        months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[اليوم على الساعة] LT',
	            nextDay: '[غدا على الساعة] LT',
	            nextWeek: 'dddd [على الساعة] LT',
	            lastDay: '[أمس على الساعة] LT',
	            lastWeek: 'dddd [على الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'في %s',
	            past: 'منذ %s',
	            s: 'ثوان',
	            m: 'دقيقة',
	            mm: '%d دقائق',
	            h: 'ساعة',
	            hh: '%d ساعات',
	            d: 'يوم',
	            dd: '%d أيام',
	            M: 'شهر',
	            MM: '%d أشهر',
	            y: 'سنة',
	            yy: '%d سنوات'
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return ar_tn;
	
	}));

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! Locale: Arabic (ar)
	//! Author: Abdel Said: https://github.com/abdelsaid
	//! Changes in months, weekdays: Ahmed Elkhatib
	//! Native plural forms: forabi https://github.com/forabi
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '١',
	        '2': '٢',
	        '3': '٣',
	        '4': '٤',
	        '5': '٥',
	        '6': '٦',
	        '7': '٧',
	        '8': '٨',
	        '9': '٩',
	        '0': '٠'
	    }, numberMap = {
	        '١': '1',
	        '٢': '2',
	        '٣': '3',
	        '٤': '4',
	        '٥': '5',
	        '٦': '6',
	        '٧': '7',
	        '٨': '8',
	        '٩': '9',
	        '٠': '0'
	    }, pluralForm = function (n) {
	        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	    }, plurals = {
	        s : ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
	        m : ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
	        h : ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
	        d : ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
	        M : ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
	        y : ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
	    }, pluralize = function (u) {
	        return function (number, withoutSuffix, string, isFuture) {
	            var f = pluralForm(number),
	                str = plurals[u][pluralForm(number)];
	            if (f === 2) {
	                str = str[withoutSuffix ? 0 : 1];
	            }
	            return str.replace(/%d/i, number);
	        };
	    }, months = [
	        'كانون الثاني يناير',
	        'شباط فبراير',
	        'آذار مارس',
	        'نيسان أبريل',
	        'أيار مايو',
	        'حزيران يونيو',
	        'تموز يوليو',
	        'آب أغسطس',
	        'أيلول سبتمبر',
	        'تشرين الأول أكتوبر',
	        'تشرين الثاني نوفمبر',
	        'كانون الأول ديسمبر'
	    ];
	
	    var ar = moment.defineLocale('ar', {
	        months : months,
	        monthsShort : months,
	        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'D/\u200FM/\u200FYYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /ص|م/,
	        isPM : function (input) {
	            return 'م' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ص';
	            } else {
	                return 'م';
	            }
	        },
	        calendar : {
	            sameDay: '[اليوم عند الساعة] LT',
	            nextDay: '[غدًا عند الساعة] LT',
	            nextWeek: 'dddd [عند الساعة] LT',
	            lastDay: '[أمس عند الساعة] LT',
	            lastWeek: 'dddd [عند الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'بعد %s',
	            past : 'منذ %s',
	            s : pluralize('s'),
	            m : pluralize('m'),
	            mm : pluralize('m'),
	            h : pluralize('h'),
	            hh : pluralize('h'),
	            d : pluralize('d'),
	            dd : pluralize('d'),
	            M : pluralize('M'),
	            MM : pluralize('M'),
	            y : pluralize('y'),
	            yy : pluralize('y')
	        },
	        preparse: function (string) {
	            return string.replace(/\u200f/g, '').replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
	                return numberMap[match];
	            }).replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '،');
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ar;
	
	}));

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : azerbaijani (az)
	//! author : topchiyev : https://github.com/topchiyev
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var suffixes = {
	        1: '-inci',
	        5: '-inci',
	        8: '-inci',
	        70: '-inci',
	        80: '-inci',
	        2: '-nci',
	        7: '-nci',
	        20: '-nci',
	        50: '-nci',
	        3: '-üncü',
	        4: '-üncü',
	        100: '-üncü',
	        6: '-ncı',
	        9: '-uncu',
	        10: '-uncu',
	        30: '-uncu',
	        60: '-ıncı',
	        90: '-ıncı'
	    };
	
	    var az = moment.defineLocale('az', {
	        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
	        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
	        weekdays : 'Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə'.split('_'),
	        weekdaysShort : 'Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən'.split('_'),
	        weekdaysMin : 'Bz_BE_ÇA_Çə_CA_Cü_Şə'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[bugün saat] LT',
	            nextDay : '[sabah saat] LT',
	            nextWeek : '[gələn həftə] dddd [saat] LT',
	            lastDay : '[dünən] LT',
	            lastWeek : '[keçən həftə] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s sonra',
	            past : '%s əvvəl',
	            s : 'birneçə saniyyə',
	            m : 'bir dəqiqə',
	            mm : '%d dəqiqə',
	            h : 'bir saat',
	            hh : '%d saat',
	            d : 'bir gün',
	            dd : '%d gün',
	            M : 'bir ay',
	            MM : '%d ay',
	            y : 'bir il',
	            yy : '%d il'
	        },
	        meridiemParse: /gecə|səhər|gündüz|axşam/,
	        isPM : function (input) {
	            return /^(gündüz|axşam)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'gecə';
	            } else if (hour < 12) {
	                return 'səhər';
	            } else if (hour < 17) {
	                return 'gündüz';
	            } else {
	                return 'axşam';
	            }
	        },
	        ordinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
	        ordinal : function (number) {
	            if (number === 0) {  // special case for zero
	                return number + '-ıncı';
	            }
	            var a = number % 10,
	                b = number % 100 - a,
	                c = number >= 100 ? 100 : null;
	            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return az;
	
	}));

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : belarusian (be)
	//! author : Dmitry Demidov : https://github.com/demidov91
	//! author: Praleska: http://praleska.pro/
	//! Author : Menelion Elensúle : https://github.com/Oire
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? 'хвіліна_хвіліны_хвілін' : 'хвіліну_хвіліны_хвілін',
	            'hh': withoutSuffix ? 'гадзіна_гадзіны_гадзін' : 'гадзіну_гадзіны_гадзін',
	            'dd': 'дзень_дні_дзён',
	            'MM': 'месяц_месяцы_месяцаў',
	            'yy': 'год_гады_гадоў'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? 'хвіліна' : 'хвіліну';
	        }
	        else if (key === 'h') {
	            return withoutSuffix ? 'гадзіна' : 'гадзіну';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	
	    var be = moment.defineLocale('be', {
	        months : {
	            format: 'студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня'.split('_'),
	            standalone: 'студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань'.split('_')
	        },
	        monthsShort : 'студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж'.split('_'),
	        weekdays : {
	            format: 'нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу'.split('_'),
	            standalone: 'нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота'.split('_'),
	            isFormat: /\[ ?[Вв] ?(?:мінулую|наступную)? ?\] ?dddd/
	        },
	        weekdaysShort : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
	        weekdaysMin : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY г.',
	            LLL : 'D MMMM YYYY г., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY г., HH:mm'
	        },
	        calendar : {
	            sameDay: '[Сёння ў] LT',
	            nextDay: '[Заўтра ў] LT',
	            lastDay: '[Учора ў] LT',
	            nextWeek: function () {
	                return '[У] dddd [ў] LT';
	            },
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return '[У мінулую] dddd [ў] LT';
	                case 1:
	                case 2:
	                case 4:
	                    return '[У мінулы] dddd [ў] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'праз %s',
	            past : '%s таму',
	            s : 'некалькі секунд',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : relativeTimeWithPlural,
	            hh : relativeTimeWithPlural,
	            d : 'дзень',
	            dd : relativeTimeWithPlural,
	            M : 'месяц',
	            MM : relativeTimeWithPlural,
	            y : 'год',
	            yy : relativeTimeWithPlural
	        },
	        meridiemParse: /ночы|раніцы|дня|вечара/,
	        isPM : function (input) {
	            return /^(дня|вечара)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'ночы';
	            } else if (hour < 12) {
	                return 'раніцы';
	            } else if (hour < 17) {
	                return 'дня';
	            } else {
	                return 'вечара';
	            }
	        },
	        ordinalParse: /\d{1,2}-(і|ы|га)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-і' : number + '-ы';
	            case 'D':
	                return number + '-га';
	            default:
	                return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return be;
	
	}));

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : bulgarian (bg)
	//! author : Krasen Borisov : https://github.com/kraz
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var bg = moment.defineLocale('bg', {
	        months : 'януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември'.split('_'),
	        monthsShort : 'янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек'.split('_'),
	        weekdays : 'неделя_понеделник_вторник_сряда_четвъртък_петък_събота'.split('_'),
	        weekdaysShort : 'нед_пон_вто_сря_чет_пет_съб'.split('_'),
	        weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'D.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : '[Днес в] LT',
	            nextDay : '[Утре в] LT',
	            nextWeek : 'dddd [в] LT',
	            lastDay : '[Вчера в] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[В изминалата] dddd [в] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[В изминалия] dddd [в] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'след %s',
	            past : 'преди %s',
	            s : 'няколко секунди',
	            m : 'минута',
	            mm : '%d минути',
	            h : 'час',
	            hh : '%d часа',
	            d : 'ден',
	            dd : '%d дни',
	            M : 'месец',
	            MM : '%d месеца',
	            y : 'година',
	            yy : '%d години'
	        },
	        ordinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
	        ordinal : function (number) {
	            var lastDigit = number % 10,
	                last2Digits = number % 100;
	            if (number === 0) {
	                return number + '-ев';
	            } else if (last2Digits === 0) {
	                return number + '-ен';
	            } else if (last2Digits > 10 && last2Digits < 20) {
	                return number + '-ти';
	            } else if (lastDigit === 1) {
	                return number + '-ви';
	            } else if (lastDigit === 2) {
	                return number + '-ри';
	            } else if (lastDigit === 7 || lastDigit === 8) {
	                return number + '-ми';
	            } else {
	                return number + '-ти';
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return bg;
	
	}));

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bengali (bn)
	//! author : Kaushik Gandhi : https://github.com/kaushikgandhi
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '১',
	        '2': '২',
	        '3': '৩',
	        '4': '৪',
	        '5': '৫',
	        '6': '৬',
	        '7': '৭',
	        '8': '৮',
	        '9': '৯',
	        '0': '০'
	    },
	    numberMap = {
	        '১': '1',
	        '২': '2',
	        '৩': '3',
	        '৪': '4',
	        '৫': '5',
	        '৬': '6',
	        '৭': '7',
	        '৮': '8',
	        '৯': '9',
	        '০': '0'
	    };
	
	    var bn = moment.defineLocale('bn', {
	        months : 'জানুয়ারী_ফেবুয়ারী_মার্চ_এপ্রিল_মে_জুন_জুলাই_অগাস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split('_'),
	        monthsShort : 'জানু_ফেব_মার্চ_এপর_মে_জুন_জুল_অগ_সেপ্ট_অক্টো_নভ_ডিসেম্'.split('_'),
	        weekdays : 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পত্তিবার_শুক্রবার_শনিবার'.split('_'),
	        weekdaysShort : 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পত্তি_শুক্র_শনি'.split('_'),
	        weekdaysMin : 'রব_সম_মঙ্গ_বু_ব্রিহ_শু_শনি'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm সময়',
	            LTS : 'A h:mm:ss সময়',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm সময়',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm সময়'
	        },
	        calendar : {
	            sameDay : '[আজ] LT',
	            nextDay : '[আগামীকাল] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[গতকাল] LT',
	            lastWeek : '[গত] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s পরে',
	            past : '%s আগে',
	            s : 'কয়েক সেকেন্ড',
	            m : 'এক মিনিট',
	            mm : '%d মিনিট',
	            h : 'এক ঘন্টা',
	            hh : '%d ঘন্টা',
	            d : 'এক দিন',
	            dd : '%d দিন',
	            M : 'এক মাস',
	            MM : '%d মাস',
	            y : 'এক বছর',
	            yy : '%d বছর'
	        },
	        preparse: function (string) {
	            return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
	        isPM: function (input) {
	            return /^(দুপুর|বিকাল|রাত)$/.test(input);
	        },
	        //Bengali is a vast language its spoken
	        //in different forms in various parts of the world.
	        //I have just generalized with most common one used
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'রাত';
	            } else if (hour < 10) {
	                return 'সকাল';
	            } else if (hour < 17) {
	                return 'দুপুর';
	            } else if (hour < 20) {
	                return 'বিকাল';
	            } else {
	                return 'রাত';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return bn;
	
	}));

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : tibetan (bo)
	//! author : Thupten N. Chakrishar : https://github.com/vajradog
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '༡',
	        '2': '༢',
	        '3': '༣',
	        '4': '༤',
	        '5': '༥',
	        '6': '༦',
	        '7': '༧',
	        '8': '༨',
	        '9': '༩',
	        '0': '༠'
	    },
	    numberMap = {
	        '༡': '1',
	        '༢': '2',
	        '༣': '3',
	        '༤': '4',
	        '༥': '5',
	        '༦': '6',
	        '༧': '7',
	        '༨': '8',
	        '༩': '9',
	        '༠': '0'
	    };
	
	    var bo = moment.defineLocale('bo', {
	        months : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
	        monthsShort : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
	        weekdays : 'གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་'.split('_'),
	        weekdaysShort : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
	        weekdaysMin : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm',
	            LTS : 'A h:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm'
	        },
	        calendar : {
	            sameDay : '[དི་རིང] LT',
	            nextDay : '[སང་ཉིན] LT',
	            nextWeek : '[བདུན་ཕྲག་རྗེས་མ], LT',
	            lastDay : '[ཁ་སང] LT',
	            lastWeek : '[བདུན་ཕྲག་མཐའ་མ] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ལ་',
	            past : '%s སྔན་ལ',
	            s : 'ལམ་སང',
	            m : 'སྐར་མ་གཅིག',
	            mm : '%d སྐར་མ',
	            h : 'ཆུ་ཚོད་གཅིག',
	            hh : '%d ཆུ་ཚོད',
	            d : 'ཉིན་གཅིག',
	            dd : '%d ཉིན་',
	            M : 'ཟླ་བ་གཅིག',
	            MM : '%d ཟླ་བ',
	            y : 'ལོ་གཅིག',
	            yy : '%d ལོ'
	        },
	        preparse: function (string) {
	            return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
	        isPM: function (input) {
	            return /^(ཉིན་གུང|དགོང་དག|མཚན་མོ)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'མཚན་མོ';
	            } else if (hour < 10) {
	                return 'ཞོགས་ཀས';
	            } else if (hour < 17) {
	                return 'ཉིན་གུང';
	            } else if (hour < 20) {
	                return 'དགོང་དག';
	            } else {
	                return 'མཚན་མོ';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return bo;
	
	}));

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : breton (br)
	//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function relativeTimeWithMutation(number, withoutSuffix, key) {
	        var format = {
	            'mm': 'munutenn',
	            'MM': 'miz',
	            'dd': 'devezh'
	        };
	        return number + ' ' + mutation(format[key], number);
	    }
	    function specialMutationForYears(number) {
	        switch (lastNumber(number)) {
	        case 1:
	        case 3:
	        case 4:
	        case 5:
	        case 9:
	            return number + ' bloaz';
	        default:
	            return number + ' vloaz';
	        }
	    }
	    function lastNumber(number) {
	        if (number > 9) {
	            return lastNumber(number % 10);
	        }
	        return number;
	    }
	    function mutation(text, number) {
	        if (number === 2) {
	            return softMutation(text);
	        }
	        return text;
	    }
	    function softMutation(text) {
	        var mutationTable = {
	            'm': 'v',
	            'b': 'v',
	            'd': 'z'
	        };
	        if (mutationTable[text.charAt(0)] === undefined) {
	            return text;
	        }
	        return mutationTable[text.charAt(0)] + text.substring(1);
	    }
	
	    var br = moment.defineLocale('br', {
	        months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
	        monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
	        weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
	        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
	        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h[e]mm A',
	            LTS : 'h[e]mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D [a viz] MMMM YYYY',
	            LLL : 'D [a viz] MMMM YYYY h[e]mm A',
	            LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
	        },
	        calendar : {
	            sameDay : '[Hiziv da] LT',
	            nextDay : '[Warc\'hoazh da] LT',
	            nextWeek : 'dddd [da] LT',
	            lastDay : '[Dec\'h da] LT',
	            lastWeek : 'dddd [paset da] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'a-benn %s',
	            past : '%s \'zo',
	            s : 'un nebeud segondennoù',
	            m : 'ur vunutenn',
	            mm : relativeTimeWithMutation,
	            h : 'un eur',
	            hh : '%d eur',
	            d : 'un devezh',
	            dd : relativeTimeWithMutation,
	            M : 'ur miz',
	            MM : relativeTimeWithMutation,
	            y : 'ur bloaz',
	            yy : specialMutationForYears
	        },
	        ordinalParse: /\d{1,2}(añ|vet)/,
	        ordinal : function (number) {
	            var output = (number === 1) ? 'añ' : 'vet';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return br;
	
	}));

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : bosnian (bs)
	//! author : Nedim Cholich : https://github.com/frontyard
	//! based on (hr) translation by Bojan Marković
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	        }
	    }
	
	    var bs = moment.defineLocale('bs', {
	        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
	        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
	        weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
	        weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD. MM. YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[danas u] LT',
	            nextDay  : '[sutra u] LT',
	            nextWeek : function () {
	                switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[jučer u] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prošlu] dddd [u] LT';
	                case 6:
	                    return '[prošle] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prošli] dddd [u] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'par sekundi',
	            m      : translate,
	            mm     : translate,
	            h      : translate,
	            hh     : translate,
	            d      : 'dan',
	            dd     : translate,
	            M      : 'mjesec',
	            MM     : translate,
	            y      : 'godinu',
	            yy     : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return bs;
	
	}));

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : catalan (ca)
	//! author : Juan G. Hurtado : https://github.com/juanghurtado
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ca = moment.defineLocale('ca', {
	        months : 'gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
	        monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
	        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
	        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
	        weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            nextDay : function () {
	                return '[demà a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            lastDay : function () {
	                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'fa %s',
	            s : 'uns segons',
	            m : 'un minut',
	            mm : '%d minuts',
	            h : 'una hora',
	            hh : '%d hores',
	            d : 'un dia',
	            dd : '%d dies',
	            M : 'un mes',
	            MM : '%d mesos',
	            y : 'un any',
	            yy : '%d anys'
	        },
	        ordinalParse: /\d{1,2}(r|n|t|è|a)/,
	        ordinal : function (number, period) {
	            var output = (number === 1) ? 'r' :
	                (number === 2) ? 'n' :
	                (number === 3) ? 'r' :
	                (number === 4) ? 't' : 'è';
	            if (period === 'w' || period === 'W') {
	                output = 'a';
	            }
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return ca;
	
	}));

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : czech (cs)
	//! author : petrbela : https://github.com/petrbela
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var months = 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split('_'),
	        monthsShort = 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_');
	    function plural(n) {
	        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pár sekund' : 'pár sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minuty' : 'minut');
	            } else {
	                return result + 'minutami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodin');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dny' : 'dní');
	            } else {
	                return result + 'dny';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'měsíc' : 'měsícem';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'měsíce' : 'měsíců');
	            } else {
	                return result + 'měsíci';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'let');
	            } else {
	                return result + 'lety';
	            }
	            break;
	        }
	    }
	
	    var cs = moment.defineLocale('cs', {
	        months : months,
	        monthsShort : monthsShort,
	        monthsParse : (function (months, monthsShort) {
	            var i, _monthsParse = [];
	            for (i = 0; i < 12; i++) {
	                // use custom parser to solve problem with July (červenec)
	                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
	            }
	            return _monthsParse;
	        }(months, monthsShort)),
	        shortMonthsParse : (function (monthsShort) {
	            var i, _shortMonthsParse = [];
	            for (i = 0; i < 12; i++) {
	                _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
	            }
	            return _shortMonthsParse;
	        }(monthsShort)),
	        longMonthsParse : (function (months) {
	            var i, _longMonthsParse = [];
	            for (i = 0; i < 12; i++) {
	                _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
	            }
	            return _longMonthsParse;
	        }(months)),
	        weekdays : 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
	        weekdaysShort : 'ne_po_út_st_čt_pá_so'.split('_'),
	        weekdaysMin : 'ne_po_út_st_čt_pá_so'.split('_'),
	        longDateFormat : {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay: '[dnes v] LT',
	            nextDay: '[zítra v] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[v neděli v] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [v] LT';
	                case 3:
	                    return '[ve středu v] LT';
	                case 4:
	                    return '[ve čtvrtek v] LT';
	                case 5:
	                    return '[v pátek v] LT';
	                case 6:
	                    return '[v sobotu v] LT';
	                }
	            },
	            lastDay: '[včera v] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[minulou neděli v] LT';
	                case 1:
	                case 2:
	                    return '[minulé] dddd [v] LT';
	                case 3:
	                    return '[minulou středu v] LT';
	                case 4:
	                case 5:
	                    return '[minulý] dddd [v] LT';
	                case 6:
	                    return '[minulou sobotu v] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : 'před %s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse : /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return cs;
	
	}));

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : chuvash (cv)
	//! author : Anatoly Mironov : https://github.com/mirontoli
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var cv = moment.defineLocale('cv', {
	        months : 'кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав'.split('_'),
	        monthsShort : 'кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш'.split('_'),
	        weekdays : 'вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун'.split('_'),
	        weekdaysShort : 'выр_тун_ытл_юн_кӗҫ_эрн_шӑм'.split('_'),
	        weekdaysMin : 'вр_тн_ыт_юн_кҫ_эр_шм'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]',
	            LLL : 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
	            LLLL : 'dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm'
	        },
	        calendar : {
	            sameDay: '[Паян] LT [сехетре]',
	            nextDay: '[Ыран] LT [сехетре]',
	            lastDay: '[Ӗнер] LT [сехетре]',
	            nextWeek: '[Ҫитес] dddd LT [сехетре]',
	            lastWeek: '[Иртнӗ] dddd LT [сехетре]',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : function (output) {
	                var affix = /сехет$/i.exec(output) ? 'рен' : /ҫул$/i.exec(output) ? 'тан' : 'ран';
	                return output + affix;
	            },
	            past : '%s каялла',
	            s : 'пӗр-ик ҫеккунт',
	            m : 'пӗр минут',
	            mm : '%d минут',
	            h : 'пӗр сехет',
	            hh : '%d сехет',
	            d : 'пӗр кун',
	            dd : '%d кун',
	            M : 'пӗр уйӑх',
	            MM : '%d уйӑх',
	            y : 'пӗр ҫул',
	            yy : '%d ҫул'
	        },
	        ordinalParse: /\d{1,2}-мӗш/,
	        ordinal : '%d-мӗш',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return cv;
	
	}));

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Welsh (cy)
	//! author : Robert Allen
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var cy = moment.defineLocale('cy', {
	        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
	        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
	        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
	        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
	        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
	        // time formats are the same as en-gb
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[Heddiw am] LT',
	            nextDay: '[Yfory am] LT',
	            nextWeek: 'dddd [am] LT',
	            lastDay: '[Ddoe am] LT',
	            lastWeek: 'dddd [diwethaf am] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'mewn %s',
	            past: '%s yn ôl',
	            s: 'ychydig eiliadau',
	            m: 'munud',
	            mm: '%d munud',
	            h: 'awr',
	            hh: '%d awr',
	            d: 'diwrnod',
	            dd: '%d diwrnod',
	            M: 'mis',
	            MM: '%d mis',
	            y: 'blwyddyn',
	            yy: '%d flynedd'
	        },
	        ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
	        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
	        ordinal: function (number) {
	            var b = number,
	                output = '',
	                lookup = [
	                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
	                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
	                ];
	            if (b > 20) {
	                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
	                    output = 'fed'; // not 30ain, 70ain or 90ain
	                } else {
	                    output = 'ain';
	                }
	            } else if (b > 0) {
	                output = lookup[b];
	            }
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return cy;
	
	}));

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : danish (da)
	//! author : Ulrik Nielsen : https://github.com/mrbase
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var da = moment.defineLocale('da', {
	        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
	        weekdaysShort : 'søn_man_tir_ons_tor_fre_lør'.split('_'),
	        weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY HH:mm',
	            LLLL : 'dddd [d.] D. MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[I dag kl.] LT',
	            nextDay : '[I morgen kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[I går kl.] LT',
	            lastWeek : '[sidste] dddd [kl] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : '%s siden',
	            s : 'få sekunder',
	            m : 'et minut',
	            mm : '%d minutter',
	            h : 'en time',
	            hh : '%d timer',
	            d : 'en dag',
	            dd : '%d dage',
	            M : 'en måned',
	            MM : '%d måneder',
	            y : 'et år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return da;
	
	}));

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : austrian german (de-at)
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensúle: https://github.com/Oire
	//! author : Martin Groller : https://github.com/MadMG
	//! author : Mikolaj Dadela : https://github.com/mik01aj
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eine Minute', 'einer Minute'],
	            'h': ['eine Stunde', 'einer Stunde'],
	            'd': ['ein Tag', 'einem Tag'],
	            'dd': [number + ' Tage', number + ' Tagen'],
	            'M': ['ein Monat', 'einem Monat'],
	            'MM': [number + ' Monate', number + ' Monaten'],
	            'y': ['ein Jahr', 'einem Jahr'],
	            'yy': [number + ' Jahre', number + ' Jahren']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }
	
	    var de_at = moment.defineLocale('de-at', {
	        months : 'Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort : 'Jän._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY HH:mm',
	            LLLL : 'dddd, D. MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[heute um] LT [Uhr]',
	            sameElse: 'L',
	            nextDay: '[morgen um] LT [Uhr]',
	            nextWeek: 'dddd [um] LT [Uhr]',
	            lastDay: '[gestern um] LT [Uhr]',
	            lastWeek: '[letzten] dddd [um] LT [Uhr]'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : 'vor %s',
	            s : 'ein paar Sekunden',
	            m : processRelativeTime,
	            mm : '%d Minuten',
	            h : processRelativeTime,
	            hh : '%d Stunden',
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return de_at;
	
	}));

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : german (de)
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensúle: https://github.com/Oire
	//! author : Mikolaj Dadela : https://github.com/mik01aj
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eine Minute', 'einer Minute'],
	            'h': ['eine Stunde', 'einer Stunde'],
	            'd': ['ein Tag', 'einem Tag'],
	            'dd': [number + ' Tage', number + ' Tagen'],
	            'M': ['ein Monat', 'einem Monat'],
	            'MM': [number + ' Monate', number + ' Monaten'],
	            'y': ['ein Jahr', 'einem Jahr'],
	            'yy': [number + ' Jahre', number + ' Jahren']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }
	
	    var de = moment.defineLocale('de', {
	        months : 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY HH:mm',
	            LLLL : 'dddd, D. MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[heute um] LT [Uhr]',
	            sameElse: 'L',
	            nextDay: '[morgen um] LT [Uhr]',
	            nextWeek: 'dddd [um] LT [Uhr]',
	            lastDay: '[gestern um] LT [Uhr]',
	            lastWeek: '[letzten] dddd [um] LT [Uhr]'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : 'vor %s',
	            s : 'ein paar Sekunden',
	            m : processRelativeTime,
	            mm : '%d Minuten',
	            h : processRelativeTime,
	            hh : '%d Stunden',
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return de;
	
	}));

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : dhivehi (dv)
	//! author : Jawish Hameed : https://github.com/jawish
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var months = [
	        'ޖެނުއަރީ',
	        'ފެބްރުއަރީ',
	        'މާރިޗު',
	        'އޭޕްރީލު',
	        'މޭ',
	        'ޖޫން',
	        'ޖުލައި',
	        'އޯގަސްޓު',
	        'ސެޕްޓެމްބަރު',
	        'އޮކްޓޯބަރު',
	        'ނޮވެމްބަރު',
	        'ޑިސެމްބަރު'
	    ], weekdays = [
	        'އާދިއްތަ',
	        'ހޯމަ',
	        'އަންގާރަ',
	        'ބުދަ',
	        'ބުރާސްފަތި',
	        'ހުކުރު',
	        'ހޮނިހިރު'
	    ];
	
	    var dv = moment.defineLocale('dv', {
	        months : months,
	        monthsShort : months,
	        weekdays : weekdays,
	        weekdaysShort : weekdays,
	        weekdaysMin : 'އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި'.split('_'),
	        longDateFormat : {
	
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'D/M/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /މކ|މފ/,
	        isPM : function (input) {
	            return '' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'މކ';
	            } else {
	                return 'މފ';
	            }
	        },
	        calendar : {
	            sameDay : '[މިއަދު] LT',
	            nextDay : '[މާދަމާ] LT',
	            nextWeek : 'dddd LT',
	            lastDay : '[އިއްޔެ] LT',
	            lastWeek : '[ފާއިތުވި] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'ތެރޭގައި %s',
	            past : 'ކުރިން %s',
	            s : 'ސިކުންތުކޮޅެއް',
	            m : 'މިނިޓެއް',
	            mm : 'މިނިޓު %d',
	            h : 'ގަޑިއިރެއް',
	            hh : 'ގަޑިއިރު %d',
	            d : 'ދުވަހެއް',
	            dd : 'ދުވަސް %d',
	            M : 'މަހެއް',
	            MM : 'މަސް %d',
	            y : 'އަހަރެއް',
	            yy : 'އަހަރު %d'
	        },
	        preparse: function (string) {
	            return string.replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/,/g, '،');
	        },
	        week : {
	            dow : 7,  // Sunday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return dv;
	
	}));

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : modern greek (el)
	//! author : Aggelos Karalias : https://github.com/mehiel
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	    function isFunction(input) {
	        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	    }
	
	
	    var el = moment.defineLocale('el', {
	        monthsNominativeEl : 'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split('_'),
	        monthsGenitiveEl : 'Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου'.split('_'),
	        months : function (momentToFormat, format) {
	            if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
	                return this._monthsGenitiveEl[momentToFormat.month()];
	            } else {
	                return this._monthsNominativeEl[momentToFormat.month()];
	            }
	        },
	        monthsShort : 'Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ'.split('_'),
	        weekdays : 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split('_'),
	        weekdaysShort : 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
	        weekdaysMin : 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'μμ' : 'ΜΜ';
	            } else {
	                return isLower ? 'πμ' : 'ΠΜ';
	            }
	        },
	        isPM : function (input) {
	            return ((input + '').toLowerCase()[0] === 'μ');
	        },
	        meridiemParse : /[ΠΜ]\.?Μ?\.?/i,
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendarEl : {
	            sameDay : '[Σήμερα {}] LT',
	            nextDay : '[Αύριο {}] LT',
	            nextWeek : 'dddd [{}] LT',
	            lastDay : '[Χθες {}] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 6:
	                        return '[το προηγούμενο] dddd [{}] LT';
	                    default:
	                        return '[την προηγούμενη] dddd [{}] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        calendar : function (key, mom) {
	            var output = this._calendarEl[key],
	                hours = mom && mom.hours();
	            if (isFunction(output)) {
	                output = output.apply(mom);
	            }
	            return output.replace('{}', (hours % 12 === 1 ? 'στη' : 'στις'));
	        },
	        relativeTime : {
	            future : 'σε %s',
	            past : '%s πριν',
	            s : 'λίγα δευτερόλεπτα',
	            m : 'ένα λεπτό',
	            mm : '%d λεπτά',
	            h : 'μία ώρα',
	            hh : '%d ώρες',
	            d : 'μία μέρα',
	            dd : '%d μέρες',
	            M : 'ένας μήνας',
	            MM : '%d μήνες',
	            y : 'ένας χρόνος',
	            yy : '%d χρόνια'
	        },
	        ordinalParse: /\d{1,2}η/,
	        ordinal: '%dη',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4st is the first week of the year.
	        }
	    });
	
	    return el;
	
	}));

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : australian english (en-au)
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var en_au = moment.defineLocale('en-au', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return en_au;
	
	}));

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : canadian english (en-ca)
	//! author : Jonathan Abourbih : https://github.com/jonbca
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var en_ca = moment.defineLocale('en-ca', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM, YYYY',
	            LLL : 'D MMMM, YYYY h:mm A',
	            LLLL : 'dddd, D MMMM, YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });
	
	    return en_ca;
	
	}));

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : great britain english (en-gb)
	//! author : Chris Gedrim : https://github.com/chrisgedrim
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var en_gb = moment.defineLocale('en-gb', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return en_gb;
	
	}));

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Irish english (en-ie)
	//! author : Chris Cartlidge : https://github.com/chriscartlidge
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var en_ie = moment.defineLocale('en-ie', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return en_ie;
	
	}));

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : New Zealand english (en-nz)
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var en_nz = moment.defineLocale('en-nz', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return en_nz;
	
	}));

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : esperanto (eo)
	//! author : Colin Dean : https://github.com/colindean
	//! komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
	//!          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var eo = moment.defineLocale('eo', {
	        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec'.split('_'),
	        weekdays : 'Dimanĉo_Lundo_Mardo_Merkredo_Ĵaŭdo_Vendredo_Sabato'.split('_'),
	        weekdaysShort : 'Dim_Lun_Mard_Merk_Ĵaŭ_Ven_Sab'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Ĵa_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D[-an de] MMMM, YYYY',
	            LLL : 'D[-an de] MMMM, YYYY HH:mm',
	            LLLL : 'dddd, [la] D[-an de] MMMM, YYYY HH:mm'
	        },
	        meridiemParse: /[ap]\.t\.m/i,
	        isPM: function (input) {
	            return input.charAt(0).toLowerCase() === 'p';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'p.t.m.' : 'P.T.M.';
	            } else {
	                return isLower ? 'a.t.m.' : 'A.T.M.';
	            }
	        },
	        calendar : {
	            sameDay : '[Hodiaŭ je] LT',
	            nextDay : '[Morgaŭ je] LT',
	            nextWeek : 'dddd [je] LT',
	            lastDay : '[Hieraŭ je] LT',
	            lastWeek : '[pasinta] dddd [je] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'je %s',
	            past : 'antaŭ %s',
	            s : 'sekundoj',
	            m : 'minuto',
	            mm : '%d minutoj',
	            h : 'horo',
	            hh : '%d horoj',
	            d : 'tago',//ne 'diurno', ĉar estas uzita por proksimumo
	            dd : '%d tagoj',
	            M : 'monato',
	            MM : '%d monatoj',
	            y : 'jaro',
	            yy : '%d jaroj'
	        },
	        ordinalParse: /\d{1,2}a/,
	        ordinal : '%da',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return eo;
	
	}));

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : spanish (es)
	//! author : Julio Napurí : https://github.com/julionc
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
	        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');
	
	    var es = moment.defineLocale('es', {
	        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShort[m.month()];
	            } else {
	                return monthsShortDot[m.month()];
	            }
	        },
	        weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
	        weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
	        weekdaysMin : 'do_lu_ma_mi_ju_vi_sá'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY H:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextDay : function () {
	                return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastDay : function () {
	                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'hace %s',
	            s : 'unos segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'una hora',
	            hh : '%d horas',
	            d : 'un día',
	            dd : '%d días',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un año',
	            yy : '%d años'
	        },
	        ordinalParse : /\d{1,2}º/,
	        ordinal : '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return es;
	
	}));

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : estonian (et)
	//! author : Henry Kehlmann : https://github.com/madhenry
	//! improvements : Illimar Tambek : https://github.com/ragulka
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            's' : ['mõne sekundi', 'mõni sekund', 'paar sekundit'],
	            'm' : ['ühe minuti', 'üks minut'],
	            'mm': [number + ' minuti', number + ' minutit'],
	            'h' : ['ühe tunni', 'tund aega', 'üks tund'],
	            'hh': [number + ' tunni', number + ' tundi'],
	            'd' : ['ühe päeva', 'üks päev'],
	            'M' : ['kuu aja', 'kuu aega', 'üks kuu'],
	            'MM': [number + ' kuu', number + ' kuud'],
	            'y' : ['ühe aasta', 'aasta', 'üks aasta'],
	            'yy': [number + ' aasta', number + ' aastat']
	        };
	        if (withoutSuffix) {
	            return format[key][2] ? format[key][2] : format[key][1];
	        }
	        return isFuture ? format[key][0] : format[key][1];
	    }
	
	    var et = moment.defineLocale('et', {
	        months        : 'jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
	        monthsShort   : 'jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
	        weekdays      : 'pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev'.split('_'),
	        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
	        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
	        longDateFormat : {
	            LT   : 'H:mm',
	            LTS : 'H:mm:ss',
	            L    : 'DD.MM.YYYY',
	            LL   : 'D. MMMM YYYY',
	            LLL  : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[Täna,] LT',
	            nextDay  : '[Homme,] LT',
	            nextWeek : '[Järgmine] dddd LT',
	            lastDay  : '[Eile,] LT',
	            lastWeek : '[Eelmine] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s pärast',
	            past   : '%s tagasi',
	            s      : processRelativeTime,
	            m      : processRelativeTime,
	            mm     : processRelativeTime,
	            h      : processRelativeTime,
	            hh     : processRelativeTime,
	            d      : processRelativeTime,
	            dd     : '%d päeva',
	            M      : processRelativeTime,
	            MM     : processRelativeTime,
	            y      : processRelativeTime,
	            yy     : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return et;
	
	}));

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : euskara (eu)
	//! author : Eneko Illarramendi : https://github.com/eillarra
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var eu = moment.defineLocale('eu', {
	        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
	        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
	        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
	        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
	        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY[ko] MMMM[ren] D[a]',
	            LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
	            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
	            l : 'YYYY-M-D',
	            ll : 'YYYY[ko] MMM D[a]',
	            lll : 'YYYY[ko] MMM D[a] HH:mm',
	            llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
	        },
	        calendar : {
	            sameDay : '[gaur] LT[etan]',
	            nextDay : '[bihar] LT[etan]',
	            nextWeek : 'dddd LT[etan]',
	            lastDay : '[atzo] LT[etan]',
	            lastWeek : '[aurreko] dddd LT[etan]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s barru',
	            past : 'duela %s',
	            s : 'segundo batzuk',
	            m : 'minutu bat',
	            mm : '%d minutu',
	            h : 'ordu bat',
	            hh : '%d ordu',
	            d : 'egun bat',
	            dd : '%d egun',
	            M : 'hilabete bat',
	            MM : '%d hilabete',
	            y : 'urte bat',
	            yy : '%d urte'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return eu;
	
	}));

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Persian (fa)
	//! author : Ebrahim Byagowi : https://github.com/ebraminio
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '۱',
	        '2': '۲',
	        '3': '۳',
	        '4': '۴',
	        '5': '۵',
	        '6': '۶',
	        '7': '۷',
	        '8': '۸',
	        '9': '۹',
	        '0': '۰'
	    }, numberMap = {
	        '۱': '1',
	        '۲': '2',
	        '۳': '3',
	        '۴': '4',
	        '۵': '5',
	        '۶': '6',
	        '۷': '7',
	        '۸': '8',
	        '۹': '9',
	        '۰': '0'
	    };
	
	    var fa = moment.defineLocale('fa', {
	        months : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
	        monthsShort : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
	        weekdays : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
	        weekdaysShort : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
	        weekdaysMin : 'ی_د_س_چ_پ_ج_ش'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /قبل از ظهر|بعد از ظهر/,
	        isPM: function (input) {
	            return /بعد از ظهر/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'قبل از ظهر';
	            } else {
	                return 'بعد از ظهر';
	            }
	        },
	        calendar : {
	            sameDay : '[امروز ساعت] LT',
	            nextDay : '[فردا ساعت] LT',
	            nextWeek : 'dddd [ساعت] LT',
	            lastDay : '[دیروز ساعت] LT',
	            lastWeek : 'dddd [پیش] [ساعت] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'در %s',
	            past : '%s پیش',
	            s : 'چندین ثانیه',
	            m : 'یک دقیقه',
	            mm : '%d دقیقه',
	            h : 'یک ساعت',
	            hh : '%d ساعت',
	            d : 'یک روز',
	            dd : '%d روز',
	            M : 'یک ماه',
	            MM : '%d ماه',
	            y : 'یک سال',
	            yy : '%d سال'
	        },
	        preparse: function (string) {
	            return string.replace(/[۰-۹]/g, function (match) {
	                return numberMap[match];
	            }).replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '،');
	        },
	        ordinalParse: /\d{1,2}م/,
	        ordinal : '%dم',
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12 // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return fa;
	
	}));

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : finnish (fi)
	//! author : Tarmo Aidantausta : https://github.com/bleadof
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var numbersPast = 'nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän'.split(' '),
	        numbersFuture = [
	            'nolla', 'yhden', 'kahden', 'kolmen', 'neljän', 'viiden', 'kuuden',
	            numbersPast[7], numbersPast[8], numbersPast[9]
	        ];
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = '';
	        switch (key) {
	        case 's':
	            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
	        case 'm':
	            return isFuture ? 'minuutin' : 'minuutti';
	        case 'mm':
	            result = isFuture ? 'minuutin' : 'minuuttia';
	            break;
	        case 'h':
	            return isFuture ? 'tunnin' : 'tunti';
	        case 'hh':
	            result = isFuture ? 'tunnin' : 'tuntia';
	            break;
	        case 'd':
	            return isFuture ? 'päivän' : 'päivä';
	        case 'dd':
	            result = isFuture ? 'päivän' : 'päivää';
	            break;
	        case 'M':
	            return isFuture ? 'kuukauden' : 'kuukausi';
	        case 'MM':
	            result = isFuture ? 'kuukauden' : 'kuukautta';
	            break;
	        case 'y':
	            return isFuture ? 'vuoden' : 'vuosi';
	        case 'yy':
	            result = isFuture ? 'vuoden' : 'vuotta';
	            break;
	        }
	        result = verbalNumber(number, isFuture) + ' ' + result;
	        return result;
	    }
	    function verbalNumber(number, isFuture) {
	        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
	    }
	
	    var fi = moment.defineLocale('fi', {
	        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
	        monthsShort : 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split('_'),
	        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
	        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
	        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD.MM.YYYY',
	            LL : 'Do MMMM[ta] YYYY',
	            LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
	            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
	            l : 'D.M.YYYY',
	            ll : 'Do MMM YYYY',
	            lll : 'Do MMM YYYY, [klo] HH.mm',
	            llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
	        },
	        calendar : {
	            sameDay : '[tänään] [klo] LT',
	            nextDay : '[huomenna] [klo] LT',
	            nextWeek : 'dddd [klo] LT',
	            lastDay : '[eilen] [klo] LT',
	            lastWeek : '[viime] dddd[na] [klo] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s päästä',
	            past : '%s sitten',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return fi;
	
	}));

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : faroese (fo)
	//! author : Ragnar Johannesen : https://github.com/ragnar123
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var fo = moment.defineLocale('fo', {
	        months : 'januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur'.split('_'),
	        weekdaysShort : 'sun_mán_týs_mik_hós_frí_ley'.split('_'),
	        weekdaysMin : 'su_má_tý_mi_hó_fr_le'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D. MMMM, YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Í dag kl.] LT',
	            nextDay : '[Í morgin kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[Í gjár kl.] LT',
	            lastWeek : '[síðstu] dddd [kl] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'um %s',
	            past : '%s síðani',
	            s : 'fá sekund',
	            m : 'ein minutt',
	            mm : '%d minuttir',
	            h : 'ein tími',
	            hh : '%d tímar',
	            d : 'ein dagur',
	            dd : '%d dagar',
	            M : 'ein mánaði',
	            MM : '%d mánaðir',
	            y : 'eitt ár',
	            yy : '%d ár'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return fo;
	
	}));

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : canadian french (fr-ca)
	//! author : Jonathan Abourbih : https://github.com/jonbca
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var fr_ca = moment.defineLocale('fr-ca', {
	        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui à] LT',
	            nextDay: '[Demain à] LT',
	            nextWeek: 'dddd [à] LT',
	            lastDay: '[Hier à] LT',
	            lastWeek: 'dddd [dernier à] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|e)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : 'e');
	        }
	    });
	
	    return fr_ca;
	
	}));

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : swiss french (fr)
	//! author : Gaspard Bucher : https://github.com/gaspard
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var fr_ch = moment.defineLocale('fr-ch', {
	        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui à] LT',
	            nextDay: '[Demain à] LT',
	            nextWeek: 'dddd [à] LT',
	            lastDay: '[Hier à] LT',
	            lastWeek: 'dddd [dernier à] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|e)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : 'e');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return fr_ch;
	
	}));

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : french (fr)
	//! author : John Fischer : https://github.com/jfroffice
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var fr = moment.defineLocale('fr', {
	        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui à] LT',
	            nextDay: '[Demain à] LT',
	            nextWeek: 'dddd [à] LT',
	            lastDay: '[Hier à] LT',
	            lastWeek: 'dddd [dernier à] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : '');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return fr;
	
	}));

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : frisian (fy)
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
	        monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');
	
	    var fy = moment.defineLocale('fy', {
	        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShortWithoutDots[m.month()];
	            } else {
	                return monthsShortWithDots[m.month()];
	            }
	        },
	        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
	        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
	        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[hjoed om] LT',
	            nextDay: '[moarn om] LT',
	            nextWeek: 'dddd [om] LT',
	            lastDay: '[juster om] LT',
	            lastWeek: '[ôfrûne] dddd [om] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'oer %s',
	            past : '%s lyn',
	            s : 'in pear sekonden',
	            m : 'ien minút',
	            mm : '%d minuten',
	            h : 'ien oere',
	            hh : '%d oeren',
	            d : 'ien dei',
	            dd : '%d dagen',
	            M : 'ien moanne',
	            MM : '%d moannen',
	            y : 'ien jier',
	            yy : '%d jierren'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return fy;
	
	}));

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : great britain scottish gealic (gd)
	//! author : Jon Ashdown : https://github.com/jonashdown
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var months = [
	        'Am Faoilleach', 'An Gearran', 'Am Màrt', 'An Giblean', 'An Cèitean', 'An t-Ògmhios', 'An t-Iuchar', 'An Lùnastal', 'An t-Sultain', 'An Dàmhair', 'An t-Samhain', 'An Dùbhlachd'
	    ];
	
	    var monthsShort = ['Faoi', 'Gear', 'Màrt', 'Gibl', 'Cèit', 'Ògmh', 'Iuch', 'Lùn', 'Sult', 'Dàmh', 'Samh', 'Dùbh'];
	
	    var weekdays = ['Didòmhnaich', 'Diluain', 'Dimàirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];
	
	    var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];
	
	    var weekdaysMin = ['Dò', 'Lu', 'Mà', 'Ci', 'Ar', 'Ha', 'Sa'];
	
	    var gd = moment.defineLocale('gd', {
	        months : months,
	        monthsShort : monthsShort,
	        monthsParseExact : true,
	        weekdays : weekdays,
	        weekdaysShort : weekdaysShort,
	        weekdaysMin : weekdaysMin,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[An-diugh aig] LT',
	            nextDay : '[A-màireach aig] LT',
	            nextWeek : 'dddd [aig] LT',
	            lastDay : '[An-dè aig] LT',
	            lastWeek : 'dddd [seo chaidh] [aig] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'ann an %s',
	            past : 'bho chionn %s',
	            s : 'beagan diogan',
	            m : 'mionaid',
	            mm : '%d mionaidean',
	            h : 'uair',
	            hh : '%d uairean',
	            d : 'latha',
	            dd : '%d latha',
	            M : 'mìos',
	            MM : '%d mìosan',
	            y : 'bliadhna',
	            yy : '%d bliadhna'
	        },
	        ordinalParse : /\d{1,2}(d|na|mh)/,
	        ordinal : function (number) {
	            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return gd;
	
	}));

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : galician (gl)
	//! author : Juan G. Hurtado : https://github.com/juanghurtado
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var gl = moment.defineLocale('gl', {
	        months : 'Xaneiro_Febreiro_Marzo_Abril_Maio_Xuño_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro'.split('_'),
	        monthsShort : 'Xan._Feb._Mar._Abr._Mai._Xuñ._Xul._Ago._Set._Out._Nov._Dec.'.split('_'),
	        weekdays : 'Domingo_Luns_Martes_Mércores_Xoves_Venres_Sábado'.split('_'),
	        weekdaysShort : 'Dom._Lun._Mar._Mér._Xov._Ven._Sáb.'.split('_'),
	        weekdaysMin : 'Do_Lu_Ma_Mé_Xo_Ve_Sá'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoxe ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
	            },
	            nextDay : function () {
	                return '[mañá ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
	            },
	            lastDay : function () {
	                return '[onte ' + ((this.hours() !== 1) ? 'á' : 'a') + '] LT';
	            },
	            lastWeek : function () {
	                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : function (str) {
	                if (str === 'uns segundos') {
	                    return 'nuns segundos';
	                }
	                return 'en ' + str;
	            },
	            past : 'hai %s',
	            s : 'uns segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'unha hora',
	            hh : '%d horas',
	            d : 'un día',
	            dd : '%d días',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un ano',
	            yy : '%d anos'
	        },
	        ordinalParse : /\d{1,2}º/,
	        ordinal : '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return gl;
	
	}));

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hebrew (he)
	//! author : Tomer Cohen : https://github.com/tomer
	//! author : Moshe Simantov : https://github.com/DevelopmentIL
	//! author : Tal Ater : https://github.com/TalAter
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var he = moment.defineLocale('he', {
	        months : 'ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר'.split('_'),
	        monthsShort : 'ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳'.split('_'),
	        weekdays : 'ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת'.split('_'),
	        weekdaysShort : 'א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳'.split('_'),
	        weekdaysMin : 'א_ב_ג_ד_ה_ו_ש'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [ב]MMMM YYYY',
	            LLL : 'D [ב]MMMM YYYY HH:mm',
	            LLLL : 'dddd, D [ב]MMMM YYYY HH:mm',
	            l : 'D/M/YYYY',
	            ll : 'D MMM YYYY',
	            lll : 'D MMM YYYY HH:mm',
	            llll : 'ddd, D MMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[היום ב־]LT',
	            nextDay : '[מחר ב־]LT',
	            nextWeek : 'dddd [בשעה] LT',
	            lastDay : '[אתמול ב־]LT',
	            lastWeek : '[ביום] dddd [האחרון בשעה] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'בעוד %s',
	            past : 'לפני %s',
	            s : 'מספר שניות',
	            m : 'דקה',
	            mm : '%d דקות',
	            h : 'שעה',
	            hh : function (number) {
	                if (number === 2) {
	                    return 'שעתיים';
	                }
	                return number + ' שעות';
	            },
	            d : 'יום',
	            dd : function (number) {
	                if (number === 2) {
	                    return 'יומיים';
	                }
	                return number + ' ימים';
	            },
	            M : 'חודש',
	            MM : function (number) {
	                if (number === 2) {
	                    return 'חודשיים';
	                }
	                return number + ' חודשים';
	            },
	            y : 'שנה',
	            yy : function (number) {
	                if (number === 2) {
	                    return 'שנתיים';
	                } else if (number % 10 === 0 && number !== 10) {
	                    return number + ' שנה';
	                }
	                return number + ' שנים';
	            }
	        }
	    });
	
	    return he;
	
	}));

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : hindi (hi)
	//! author : Mayank Singhal : https://github.com/mayanksinghal
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '१',
	        '2': '२',
	        '3': '३',
	        '4': '४',
	        '5': '५',
	        '6': '६',
	        '7': '७',
	        '8': '८',
	        '9': '९',
	        '0': '०'
	    },
	    numberMap = {
	        '१': '1',
	        '२': '2',
	        '३': '3',
	        '४': '4',
	        '५': '5',
	        '६': '6',
	        '७': '7',
	        '८': '8',
	        '९': '9',
	        '०': '0'
	    };
	
	    var hi = moment.defineLocale('hi', {
	        months : 'जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर'.split('_'),
	        monthsShort : 'जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.'.split('_'),
	        weekdays : 'रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
	        weekdaysShort : 'रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि'.split('_'),
	        weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm बजे',
	            LTS : 'A h:mm:ss बजे',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm बजे',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm बजे'
	        },
	        calendar : {
	            sameDay : '[आज] LT',
	            nextDay : '[कल] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[कल] LT',
	            lastWeek : '[पिछले] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s में',
	            past : '%s पहले',
	            s : 'कुछ ही क्षण',
	            m : 'एक मिनट',
	            mm : '%d मिनट',
	            h : 'एक घंटा',
	            hh : '%d घंटे',
	            d : 'एक दिन',
	            dd : '%d दिन',
	            M : 'एक महीने',
	            MM : '%d महीने',
	            y : 'एक वर्ष',
	            yy : '%d वर्ष'
	        },
	        preparse: function (string) {
	            return string.replace(/[१२३४५६७८९०]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
	        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
	        meridiemParse: /रात|सुबह|दोपहर|शाम/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'रात') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === 'सुबह') {
	                return hour;
	            } else if (meridiem === 'दोपहर') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'शाम') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'रात';
	            } else if (hour < 10) {
	                return 'सुबह';
	            } else if (hour < 17) {
	                return 'दोपहर';
	            } else if (hour < 20) {
	                return 'शाम';
	            } else {
	                return 'रात';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return hi;
	
	}));

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : hrvatski (hr)
	//! author : Bojan Marković : https://github.com/bmarkovic
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	        }
	    }
	
	    var hr = moment.defineLocale('hr', {
	        months : {
	            format: 'siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
	            standalone: 'siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
	        },
	        monthsShort : 'sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
	        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
	        weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
	        weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD. MM. YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[danas u] LT',
	            nextDay  : '[sutra u] LT',
	            nextWeek : function () {
	                switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[jučer u] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prošlu] dddd [u] LT';
	                case 6:
	                    return '[prošle] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prošli] dddd [u] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'par sekundi',
	            m      : translate,
	            mm     : translate,
	            h      : translate,
	            hh     : translate,
	            d      : 'dan',
	            dd     : translate,
	            M      : 'mjesec',
	            MM     : translate,
	            y      : 'godinu',
	            yy     : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return hr;
	
	}));

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : hungarian (hu)
	//! author : Adam Brunner : https://github.com/adambrunner
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var weekEndings = 'vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton'.split(' ');
	    function translate(number, withoutSuffix, key, isFuture) {
	        var num = number,
	            suffix;
	        switch (key) {
	        case 's':
	            return (isFuture || withoutSuffix) ? 'néhány másodperc' : 'néhány másodperce';
	        case 'm':
	            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'mm':
	            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'h':
	            return 'egy' + (isFuture || withoutSuffix ? ' óra' : ' órája');
	        case 'hh':
	            return num + (isFuture || withoutSuffix ? ' óra' : ' órája');
	        case 'd':
	            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'dd':
	            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'M':
	            return 'egy' + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
	        case 'MM':
	            return num + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
	        case 'y':
	            return 'egy' + (isFuture || withoutSuffix ? ' év' : ' éve');
	        case 'yy':
	            return num + (isFuture || withoutSuffix ? ' év' : ' éve');
	        }
	        return '';
	    }
	    function week(isFuture) {
	        return (isFuture ? '' : '[múlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
	    }
	
	    var hu = moment.defineLocale('hu', {
	        months : 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split('_'),
	        monthsShort : 'jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec'.split('_'),
	        weekdays : 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
	        weekdaysShort : 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
	        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'YYYY.MM.DD.',
	            LL : 'YYYY. MMMM D.',
	            LLL : 'YYYY. MMMM D. H:mm',
	            LLLL : 'YYYY. MMMM D., dddd H:mm'
	        },
	        meridiemParse: /de|du/i,
	        isPM: function (input) {
	            return input.charAt(1).toLowerCase() === 'u';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower === true ? 'de' : 'DE';
	            } else {
	                return isLower === true ? 'du' : 'DU';
	            }
	        },
	        calendar : {
	            sameDay : '[ma] LT[-kor]',
	            nextDay : '[holnap] LT[-kor]',
	            nextWeek : function () {
	                return week.call(this, true);
	            },
	            lastDay : '[tegnap] LT[-kor]',
	            lastWeek : function () {
	                return week.call(this, false);
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s múlva',
	            past : '%s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return hu;
	
	}));

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Armenian (hy-am)
	//! author : Armendarabyan : https://github.com/armendarabyan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var hy_am = moment.defineLocale('hy-am', {
	        months : {
	            format: 'հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի'.split('_'),
	            standalone: 'հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր'.split('_')
	        },
	        monthsShort : 'հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ'.split('_'),
	        weekdays : 'կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ'.split('_'),
	        weekdaysShort : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
	        weekdaysMin : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY թ.',
	            LLL : 'D MMMM YYYY թ., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY թ., HH:mm'
	        },
	        calendar : {
	            sameDay: '[այսօր] LT',
	            nextDay: '[վաղը] LT',
	            lastDay: '[երեկ] LT',
	            nextWeek: function () {
	                return 'dddd [օրը ժամը] LT';
	            },
	            lastWeek: function () {
	                return '[անցած] dddd [օրը ժամը] LT';
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s հետո',
	            past : '%s առաջ',
	            s : 'մի քանի վայրկյան',
	            m : 'րոպե',
	            mm : '%d րոպե',
	            h : 'ժամ',
	            hh : '%d ժամ',
	            d : 'օր',
	            dd : '%d օր',
	            M : 'ամիս',
	            MM : '%d ամիս',
	            y : 'տարի',
	            yy : '%d տարի'
	        },
	        meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
	        isPM: function (input) {
	            return /^(ցերեկվա|երեկոյան)$/.test(input);
	        },
	        meridiem : function (hour) {
	            if (hour < 4) {
	                return 'գիշերվա';
	            } else if (hour < 12) {
	                return 'առավոտվա';
	            } else if (hour < 17) {
	                return 'ցերեկվա';
	            } else {
	                return 'երեկոյան';
	            }
	        },
	        ordinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'DDD':
	            case 'w':
	            case 'W':
	            case 'DDDo':
	                if (number === 1) {
	                    return number + '-ին';
	                }
	                return number + '-րդ';
	            default:
	                return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return hy_am;
	
	}));

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bahasa Indonesia (id)
	//! author : Mohammad Satrio Utomo : https://github.com/tyok
	//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var id = moment.defineLocale('id', {
	        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
	        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
	        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /pagi|siang|sore|malam/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'siang') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'sore' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'siang';
	            } else if (hours < 19) {
	                return 'sore';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Besok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kemarin pukul] LT',
	            lastWeek : 'dddd [lalu pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lalu',
	            s : 'beberapa detik',
	            m : 'semenit',
	            mm : '%d menit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return id;
	
	}));

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : icelandic (is)
	//! author : Hinrik Örn Sigurðsson : https://github.com/hinrik
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function plural(n) {
	        if (n % 100 === 11) {
	            return true;
	        } else if (n % 10 === 1) {
	            return false;
	        }
	        return true;
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	        case 's':
	            return withoutSuffix || isFuture ? 'nokkrar sekúndur' : 'nokkrum sekúndum';
	        case 'm':
	            return withoutSuffix ? 'mínúta' : 'mínútu';
	        case 'mm':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'mínútur' : 'mínútum');
	            } else if (withoutSuffix) {
	                return result + 'mínúta';
	            }
	            return result + 'mínútu';
	        case 'hh':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
	            }
	            return result + 'klukkustund';
	        case 'd':
	            if (withoutSuffix) {
	                return 'dagur';
	            }
	            return isFuture ? 'dag' : 'degi';
	        case 'dd':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'dagar';
	                }
	                return result + (isFuture ? 'daga' : 'dögum');
	            } else if (withoutSuffix) {
	                return result + 'dagur';
	            }
	            return result + (isFuture ? 'dag' : 'degi');
	        case 'M':
	            if (withoutSuffix) {
	                return 'mánuður';
	            }
	            return isFuture ? 'mánuð' : 'mánuði';
	        case 'MM':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'mánuðir';
	                }
	                return result + (isFuture ? 'mánuði' : 'mánuðum');
	            } else if (withoutSuffix) {
	                return result + 'mánuður';
	            }
	            return result + (isFuture ? 'mánuð' : 'mánuði');
	        case 'y':
	            return withoutSuffix || isFuture ? 'ár' : 'ári';
	        case 'yy':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'ár' : 'árum');
	            }
	            return result + (withoutSuffix || isFuture ? 'ár' : 'ári');
	        }
	    }
	
	    var is = moment.defineLocale('is', {
	        months : 'janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des'.split('_'),
	        weekdays : 'sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur'.split('_'),
	        weekdaysShort : 'sun_mán_þri_mið_fim_fös_lau'.split('_'),
	        weekdaysMin : 'Su_Má_Þr_Mi_Fi_Fö_La'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] H:mm',
	            LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
	        },
	        calendar : {
	            sameDay : '[í dag kl.] LT',
	            nextDay : '[á morgun kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[í gær kl.] LT',
	            lastWeek : '[síðasta] dddd [kl.] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'eftir %s',
	            past : 'fyrir %s síðan',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : 'klukkustund',
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return is;
	
	}));

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : italian (it)
	//! author : Lorenzo : https://github.com/aliem
	//! author: Mattia Larentis: https://github.com/nostalgiaz
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var it = moment.defineLocale('it', {
	        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
	        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
	        weekdays : 'Domenica_Lunedì_Martedì_Mercoledì_Giovedì_Venerdì_Sabato'.split('_'),
	        weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
	        weekdaysMin : 'Do_Lu_Ma_Me_Gi_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Oggi alle] LT',
	            nextDay: '[Domani alle] LT',
	            nextWeek: 'dddd [alle] LT',
	            lastDay: '[Ieri alle] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[la scorsa] dddd [alle] LT';
	                    default:
	                        return '[lo scorso] dddd [alle] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : function (s) {
	                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
	            },
	            past : '%s fa',
	            s : 'alcuni secondi',
	            m : 'un minuto',
	            mm : '%d minuti',
	            h : 'un\'ora',
	            hh : '%d ore',
	            d : 'un giorno',
	            dd : '%d giorni',
	            M : 'un mese',
	            MM : '%d mesi',
	            y : 'un anno',
	            yy : '%d anni'
	        },
	        ordinalParse : /\d{1,2}º/,
	        ordinal: '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return it;
	
	}));

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : japanese (ja)
	//! author : LI Long : https://github.com/baryon
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ja = moment.defineLocale('ja', {
	        months : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        weekdays : '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
	        weekdaysShort : '日_月_火_水_木_金_土'.split('_'),
	        weekdaysMin : '日_月_火_水_木_金_土'.split('_'),
	        longDateFormat : {
	            LT : 'Ah時m分',
	            LTS : 'Ah時m分s秒',
	            L : 'YYYY/MM/DD',
	            LL : 'YYYY年M月D日',
	            LLL : 'YYYY年M月D日Ah時m分',
	            LLLL : 'YYYY年M月D日Ah時m分 dddd'
	        },
	        meridiemParse: /午前|午後/i,
	        isPM : function (input) {
	            return input === '午後';
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '午前';
	            } else {
	                return '午後';
	            }
	        },
	        calendar : {
	            sameDay : '[今日] LT',
	            nextDay : '[明日] LT',
	            nextWeek : '[来週]dddd LT',
	            lastDay : '[昨日] LT',
	            lastWeek : '[前週]dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s後',
	            past : '%s前',
	            s : '数秒',
	            m : '1分',
	            mm : '%d分',
	            h : '1時間',
	            hh : '%d時間',
	            d : '1日',
	            dd : '%d日',
	            M : '1ヶ月',
	            MM : '%dヶ月',
	            y : '1年',
	            yy : '%d年'
	        }
	    });
	
	    return ja;
	
	}));

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Boso Jowo (jv)
	//! author : Rony Lantip : https://github.com/lantip
	//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var jv = moment.defineLocale('jv', {
	        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
	        weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
	        weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
	        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /enjing|siyang|sonten|ndalu/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'enjing') {
	                return hour;
	            } else if (meridiem === 'siyang') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'enjing';
	            } else if (hours < 15) {
	                return 'siyang';
	            } else if (hours < 19) {
	                return 'sonten';
	            } else {
	                return 'ndalu';
	            }
	        },
	        calendar : {
	            sameDay : '[Dinten puniko pukul] LT',
	            nextDay : '[Mbenjang pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kala wingi pukul] LT',
	            lastWeek : 'dddd [kepengker pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'wonten ing %s',
	            past : '%s ingkang kepengker',
	            s : 'sawetawis detik',
	            m : 'setunggal menit',
	            mm : '%d menit',
	            h : 'setunggal jam',
	            hh : '%d jam',
	            d : 'sedinten',
	            dd : '%d dinten',
	            M : 'sewulan',
	            MM : '%d wulan',
	            y : 'setaun',
	            yy : '%d taun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return jv;
	
	}));

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Georgian (ka)
	//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ka = moment.defineLocale('ka', {
	        months : {
	            standalone: 'იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი'.split('_'),
	            format: 'იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს'.split('_')
	        },
	        monthsShort : 'იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ'.split('_'),
	        weekdays : {
	            standalone: 'კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი'.split('_'),
	            format: 'კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს'.split('_'),
	            isFormat: /(წინა|შემდეგ)/
	        },
	        weekdaysShort : 'კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ'.split('_'),
	        weekdaysMin : 'კვ_ორ_სა_ოთ_ხუ_პა_შა'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[დღეს] LT[-ზე]',
	            nextDay : '[ხვალ] LT[-ზე]',
	            lastDay : '[გუშინ] LT[-ზე]',
	            nextWeek : '[შემდეგ] dddd LT[-ზე]',
	            lastWeek : '[წინა] dddd LT-ზე',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : function (s) {
	                return (/(წამი|წუთი|საათი|წელი)/).test(s) ?
	                    s.replace(/ი$/, 'ში') :
	                    s + 'ში';
	            },
	            past : function (s) {
	                if ((/(წამი|წუთი|საათი|დღე|თვე)/).test(s)) {
	                    return s.replace(/(ი|ე)$/, 'ის წინ');
	                }
	                if ((/წელი/).test(s)) {
	                    return s.replace(/წელი$/, 'წლის წინ');
	                }
	            },
	            s : 'რამდენიმე წამი',
	            m : 'წუთი',
	            mm : '%d წუთი',
	            h : 'საათი',
	            hh : '%d საათი',
	            d : 'დღე',
	            dd : '%d დღე',
	            M : 'თვე',
	            MM : '%d თვე',
	            y : 'წელი',
	            yy : '%d წელი'
	        },
	        ordinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
	        ordinal : function (number) {
	            if (number === 0) {
	                return number;
	            }
	            if (number === 1) {
	                return number + '-ლი';
	            }
	            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
	                return 'მე-' + number;
	            }
	            return number + '-ე';
	        },
	        week : {
	            dow : 1,
	            doy : 7
	        }
	    });
	
	    return ka;
	
	}));

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : kazakh (kk)
	//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var suffixes = {
	        0: '-ші',
	        1: '-ші',
	        2: '-ші',
	        3: '-ші',
	        4: '-ші',
	        5: '-ші',
	        6: '-шы',
	        7: '-ші',
	        8: '-ші',
	        9: '-шы',
	        10: '-шы',
	        20: '-шы',
	        30: '-шы',
	        40: '-шы',
	        50: '-ші',
	        60: '-шы',
	        70: '-ші',
	        80: '-ші',
	        90: '-шы',
	        100: '-ші'
	    };
	
	    var kk = moment.defineLocale('kk', {
	        months : 'Қаңтар_Ақпан_Наурыз_Сәуір_Мамыр_Маусым_Шілде_Тамыз_Қыркүйек_Қазан_Қараша_Желтоқсан'.split('_'),
	        monthsShort : 'Қаң_Ақп_Нау_Сәу_Мам_Мау_Шіл_Там_Қыр_Қаз_Қар_Жел'.split('_'),
	        weekdays : 'Жексенбі_Дүйсенбі_Сейсенбі_Сәрсенбі_Бейсенбі_Жұма_Сенбі'.split('_'),
	        weekdaysShort : 'Жек_Дүй_Сей_Сәр_Бей_Жұм_Сен'.split('_'),
	        weekdaysMin : 'Жк_Дй_Сй_Ср_Бй_Жм_Сн'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Бүгін сағат] LT',
	            nextDay : '[Ертең сағат] LT',
	            nextWeek : 'dddd [сағат] LT',
	            lastDay : '[Кеше сағат] LT',
	            lastWeek : '[Өткен аптаның] dddd [сағат] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ішінде',
	            past : '%s бұрын',
	            s : 'бірнеше секунд',
	            m : 'бір минут',
	            mm : '%d минут',
	            h : 'бір сағат',
	            hh : '%d сағат',
	            d : 'бір күн',
	            dd : '%d күн',
	            M : 'бір ай',
	            MM : '%d ай',
	            y : 'бір жыл',
	            yy : '%d жыл'
	        },
	        ordinalParse: /\d{1,2}-(ші|шы)/,
	        ordinal : function (number) {
	            var a = number % 10,
	                b = number >= 100 ? 100 : null;
	            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return kk;
	
	}));

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : khmer (km)
	//! author : Kruy Vanna : https://github.com/kruyvanna
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var km = moment.defineLocale('km', {
	        months: 'មករា_កុម្ភៈ_មិនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
	        monthsShort: 'មករា_កុម្ភៈ_មិនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
	        weekdays: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	        weekdaysShort: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	        weekdaysMin: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[ថ្ងៃនេះ ម៉ោង] LT',
	            nextDay: '[ស្អែក ម៉ោង] LT',
	            nextWeek: 'dddd [ម៉ោង] LT',
	            lastDay: '[ម្សិលមិញ ម៉ោង] LT',
	            lastWeek: 'dddd [សប្តាហ៍មុន] [ម៉ោង] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: '%sទៀត',
	            past: '%sមុន',
	            s: 'ប៉ុន្មានវិនាទី',
	            m: 'មួយនាទី',
	            mm: '%d នាទី',
	            h: 'មួយម៉ោង',
	            hh: '%d ម៉ោង',
	            d: 'មួយថ្ងៃ',
	            dd: '%d ថ្ងៃ',
	            M: 'មួយខែ',
	            MM: '%d ខែ',
	            y: 'មួយឆ្នាំ',
	            yy: '%d ឆ្នាំ'
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return km;
	
	}));

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : korean (ko)
	//!
	//! authors
	//!
	//! - Kyungwook, Park : https://github.com/kyungw00k
	//! - Jeeeyul Lee <jeeeyul@gmail.com>
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ko = moment.defineLocale('ko', {
	        months : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
	        monthsShort : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
	        weekdays : '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),
	        weekdaysShort : '일_월_화_수_목_금_토'.split('_'),
	        weekdaysMin : '일_월_화_수_목_금_토'.split('_'),
	        longDateFormat : {
	            LT : 'A h시 m분',
	            LTS : 'A h시 m분 s초',
	            L : 'YYYY.MM.DD',
	            LL : 'YYYY년 MMMM D일',
	            LLL : 'YYYY년 MMMM D일 A h시 m분',
	            LLLL : 'YYYY년 MMMM D일 dddd A h시 m분'
	        },
	        calendar : {
	            sameDay : '오늘 LT',
	            nextDay : '내일 LT',
	            nextWeek : 'dddd LT',
	            lastDay : '어제 LT',
	            lastWeek : '지난주 dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s 후',
	            past : '%s 전',
	            s : '몇초',
	            ss : '%d초',
	            m : '일분',
	            mm : '%d분',
	            h : '한시간',
	            hh : '%d시간',
	            d : '하루',
	            dd : '%d일',
	            M : '한달',
	            MM : '%d달',
	            y : '일년',
	            yy : '%d년'
	        },
	        ordinalParse : /\d{1,2}일/,
	        ordinal : '%d일',
	        meridiemParse : /오전|오후/,
	        isPM : function (token) {
	            return token === '오후';
	        },
	        meridiem : function (hour, minute, isUpper) {
	            return hour < 12 ? '오전' : '오후';
	        }
	    });
	
	    return ko;
	
	}));

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Luxembourgish (lb)
	//! author : mweimerskirch : https://github.com/mweimerskirch, David Raison : https://github.com/kwisatz
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eng Minutt', 'enger Minutt'],
	            'h': ['eng Stonn', 'enger Stonn'],
	            'd': ['een Dag', 'engem Dag'],
	            'M': ['ee Mount', 'engem Mount'],
	            'y': ['ee Joer', 'engem Joer']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }
	    function processFutureTime(string) {
	        var number = string.substr(0, string.indexOf(' '));
	        if (eifelerRegelAppliesToNumber(number)) {
	            return 'a ' + string;
	        }
	        return 'an ' + string;
	    }
	    function processPastTime(string) {
	        var number = string.substr(0, string.indexOf(' '));
	        if (eifelerRegelAppliesToNumber(number)) {
	            return 'viru ' + string;
	        }
	        return 'virun ' + string;
	    }
	    /**
	     * Returns true if the word before the given number loses the '-n' ending.
	     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
	     *
	     * @param number {integer}
	     * @returns {boolean}
	     */
	    function eifelerRegelAppliesToNumber(number) {
	        number = parseInt(number, 10);
	        if (isNaN(number)) {
	            return false;
	        }
	        if (number < 0) {
	            // Negative Number --> always true
	            return true;
	        } else if (number < 10) {
	            // Only 1 digit
	            if (4 <= number && number <= 7) {
	                return true;
	            }
	            return false;
	        } else if (number < 100) {
	            // 2 digits
	            var lastDigit = number % 10, firstDigit = number / 10;
	            if (lastDigit === 0) {
	                return eifelerRegelAppliesToNumber(firstDigit);
	            }
	            return eifelerRegelAppliesToNumber(lastDigit);
	        } else if (number < 10000) {
	            // 3 or 4 digits --> recursively check first digit
	            while (number >= 10) {
	                number = number / 10;
	            }
	            return eifelerRegelAppliesToNumber(number);
	        } else {
	            // Anything larger than 4 digits: recursively check first n-3 digits
	            number = number / 1000;
	            return eifelerRegelAppliesToNumber(number);
	        }
	    }
	
	    var lb = moment.defineLocale('lb', {
	        months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
	        weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),
	        weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),
	        longDateFormat: {
	            LT: 'H:mm [Auer]',
	            LTS: 'H:mm:ss [Auer]',
	            L: 'DD.MM.YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm [Auer]',
	            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
	        },
	        calendar: {
	            sameDay: '[Haut um] LT',
	            sameElse: 'L',
	            nextDay: '[Muer um] LT',
	            nextWeek: 'dddd [um] LT',
	            lastDay: '[Gëschter um] LT',
	            lastWeek: function () {
	                // Different date string for 'Dënschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
	                switch (this.day()) {
	                    case 2:
	                    case 4:
	                        return '[Leschten] dddd [um] LT';
	                    default:
	                        return '[Leschte] dddd [um] LT';
	                }
	            }
	        },
	        relativeTime : {
	            future : processFutureTime,
	            past : processPastTime,
	            s : 'e puer Sekonnen',
	            m : processRelativeTime,
	            mm : '%d Minutten',
	            h : processRelativeTime,
	            hh : '%d Stonnen',
	            d : processRelativeTime,
	            dd : '%d Deeg',
	            M : processRelativeTime,
	            MM : '%d Méint',
	            y : processRelativeTime,
	            yy : '%d Joer'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal: '%d.',
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return lb;
	
	}));

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : lao (lo)
	//! author : Ryan Hart : https://github.com/ryanhart2
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var lo = moment.defineLocale('lo', {
	        months : 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
	        monthsShort : 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
	        weekdays : 'ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
	        weekdaysShort : 'ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
	        weekdaysMin : 'ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'ວັນdddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
	        isPM: function (input) {
	            return input === 'ຕອນແລງ';
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ຕອນເຊົ້າ';
	            } else {
	                return 'ຕອນແລງ';
	            }
	        },
	        calendar : {
	            sameDay : '[ມື້ນີ້ເວລາ] LT',
	            nextDay : '[ມື້ອື່ນເວລາ] LT',
	            nextWeek : '[ວັນ]dddd[ໜ້າເວລາ] LT',
	            lastDay : '[ມື້ວານນີ້ເວລາ] LT',
	            lastWeek : '[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'ອີກ %s',
	            past : '%sຜ່ານມາ',
	            s : 'ບໍ່ເທົ່າໃດວິນາທີ',
	            m : '1 ນາທີ',
	            mm : '%d ນາທີ',
	            h : '1 ຊົ່ວໂມງ',
	            hh : '%d ຊົ່ວໂມງ',
	            d : '1 ມື້',
	            dd : '%d ມື້',
	            M : '1 ເດືອນ',
	            MM : '%d ເດືອນ',
	            y : '1 ປີ',
	            yy : '%d ປີ'
	        },
	        ordinalParse: /(ທີ່)\d{1,2}/,
	        ordinal : function (number) {
	            return 'ທີ່' + number;
	        }
	    });
	
	    return lo;
	
	}));

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lithuanian (lt)
	//! author : Mindaugas Mozūras : https://github.com/mmozuras
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var units = {
	        'm' : 'minutė_minutės_minutę',
	        'mm': 'minutės_minučių_minutes',
	        'h' : 'valanda_valandos_valandą',
	        'hh': 'valandos_valandų_valandas',
	        'd' : 'diena_dienos_dieną',
	        'dd': 'dienos_dienų_dienas',
	        'M' : 'mėnuo_mėnesio_mėnesį',
	        'MM': 'mėnesiai_mėnesių_mėnesius',
	        'y' : 'metai_metų_metus',
	        'yy': 'metai_metų_metus'
	    };
	    function translateSeconds(number, withoutSuffix, key, isFuture) {
	        if (withoutSuffix) {
	            return 'kelios sekundės';
	        } else {
	            return isFuture ? 'kelių sekundžių' : 'kelias sekundes';
	        }
	    }
	    function translateSingular(number, withoutSuffix, key, isFuture) {
	        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
	    }
	    function special(number) {
	        return number % 10 === 0 || (number > 10 && number < 20);
	    }
	    function forms(key) {
	        return units[key].split('_');
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        if (number === 1) {
	            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
	        } else if (withoutSuffix) {
	            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
	        } else {
	            if (isFuture) {
	                return result + forms(key)[1];
	            } else {
	                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
	            }
	        }
	    }
	    var lt = moment.defineLocale('lt', {
	        months : {
	            format: 'sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio'.split('_'),
	            standalone: 'sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis'.split('_')
	        },
	        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
	        weekdays : {
	            format: 'sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį'.split('_'),
	            standalone: 'sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis'.split('_'),
	            isFormat: /dddd HH:mm/
	        },
	        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_Šeš'.split('_'),
	        weekdaysMin : 'S_P_A_T_K_Pn_Š'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY [m.] MMMM D [d.]',
	            LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	            LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
	            l : 'YYYY-MM-DD',
	            ll : 'YYYY [m.] MMMM D [d.]',
	            lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	            llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
	        },
	        calendar : {
	            sameDay : '[Šiandien] LT',
	            nextDay : '[Rytoj] LT',
	            nextWeek : 'dddd LT',
	            lastDay : '[Vakar] LT',
	            lastWeek : '[Praėjusį] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'po %s',
	            past : 'prieš %s',
	            s : translateSeconds,
	            m : translateSingular,
	            mm : translate,
	            h : translateSingular,
	            hh : translate,
	            d : translateSingular,
	            dd : translate,
	            M : translateSingular,
	            MM : translate,
	            y : translateSingular,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}-oji/,
	        ordinal : function (number) {
	            return number + '-oji';
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return lt;
	
	}));

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : latvian (lv)
	//! author : Kristaps Karlsons : https://github.com/skakri
	//! author : Jānis Elmeris : https://github.com/JanisE
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var units = {
	        'm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
	        'mm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
	        'h': 'stundas_stundām_stunda_stundas'.split('_'),
	        'hh': 'stundas_stundām_stunda_stundas'.split('_'),
	        'd': 'dienas_dienām_diena_dienas'.split('_'),
	        'dd': 'dienas_dienām_diena_dienas'.split('_'),
	        'M': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
	        'MM': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
	        'y': 'gada_gadiem_gads_gadi'.split('_'),
	        'yy': 'gada_gadiem_gads_gadi'.split('_')
	    };
	    /**
	     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
	     */
	    function format(forms, number, withoutSuffix) {
	        if (withoutSuffix) {
	            // E.g. "21 minūte", "3 minūtes".
	            return number % 10 === 1 && number !== 11 ? forms[2] : forms[3];
	        } else {
	            // E.g. "21 minūtes" as in "pēc 21 minūtes".
	            // E.g. "3 minūtēm" as in "pēc 3 minūtēm".
	            return number % 10 === 1 && number !== 11 ? forms[0] : forms[1];
	        }
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        return number + ' ' + format(units[key], number, withoutSuffix);
	    }
	    function relativeTimeWithSingular(number, withoutSuffix, key) {
	        return format(units[key], number, withoutSuffix);
	    }
	    function relativeSeconds(number, withoutSuffix) {
	        return withoutSuffix ? 'dažas sekundes' : 'dažām sekundēm';
	    }
	
	    var lv = moment.defineLocale('lv', {
	        months : 'janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena'.split('_'),
	        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
	        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY.',
	            LL : 'YYYY. [gada] D. MMMM',
	            LLL : 'YYYY. [gada] D. MMMM, HH:mm',
	            LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
	        },
	        calendar : {
	            sameDay : '[Šodien pulksten] LT',
	            nextDay : '[Rīt pulksten] LT',
	            nextWeek : 'dddd [pulksten] LT',
	            lastDay : '[Vakar pulksten] LT',
	            lastWeek : '[Pagājušā] dddd [pulksten] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'pēc %s',
	            past : 'pirms %s',
	            s : relativeSeconds,
	            m : relativeTimeWithSingular,
	            mm : relativeTimeWithPlural,
	            h : relativeTimeWithSingular,
	            hh : relativeTimeWithPlural,
	            d : relativeTimeWithSingular,
	            dd : relativeTimeWithPlural,
	            M : relativeTimeWithSingular,
	            MM : relativeTimeWithPlural,
	            y : relativeTimeWithSingular,
	            yy : relativeTimeWithPlural
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return lv;
	
	}));

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Montenegrin (me)
	//! author : Miodrag Nikač <miodrag@restartit.me> : https://github.com/miodragnikac
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var translator = {
	        words: { //Different grammatical cases
	            m: ['jedan minut', 'jednog minuta'],
	            mm: ['minut', 'minuta', 'minuta'],
	            h: ['jedan sat', 'jednog sata'],
	            hh: ['sat', 'sata', 'sati'],
	            dd: ['dan', 'dana', 'dana'],
	            MM: ['mjesec', 'mjeseca', 'mjeseci'],
	            yy: ['godina', 'godine', 'godina']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };
	
	    var me = moment.defineLocale('me', {
	        months: ['januar', 'februar', 'mart', 'april', 'maj', 'jun', 'jul', 'avgust', 'septembar', 'oktobar', 'novembar', 'decembar'],
	        monthsShort: ['jan.', 'feb.', 'mar.', 'apr.', 'maj', 'jun', 'jul', 'avg.', 'sep.', 'okt.', 'nov.', 'dec.'],
	        weekdays: ['nedjelja', 'ponedjeljak', 'utorak', 'srijeda', 'četvrtak', 'petak', 'subota'],
	        weekdaysShort: ['ned.', 'pon.', 'uto.', 'sri.', 'čet.', 'pet.', 'sub.'],
	        weekdaysMin: ['ne', 'po', 'ut', 'sr', 'če', 'pe', 'su'],
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L: 'DD. MM. YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm',
	            LLLL: 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar: {
	            sameDay: '[danas u] LT',
	            nextDay: '[sjutra u] LT',
	
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[juče u] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[prošle] [nedjelje] [u] LT',
	                    '[prošlog] [ponedjeljka] [u] LT',
	                    '[prošlog] [utorka] [u] LT',
	                    '[prošle] [srijede] [u] LT',
	                    '[prošlog] [četvrtka] [u] LT',
	                    '[prošlog] [petka] [u] LT',
	                    '[prošle] [subote] [u] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'nekoliko sekundi',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'dan',
	            dd     : translator.translate,
	            M      : 'mjesec',
	            MM     : translator.translate,
	            y      : 'godinu',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return me;
	
	}));

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : macedonian (mk)
	//! author : Borislav Mickov : https://github.com/B0k0
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var mk = moment.defineLocale('mk', {
	        months : 'јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември'.split('_'),
	        monthsShort : 'јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек'.split('_'),
	        weekdays : 'недела_понеделник_вторник_среда_четврток_петок_сабота'.split('_'),
	        weekdaysShort : 'нед_пон_вто_сре_чет_пет_саб'.split('_'),
	        weekdaysMin : 'нe_пo_вт_ср_че_пе_сa'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'D.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : '[Денес во] LT',
	            nextDay : '[Утре во] LT',
	            nextWeek : '[Во] dddd [во] LT',
	            lastDay : '[Вчера во] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[Изминатата] dddd [во] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[Изминатиот] dddd [во] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'после %s',
	            past : 'пред %s',
	            s : 'неколку секунди',
	            m : 'минута',
	            mm : '%d минути',
	            h : 'час',
	            hh : '%d часа',
	            d : 'ден',
	            dd : '%d дена',
	            M : 'месец',
	            MM : '%d месеци',
	            y : 'година',
	            yy : '%d години'
	        },
	        ordinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
	        ordinal : function (number) {
	            var lastDigit = number % 10,
	                last2Digits = number % 100;
	            if (number === 0) {
	                return number + '-ев';
	            } else if (last2Digits === 0) {
	                return number + '-ен';
	            } else if (last2Digits > 10 && last2Digits < 20) {
	                return number + '-ти';
	            } else if (lastDigit === 1) {
	                return number + '-ви';
	            } else if (lastDigit === 2) {
	                return number + '-ри';
	            } else if (lastDigit === 7 || lastDigit === 8) {
	                return number + '-ми';
	            } else {
	                return number + '-ти';
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return mk;
	
	}));

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : malayalam (ml)
	//! author : Floyd Pink : https://github.com/floydpink
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ml = moment.defineLocale('ml', {
	        months : 'ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ'.split('_'),
	        monthsShort : 'ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.'.split('_'),
	        weekdays : 'ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച'.split('_'),
	        weekdaysShort : 'ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി'.split('_'),
	        weekdaysMin : 'ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm -നു',
	            LTS : 'A h:mm:ss -നു',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm -നു',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm -നു'
	        },
	        calendar : {
	            sameDay : '[ഇന്ന്] LT',
	            nextDay : '[നാളെ] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[ഇന്നലെ] LT',
	            lastWeek : '[കഴിഞ്ഞ] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s കഴിഞ്ഞ്',
	            past : '%s മുൻപ്',
	            s : 'അൽപ നിമിഷങ്ങൾ',
	            m : 'ഒരു മിനിറ്റ്',
	            mm : '%d മിനിറ്റ്',
	            h : 'ഒരു മണിക്കൂർ',
	            hh : '%d മണിക്കൂർ',
	            d : 'ഒരു ദിവസം',
	            dd : '%d ദിവസം',
	            M : 'ഒരു മാസം',
	            MM : '%d മാസം',
	            y : 'ഒരു വർഷം',
	            yy : '%d വർഷം'
	        },
	        meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
	        isPM : function (input) {
	            return /^(ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'രാത്രി';
	            } else if (hour < 12) {
	                return 'രാവിലെ';
	            } else if (hour < 17) {
	                return 'ഉച്ച കഴിഞ്ഞ്';
	            } else if (hour < 20) {
	                return 'വൈകുന്നേരം';
	            } else {
	                return 'രാത്രി';
	            }
	        }
	    });
	
	    return ml;
	
	}));

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Marathi (mr)
	//! author : Harshad Kale : https://github.com/kalehv
	//! author : Vivek Athalye : https://github.com/vnathalye
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '१',
	        '2': '२',
	        '3': '३',
	        '4': '४',
	        '5': '५',
	        '6': '६',
	        '7': '७',
	        '8': '८',
	        '9': '९',
	        '0': '०'
	    },
	    numberMap = {
	        '१': '1',
	        '२': '2',
	        '३': '3',
	        '४': '4',
	        '५': '5',
	        '६': '6',
	        '७': '7',
	        '८': '8',
	        '९': '9',
	        '०': '0'
	    };
	
	    function relativeTimeMr(number, withoutSuffix, string, isFuture)
	    {
	        var output = '';
	        if (withoutSuffix) {
	            switch (string) {
	                case 's': output = 'काही सेकंद'; break;
	                case 'm': output = 'एक मिनिट'; break;
	                case 'mm': output = '%d मिनिटे'; break;
	                case 'h': output = 'एक तास'; break;
	                case 'hh': output = '%d तास'; break;
	                case 'd': output = 'एक दिवस'; break;
	                case 'dd': output = '%d दिवस'; break;
	                case 'M': output = 'एक महिना'; break;
	                case 'MM': output = '%d महिने'; break;
	                case 'y': output = 'एक वर्ष'; break;
	                case 'yy': output = '%d वर्षे'; break;
	            }
	        }
	        else {
	            switch (string) {
	                case 's': output = 'काही सेकंदां'; break;
	                case 'm': output = 'एका मिनिटा'; break;
	                case 'mm': output = '%d मिनिटां'; break;
	                case 'h': output = 'एका तासा'; break;
	                case 'hh': output = '%d तासां'; break;
	                case 'd': output = 'एका दिवसा'; break;
	                case 'dd': output = '%d दिवसां'; break;
	                case 'M': output = 'एका महिन्या'; break;
	                case 'MM': output = '%d महिन्यां'; break;
	                case 'y': output = 'एका वर्षा'; break;
	                case 'yy': output = '%d वर्षां'; break;
	            }
	        }
	        return output.replace(/%d/i, number);
	    }
	
	    var mr = moment.defineLocale('mr', {
	        months : 'जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split('_'),
	        monthsShort: 'जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split('_'),
	        weekdays : 'रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
	        weekdaysShort : 'रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि'.split('_'),
	        weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm वाजता',
	            LTS : 'A h:mm:ss वाजता',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm वाजता',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm वाजता'
	        },
	        calendar : {
	            sameDay : '[आज] LT',
	            nextDay : '[उद्या] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[काल] LT',
	            lastWeek: '[मागील] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future: '%sमध्ये',
	            past: '%sपूर्वी',
	            s: relativeTimeMr,
	            m: relativeTimeMr,
	            mm: relativeTimeMr,
	            h: relativeTimeMr,
	            hh: relativeTimeMr,
	            d: relativeTimeMr,
	            dd: relativeTimeMr,
	            M: relativeTimeMr,
	            MM: relativeTimeMr,
	            y: relativeTimeMr,
	            yy: relativeTimeMr
	        },
	        preparse: function (string) {
	            return string.replace(/[१२३४५६७८९०]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /रात्री|सकाळी|दुपारी|सायंकाळी/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'रात्री') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === 'सकाळी') {
	                return hour;
	            } else if (meridiem === 'दुपारी') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'सायंकाळी') {
	                return hour + 12;
	            }
	        },
	        meridiem: function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'रात्री';
	            } else if (hour < 10) {
	                return 'सकाळी';
	            } else if (hour < 17) {
	                return 'दुपारी';
	            } else if (hour < 20) {
	                return 'सायंकाळी';
	            } else {
	                return 'रात्री';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return mr;
	
	}));

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bahasa Malaysia (ms-MY)
	//! author : Weldan Jamili : https://github.com/weldan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ms_my = moment.defineLocale('ms-my', {
	        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /pagi|tengahari|petang|malam/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'tengahari') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'petang' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'tengahari';
	            } else if (hours < 19) {
	                return 'petang';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Esok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kelmarin pukul] LT',
	            lastWeek : 'dddd [lepas pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lepas',
	            s : 'beberapa saat',
	            m : 'seminit',
	            mm : '%d minit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ms_my;
	
	}));

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bahasa Malaysia (ms-MY)
	//! author : Weldan Jamili : https://github.com/weldan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ms = moment.defineLocale('ms', {
	        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /pagi|tengahari|petang|malam/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'tengahari') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'petang' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'tengahari';
	            } else if (hours < 19) {
	                return 'petang';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Esok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kelmarin pukul] LT',
	            lastWeek : 'dddd [lepas pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lepas',
	            s : 'beberapa saat',
	            m : 'seminit',
	            mm : '%d minit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ms;
	
	}));

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Burmese (my)
	//! author : Squar team, mysquar.com
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '၁',
	        '2': '၂',
	        '3': '၃',
	        '4': '၄',
	        '5': '၅',
	        '6': '၆',
	        '7': '၇',
	        '8': '၈',
	        '9': '၉',
	        '0': '၀'
	    }, numberMap = {
	        '၁': '1',
	        '၂': '2',
	        '၃': '3',
	        '၄': '4',
	        '၅': '5',
	        '၆': '6',
	        '၇': '7',
	        '၈': '8',
	        '၉': '9',
	        '၀': '0'
	    };
	
	    var my = moment.defineLocale('my', {
	        months: 'ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ'.split('_'),
	        monthsShort: 'ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ'.split('_'),
	        weekdays: 'တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ'.split('_'),
	        weekdaysShort: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
	        weekdaysMin: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
	
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[ယနေ.] LT [မှာ]',
	            nextDay: '[မနက်ဖြန်] LT [မှာ]',
	            nextWeek: 'dddd LT [မှာ]',
	            lastDay: '[မနေ.က] LT [မှာ]',
	            lastWeek: '[ပြီးခဲ့သော] dddd LT [မှာ]',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'လာမည့် %s မှာ',
	            past: 'လွန်ခဲ့သော %s က',
	            s: 'စက္ကန်.အနည်းငယ်',
	            m: 'တစ်မိနစ်',
	            mm: '%d မိနစ်',
	            h: 'တစ်နာရီ',
	            hh: '%d နာရီ',
	            d: 'တစ်ရက်',
	            dd: '%d ရက်',
	            M: 'တစ်လ',
	            MM: '%d လ',
	            y: 'တစ်နှစ်',
	            yy: '%d နှစ်'
	        },
	        preparse: function (string) {
	            return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return my;
	
	}));

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : norwegian bokmål (nb)
	//! authors : Espen Hovlandsdal : https://github.com/rexxars
	//!           Sigurd Gartmann : https://github.com/sigurdga
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var nb = moment.defineLocale('nb', {
	        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
	        weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
	        weekdaysShort : 'sø._ma._ti._on._to._fr._lø.'.split('_'),
	        weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] HH:mm',
	            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
	        },
	        calendar : {
	            sameDay: '[i dag kl.] LT',
	            nextDay: '[i morgen kl.] LT',
	            nextWeek: 'dddd [kl.] LT',
	            lastDay: '[i går kl.] LT',
	            lastWeek: '[forrige] dddd [kl.] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : 'for %s siden',
	            s : 'noen sekunder',
	            m : 'ett minutt',
	            mm : '%d minutter',
	            h : 'en time',
	            hh : '%d timer',
	            d : 'en dag',
	            dd : '%d dager',
	            M : 'en måned',
	            MM : '%d måneder',
	            y : 'ett år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return nb;
	
	}));

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : nepali/nepalese
	//! author : suvash : https://github.com/suvash
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '१',
	        '2': '२',
	        '3': '३',
	        '4': '४',
	        '5': '५',
	        '6': '६',
	        '7': '७',
	        '8': '८',
	        '9': '९',
	        '0': '०'
	    },
	    numberMap = {
	        '१': '1',
	        '२': '2',
	        '३': '3',
	        '४': '4',
	        '५': '5',
	        '६': '6',
	        '७': '7',
	        '८': '8',
	        '९': '9',
	        '०': '0'
	    };
	
	    var ne = moment.defineLocale('ne', {
	        months : 'जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर'.split('_'),
	        monthsShort : 'जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.'.split('_'),
	        weekdays : 'आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार'.split('_'),
	        weekdaysShort : 'आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.'.split('_'),
	        weekdaysMin : 'आ._सो._मं._बु._बि._शु._श.'.split('_'),
	        longDateFormat : {
	            LT : 'Aको h:mm बजे',
	            LTS : 'Aको h:mm:ss बजे',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, Aको h:mm बजे',
	            LLLL : 'dddd, D MMMM YYYY, Aको h:mm बजे'
	        },
	        preparse: function (string) {
	            return string.replace(/[१२३४५६७८९०]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'राति') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === 'बिहान') {
	                return hour;
	            } else if (meridiem === 'दिउँसो') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'साँझ') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 3) {
	                return 'राति';
	            } else if (hour < 12) {
	                return 'बिहान';
	            } else if (hour < 16) {
	                return 'दिउँसो';
	            } else if (hour < 20) {
	                return 'साँझ';
	            } else {
	                return 'राति';
	            }
	        },
	        calendar : {
	            sameDay : '[आज] LT',
	            nextDay : '[भोलि] LT',
	            nextWeek : '[आउँदो] dddd[,] LT',
	            lastDay : '[हिजो] LT',
	            lastWeek : '[गएको] dddd[,] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%sमा',
	            past : '%s अगाडि',
	            s : 'केही क्षण',
	            m : 'एक मिनेट',
	            mm : '%d मिनेट',
	            h : 'एक घण्टा',
	            hh : '%d घण्टा',
	            d : 'एक दिन',
	            dd : '%d दिन',
	            M : 'एक महिना',
	            MM : '%d महिना',
	            y : 'एक बर्ष',
	            yy : '%d बर्ष'
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ne;
	
	}));

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : dutch (nl)
	//! author : Joris Röling : https://github.com/jjupiter
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');
	
	    var nl = moment.defineLocale('nl', {
	        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShortWithoutDots[m.month()];
	            } else {
	                return monthsShortWithDots[m.month()];
	            }
	        },
	        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
	        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
	        weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[vandaag om] LT',
	            nextDay: '[morgen om] LT',
	            nextWeek: 'dddd [om] LT',
	            lastDay: '[gisteren om] LT',
	            lastWeek: '[afgelopen] dddd [om] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'over %s',
	            past : '%s geleden',
	            s : 'een paar seconden',
	            m : 'één minuut',
	            mm : '%d minuten',
	            h : 'één uur',
	            hh : '%d uur',
	            d : 'één dag',
	            dd : '%d dagen',
	            M : 'één maand',
	            MM : '%d maanden',
	            y : 'één jaar',
	            yy : '%d jaar'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return nl;
	
	}));

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : norwegian nynorsk (nn)
	//! author : https://github.com/mechuwind
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var nn = moment.defineLocale('nn', {
	        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
	        weekdaysShort : 'sun_mån_tys_ons_tor_fre_lau'.split('_'),
	        weekdaysMin : 'su_må_ty_on_to_fr_lø'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] H:mm',
	            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
	        },
	        calendar : {
	            sameDay: '[I dag klokka] LT',
	            nextDay: '[I morgon klokka] LT',
	            nextWeek: 'dddd [klokka] LT',
	            lastDay: '[I går klokka] LT',
	            lastWeek: '[Føregåande] dddd [klokka] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : 'for %s sidan',
	            s : 'nokre sekund',
	            m : 'eit minutt',
	            mm : '%d minutt',
	            h : 'ein time',
	            hh : '%d timar',
	            d : 'ein dag',
	            dd : '%d dagar',
	            M : 'ein månad',
	            MM : '%d månader',
	            y : 'eit år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return nn;
	
	}));

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : polish (pl)
	//! author : Rafal Hirsz : https://github.com/evoL
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var monthsNominative = 'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split('_'),
	        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split('_');
	    function plural(n) {
	        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
	    }
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	        case 'm':
	            return withoutSuffix ? 'minuta' : 'minutę';
	        case 'mm':
	            return result + (plural(number) ? 'minuty' : 'minut');
	        case 'h':
	            return withoutSuffix  ? 'godzina'  : 'godzinę';
	        case 'hh':
	            return result + (plural(number) ? 'godziny' : 'godzin');
	        case 'MM':
	            return result + (plural(number) ? 'miesiące' : 'miesięcy');
	        case 'yy':
	            return result + (plural(number) ? 'lata' : 'lat');
	        }
	    }
	
	    var pl = moment.defineLocale('pl', {
	        months : function (momentToFormat, format) {
	            if (format === '') {
	                // Hack: if format empty we know this is used to generate
	                // RegExp by moment. Give then back both valid forms of months
	                // in RegExp ready format.
	                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
	            } else if (/D MMMM/.test(format)) {
	                return monthsSubjective[momentToFormat.month()];
	            } else {
	                return monthsNominative[momentToFormat.month()];
	            }
	        },
	        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
	        weekdays : 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split('_'),
	        weekdaysShort : 'nie_pon_wt_śr_czw_pt_sb'.split('_'),
	        weekdaysMin : 'Nd_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Dziś o] LT',
	            nextDay: '[Jutro o] LT',
	            nextWeek: '[W] dddd [o] LT',
	            lastDay: '[Wczoraj o] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[W zeszłą niedzielę o] LT';
	                case 3:
	                    return '[W zeszłą środę o] LT';
	                case 6:
	                    return '[W zeszłą sobotę o] LT';
	                default:
	                    return '[W zeszły] dddd [o] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : '%s temu',
	            s : 'kilka sekund',
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : '1 dzień',
	            dd : '%d dni',
	            M : 'miesiąc',
	            MM : translate,
	            y : 'rok',
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return pl;
	
	}));

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : brazilian portuguese (pt-br)
	//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var pt_br = moment.defineLocale('pt-br', {
	        months : 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	        weekdays : 'Domingo_Segunda-Feira_Terça-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sábado'.split('_'),
	        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
	        weekdaysMin : 'Dom_2ª_3ª_4ª_5ª_6ª_Sáb'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY [às] HH:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY [às] HH:mm'
	        },
	        calendar : {
	            sameDay: '[Hoje às] LT',
	            nextDay: '[Amanhã às] LT',
	            nextWeek: 'dddd [às] LT',
	            lastDay: '[Ontem às] LT',
	            lastWeek: function () {
	                return (this.day() === 0 || this.day() === 6) ?
	                    '[Último] dddd [às] LT' : // Saturday + Sunday
	                    '[Última] dddd [às] LT'; // Monday - Friday
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'em %s',
	            past : '%s atrás',
	            s : 'poucos segundos',
	            m : 'um minuto',
	            mm : '%d minutos',
	            h : 'uma hora',
	            hh : '%d horas',
	            d : 'um dia',
	            dd : '%d dias',
	            M : 'um mês',
	            MM : '%d meses',
	            y : 'um ano',
	            yy : '%d anos'
	        },
	        ordinalParse: /\d{1,2}º/,
	        ordinal : '%dº'
	    });
	
	    return pt_br;
	
	}));

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : portuguese (pt)
	//! author : Jefferson : https://github.com/jalex79
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var pt = moment.defineLocale('pt', {
	        months : 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	        weekdays : 'Domingo_Segunda-Feira_Terça-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sábado'.split('_'),
	        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
	        weekdaysMin : 'Dom_2ª_3ª_4ª_5ª_6ª_Sáb'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY HH:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Hoje às] LT',
	            nextDay: '[Amanhã às] LT',
	            nextWeek: 'dddd [às] LT',
	            lastDay: '[Ontem às] LT',
	            lastWeek: function () {
	                return (this.day() === 0 || this.day() === 6) ?
	                    '[Último] dddd [às] LT' : // Saturday + Sunday
	                    '[Última] dddd [às] LT'; // Monday - Friday
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'em %s',
	            past : 'há %s',
	            s : 'segundos',
	            m : 'um minuto',
	            mm : '%d minutos',
	            h : 'uma hora',
	            hh : '%d horas',
	            d : 'um dia',
	            dd : '%d dias',
	            M : 'um mês',
	            MM : '%d meses',
	            y : 'um ano',
	            yy : '%d anos'
	        },
	        ordinalParse: /\d{1,2}º/,
	        ordinal : '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return pt;
	
	}));

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : romanian (ro)
	//! author : Vlad Gurdiga : https://github.com/gurdiga
	//! author : Valentin Agachi : https://github.com/avaly
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	                'mm': 'minute',
	                'hh': 'ore',
	                'dd': 'zile',
	                'MM': 'luni',
	                'yy': 'ani'
	            },
	            separator = ' ';
	        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
	            separator = ' de ';
	        }
	        return number + separator + format[key];
	    }
	
	    var ro = moment.defineLocale('ro', {
	        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
	        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
	        weekdays : 'duminică_luni_marți_miercuri_joi_vineri_sâmbătă'.split('_'),
	        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sâm'.split('_'),
	        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_Sâ'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay: '[azi la] LT',
	            nextDay: '[mâine la] LT',
	            nextWeek: 'dddd [la] LT',
	            lastDay: '[ieri la] LT',
	            lastWeek: '[fosta] dddd [la] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'peste %s',
	            past : '%s în urmă',
	            s : 'câteva secunde',
	            m : 'un minut',
	            mm : relativeTimeWithPlural,
	            h : 'o oră',
	            hh : relativeTimeWithPlural,
	            d : 'o zi',
	            dd : relativeTimeWithPlural,
	            M : 'o lună',
	            MM : relativeTimeWithPlural,
	            y : 'un an',
	            yy : relativeTimeWithPlural
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ro;
	
	}));

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : russian (ru)
	//! author : Viktorminator : https://github.com/Viktorminator
	//! Author : Menelion Elensúle : https://github.com/Oire
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
	            'hh': 'час_часа_часов',
	            'dd': 'день_дня_дней',
	            'MM': 'месяц_месяца_месяцев',
	            'yy': 'год_года_лет'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? 'минута' : 'минуту';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	    var monthsParse = [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[й|я]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i];
	
	    var ru = moment.defineLocale('ru', {
	        months : {
	            format: 'Января_Февраля_Марта_Апреля_Мая_Июня_Июля_Августа_Сентября_Октября_Ноября_Декабря'.split('_'),
	            standalone: 'Январь_Февраль_Март_Апрель_Май_Июнь_Июль_Август_Сентябрь_Октябрь_Ноябрь_Декабрь'.split('_')
	        },
	        monthsShort : {
	            format: 'янв_фев_мар_апр_мая_июня_июля_авг_сен_окт_ноя_дек'.split('_'),
	            standalone: 'янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек'.split('_')
	        },
	        weekdays : {
	            standalone: 'Воскресенье_Понедельник_Вторник_Среда_Четверг_Пятница_Суббота'.split('_'),
	            format: 'Воскресенье_Понедельник_Вторник_Среду_Четверг_Пятницу_Субботу'.split('_'),
	            isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/
	        },
	        weekdaysShort : 'Вс_Пн_Вт_Ср_Чт_Пт_Сб'.split('_'),
	        weekdaysMin : 'Вс_Пн_Вт_Ср_Чт_Пт_Сб'.split('_'),
	        monthsParse : monthsParse,
	        longMonthsParse : monthsParse,
	        shortMonthsParse : monthsParse,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY г.',
	            LLL : 'D MMMM YYYY г., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY г., HH:mm'
	        },
	        calendar : {
	            sameDay: '[Сегодня в] LT',
	            nextDay: '[Завтра в] LT',
	            lastDay: '[Вчера в] LT',
	            nextWeek: function (now) {
	                if (now.week() !== this.week()) {
	                    switch (this.day()) {
	                    case 0:
	                        return '[В следующее] dddd [в] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[В следующий] dddd [в] LT';
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[В следующую] dddd [в] LT';
	                    }
	                } else {
	                    if (this.day() === 2) {
	                        return '[Во] dddd [в] LT';
	                    } else {
	                        return '[В] dddd [в] LT';
	                    }
	                }
	            },
	            lastWeek: function (now) {
	                if (now.week() !== this.week()) {
	                    switch (this.day()) {
	                    case 0:
	                        return '[В прошлое] dddd [в] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[В прошлый] dddd [в] LT';
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[В прошлую] dddd [в] LT';
	                    }
	                } else {
	                    if (this.day() === 2) {
	                        return '[Во] dddd [в] LT';
	                    } else {
	                        return '[В] dddd [в] LT';
	                    }
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'через %s',
	            past : '%s назад',
	            s : 'несколько секунд',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : 'час',
	            hh : relativeTimeWithPlural,
	            d : 'день',
	            dd : relativeTimeWithPlural,
	            M : 'месяц',
	            MM : relativeTimeWithPlural,
	            y : 'год',
	            yy : relativeTimeWithPlural
	        },
	        meridiemParse: /ночи|утра|дня|вечера/i,
	        isPM : function (input) {
	            return /^(дня|вечера)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'ночи';
	            } else if (hour < 12) {
	                return 'утра';
	            } else if (hour < 17) {
	                return 'дня';
	            } else {
	                return 'вечера';
	            }
	        },
	        ordinalParse: /\d{1,2}-(й|го|я)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	                return number + '-й';
	            case 'D':
	                return number + '-го';
	            case 'w':
	            case 'W':
	                return number + '-я';
	            default:
	                return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ru;
	
	}));

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Northern Sami (se)
	//! authors : Bård Rolstad Henriksen : https://github.com/karamell
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	
	    var se = moment.defineLocale('se', {
	        months : 'ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu'.split('_'),
	        monthsShort : 'ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov'.split('_'),
	        weekdays : 'sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat'.split('_'),
	        weekdaysShort : 'sotn_vuos_maŋ_gask_duor_bear_láv'.split('_'),
	        weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'MMMM D. [b.] YYYY',
	            LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
	            LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
	        },
	        calendar : {
	            sameDay: '[otne ti] LT',
	            nextDay: '[ihttin ti] LT',
	            nextWeek: 'dddd [ti] LT',
	            lastDay: '[ikte ti] LT',
	            lastWeek: '[ovddit] dddd [ti] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s geažes',
	            past : 'maŋit %s',
	            s : 'moadde sekunddat',
	            m : 'okta minuhta',
	            mm : '%d minuhtat',
	            h : 'okta diimmu',
	            hh : '%d diimmut',
	            d : 'okta beaivi',
	            dd : '%d beaivvit',
	            M : 'okta mánnu',
	            MM : '%d mánut',
	            y : 'okta jahki',
	            yy : '%d jagit'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return se;
	
	}));

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Sinhalese (si)
	//! author : Sampath Sitinamaluwa : https://github.com/sampathsris
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    /*jshint -W100*/
	    var si = moment.defineLocale('si', {
	        months : 'ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්'.split('_'),
	        monthsShort : 'ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ'.split('_'),
	        weekdays : 'ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා'.split('_'),
	        weekdaysShort : 'ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන'.split('_'),
	        weekdaysMin : 'ඉ_ස_අ_බ_බ්‍ර_සි_සෙ'.split('_'),
	        longDateFormat : {
	            LT : 'a h:mm',
	            LTS : 'a h:mm:ss',
	            L : 'YYYY/MM/DD',
	            LL : 'YYYY MMMM D',
	            LLL : 'YYYY MMMM D, a h:mm',
	            LLLL : 'YYYY MMMM D [වැනි] dddd, a h:mm:ss'
	        },
	        calendar : {
	            sameDay : '[අද] LT[ට]',
	            nextDay : '[හෙට] LT[ට]',
	            nextWeek : 'dddd LT[ට]',
	            lastDay : '[ඊයේ] LT[ට]',
	            lastWeek : '[පසුගිය] dddd LT[ට]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%sකින්',
	            past : '%sකට පෙර',
	            s : 'තත්පර කිහිපය',
	            m : 'මිනිත්තුව',
	            mm : 'මිනිත්තු %d',
	            h : 'පැය',
	            hh : 'පැය %d',
	            d : 'දිනය',
	            dd : 'දින %d',
	            M : 'මාසය',
	            MM : 'මාස %d',
	            y : 'වසර',
	            yy : 'වසර %d'
	        },
	        ordinalParse: /\d{1,2} වැනි/,
	        ordinal : function (number) {
	            return number + ' වැනි';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'ප.ව.' : 'පස් වරු';
	            } else {
	                return isLower ? 'පෙ.ව.' : 'පෙර වරු';
	            }
	        }
	    });
	
	    return si;
	
	}));

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : slovak (sk)
	//! author : Martin Minka : https://github.com/k2s
	//! based on work of petrbela : https://github.com/petrbela
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var months = 'január_február_marec_apríl_máj_jún_júl_august_september_október_november_december'.split('_'),
	        monthsShort = 'jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec'.split('_');
	    function plural(n) {
	        return (n > 1) && (n < 5);
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pár sekúnd' : 'pár sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minúta' : (isFuture ? 'minútu' : 'minútou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minúty' : 'minút');
	            } else {
	                return result + 'minútami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodín');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'deň' : 'dňom';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dni' : 'dní');
	            } else {
	                return result + 'dňami';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'mesiace' : 'mesiacov');
	            } else {
	                return result + 'mesiacmi';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'rokov');
	            } else {
	                return result + 'rokmi';
	            }
	            break;
	        }
	    }
	
	    var sk = moment.defineLocale('sk', {
	        months : months,
	        monthsShort : monthsShort,
	        weekdays : 'nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota'.split('_'),
	        weekdaysShort : 'ne_po_ut_st_št_pi_so'.split('_'),
	        weekdaysMin : 'ne_po_ut_st_št_pi_so'.split('_'),
	        longDateFormat : {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay: '[dnes o] LT',
	            nextDay: '[zajtra o] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[v nedeľu o] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [o] LT';
	                case 3:
	                    return '[v stredu o] LT';
	                case 4:
	                    return '[vo štvrtok o] LT';
	                case 5:
	                    return '[v piatok o] LT';
	                case 6:
	                    return '[v sobotu o] LT';
	                }
	            },
	            lastDay: '[včera o] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[minulú nedeľu o] LT';
	                case 1:
	                case 2:
	                    return '[minulý] dddd [o] LT';
	                case 3:
	                    return '[minulú stredu o] LT';
	                case 4:
	                case 5:
	                    return '[minulý] dddd [o] LT';
	                case 6:
	                    return '[minulú sobotu o] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : 'pred %s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return sk;
	
	}));

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : slovenian (sl)
	//! author : Robert Sedovšek : https://github.com/sedovsek
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	        case 's':
	            return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
	        case 'm':
	            return withoutSuffix ? 'ena minuta' : 'eno minuto';
	        case 'mm':
	            if (number === 1) {
	                result += withoutSuffix ? 'minuta' : 'minuto';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'minute' : 'minutami';
	            } else {
	                result += withoutSuffix || isFuture ? 'minut' : 'minutami';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'ena ura' : 'eno uro';
	        case 'hh':
	            if (number === 1) {
	                result += withoutSuffix ? 'ura' : 'uro';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'uri' : 'urama';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'ure' : 'urami';
	            } else {
	                result += withoutSuffix || isFuture ? 'ur' : 'urami';
	            }
	            return result;
	        case 'd':
	            return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
	        case 'dd':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'dan' : 'dnem';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
	            } else {
	                result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
	            }
	            return result;
	        case 'M':
	            return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
	        case 'MM':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
	            } else {
	                result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
	            }
	            return result;
	        case 'y':
	            return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
	        case 'yy':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'leto' : 'letom';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'leti' : 'letoma';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'leta' : 'leti';
	            } else {
	                result += withoutSuffix || isFuture ? 'let' : 'leti';
	            }
	            return result;
	        }
	    }
	
	    var sl = moment.defineLocale('sl', {
	        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
	        weekdays : 'nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota'.split('_'),
	        weekdaysShort : 'ned._pon._tor._sre._čet._pet._sob.'.split('_'),
	        weekdaysMin : 'ne_po_to_sr_če_pe_so'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD. MM. YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[danes ob] LT',
	            nextDay  : '[jutri ob] LT',
	
	            nextWeek : function () {
	                switch (this.day()) {
	                case 0:
	                    return '[v] [nedeljo] [ob] LT';
	                case 3:
	                    return '[v] [sredo] [ob] LT';
	                case 6:
	                    return '[v] [soboto] [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[v] dddd [ob] LT';
	                }
	            },
	            lastDay  : '[včeraj ob] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                    return '[prejšnjo] [nedeljo] [ob] LT';
	                case 3:
	                    return '[prejšnjo] [sredo] [ob] LT';
	                case 6:
	                    return '[prejšnjo] [soboto] [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prejšnji] dddd [ob] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'čez %s',
	            past   : 'pred %s',
	            s      : processRelativeTime,
	            m      : processRelativeTime,
	            mm     : processRelativeTime,
	            h      : processRelativeTime,
	            hh     : processRelativeTime,
	            d      : processRelativeTime,
	            dd     : processRelativeTime,
	            M      : processRelativeTime,
	            MM     : processRelativeTime,
	            y      : processRelativeTime,
	            yy     : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return sl;
	
	}));

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Albanian (sq)
	//! author : Flakërim Ismani : https://github.com/flakerimi
	//! author: Menelion Elensúle: https://github.com/Oire (tests)
	//! author : Oerd Cukalla : https://github.com/oerd (fixes)
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var sq = moment.defineLocale('sq', {
	        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor'.split('_'),
	        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj'.split('_'),
	        weekdays : 'E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë'.split('_'),
	        weekdaysShort : 'Die_Hën_Mar_Mër_Enj_Pre_Sht'.split('_'),
	        weekdaysMin : 'D_H_Ma_Më_E_P_Sh'.split('_'),
	        meridiemParse: /PD|MD/,
	        isPM: function (input) {
	            return input.charAt(0) === 'M';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            return hours < 12 ? 'PD' : 'MD';
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Sot në] LT',
	            nextDay : '[Nesër në] LT',
	            nextWeek : 'dddd [në] LT',
	            lastDay : '[Dje në] LT',
	            lastWeek : 'dddd [e kaluar në] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'në %s',
	            past : '%s më parë',
	            s : 'disa sekonda',
	            m : 'një minutë',
	            mm : '%d minuta',
	            h : 'një orë',
	            hh : '%d orë',
	            d : 'një ditë',
	            dd : '%d ditë',
	            M : 'një muaj',
	            MM : '%d muaj',
	            y : 'një vit',
	            yy : '%d vite'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return sq;
	
	}));

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian-cyrillic (sr-cyrl)
	//! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var translator = {
	        words: { //Different grammatical cases
	            m: ['један минут', 'једне минуте'],
	            mm: ['минут', 'минуте', 'минута'],
	            h: ['један сат', 'једног сата'],
	            hh: ['сат', 'сата', 'сати'],
	            dd: ['дан', 'дана', 'дана'],
	            MM: ['месец', 'месеца', 'месеци'],
	            yy: ['година', 'године', 'година']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };
	
	    var sr_cyrl = moment.defineLocale('sr-cyrl', {
	        months: ['јануар', 'фебруар', 'март', 'април', 'мај', 'јун', 'јул', 'август', 'септембар', 'октобар', 'новембар', 'децембар'],
	        monthsShort: ['јан.', 'феб.', 'мар.', 'апр.', 'мај', 'јун', 'јул', 'авг.', 'сеп.', 'окт.', 'нов.', 'дец.'],
	        weekdays: ['недеља', 'понедељак', 'уторак', 'среда', 'четвртак', 'петак', 'субота'],
	        weekdaysShort: ['нед.', 'пон.', 'уто.', 'сре.', 'чет.', 'пет.', 'суб.'],
	        weekdaysMin: ['не', 'по', 'ут', 'ср', 'че', 'пе', 'су'],
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L: 'DD. MM. YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm',
	            LLLL: 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar: {
	            sameDay: '[данас у] LT',
	            nextDay: '[сутра у] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[у] [недељу] [у] LT';
	                case 3:
	                    return '[у] [среду] [у] LT';
	                case 6:
	                    return '[у] [суботу] [у] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[у] dddd [у] LT';
	                }
	            },
	            lastDay  : '[јуче у] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[прошле] [недеље] [у] LT',
	                    '[прошлог] [понедељка] [у] LT',
	                    '[прошлог] [уторка] [у] LT',
	                    '[прошле] [среде] [у] LT',
	                    '[прошлог] [четвртка] [у] LT',
	                    '[прошлог] [петка] [у] LT',
	                    '[прошле] [суботе] [у] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'за %s',
	            past   : 'пре %s',
	            s      : 'неколико секунди',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'дан',
	            dd     : translator.translate,
	            M      : 'месец',
	            MM     : translator.translate,
	            y      : 'годину',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return sr_cyrl;
	
	}));

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian-latin (sr)
	//! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var translator = {
	        words: { //Different grammatical cases
	            m: ['jedan minut', 'jedne minute'],
	            mm: ['minut', 'minute', 'minuta'],
	            h: ['jedan sat', 'jednog sata'],
	            hh: ['sat', 'sata', 'sati'],
	            dd: ['dan', 'dana', 'dana'],
	            MM: ['mesec', 'meseca', 'meseci'],
	            yy: ['godina', 'godine', 'godina']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };
	
	    var sr = moment.defineLocale('sr', {
	        months: ['januar', 'februar', 'mart', 'april', 'maj', 'jun', 'jul', 'avgust', 'septembar', 'oktobar', 'novembar', 'decembar'],
	        monthsShort: ['jan.', 'feb.', 'mar.', 'apr.', 'maj', 'jun', 'jul', 'avg.', 'sep.', 'okt.', 'nov.', 'dec.'],
	        weekdays: ['nedelja', 'ponedeljak', 'utorak', 'sreda', 'četvrtak', 'petak', 'subota'],
	        weekdaysShort: ['ned.', 'pon.', 'uto.', 'sre.', 'čet.', 'pet.', 'sub.'],
	        weekdaysMin: ['ne', 'po', 'ut', 'sr', 'če', 'pe', 'su'],
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L: 'DD. MM. YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm',
	            LLLL: 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar: {
	            sameDay: '[danas u] LT',
	            nextDay: '[sutra u] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[u] [nedelju] [u] LT';
	                case 3:
	                    return '[u] [sredu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[juče u] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[prošle] [nedelje] [u] LT',
	                    '[prošlog] [ponedeljka] [u] LT',
	                    '[prošlog] [utorka] [u] LT',
	                    '[prošle] [srede] [u] LT',
	                    '[prošlog] [četvrtka] [u] LT',
	                    '[prošlog] [petka] [u] LT',
	                    '[prošle] [subote] [u] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'pre %s',
	            s      : 'nekoliko sekundi',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'dan',
	            dd     : translator.translate,
	            M      : 'mesec',
	            MM     : translator.translate,
	            y      : 'godinu',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return sr;
	
	}));

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : swedish (sv)
	//! author : Jens Alm : https://github.com/ulmus
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var sv = moment.defineLocale('sv', {
	        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
	        weekdaysShort : 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
	        weekdaysMin : 'sö_må_ti_on_to_fr_lö'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Idag] LT',
	            nextDay: '[Imorgon] LT',
	            lastDay: '[Igår] LT',
	            nextWeek: '[På] dddd LT',
	            lastWeek: '[I] dddd[s] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : 'för %s sedan',
	            s : 'några sekunder',
	            m : 'en minut',
	            mm : '%d minuter',
	            h : 'en timme',
	            hh : '%d timmar',
	            d : 'en dag',
	            dd : '%d dagar',
	            M : 'en månad',
	            MM : '%d månader',
	            y : 'ett år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}(e|a)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'e' :
	                (b === 1) ? 'a' :
	                (b === 2) ? 'a' :
	                (b === 3) ? 'e' : 'e';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return sv;
	
	}));

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : swahili (sw)
	//! author : Fahad Kassim : https://github.com/fadsel
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var sw = moment.defineLocale('sw', {
	        months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
	        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
	        weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
	        weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[leo saa] LT',
	            nextDay : '[kesho saa] LT',
	            nextWeek : '[wiki ijayo] dddd [saat] LT',
	            lastDay : '[jana] LT',
	            lastWeek : '[wiki iliyopita] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s baadaye',
	            past : 'tokea %s',
	            s : 'hivi punde',
	            m : 'dakika moja',
	            mm : 'dakika %d',
	            h : 'saa limoja',
	            hh : 'masaa %d',
	            d : 'siku moja',
	            dd : 'masiku %d',
	            M : 'mwezi mmoja',
	            MM : 'miezi %d',
	            y : 'mwaka mmoja',
	            yy : 'miaka %d'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return sw;
	
	}));

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : tamil (ta)
	//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '௧',
	        '2': '௨',
	        '3': '௩',
	        '4': '௪',
	        '5': '௫',
	        '6': '௬',
	        '7': '௭',
	        '8': '௮',
	        '9': '௯',
	        '0': '௦'
	    }, numberMap = {
	        '௧': '1',
	        '௨': '2',
	        '௩': '3',
	        '௪': '4',
	        '௫': '5',
	        '௬': '6',
	        '௭': '7',
	        '௮': '8',
	        '௯': '9',
	        '௦': '0'
	    };
	
	    var ta = moment.defineLocale('ta', {
	        months : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
	        monthsShort : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
	        weekdays : 'ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை'.split('_'),
	        weekdaysShort : 'ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி'.split('_'),
	        weekdaysMin : 'ஞா_தி_செ_பு_வி_வெ_ச'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, HH:mm',
	            LLLL : 'dddd, D MMMM YYYY, HH:mm'
	        },
	        calendar : {
	            sameDay : '[இன்று] LT',
	            nextDay : '[நாளை] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[நேற்று] LT',
	            lastWeek : '[கடந்த வாரம்] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s இல்',
	            past : '%s முன்',
	            s : 'ஒரு சில விநாடிகள்',
	            m : 'ஒரு நிமிடம்',
	            mm : '%d நிமிடங்கள்',
	            h : 'ஒரு மணி நேரம்',
	            hh : '%d மணி நேரம்',
	            d : 'ஒரு நாள்',
	            dd : '%d நாட்கள்',
	            M : 'ஒரு மாதம்',
	            MM : '%d மாதங்கள்',
	            y : 'ஒரு வருடம்',
	            yy : '%d ஆண்டுகள்'
	        },
	        ordinalParse: /\d{1,2}வது/,
	        ordinal : function (number) {
	            return number + 'வது';
	        },
	        preparse: function (string) {
	            return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        // refer http://ta.wikipedia.org/s/1er1
	        meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 2) {
	                return ' யாமம்';
	            } else if (hour < 6) {
	                return ' வைகறை';  // வைகறை
	            } else if (hour < 10) {
	                return ' காலை'; // காலை
	            } else if (hour < 14) {
	                return ' நண்பகல்'; // நண்பகல்
	            } else if (hour < 18) {
	                return ' எற்பாடு'; // எற்பாடு
	            } else if (hour < 22) {
	                return ' மாலை'; // மாலை
	            } else {
	                return ' யாமம்';
	            }
	        },
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'யாமம்') {
	                return hour < 2 ? hour : hour + 12;
	            } else if (meridiem === 'வைகறை' || meridiem === 'காலை') {
	                return hour;
	            } else if (meridiem === 'நண்பகல்') {
	                return hour >= 10 ? hour : hour + 12;
	            } else {
	                return hour + 12;
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ta;
	
	}));

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : telugu (te)
	//! author : Krishna Chaitanya Thota : https://github.com/kcthota
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var te = moment.defineLocale('te', {
	        months : 'జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జూలై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్'.split('_'),
	        monthsShort : 'జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జూలై_ఆగ._సెప్._అక్టో._నవ._డిసె.'.split('_'),
	        weekdays : 'ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం'.split('_'),
	        weekdaysShort : 'ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని'.split('_'),
	        weekdaysMin : 'ఆ_సో_మం_బు_గు_శు_శ'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm',
	            LTS : 'A h:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm'
	        },
	        calendar : {
	            sameDay : '[నేడు] LT',
	            nextDay : '[రేపు] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[నిన్న] LT',
	            lastWeek : '[గత] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s లో',
	            past : '%s క్రితం',
	            s : 'కొన్ని క్షణాలు',
	            m : 'ఒక నిమిషం',
	            mm : '%d నిమిషాలు',
	            h : 'ఒక గంట',
	            hh : '%d గంటలు',
	            d : 'ఒక రోజు',
	            dd : '%d రోజులు',
	            M : 'ఒక నెల',
	            MM : '%d నెలలు',
	            y : 'ఒక సంవత్సరం',
	            yy : '%d సంవత్సరాలు'
	        },
	        ordinalParse : /\d{1,2}వ/,
	        ordinal : '%dవ',
	        meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'రాత్రి') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === 'ఉదయం') {
	                return hour;
	            } else if (meridiem === 'మధ్యాహ్నం') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'సాయంత్రం') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'రాత్రి';
	            } else if (hour < 10) {
	                return 'ఉదయం';
	            } else if (hour < 17) {
	                return 'మధ్యాహ్నం';
	            } else if (hour < 20) {
	                return 'సాయంత్రం';
	            } else {
	                return 'రాత్రి';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return te;
	
	}));

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : thai (th)
	//! author : Kridsada Thanabulpong : https://github.com/sirn
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var th = moment.defineLocale('th', {
	        months : 'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split('_'),
	        monthsShort : 'มกรา_กุมภา_มีนา_เมษา_พฤษภา_มิถุนา_กรกฎา_สิงหา_กันยา_ตุลา_พฤศจิกา_ธันวา'.split('_'),
	        weekdays : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
	        weekdaysShort : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'), // yes, three characters difference
	        weekdaysMin : 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
	        longDateFormat : {
	            LT : 'H นาฬิกา m นาที',
	            LTS : 'H นาฬิกา m นาที s วินาที',
	            L : 'YYYY/MM/DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY เวลา H นาฬิกา m นาที',
	            LLLL : 'วันddddที่ D MMMM YYYY เวลา H นาฬิกา m นาที'
	        },
	        meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
	        isPM: function (input) {
	            return input === 'หลังเที่ยง';
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ก่อนเที่ยง';
	            } else {
	                return 'หลังเที่ยง';
	            }
	        },
	        calendar : {
	            sameDay : '[วันนี้ เวลา] LT',
	            nextDay : '[พรุ่งนี้ เวลา] LT',
	            nextWeek : 'dddd[หน้า เวลา] LT',
	            lastDay : '[เมื่อวานนี้ เวลา] LT',
	            lastWeek : '[วัน]dddd[ที่แล้ว เวลา] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'อีก %s',
	            past : '%sที่แล้ว',
	            s : 'ไม่กี่วินาที',
	            m : '1 นาที',
	            mm : '%d นาที',
	            h : '1 ชั่วโมง',
	            hh : '%d ชั่วโมง',
	            d : '1 วัน',
	            dd : '%d วัน',
	            M : '1 เดือน',
	            MM : '%d เดือน',
	            y : '1 ปี',
	            yy : '%d ปี'
	        }
	    });
	
	    return th;
	
	}));

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tagalog/Filipino (tl-ph)
	//! author : Dan Hagman
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var tl_ph = moment.defineLocale('tl-ph', {
	        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
	        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
	        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
	        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
	        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'MM/D/YYYY',
	            LL : 'MMMM D, YYYY',
	            LLL : 'MMMM D, YYYY HH:mm',
	            LLLL : 'dddd, MMMM DD, YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Ngayon sa] LT',
	            nextDay: '[Bukas sa] LT',
	            nextWeek: 'dddd [sa] LT',
	            lastDay: '[Kahapon sa] LT',
	            lastWeek: 'dddd [huling linggo] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'sa loob ng %s',
	            past : '%s ang nakalipas',
	            s : 'ilang segundo',
	            m : 'isang minuto',
	            mm : '%d minuto',
	            h : 'isang oras',
	            hh : '%d oras',
	            d : 'isang araw',
	            dd : '%d araw',
	            M : 'isang buwan',
	            MM : '%d buwan',
	            y : 'isang taon',
	            yy : '%d taon'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return tl_ph;
	
	}));

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Klingon (tlh)
	//! author : Dominika Kruk : https://github.com/amaranthrose
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var numbersNouns = 'pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');
	
	    function translateFuture(output) {
	        var time = output;
	        time = (output.indexOf('jaj') !== -1) ?
	    	time.slice(0, -3) + 'leS' :
	    	(output.indexOf('jar') !== -1) ?
	    	time.slice(0, -3) + 'waQ' :
	    	(output.indexOf('DIS') !== -1) ?
	    	time.slice(0, -3) + 'nem' :
	    	time + ' pIq';
	        return time;
	    }
	
	    function translatePast(output) {
	        var time = output;
	        time = (output.indexOf('jaj') !== -1) ?
	    	time.slice(0, -3) + 'Hu’' :
	    	(output.indexOf('jar') !== -1) ?
	    	time.slice(0, -3) + 'wen' :
	    	(output.indexOf('DIS') !== -1) ?
	    	time.slice(0, -3) + 'ben' :
	    	time + ' ret';
	        return time;
	    }
	
	    function translate(number, withoutSuffix, string, isFuture) {
	        var numberNoun = numberAsNoun(number);
	        switch (string) {
	            case 'mm':
	                return numberNoun + ' tup';
	            case 'hh':
	                return numberNoun + ' rep';
	            case 'dd':
	                return numberNoun + ' jaj';
	            case 'MM':
	                return numberNoun + ' jar';
	            case 'yy':
	                return numberNoun + ' DIS';
	        }
	    }
	
	    function numberAsNoun(number) {
	        var hundred = Math.floor((number % 1000) / 100),
	    	ten = Math.floor((number % 100) / 10),
	    	one = number % 10,
	    	word = '';
	        if (hundred > 0) {
	            word += numbersNouns[hundred] + 'vatlh';
	        }
	        if (ten > 0) {
	            word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
	        }
	        if (one > 0) {
	            word += ((word !== '') ? ' ' : '') + numbersNouns[one];
	        }
	        return (word === '') ? 'pagh' : word;
	    }
	
	    var tlh = moment.defineLocale('tlh', {
	        months : 'tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’'.split('_'),
	        monthsShort : 'jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’'.split('_'),
	        weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	        weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	        weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[DaHjaj] LT',
	            nextDay: '[wa’leS] LT',
	            nextWeek: 'LLL',
	            lastDay: '[wa’Hu’] LT',
	            lastWeek: 'LLL',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : translateFuture,
	            past : translatePast,
	            s : 'puS lup',
	            m : 'wa’ tup',
	            mm : translate,
	            h : 'wa’ rep',
	            hh : translate,
	            d : 'wa’ jaj',
	            dd : translate,
	            M : 'wa’ jar',
	            MM : translate,
	            y : 'wa’ DIS',
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return tlh;
	
	}));

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : turkish (tr)
	//! authors : Erhan Gundogan : https://github.com/erhangundogan,
	//!           Burak Yiğit Kaya: https://github.com/BYK
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var suffixes = {
	        1: '\'inci',
	        5: '\'inci',
	        8: '\'inci',
	        70: '\'inci',
	        80: '\'inci',
	        2: '\'nci',
	        7: '\'nci',
	        20: '\'nci',
	        50: '\'nci',
	        3: '\'üncü',
	        4: '\'üncü',
	        100: '\'üncü',
	        6: '\'ncı',
	        9: '\'uncu',
	        10: '\'uncu',
	        30: '\'uncu',
	        60: '\'ıncı',
	        90: '\'ıncı'
	    };
	
	    var tr = moment.defineLocale('tr', {
	        months : 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split('_'),
	        monthsShort : 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
	        weekdays : 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split('_'),
	        weekdaysShort : 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
	        weekdaysMin : 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[bugün saat] LT',
	            nextDay : '[yarın saat] LT',
	            nextWeek : '[haftaya] dddd [saat] LT',
	            lastDay : '[dün] LT',
	            lastWeek : '[geçen hafta] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s sonra',
	            past : '%s önce',
	            s : 'birkaç saniye',
	            m : 'bir dakika',
	            mm : '%d dakika',
	            h : 'bir saat',
	            hh : '%d saat',
	            d : 'bir gün',
	            dd : '%d gün',
	            M : 'bir ay',
	            MM : '%d ay',
	            y : 'bir yıl',
	            yy : '%d yıl'
	        },
	        ordinalParse: /\d{1,2}'(inci|nci|üncü|ncı|uncu|ıncı)/,
	        ordinal : function (number) {
	            if (number === 0) {  // special case for zero
	                return number + '\'ıncı';
	            }
	            var a = number % 10,
	                b = number % 100 - a,
	                c = number >= 100 ? 100 : null;
	            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return tr;
	
	}));

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : talossan (tzl)
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v with the help of Iustì Canun
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	
	    // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
	    // This is currently too difficult (maybe even impossible) to add.
	    var tzl = moment.defineLocale('tzl', {
	        months : 'Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar'.split('_'),
	        monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
	        weekdays : 'Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi'.split('_'),
	        weekdaysShort : 'Súl_Lún_Mai_Már_Xhú_Vié_Sát'.split('_'),
	        weekdaysMin : 'Sú_Lú_Ma_Má_Xh_Vi_Sá'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM [dallas] YYYY',
	            LLL : 'D. MMMM [dallas] YYYY HH.mm',
	            LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'd\'o' : 'D\'O';
	            } else {
	                return isLower ? 'd\'a' : 'D\'A';
	            }
	        },
	        calendar : {
	            sameDay : '[oxhi à] LT',
	            nextDay : '[demà à] LT',
	            nextWeek : 'dddd [à] LT',
	            lastDay : '[ieiri à] LT',
	            lastWeek : '[sür el] dddd [lasteu à] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'osprei %s',
	            past : 'ja%s',
	            s : processRelativeTime,
	            m : processRelativeTime,
	            mm : processRelativeTime,
	            h : processRelativeTime,
	            hh : processRelativeTime,
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            's': ['viensas secunds', '\'iensas secunds'],
	            'm': ['\'n míut', '\'iens míut'],
	            'mm': [number + ' míuts', '' + number + ' míuts'],
	            'h': ['\'n þora', '\'iensa þora'],
	            'hh': [number + ' þoras', '' + number + ' þoras'],
	            'd': ['\'n ziua', '\'iensa ziua'],
	            'dd': [number + ' ziuas', '' + number + ' ziuas'],
	            'M': ['\'n mes', '\'iens mes'],
	            'MM': [number + ' mesen', '' + number + ' mesen'],
	            'y': ['\'n ar', '\'iens ar'],
	            'yy': [number + ' ars', '' + number + ' ars']
	        };
	        return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
	    }
	
	    return tzl;
	
	}));

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Morocco Central Atlas Tamaziɣt in Latin (tzm-latn)
	//! author : Abdel Said : https://github.com/abdelsaid
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var tzm_latn = moment.defineLocale('tzm-latn', {
	        months : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
	        monthsShort : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
	        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[asdkh g] LT',
	            nextDay: '[aska g] LT',
	            nextWeek: 'dddd [g] LT',
	            lastDay: '[assant g] LT',
	            lastWeek: 'dddd [g] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dadkh s yan %s',
	            past : 'yan %s',
	            s : 'imik',
	            m : 'minuḍ',
	            mm : '%d minuḍ',
	            h : 'saɛa',
	            hh : '%d tassaɛin',
	            d : 'ass',
	            dd : '%d ossan',
	            M : 'ayowr',
	            MM : '%d iyyirn',
	            y : 'asgas',
	            yy : '%d isgasn'
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return tzm_latn;
	
	}));

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Morocco Central Atlas Tamaziɣt (tzm)
	//! author : Abdel Said : https://github.com/abdelsaid
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var tzm = moment.defineLocale('tzm', {
	        months : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
	        monthsShort : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
	        weekdays : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	        weekdaysShort : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	        weekdaysMin : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[ⴰⵙⴷⵅ ⴴ] LT',
	            nextDay: '[ⴰⵙⴽⴰ ⴴ] LT',
	            nextWeek: 'dddd [ⴴ] LT',
	            lastDay: '[ⴰⵚⴰⵏⵜ ⴴ] LT',
	            lastWeek: 'dddd [ⴴ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s',
	            past : 'ⵢⴰⵏ %s',
	            s : 'ⵉⵎⵉⴽ',
	            m : 'ⵎⵉⵏⵓⴺ',
	            mm : '%d ⵎⵉⵏⵓⴺ',
	            h : 'ⵙⴰⵄⴰ',
	            hh : '%d ⵜⴰⵙⵙⴰⵄⵉⵏ',
	            d : 'ⴰⵙⵙ',
	            dd : '%d oⵙⵙⴰⵏ',
	            M : 'ⴰⵢoⵓⵔ',
	            MM : '%d ⵉⵢⵢⵉⵔⵏ',
	            y : 'ⴰⵙⴳⴰⵙ',
	            yy : '%d ⵉⵙⴳⴰⵙⵏ'
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return tzm;
	
	}));

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : ukrainian (uk)
	//! author : zemlanin : https://github.com/zemlanin
	//! Author : Menelion Elensúle : https://github.com/Oire
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? 'хвилина_хвилини_хвилин' : 'хвилину_хвилини_хвилин',
	            'hh': withoutSuffix ? 'година_години_годин' : 'годину_години_годин',
	            'dd': 'день_дні_днів',
	            'MM': 'місяць_місяці_місяців',
	            'yy': 'рік_роки_років'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? 'хвилина' : 'хвилину';
	        }
	        else if (key === 'h') {
	            return withoutSuffix ? 'година' : 'годину';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': 'неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота'.split('_'),
	            'accusative': 'неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу'.split('_'),
	            'genitive': 'неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи'.split('_')
	        },
	        nounCase = (/(\[[ВвУу]\]) ?dddd/).test(format) ?
	            'accusative' :
	            ((/\[?(?:минулої|наступної)? ?\] ?dddd/).test(format) ?
	                'genitive' :
	                'nominative');
	        return weekdays[nounCase][m.day()];
	    }
	    function processHoursFunction(str) {
	        return function () {
	            return str + 'о' + (this.hours() === 11 ? 'б' : '') + '] LT';
	        };
	    }
	
	    var uk = moment.defineLocale('uk', {
	        months : {
	            'format': 'січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня'.split('_'),
	            'standalone': 'січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень'.split('_')
	        },
	        monthsShort : 'січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд'.split('_'),
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	        weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY р.',
	            LLL : 'D MMMM YYYY р., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY р., HH:mm'
	        },
	        calendar : {
	            sameDay: processHoursFunction('[Сьогодні '),
	            nextDay: processHoursFunction('[Завтра '),
	            lastDay: processHoursFunction('[Вчора '),
	            nextWeek: processHoursFunction('[У] dddd ['),
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return processHoursFunction('[Минулої] dddd [').call(this);
	                case 1:
	                case 2:
	                case 4:
	                    return processHoursFunction('[Минулого] dddd [').call(this);
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'за %s',
	            past : '%s тому',
	            s : 'декілька секунд',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : 'годину',
	            hh : relativeTimeWithPlural,
	            d : 'день',
	            dd : relativeTimeWithPlural,
	            M : 'місяць',
	            MM : relativeTimeWithPlural,
	            y : 'рік',
	            yy : relativeTimeWithPlural
	        },
	        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
	        meridiemParse: /ночі|ранку|дня|вечора/,
	        isPM: function (input) {
	            return /^(дня|вечора)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'ночі';
	            } else if (hour < 12) {
	                return 'ранку';
	            } else if (hour < 17) {
	                return 'дня';
	            } else {
	                return 'вечора';
	            }
	        },
	        ordinalParse: /\d{1,2}-(й|го)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return number + '-й';
	            case 'D':
	                return number + '-го';
	            default:
	                return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return uk;
	
	}));

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : uzbek (uz)
	//! author : Sardor Muminov : https://github.com/muminoff
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var uz = moment.defineLocale('uz', {
	        months : 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split('_'),
	        monthsShort : 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
	        weekdays : 'Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба'.split('_'),
	        weekdaysShort : 'Якш_Душ_Сеш_Чор_Пай_Жум_Шан'.split('_'),
	        weekdaysMin : 'Як_Ду_Се_Чо_Па_Жу_Ша'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'D MMMM YYYY, dddd HH:mm'
	        },
	        calendar : {
	            sameDay : '[Бугун соат] LT [да]',
	            nextDay : '[Эртага] LT [да]',
	            nextWeek : 'dddd [куни соат] LT [да]',
	            lastDay : '[Кеча соат] LT [да]',
	            lastWeek : '[Утган] dddd [куни соат] LT [да]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'Якин %s ичида',
	            past : 'Бир неча %s олдин',
	            s : 'фурсат',
	            m : 'бир дакика',
	            mm : '%d дакика',
	            h : 'бир соат',
	            hh : '%d соат',
	            d : 'бир кун',
	            dd : '%d кун',
	            M : 'бир ой',
	            MM : '%d ой',
	            y : 'бир йил',
	            yy : '%d йил'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return uz;
	
	}));

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : vietnamese (vi)
	//! author : Bang Nguyen : https://github.com/bangnk
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var vi = moment.defineLocale('vi', {
	        months : 'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split('_'),
	        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
	        weekdays : 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split('_'),
	        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM [năm] YYYY',
	            LLL : 'D MMMM [năm] YYYY HH:mm',
	            LLLL : 'dddd, D MMMM [năm] YYYY HH:mm',
	            l : 'DD/M/YYYY',
	            ll : 'D MMM YYYY',
	            lll : 'D MMM YYYY HH:mm',
	            llll : 'ddd, D MMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Hôm nay lúc] LT',
	            nextDay: '[Ngày mai lúc] LT',
	            nextWeek: 'dddd [tuần tới lúc] LT',
	            lastDay: '[Hôm qua lúc] LT',
	            lastWeek: 'dddd [tuần rồi lúc] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s tới',
	            past : '%s trước',
	            s : 'vài giây',
	            m : 'một phút',
	            mm : '%d phút',
	            h : 'một giờ',
	            hh : '%d giờ',
	            d : 'một ngày',
	            dd : '%d ngày',
	            M : 'một tháng',
	            MM : '%d tháng',
	            y : 'một năm',
	            yy : '%d năm'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return vi;
	
	}));

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : chinese (zh-cn)
	//! author : suupic : https://github.com/suupic
	//! author : Zeno Zeng : https://github.com/zenozeng
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var zh_cn = moment.defineLocale('zh-cn', {
	        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
	        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
	        weekdaysShort : '周日_周一_周二_周三_周四_周五_周六'.split('_'),
	        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
	        longDateFormat : {
	            LT : 'Ah点mm分',
	            LTS : 'Ah点m分s秒',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY年MMMD日',
	            LLL : 'YYYY年MMMD日Ah点mm分',
	            LLLL : 'YYYY年MMMD日ddddAh点mm分',
	            l : 'YYYY-MM-DD',
	            ll : 'YYYY年MMMD日',
	            lll : 'YYYY年MMMD日Ah点mm分',
	            llll : 'YYYY年MMMD日ddddAh点mm分'
	        },
	        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '凌晨' || meridiem === '早上' ||
	                    meridiem === '上午') {
	                return hour;
	            } else if (meridiem === '下午' || meridiem === '晚上') {
	                return hour + 12;
	            } else {
	                // '中午'
	                return hour >= 11 ? hour : hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            var hm = hour * 100 + minute;
	            if (hm < 600) {
	                return '凌晨';
	            } else if (hm < 900) {
	                return '早上';
	            } else if (hm < 1130) {
	                return '上午';
	            } else if (hm < 1230) {
	                return '中午';
	            } else if (hm < 1800) {
	                return '下午';
	            } else {
	                return '晚上';
	            }
	        },
	        calendar : {
	            sameDay : function () {
	                return this.minutes() === 0 ? '[今天]Ah[点整]' : '[今天]LT';
	            },
	            nextDay : function () {
	                return this.minutes() === 0 ? '[明天]Ah[点整]' : '[明天]LT';
	            },
	            lastDay : function () {
	                return this.minutes() === 0 ? '[昨天]Ah[点整]' : '[昨天]LT';
	            },
	            nextWeek : function () {
	                var startOfWeek, prefix;
	                startOfWeek = moment().startOf('week');
	                prefix = this.unix() - startOfWeek.unix() >= 7 * 24 * 3600 ? '[下]' : '[本]';
	                return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';
	            },
	            lastWeek : function () {
	                var startOfWeek, prefix;
	                startOfWeek = moment().startOf('week');
	                prefix = this.unix() < startOfWeek.unix()  ? '[上]' : '[本]';
	                return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';
	            },
	            sameElse : 'LL'
	        },
	        ordinalParse: /\d{1,2}(日|月|周)/,
	        ordinal : function (number, period) {
	            switch (period) {
	            case 'd':
	            case 'D':
	            case 'DDD':
	                return number + '日';
	            case 'M':
	                return number + '月';
	            case 'w':
	            case 'W':
	                return number + '周';
	            default:
	                return number;
	            }
	        },
	        relativeTime : {
	            future : '%s内',
	            past : '%s前',
	            s : '几秒',
	            m : '1 分钟',
	            mm : '%d 分钟',
	            h : '1 小时',
	            hh : '%d 小时',
	            d : '1 天',
	            dd : '%d 天',
	            M : '1 个月',
	            MM : '%d 个月',
	            y : '1 年',
	            yy : '%d 年'
	        },
	        week : {
	            // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return zh_cn;
	
	}));

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : traditional chinese (zh-tw)
	//! author : Ben : https://github.com/ben-lin
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(1)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var zh_tw = moment.defineLocale('zh-tw', {
	        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
	        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
	        weekdaysShort : '週日_週一_週二_週三_週四_週五_週六'.split('_'),
	        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
	        longDateFormat : {
	            LT : 'Ah點mm分',
	            LTS : 'Ah點m分s秒',
	            L : 'YYYY年MMMD日',
	            LL : 'YYYY年MMMD日',
	            LLL : 'YYYY年MMMD日Ah點mm分',
	            LLLL : 'YYYY年MMMD日ddddAh點mm分',
	            l : 'YYYY年MMMD日',
	            ll : 'YYYY年MMMD日',
	            lll : 'YYYY年MMMD日Ah點mm分',
	            llll : 'YYYY年MMMD日ddddAh點mm分'
	        },
	        meridiemParse: /早上|上午|中午|下午|晚上/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '早上' || meridiem === '上午') {
	                return hour;
	            } else if (meridiem === '中午') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === '下午' || meridiem === '晚上') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            var hm = hour * 100 + minute;
	            if (hm < 900) {
	                return '早上';
	            } else if (hm < 1130) {
	                return '上午';
	            } else if (hm < 1230) {
	                return '中午';
	            } else if (hm < 1800) {
	                return '下午';
	            } else {
	                return '晚上';
	            }
	        },
	        calendar : {
	            sameDay : '[今天]LT',
	            nextDay : '[明天]LT',
	            nextWeek : '[下]ddddLT',
	            lastDay : '[昨天]LT',
	            lastWeek : '[上]ddddLT',
	            sameElse : 'L'
	        },
	        ordinalParse: /\d{1,2}(日|月|週)/,
	        ordinal : function (number, period) {
	            switch (period) {
	            case 'd' :
	            case 'D' :
	            case 'DDD' :
	                return number + '日';
	            case 'M' :
	                return number + '月';
	            case 'w' :
	            case 'W' :
	                return number + '週';
	            default :
	                return number;
	            }
	        },
	        relativeTime : {
	            future : '%s內',
	            past : '%s前',
	            s : '幾秒',
	            m : '一分鐘',
	            mm : '%d分鐘',
	            h : '一小時',
	            hh : '%d小時',
	            d : '一天',
	            dd : '%d天',
	            M : '一個月',
	            MM : '%d個月',
	            y : '一年',
	            yy : '%d年'
	        }
	    });
	
	    return zh_tw;
	
	}));

/***/ },
/* 233 */
/***/ function(module, exports) {

	'use strict';
	
	function Request(optsOrUrl) {
	  var opts = typeof optsOrUrl === 'string' ? {url: optsOrUrl} : optsOrUrl || {};
	  this.method = opts.method ? opts.method.toUpperCase() : 'GET';
	  this.url = opts.url;
	  this.headers = opts.headers || {};
	  this.body = opts.body;
	  this.timeout = opts.timeout || 0;
	  this.errorOn404 = opts.errorOn404 != null ? opts.errorOn404 : true;
	  this.onload = opts.onload;
	  this.onerror = opts.onerror;
	}
	
	Request.prototype.abort = function() {
	  if (this.aborted) return;
	  this.aborted = true;
	  this.xhr.abort();
	  return this;
	};
	
	Request.prototype.header = function(name, value) {
	  var k;
	  for (k in this.headers) {
	    if (this.headers.hasOwnProperty(k)) {
	      if (name.toLowerCase() === k.toLowerCase()) {
	        if (arguments.length === 1) {
	          return this.headers[k];
	        }
	
	        delete this.headers[k];
	        break;
	      }
	    }
	  }
	  if (value != null) {
	    this.headers[name] = value;
	    return value;
	  }
	};
	
	
	module.exports = Request;


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Request = __webpack_require__(233);
	var extractResponseProps = __webpack_require__(235);
	
	function Response(props) {
	  this.request = props.request;
	  this.xhr = props.xhr;
	  this.headers = props.headers || {};
	  this.status = props.status || 0;
	  this.text = props.text;
	  this.body = props.body;
	  this.contentType = props.contentType;
	  this.isHttpError = props.status >= 400;
	}
	
	Response.prototype.header = Request.prototype.header;
	
	Response.fromRequest = function(req) {
	  return new Response(extractResponseProps(req));
	};
	
	
	module.exports = Response;


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var extend = __webpack_require__(97);
	
	module.exports = function(req) {
	  var xhr = req.xhr;
	  var props = {request: req, xhr: xhr};
	
	  // Try to create the response from the request. If the request was aborted,
	  // accesssing properties of the XHR may throw an error, so we wrap in a
	  // try/catch.
	  try {
	    var lines, i, m, headers = {};
	    if (xhr.getAllResponseHeaders) {
	      lines = xhr.getAllResponseHeaders().split('\n');
	      for (i = 0; i < lines.length; i++) {
	        if ((m = lines[i].match(/\s*([^\s]+):\s+([^\s]+)/))) {
	          headers[m[1]] = m[2];
	        }
	      }
	    }
	
	    props = extend(props, {
	      status: xhr.status,
	      contentType: xhr.contentType || (xhr.getResponseHeader && xhr.getResponseHeader('Content-Type')),
	      headers: headers,
	      text: xhr.responseText,
	      body: xhr.response || xhr.responseText
	    });
	  } catch (err) {}
	
	  return props;
	};


/***/ },
/* 236 */
/***/ function(module, exports) {

	'use strict';
	
	// A "once" utility.
	module.exports = function(fn) {
	  var result, called = false;
	  return function() {
	    if (!called) {
	      called = true;
	      result = fn.apply(this, arguments);
	    }
	    return result;
	  };
	};


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _require = __webpack_require__(5);
	
	var PropTypes = _require.PropTypes;
	
	var storeShape = PropTypes.shape({
	  subscribe: PropTypes.func.isRequired,
	  dispatch: PropTypes.func.isRequired,
	  getState: PropTypes.func.isRequired
	});
	
	module.exports = storeShape;

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var React3Module = function () {
	  function React3Module() {
	    _classCallCheck(this, React3Module);
	
	    this.userData = {};
	    this.uuid = _three2.default.Math.generateUUID();
	  }
	
	  _createClass(React3Module, [{
	    key: 'setup',
	    value: function setup(react3RendererInstance) {// eslint-disable-line no-unused-vars
	
	    }
	  }, {
	    key: 'update',
	    value: function update() {}
	  }, {
	    key: 'dispose',
	    value: function dispose() {}
	  }]);
	
	  return React3Module;
	}();
	
	module.exports = React3Module;

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _ReactCompositeComponent = __webpack_require__(254);
	
	var _ReactCompositeComponent2 = _interopRequireDefault(_ReactCompositeComponent);
	
	var _ReactElement = __webpack_require__(11);
	
	var _ReactElement2 = _interopRequireDefault(_ReactElement);
	
	var _ReactCurrentOwner = __webpack_require__(19);
	
	var _ReactCurrentOwner2 = _interopRequireDefault(_ReactCurrentOwner);
	
	var _ReactReconciler = __webpack_require__(23);
	
	var _ReactReconciler2 = _interopRequireDefault(_ReactReconciler);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ReactInstanceMap = __webpack_require__(32);
	
	var _ReactInstanceMap2 = _interopRequireDefault(_ReactInstanceMap);
	
	var _emptyObject = __webpack_require__(248);
	
	var _emptyObject2 = _interopRequireDefault(_emptyObject);
	
	var _warning = __webpack_require__(30);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _ReactUpdateQueue = __webpack_require__(45);
	
	var _ReactUpdateQueue2 = _interopRequireDefault(_ReactUpdateQueue);
	
	var _ReactComponent2 = __webpack_require__(62);
	
	var _ReactComponent3 = _interopRequireDefault(_ReactComponent2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ReactCompositeComponentMixinImpl = function ReactCompositeComponentMixinImpl() {
	  _classCallCheck(this, ReactCompositeComponentMixinImpl);
	};
	
	ReactCompositeComponentMixinImpl.prototype = _extends({}, ReactCompositeComponentMixinImpl.prototype, _ReactCompositeComponent2.default.Mixin);
	
	var StatelessComponent = function (_ReactComponent) {
	  _inherits(StatelessComponent, _ReactComponent);
	
	  function StatelessComponent() {
	    _classCallCheck(this, StatelessComponent);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(StatelessComponent).apply(this, arguments));
	  }
	
	  _createClass(StatelessComponent, [{
	    key: 'render',
	    value: function render() {
	      var component = _ReactInstanceMap2.default.get(this)._currentElement.type;
	      return component(this.props, this.context, this.updater);
	    }
	  }]);
	
	  return StatelessComponent;
	}(_ReactComponent3.default);
	
	var React3CompositeComponentWrapper = function (_ReactCompositeCompon) {
	  _inherits(React3CompositeComponentWrapper, _ReactCompositeCompon);
	
	  function React3CompositeComponentWrapper(react3RendererInstance) {
	    _classCallCheck(this, React3CompositeComponentWrapper);
	
	    var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(React3CompositeComponentWrapper).call(this));
	
	    _this2._react3RendererInstance = react3RendererInstance;
	    return _this2;
	  }
	
	  _createClass(React3CompositeComponentWrapper, [{
	    key: 'construct',
	    value: function construct(element) {
	      _get(Object.getPrototypeOf(React3CompositeComponentWrapper.prototype), 'construct', this).call(this, element);
	
	      this._threeObject = null;
	    }
	  }, {
	    key: 'unmountComponent',
	    value: function unmountComponent() {
	      _get(Object.getPrototypeOf(React3CompositeComponentWrapper.prototype), 'unmountComponent', this).call(this);
	
	      // this._threeObject = null;
	    }
	  }, {
	    key: '_updateRenderedComponent',
	    value: function _updateRenderedComponent(transaction, context) {
	      _get(Object.getPrototypeOf(React3CompositeComponentWrapper.prototype), '_updateRenderedComponent', this).call(this, transaction, context);
	
	      this._threeObject = this._renderedComponent._threeObject;
	    }
	  }, {
	    key: '_instantiateReactComponent',
	    value: function _instantiateReactComponent(element) {
	      return this._react3RendererInstance.instantiateReactComponent(element);
	    }
	
	    // See ReactCompositeComponent.mountComponent
	
	  }, {
	    key: 'mountComponent',
	    value: function mountComponent(rootID, transaction, context) {
	      this._context = context;
	      this._mountOrder = this._react3RendererInstance.nextMountID++;
	      this._rootNodeID = rootID;
	
	      var publicProps = this._processProps(this._currentElement.props);
	      var publicContext = this._processContext(context);
	
	      var Component = this._currentElement.type;
	
	      // Initialize the public class
	      var inst = undefined;
	      var renderedElement = undefined;
	
	      // This is a way to detect if Component is a stateless arrow function
	      // component, which is not newable. It might not be 100% reliable but is
	      // something we can do until we start detecting that Component extends
	      // React.Component. We already assume that typeof Component === 'function'.
	      var canInstantiate = 'prototype' in Component;
	
	      if (canInstantiate) {
	        if (false) {
	          var previousCurrent = _ReactCurrentOwner2.default.current;
	
	          // noinspection JSValidateTypes
	          _ReactCurrentOwner2.default.current = this;
	
	          try {
	            inst = new Component(publicProps, publicContext, _ReactUpdateQueue2.default);
	          } finally {
	            _ReactCurrentOwner2.default.current = previousCurrent;
	          }
	        } else {
	          inst = new Component(publicProps, publicContext, _ReactUpdateQueue2.default);
	        }
	      }
	
	      if (!canInstantiate || inst === null || inst === false || _ReactElement2.default.isValidElement(inst)) {
	        renderedElement = inst;
	        inst = new StatelessComponent(Component);
	      }
	
	      if (false) {
	        // This will throw later in _renderValidatedComponent, but add an early
	        // warning now to help debugging
	        if (inst.render === null) {
	          if (process.env.NODE_ENV !== 'production') {
	            (0, _warning2.default)(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component');
	          }
	        } else {
	          // We support ES6 inheriting from React.Component, the module pattern,
	          // and stateless components, but not ES6 classes that don't extend
	          if (process.env.NODE_ENV !== 'production') {
	            var allOK = Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component);
	            (0, _warning2.default)(allOK, '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component');
	          }
	        }
	      }
	
	      // These should be set up in the constructor, but as a convenience for
	      // simpler class abstractions, we set them up after the fact.
	      inst.props = publicProps;
	      inst.context = publicContext;
	      inst.refs = _emptyObject2.default;
	      inst.updater = _ReactUpdateQueue2.default;
	
	      this._instance = inst;
	
	      // Store a reference from the instance back to the internal representation
	      _ReactInstanceMap2.default.set(inst, this);
	
	      if (false) {
	        // Since plain JS classes are defined without any special initialization
	        // logic, we can not catch common errors early. Therefore, we have to
	        // catch them here, at initialization time, instead.
	        if (process.env.NODE_ENV !== 'production') {
	          (0, _warning2.default)(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component');
	          (0, _warning2.default)(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component');
	          (0, _warning2.default)(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component');
	          (0, _warning2.default)(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component');
	          (0, _warning2.default)(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component');
	          (0, _warning2.default)(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component');
	          (0, _warning2.default)(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component');
	        }
	      }
	
	      var initialState = inst.state;
	      if (initialState === undefined) {
	        inst.state = initialState = null;
	      }
	      if (!((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState))) {
	        if (false) {
	          (0, _invariant2.default)(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent');
	        } else {
	          (0, _invariant2.default)(false);
	        }
	      }
	
	      this._pendingStateQueue = null;
	      this._pendingReplaceState = false;
	      this._pendingForceUpdate = false;
	
	      if (inst.componentWillMount) {
	        inst.componentWillMount();
	        // When mounting, calls to `setState` by `componentWillMount` will set
	        // `this._pendingStateQueue` without triggering a re-render.
	        if (this._pendingStateQueue) {
	          inst.state = this._processPendingState(inst.props, inst.context);
	        }
	      }
	
	      // If not a stateless component, we now render
	      if (renderedElement === undefined) {
	        renderedElement = this._renderValidatedComponent();
	      }
	
	      this._renderedComponent = this._instantiateReactComponent(renderedElement);
	
	      var markup = _ReactReconciler2.default.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
	      this._threeObject = this._renderedComponent._threeObject;
	      if (inst.componentDidMount) {
	        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	      }
	
	      return markup;
	    }
	
	    /**
	     * Needs to be overwritten because emptyObject points to another...
	     *
	     * Lazily allocates the refs object and stores `component` as `ref`.
	     *
	     * @param {string} ref Reference name.
	     * @param {*} component Component to store as `ref`.
	     * @final
	     * @private
	     */
	
	  }, {
	    key: 'attachRef',
	    value: function attachRef(ref, component) {
	      var inst = this.getPublicInstance();
	      var refs = inst.refs === _emptyObject2.default ? inst.refs = {} : inst.refs;
	      refs[ref] = component.getPublicInstance();
	    }
	  }]);
	
	  return React3CompositeComponentWrapper;
	}(ReactCompositeComponentMixinImpl);
	
	module.exports = React3CompositeComponentWrapper;

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ResourceReference2 = __webpack_require__(41);
	
	var _ResourceReference3 = _interopRequireDefault(_ResourceReference2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ShapeResourceReference = function (_ResourceReference) {
	  _inherits(ShapeResourceReference, _ResourceReference);
	
	  function ShapeResourceReference(resourceId) {
	    _classCallCheck(this, ShapeResourceReference);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(ShapeResourceReference).call(this, resourceId));
	  }
	
	  return ShapeResourceReference;
	}(_ResourceReference3.default);
	
	module.exports = ShapeResourceReference;

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ShapeAction2 = __webpack_require__(25);
	
	var _ShapeAction3 = _interopRequireDefault(_ShapeAction2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var HoleAction = function (_ShapeAction) {
	  _inherits(HoleAction, _ShapeAction);
	
	  function HoleAction() {
	    _classCallCheck(this, HoleAction);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(HoleAction).call(this));
	
	    _this.path = new _three2.default.Path();
	    return _this;
	  }
	
	  _createClass(HoleAction, [{
	    key: 'performAction',
	    value: function performAction(shape) {
	      shape.holes.push(this.path);
	    }
	  }]);
	
	  return HoleAction;
	}(_ShapeAction3.default);
	
	module.exports = HoleAction;

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Viewport = function Viewport(props) {
	  _classCallCheck(this, Viewport);
	
	  this.userData = {};
	
	  this.uuid = _three2.default.Math.generateUUID();
	
	  this.x = props.x;
	  this.y = props.y;
	  this.width = props.width;
	  this.height = props.height;
	  this.cameraName = props.cameraName;
	  this.onBeforeRender = props.onBeforeRender;
	};
	
	module.exports = Viewport;

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _THREEElementDescriptor = __webpack_require__(13);
	
	var _THREEElementDescriptor2 = _interopRequireDefault(_THREEElementDescriptor);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _ShapeAction = __webpack_require__(25);
	
	var _ShapeAction2 = _interopRequireDefault(_ShapeAction);
	
	var _propTypeInstanceOf = __webpack_require__(17);
	
	var _propTypeInstanceOf2 = _interopRequireDefault(_propTypeInstanceOf);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var PathDescriptorBase = function (_THREEElementDescript) {
	  _inherits(PathDescriptorBase, _THREEElementDescript);
	
	  function PathDescriptorBase(react3RendererInstance) {
	    _classCallCheck(this, PathDescriptorBase);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PathDescriptorBase).call(this, react3RendererInstance));
	
	    _this._invalidChild = function (child) {
	      var invalid = !(child instanceof _ShapeAction2.default);
	
	      return invalid;
	    };
	
	    _this.hasProp('points', {
	      type: _ReactPropTypes2.default.arrayOf((0, _propTypeInstanceOf2.default)(_three2.default.Vector2)),
	      update: _this.triggerRemount,
	      default: []
	    });
	    return _this;
	  }
	
	  _createClass(PathDescriptorBase, [{
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      threeObject.userData = _extends({}, threeObject.userData);
	
	      // paths don't have uuids
	      threeObject.uuid = _three2.default.Math.generateUUID();
	
	      return _get(Object.getPrototypeOf(PathDescriptorBase.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	    }
	  }, {
	    key: 'addChildren',
	    value: function addChildren(threeObject, children) {
	      var _this2 = this;
	
	      // TODO: create paths here
	
	      if (false) {
	        (0, _invariant2.default)(children.filter(this._invalidChild).length === 0, 'Shape children can only be shape actions!');
	      } else {
	        (0, _invariant2.default)(children.filter(this._invalidChild).length === 0, false);
	      }
	
	      // apply all actions in order
	      children.forEach(function (child) {
	        _this2.performChildAction(threeObject, child);
	      });
	    }
	  }, {
	    key: 'performChildAction',
	    value: function performChildAction(threeObject, child) {
	      child.performAction(threeObject);
	    }
	  }, {
	    key: 'addChild',
	    value: function addChild(threeObject) {
	      this.triggerRemount(threeObject);
	    }
	  }, {
	    key: 'moveChild',
	    value: function moveChild(threeObject) {
	      this.triggerRemount(threeObject);
	    }
	  }, {
	    key: 'removeChild',
	    value: function removeChild(threeObject) {
	      this.triggerRemount(threeObject);
	    }
	  }, {
	    key: 'highlight',
	    value: function highlight(threeObject) {
	      var parentObject = threeObject.userData.markup.parentMarkup.threeObject;
	
	      parentObject.userData._descriptor.highlight(parentObject);
	    }
	  }, {
	    key: 'getBoundingBoxes',
	    value: function getBoundingBoxes(threeObject) {
	      var parentObject = threeObject.userData.markup.parentMarkup.threeObject;
	
	      return parentObject.userData._descriptor.getBoundingBoxes(parentObject);
	    }
	  }]);
	
	  return PathDescriptorBase;
	}(_THREEElementDescriptor2.default);
	
	module.exports = PathDescriptorBase;

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _Object3DDescriptor2 = __webpack_require__(22);
	
	var _Object3DDescriptor3 = _interopRequireDefault(_Object3DDescriptor2);
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var CameraDescriptorBase = function (_Object3DDescriptor) {
	  _inherits(CameraDescriptorBase, _Object3DDescriptor);
	
	  function CameraDescriptorBase() {
	    _classCallCheck(this, CameraDescriptorBase);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(CameraDescriptorBase).apply(this, arguments));
	  }
	
	  _createClass(CameraDescriptorBase, [{
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(CameraDescriptorBase.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	    }
	  }, {
	    key: 'setParent',
	    value: function setParent(camera, parentObject3D) {
	      _get(Object.getPrototypeOf(CameraDescriptorBase.prototype), 'setParent', this).call(this, camera, parentObject3D);
	    }
	  }, {
	    key: 'unmount',
	    value: function unmount(threeObject) {
	      _get(Object.getPrototypeOf(CameraDescriptorBase.prototype), 'unmount', this).call(this, threeObject);
	    }
	  }, {
	    key: 'beginPropertyUpdates',
	    value: function beginPropertyUpdates(threeObject) {
	      _get(Object.getPrototypeOf(CameraDescriptorBase.prototype), 'beginPropertyUpdates', this).call(this, threeObject);
	
	      threeObject.userData._needsProjectionMatrixUpdate = false;
	    }
	
	    /**
	     * @param {THREE.PerspectiveCamera | THREE.OrthographicCamera} threeObject
	     */
	
	  }, {
	    key: 'completePropertyUpdates',
	    value: function completePropertyUpdates(threeObject) {
	      _get(Object.getPrototypeOf(CameraDescriptorBase.prototype), 'completePropertyUpdates', this).call(this, threeObject);
	
	      if (threeObject.userData._needsProjectionMatrixUpdate) {
	        threeObject.userData._needsProjectionMatrixUpdate = false;
	
	        threeObject.updateProjectionMatrix();
	        threeObject.userData.events.emit('updateProjectionMatrix');
	      }
	    }
	  }]);
	
	  return CameraDescriptorBase;
	}(_Object3DDescriptor3.default);
	
	module.exports = CameraDescriptorBase;

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _ResourceDescriptorBase = __webpack_require__(59);
	
	var _ResourceDescriptorBase2 = _interopRequireDefault(_ResourceDescriptorBase);
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var GeometryResourceDescriptor = function (_ResourceDescriptorBa) {
	  _inherits(GeometryResourceDescriptor, _ResourceDescriptorBa);
	
	  function GeometryResourceDescriptor() {
	    _classCallCheck(this, GeometryResourceDescriptor);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(GeometryResourceDescriptor).apply(this, arguments));
	  }
	
	  _createClass(GeometryResourceDescriptor, [{
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(GeometryResourceDescriptor.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	
	      threeObject.userData._propertySlot = 'geometry';
	    }
	  }, {
	    key: 'setParent',
	    value: function setParent(threeObject, parentObject3D) {
	      (0, _invariant2.default)(parentObject3D instanceof _three2.default.Mesh || parentObject3D instanceof _three2.default.Points || parentObject3D instanceof _three2.default.Line, 'Parent is not a mesh');
	
	      _get(Object.getPrototypeOf(GeometryResourceDescriptor.prototype), 'setParent', this).call(this, threeObject, parentObject3D);
	    }
	  }]);
	
	  return GeometryResourceDescriptor;
	}(_ResourceDescriptorBase2.default);
	
	module.exports = GeometryResourceDescriptor;

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _class, _temp;
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var CameraUtils = (_temp = _class = function CameraUtils() {
	  _classCallCheck(this, CameraUtils);
	}, _class.current = null, _temp);
	
	module.exports = CameraUtils;

/***/ },
/* 247 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = 'data-reactid';

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (false) {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;

/***/ },
/* 249 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSProperty
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  stopOpacity: true,
	  strokeDashoffset: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMChildrenOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var Danger = __webpack_require__(432);
	var ReactMultiChildUpdateTypes = __webpack_require__(266);
	var ReactPerf = __webpack_require__(20);
	
	var setInnerHTML = __webpack_require__(67);
	var setTextContent = __webpack_require__(120);
	var invariant = __webpack_require__(4);
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	function insertChildAt(parentNode, childNode, index) {
	  // By exploiting arrays returning `undefined` for an undefined index, we can
	  // rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. However, using `undefined` is not allowed by all
	  // browsers so we must replace it with `null`.
	
	  // fix render order error in safari
	  // IE8 will throw error when index out of list size.
	  var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);
	
	  parentNode.insertBefore(childNode, beforeChild);
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
	
	  updateTextContent: setTextContent,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markupList List of markup strings.
	   * @internal
	   */
	  processUpdates: function (updates, markupList) {
	    var update;
	    // Mapping from parent IDs to initial child orderings.
	    var initialChildren = null;
	    // List of children that will be moved or removed.
	    var updatedChildren = null;
	
	    for (var i = 0; i < updates.length; i++) {
	      update = updates[i];
	      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
	        var updatedIndex = update.fromIndex;
	        var updatedChild = update.parentNode.childNodes[updatedIndex];
	        var parentID = update.parentID;
	
	        !updatedChild ?  false ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;
	
	        initialChildren = initialChildren || {};
	        initialChildren[parentID] = initialChildren[parentID] || [];
	        initialChildren[parentID][updatedIndex] = updatedChild;
	
	        updatedChildren = updatedChildren || [];
	        updatedChildren.push(updatedChild);
	      }
	    }
	
	    var renderedMarkup;
	    // markupList is either a list of markup or just a list of elements
	    if (markupList.length && typeof markupList[0] === 'string') {
	      renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
	    } else {
	      renderedMarkup = markupList;
	    }
	
	    // Remove updated children first so that `toIndex` is consistent.
	    if (updatedChildren) {
	      for (var j = 0; j < updatedChildren.length; j++) {
	        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
	      }
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      update = updates[k];
	      switch (update.type) {
	        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
	          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
	          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.SET_MARKUP:
	          setInnerHTML(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
	          setTextContent(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.REMOVE_NODE:
	          // Already removed by the for-loop above.
	          break;
	      }
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(DOMChildrenOperations, 'DOMChildrenOperations', {
	  updateTextContent: 'updateTextContent'
	});
	
	module.exports = DOMChildrenOperations;

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginRegistry
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(4);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var EventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!EventPluginOrder) {
	    // Wait until an `EventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var PluginModule = namesToPlugins[pluginName];
	    var pluginIndex = EventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ?  false ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !PluginModule.extractEvents ?  false ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
	    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
	    var publishedEvents = PluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ?  false ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ?  false ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, PluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ?  false ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
	  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function (InjectedEventPluginOrder) {
	    !!EventPluginOrder ?  false ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
	    // Clone the ordering so it cannot be dynamically mutated.
	    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function (injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var PluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
	        !!namesToPlugins[pluginName] ?  false ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
	        namesToPlugins[pluginName] = PluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function (event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    for (var phase in dispatchConfig.phasedRegistrationNames) {
	      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
	        continue;
	      }
	      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
	      if (PluginModule) {
	        return PluginModule;
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function () {
	    EventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildren
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(27);
	var ReactElement = __webpack_require__(11);
	
	var emptyFunction = __webpack_require__(24);
	var traverseAllChildren = __webpack_require__(69);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/(?!\/)/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '//');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result;
	  var keyPrefix = bookKeeping.keyPrefix;
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild !== child ? escapeUserProvidedKey(mappedChild.key || '') + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactClass
	 */
	
	'use strict';
	
	var ReactComponent = __webpack_require__(62);
	var ReactElement = __webpack_require__(11);
	var ReactPropTypeLocations = __webpack_require__(44);
	var ReactPropTypeLocationNames = __webpack_require__(33);
	var ReactNoopUpdateQueue = __webpack_require__(268);
	
	var assign = __webpack_require__(7);
	var emptyObject = __webpack_require__(47);
	var invariant = __webpack_require__(4);
	var keyMirror = __webpack_require__(70);
	var keyOf = __webpack_require__(28);
	var warning = __webpack_require__(8);
	
	var MIXINS_KEY = keyOf({ mixins: null });
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	var SpecPolicy = keyMirror({
	  /**
	   * These methods may be defined only once by the class specification or mixin.
	   */
	  DEFINE_ONCE: null,
	  /**
	   * These methods may be defined by both the class specification and mixins.
	   * Subsequent definitions will be chained. These methods must return void.
	   */
	  DEFINE_MANY: null,
	  /**
	   * These methods are overriding the base class.
	   */
	  OVERRIDE_BASE: null,
	  /**
	   * These methods are similar to DEFINE_MANY, except we assume they return
	   * objects. We try to merge the keys of the return values of all the mixed in
	   * functions. If there is a key conflict we throw.
	   */
	  DEFINE_MANY_MERGED: null
	});
	
	var injectedMixins = [];
	
	var warnedSetProps = false;
	function warnSetProps() {
	  if (!warnedSetProps) {
	    warnedSetProps = true;
	     false ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call render again at the top level.') : undefined;
	  }
	}
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or native components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: SpecPolicy.DEFINE_MANY,
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: SpecPolicy.DEFINE_ONCE,
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: SpecPolicy.DEFINE_MANY,
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: SpecPolicy.OVERRIDE_BASE
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function (Constructor, displayName) {
	    Constructor.displayName = displayName;
	  },
	  mixins: function (Constructor, mixins) {
	    if (mixins) {
	      for (var i = 0; i < mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function (Constructor, childContextTypes) {
	    if (false) {
	      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
	    }
	    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
	  },
	  contextTypes: function (Constructor, contextTypes) {
	    if (false) {
	      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
	    }
	    Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function (Constructor, getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = getDefaultProps;
	    }
	  },
	  propTypes: function (Constructor, propTypes) {
	    if (false) {
	      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
	    }
	    Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
	  },
	  statics: function (Constructor, statics) {
	    mixStaticSpecIntoComponent(Constructor, statics);
	  },
	  autobind: function () {} };
	
	// noop
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but not in __DEV__
	       false ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
	    }
	  }
	}
	
	function validateMethodOverride(proto, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ?  false ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (proto.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ?  false ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classses.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    return;
	  }
	
	  !(typeof spec !== 'function') ?  false ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
	  !!ReactElement.isValidElement(spec) ?  false ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
	
	  var proto = Constructor.prototype;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }
	
	    var property = spec[name];
	    validateMethodOverride(proto, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isAlreadyDefined = proto.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	      if (shouldAutoBind) {
	        if (!proto.__reactAutoBindMap) {
	          proto.__reactAutoBindMap = {};
	        }
	        proto.__reactAutoBindMap[name] = property;
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ?  false ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (false) {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = (name in RESERVED_SPEC_KEYS);
	    !!isReserved ?  false ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;
	
	    var isInherited = (name in Constructor);
	    !!isInherited ?  false ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && typeof one === 'object' && typeof two === 'object') ?  false ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ?  false ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (false) {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    /* eslint-disable block-scoped-var, no-undef */
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	      /* eslint-enable */
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  for (var autoBindKey in component.__reactAutoBindMap) {
	    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
	      var method = component.__reactAutoBindMap[autoBindKey];
	      component[autoBindKey] = bindAutoBindMethod(component, method);
	    }
	  }
	}
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function (newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function () {
	    return this.updater.isMounted(this);
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {object} partialProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  setProps: function (partialProps, callback) {
	    if (false) {
	      warnSetProps();
	    }
	    this.updater.enqueueSetProps(this, partialProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },
	
	  /**
	   * Replace all the props.
	   *
	   * @param {object} newProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  replaceProps: function (newProps, callback) {
	    if (false) {
	      warnSetProps();
	    }
	    this.updater.enqueueReplaceProps(this, newProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  }
	};
	
	var ReactClassComponent = function () {};
	assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function (spec) {
	    var Constructor = function (props, context, updater) {
	      // This constructor is overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (false) {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindMap) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (false) {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !(typeof initialState === 'object' && !Array.isArray(initialState)) ?  false ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;
	
	      this.state = initialState;
	    };
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (false) {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    !Constructor.prototype.render ?  false ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;
	
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function (mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCompositeComponent
	 */
	
	'use strict';
	
	var ReactComponentEnvironment = __webpack_require__(107);
	var ReactCurrentOwner = __webpack_require__(19);
	var ReactElement = __webpack_require__(11);
	var ReactInstanceMap = __webpack_require__(32);
	var ReactPerf = __webpack_require__(20);
	var ReactPropTypeLocations = __webpack_require__(44);
	var ReactPropTypeLocationNames = __webpack_require__(33);
	var ReactReconciler = __webpack_require__(23);
	var ReactUpdateQueue = __webpack_require__(45);
	
	var assign = __webpack_require__(7);
	var emptyObject = __webpack_require__(47);
	var invariant = __webpack_require__(4);
	var shouldUpdateReactComponent = __webpack_require__(68);
	var warning = __webpack_require__(8);
	
	function getDeclarationErrorAddendum(component) {
	  var owner = component._currentElement._owner || null;
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  return Component(this.props, this.context, this.updater);
	};
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponentMixin = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function (element) {
	    this._currentElement = element;
	    this._rootNodeID = null;
	    this._instance = null;
	
	    // See ReactUpdateQueue
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedComponent = null;
	
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (rootID, transaction, context) {
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._rootNodeID = rootID;
	
	    var publicProps = this._processProps(this._currentElement.props);
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    // Initialize the public class
	    var inst;
	    var renderedElement;
	
	    // This is a way to detect if Component is a stateless arrow function
	    // component, which is not newable. It might not be 100% reliable but is
	    // something we can do until we start detecting that Component extends
	    // React.Component. We already assume that typeof Component === 'function'.
	    var canInstantiate = ('prototype' in Component);
	
	    if (canInstantiate) {
	      if (false) {
	        ReactCurrentOwner.current = this;
	        try {
	          inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	        } finally {
	          ReactCurrentOwner.current = null;
	        }
	      } else {
	        inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	      }
	    }
	
	    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {
	      renderedElement = inst;
	      inst = new StatelessComponent(Component);
	    }
	
	    if (false) {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
	      } else {
	        // We support ES6 inheriting from React.Component, the module pattern,
	        // and stateless components, but not ES6 classes that don't extend
	        process.env.NODE_ENV !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;
	      }
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = ReactUpdateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (false) {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !(typeof initialState === 'object' && !Array.isArray(initialState)) ?  false ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    if (inst.componentWillMount) {
	      inst.componentWillMount();
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    this._renderedComponent = this._instantiateReactComponent(renderedElement);
	
	    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
	    if (inst.componentDidMount) {
	      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	    }
	
	    return markup;
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function () {
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount) {
	      inst.componentWillUnmount();
	    }
	
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    this._renderedComponent = null;
	    this._instance = null;
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = null;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function (context) {
	    var maskedContext = null;
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function (context) {
	    var maskedContext = this._maskContext(context);
	    if (false) {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function (currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext = inst.getChildContext && inst.getChildContext();
	    if (childContext) {
	      !(typeof Component.childContextTypes === 'object') ?  false ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	      if (false) {
	        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ?  false ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
	      }
	      return assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Processes props by setting default values for unspecified props and
	   * asserting that the props are valid. Does not mutate its argument; returns
	   * a new props object with defaults merged in.
	   *
	   * @param {object} newProps
	   * @return {object}
	   * @private
	   */
	  _processProps: function (newProps) {
	    if (false) {
	      var Component = this._currentElement.type;
	      if (Component.propTypes) {
	        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
	      }
	    }
	    return newProps;
	  },
	
	  /**
	   * Assert that the props are valid
	   *
	   * @param {object} propTypes Map of prop name to a ReactPropType
	   * @param {object} props
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkPropTypes: function (propTypes, props, location) {
	    // TODO: Stop validating prop types here and only use the element
	    // validation.
	    var componentName = this.getName();
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error;
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          !(typeof propTypes[propName] === 'function') ?  false ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	          error = propTypes[propName](props, propName, componentName, location);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error instanceof Error) {
	          // We may want to extend this logic for similar errors in
	          // top-level render calls, so I'm abstracting it away into
	          // a function to minimize refactoring in the future
	          var addendum = getDeclarationErrorAddendum(this);
	
	          if (location === ReactPropTypeLocations.prop) {
	            // Preface gives us something to blacklist in warning module
	             false ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
	          } else {
	             false ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
	          }
	        }
	      }
	    }
	  },
	
	  receiveComponent: function (nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
	    }
	
	    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	
	    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);
	    var nextProps;
	
	    // Distinguish between a props update versus a simple state update
	    if (prevParentElement === nextParentElement) {
	      // Skip checking prop types again -- we don't read inst.props to avoid
	      // warning for DOM component props in this upgrade
	      nextProps = nextParentElement.props;
	    } else {
	      nextProps = this._processProps(nextParentElement.props);
	      // An update here will schedule an update but immediately set
	      // _pendingStateQueue which will ensure that any state updates gets
	      // immediately reconciled instead of waiting for the next batch.
	
	      if (inst.componentWillReceiveProps) {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	
	    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
	    }
	
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function (props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      inst.componentWillUpdate(nextProps, nextState, nextContext);
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function (transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      // These two IDs are actually the same! But nothing should rely on that.
	      var thisID = this._rootNodeID;
	      var prevComponentID = prevComponentInstance._rootNodeID;
	      ReactReconciler.unmountComponent(prevComponentInstance);
	
	      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);
	      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
	      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	    }
	  },
	
	  /**
	   * @protected
	   */
	  _replaceNodeWithMarkupByID: function (prevComponentID, nextMarkup) {
	    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function () {
	    var inst = this._instance;
	    var renderedComponent = inst.render();
	    if (false) {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedComponent = null;
	      }
	    }
	
	    return renderedComponent;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function () {
	    var renderedComponent;
	    ReactCurrentOwner.current = this;
	    try {
	      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	    } finally {
	      ReactCurrentOwner.current = null;
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ?  false ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	    return renderedComponent;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function (ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ?  false ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;
	    var publicComponentInstance = component.getPublicInstance();
	    if (false) {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function (ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function () {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function () {
	    var inst = this._instance;
	    if (inst instanceof StatelessComponent) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent',
	  _renderValidatedComponent: '_renderValidatedComponent'
	});
	
	var ReactCompositeComponent = {
	
	  Mixin: ReactCompositeComponentMixin
	
	};
	
	module.exports = ReactCompositeComponent;

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOM
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(19);
	var ReactDOMTextComponent = __webpack_require__(258);
	var ReactDefaultInjection = __webpack_require__(259);
	var ReactInstanceHandles = __webpack_require__(31);
	var ReactMount = __webpack_require__(14);
	var ReactPerf = __webpack_require__(20);
	var ReactReconciler = __webpack_require__(23);
	var ReactUpdates = __webpack_require__(18);
	var ReactVersion = __webpack_require__(112);
	
	var findDOMNode = __webpack_require__(113);
	var renderSubtreeIntoContainer = __webpack_require__(477);
	var warning = __webpack_require__(8);
	
	ReactDefaultInjection.inject();
	
	var render = ReactPerf.measure('React', 'render', ReactMount.render);
	
	var React = {
	  findDOMNode: findDOMNode,
	  render: render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	/* eslint-enable camelcase */
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    CurrentOwner: ReactCurrentOwner,
	    InstanceHandles: ReactInstanceHandles,
	    Mount: ReactMount,
	    Reconciler: ReactReconciler,
	    TextComponent: ReactDOMTextComponent
	  });
	}
	
	if (false) {
	  var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,
	
	    // shams
	    Object.create, Object.freeze];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
	        break;
	      }
	    }
	  }
	}
	
	module.exports = React;

/***/ },
/* 256 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFeatureFlags
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: false
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelect
	 */
	
	'use strict';
	
	var LinkedValueUtils = __webpack_require__(105);
	var ReactMount = __webpack_require__(14);
	var ReactUpdates = __webpack_require__(18);
	
	var assign = __webpack_require__(7);
	var warning = __webpack_require__(8);
	
	var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    if (props.multiple) {
	       false ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    } else {
	       false ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactMount.getNode(inst._rootNodeID).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> native component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  valueContextKey: valueContextKey,
	
	  getNativeProps: function (inst, props, context) {
	    return assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function (inst, props) {
	    if (false) {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	  },
	
	  processChildContext: function (inst, props, context) {
	    // Pass down initial value so initial generated markup has correct
	    // `selected` attributes
	    var childContext = assign({}, context);
	    childContext[valueContextKey] = inst._wrapperState.initialValue;
	    return childContext;
	  },
	
	  postUpdateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // the context value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  this._wrapperState.pendingUpdate = true;
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(250);
	var DOMPropertyOperations = __webpack_require__(104);
	var ReactComponentBrowserEnvironment = __webpack_require__(106);
	var ReactMount = __webpack_require__(14);
	
	var assign = __webpack_require__(7);
	var escapeTextContentForBrowser = __webpack_require__(66);
	var setTextContent = __webpack_require__(120);
	var validateDOMNesting = __webpack_require__(121);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings in elements so that they can undergo
	 * the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function (props) {
	  // This constructor and its argument is currently used by mocks.
	};
	
	assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * @param {ReactText} text
	   * @internal
	   */
	  construct: function (text) {
	    // TODO: This is really a ReactText (ReactNode), not a ReactElement
	    this._currentElement = text;
	    this._stringText = '' + text;
	
	    // Properties
	    this._rootNodeID = null;
	    this._mountIndex = 0;
	  },
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function (rootID, transaction, context) {
	    if (false) {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }
	
	    this._rootNodeID = rootID;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElement('span');
	      DOMPropertyOperations.setAttributeForID(el, rootID);
	      // Populate node cache
	      ReactMount.getID(el);
	      setTextContent(el, this._stringText);
	      return el;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this in a `span` for the reasons stated above, but
	        // since this is a situation where React won't take over (static pages),
	        // we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function (nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var node = ReactMount.getNode(this._rootNodeID);
	        DOMChildrenOperations.updateTextContent(node, nextStringText);
	      }
	    }
	  },
	
	  unmountComponent: function () {
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultInjection
	 */
	
	'use strict';
	
	var BeforeInputEventPlugin = __webpack_require__(428);
	var ChangeEventPlugin = __webpack_require__(430);
	var ClientReactRootIndex = __webpack_require__(431);
	var DefaultEventPluginOrder = __webpack_require__(433);
	var EnterLeaveEventPlugin = __webpack_require__(434);
	var ExecutionEnvironment = __webpack_require__(12);
	var HTMLDOMPropertyConfig = __webpack_require__(437);
	var ReactBrowserComponentMixin = __webpack_require__(439);
	var ReactComponentBrowserEnvironment = __webpack_require__(106);
	var ReactDefaultBatchingStrategy = __webpack_require__(109);
	var ReactDOMComponent = __webpack_require__(443);
	var ReactDOMTextComponent = __webpack_require__(258);
	var ReactEventListener = __webpack_require__(451);
	var ReactInjection = __webpack_require__(262);
	var ReactInstanceHandles = __webpack_require__(31);
	var ReactMount = __webpack_require__(14);
	var ReactReconcileTransaction = __webpack_require__(269);
	var SelectEventPlugin = __webpack_require__(459);
	var ServerReactRootIndex = __webpack_require__(460);
	var SimpleEventPlugin = __webpack_require__(461);
	var SVGDOMPropertyConfig = __webpack_require__(458);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
	  ReactInjection.EventPluginHub.injectMount(ReactMount);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	
	  if (false) {
	    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	    if (/[?&]react_perf\b/.test(url)) {
	      var ReactDefaultPerf = require('./ReactDefaultPerf');
	      ReactDefaultPerf.start();
	    }
	  }
	}
	
	module.exports = {
	  inject: inject
	};

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElementValidator
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(11);
	var ReactPropTypeLocations = __webpack_require__(44);
	var ReactPropTypeLocationNames = __webpack_require__(33);
	var ReactCurrentOwner = __webpack_require__(19);
	
	var canDefineProperty = __webpack_require__(65);
	var getIteratorFn = __webpack_require__(117);
	var invariant = __webpack_require__(4);
	var warning = __webpack_require__(8);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	var loggedTypeFailures = {};
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
	  if (addenda === null) {
	    // we already showed the warning
	    return;
	  }
	   false ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
	}
	
	/**
	 * Shared warning and monitoring code for the key warnings.
	 *
	 * @internal
	 * @param {string} messageType A key used for de-duping warnings.
	 * @param {ReactElement} element Component that requires a key.
	 * @param {*} parentType element's parent's type.
	 * @returns {?object} A set of addenda to use in the warning message, or null
	 * if the warning has already been shown before (and shouldn't be shown again).
	 */
	function getAddendaForKeyUse(messageType, element, parentType) {
	  var addendum = getDeclarationErrorAddendum();
	  if (!addendum) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      addendum = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	
	  var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
	  if (memoizer[addendum]) {
	    return null;
	  }
	  memoizer[addendum] = true;
	
	  var addenda = {
	    parentOrOwner: addendum,
	    url: ' See https://fb.me/react-warning-keys for more information.',
	    childOwner: null
	  };
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }
	
	  return addenda;
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if (typeof node !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Assert that the props are valid
	 *
	 * @param {string} componentName Name of the component for error messages.
	 * @param {object} propTypes Map of prop name to a ReactPropType
	 * @param {object} props
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @private
	 */
	function checkPropTypes(componentName, propTypes, props, location) {
	  for (var propName in propTypes) {
	    if (propTypes.hasOwnProperty(propName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof propTypes[propName] === 'function') ?  false ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	        error = propTypes[propName](props, propName, componentName, location);
	      } catch (ex) {
	        error = ex;
	      }
	       false ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error) : undefined;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum();
	         false ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	     false ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
	  }
	}
	
	var ReactElementValidator = {
	
	  createElement: function (type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	     false ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function (type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if (false) {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function () {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }
	
	    return validatedFactory;
	  },
	
	  cloneElement: function (element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactErrorUtils
	 * @typechecks
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {?String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a, b) {
	  try {
	    return func(a, b);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	    return undefined;
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function () {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (false) {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
	      var boundFunc = func.bind(null, a, b);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInjection
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(35);
	var EventPluginHub = __webpack_require__(42);
	var ReactComponentEnvironment = __webpack_require__(107);
	var ReactClass = __webpack_require__(253);
	var ReactEmptyComponent = __webpack_require__(110);
	var ReactBrowserEventEmitter = __webpack_require__(61);
	var ReactNativeComponent = __webpack_require__(267);
	var ReactPerf = __webpack_require__(20);
	var ReactRootIndex = __webpack_require__(270);
	var ReactUpdates = __webpack_require__(18);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  Class: ReactClass.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  NativeComponent: ReactNativeComponent.injection,
	  Perf: ReactPerf.injection,
	  RootIndex: ReactRootIndex.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInputSelection
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(447);
	
	var containsNode = __webpack_require__(278);
	var focusNode = __webpack_require__(279);
	var getActiveElement = __webpack_require__(280);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function (elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function () {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function (priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function (input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function (input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (typeof end === 'undefined') {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMarkupChecksum
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(470);
	
	var TAG_END = /\/?>/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function (markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags and self-closing tags)
	    return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function (markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChild
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactComponentEnvironment = __webpack_require__(107);
	var ReactMultiChildUpdateTypes = __webpack_require__(266);
	
	var ReactCurrentOwner = __webpack_require__(19);
	var ReactReconciler = __webpack_require__(23);
	var ReactChildReconciler = __webpack_require__(440);
	
	var flattenChildren = __webpack_require__(273);
	
	/**
	 * Updating children of a component may trigger recursive updates. The depth is
	 * used to batch recursive updates to render markup more efficiently.
	 *
	 * @type {number}
	 * @private
	 */
	var updateDepth = 0;
	
	/**
	 * Queue of update configuration objects.
	 *
	 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
	 *
	 * @type {array<object>}
	 * @private
	 */
	var updateQueue = [];
	
	/**
	 * Queue of markup to be rendered.
	 *
	 * @type {array<string>}
	 * @private
	 */
	var markupQueue = [];
	
	/**
	 * Enqueues markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function enqueueInsertMarkup(parentID, markup, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
	    markupIndex: markupQueue.push(markup) - 1,
	    content: null,
	    fromIndex: null,
	    toIndex: toIndex
	  });
	}
	
	/**
	 * Enqueues moving an existing element to another index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function enqueueMove(parentID, fromIndex, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: toIndex
	  });
	}
	
	/**
	 * Enqueues removing an element at an index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function enqueueRemove(parentID, fromIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: null
	  });
	}
	
	/**
	 * Enqueues setting the markup of a node.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function enqueueSetMarkup(parentID, markup) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.SET_MARKUP,
	    markupIndex: null,
	    content: markup,
	    fromIndex: null,
	    toIndex: null
	  });
	}
	
	/**
	 * Enqueues setting the text content.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function enqueueTextContent(parentID, textContent) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
	    markupIndex: null,
	    content: textContent,
	    fromIndex: null,
	    toIndex: null
	  });
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue() {
	  if (updateQueue.length) {
	    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
	    clearQueue();
	  }
	}
	
	/**
	 * Clears any enqueued updates.
	 *
	 * @private
	 */
	function clearQueue() {
	  updateQueue.length = 0;
	  markupQueue.length = 0;
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
	      if (false) {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, transaction, context) {
	      var nextChildren;
	      if (false) {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements);
	      return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function (nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	          var rootID = this._rootNodeID + name;
	          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function (nextContent) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        // TODO: The setTextContent operation should be enough
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChild(prevChildren[name]);
	          }
	        }
	        // Set new text content.
	        this.setTextContent(nextContent);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function (nextMarkup) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChildByName(prevChildren[name], name);
	          }
	        }
	        this.setMarkup(nextMarkup);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        this._updateChildren(nextNestedChildrenElements, transaction, context);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Improve performance by isolating this hot code path from the try/catch
	     * block in `updateChildren`.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context);
	      this._renderedChildren = nextChildren;
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var lastIndex = 0;
	      var nextIndex = 0;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          this.moveChild(prevChild, nextIndex, lastIndex);
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            this._unmountChild(prevChild);
	          }
	          // The child must be instantiated before it's mounted.
	          this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
	        }
	        nextIndex++;
	      }
	      // Remove children that are no longer present.
	      for (name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	          this._unmountChild(prevChildren[name]);
	        }
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted.
	     *
	     * @internal
	     */
	    unmountChildren: function () {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function (child, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function (child, mountImage) {
	      enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function (child) {
	      enqueueRemove(this._rootNodeID, child._mountIndex);
	    },
	
	    /**
	     * Sets this text content string.
	     *
	     * @param {string} textContent Text content to set.
	     * @protected
	     */
	    setTextContent: function (textContent) {
	      enqueueTextContent(this._rootNodeID, textContent);
	    },
	
	    /**
	     * Sets this markup string.
	     *
	     * @param {string} markup Markup to set.
	     * @protected
	     */
	    setMarkup: function (markup) {
	      enqueueSetMarkup(this._rootNodeID, markup);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildByNameAtIndex: function (child, name, index, transaction, context) {
	      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	      var rootID = this._rootNodeID + name;
	      var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	      child._mountIndex = index;
	      this.createChild(child, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function (child) {
	      this.removeChild(child);
	      child._mountIndex = null;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChildUpdateTypes
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(70);
	
	/**
	 * When a component's children are updated, a series of update configuration
	 * objects are created in order to batch and serialize the required changes.
	 *
	 * Enumerates all the possible types of update configurations.
	 *
	 * @internal
	 */
	var ReactMultiChildUpdateTypes = keyMirror({
	  INSERT_MARKUP: null,
	  MOVE_EXISTING: null,
	  REMOVE_NODE: null,
	  SET_MARKUP: null,
	  TEXT_CONTENT: null
	});
	
	module.exports = ReactMultiChildUpdateTypes;

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNativeComponent
	 */
	
	'use strict';
	
	var assign = __webpack_require__(7);
	var invariant = __webpack_require__(4);
	
	var autoGenerateWrapperClass = null;
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around native tags.
	var tagToComponentClass = {};
	var textComponentClass = null;
	
	var ReactNativeComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function (componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function (componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function (componentClasses) {
	    assign(tagToComponentClass, componentClasses);
	  }
	};
	
	/**
	 * Get a composite component wrapper class for a specific tag.
	 *
	 * @param {ReactElement} element The tag for which to get the class.
	 * @return {function} The React class constructor function.
	 */
	function getComponentClassForElement(element) {
	  if (typeof element.type === 'function') {
	    return element.type;
	  }
	  var tag = element.type;
	  var componentClass = tagToComponentClass[tag];
	  if (componentClass == null) {
	    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
	  }
	  return componentClass;
	}
	
	/**
	 * Get a native internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ?  false ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
	  return new genericComponentClass(element.type, element.props);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactNativeComponent = {
	  getComponentClassForElement: getComponentClassForElement,
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactNativeComponentInjection
	};
	
	module.exports = ReactNativeComponent;

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNoopUpdateQueue
	 */
	
	'use strict';
	
	var warning = __webpack_require__(8);
	
	function warnTDZ(publicInstance, callerName) {
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    warnTDZ(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    warnTDZ(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    warnTDZ(publicInstance, 'setState');
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function (publicInstance, partialProps) {
	    warnTDZ(publicInstance, 'setProps');
	  },
	
	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function (publicInstance, props) {
	    warnTDZ(publicInstance, 'replaceProps');
	  }
	
	};
	
	module.exports = ReactNoopUpdateQueue;

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconcileTransaction
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CallbackQueue = __webpack_require__(103);
	var PooledClass = __webpack_require__(27);
	var ReactBrowserEventEmitter = __webpack_require__(61);
	var ReactDOMFeatureFlags = __webpack_require__(256);
	var ReactInputSelection = __webpack_require__(263);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(7);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function () {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function (previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function () {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(forceHTML) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = !forceHTML && ReactDOMFeatureFlags.useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;

/***/ },
/* 270 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	var ReactRootIndexInjection = {
	  /**
	   * @param {function} _createReactRootIndex
	   */
	  injectCreateReactRootIndex: function (_createReactRootIndex) {
	    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
	  }
	};
	
	var ReactRootIndex = {
	  createReactRootIndex: null,
	  injection: ReactRootIndexInjection
	};
	
	module.exports = ReactRootIndex;

/***/ },
/* 271 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ViewportMetrics
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function (scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule accumulateInto
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(4);
	
	/**
	 *
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ?  false ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  var currentIsArray = Array.isArray(current);
	  var nextIsArray = Array.isArray(next);
	
	  if (currentIsArray && nextIsArray) {
	    current.push.apply(current, next);
	    return current;
	  }
	
	  if (currentIsArray) {
	    current.push(next);
	    return current;
	  }
	
	  if (nextIsArray) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule flattenChildren
	 */
	
	'use strict';
	
	var traverseAllChildren = __webpack_require__(69);
	var warning = __webpack_require__(8);
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name) {
	  // We found a component instance.
	  var result = traverseContext;
	  var keyUnique = result[name] === undefined;
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (keyUnique && child != null) {
	    result[name] = child;
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	  traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  return result;
	}
	
	module.exports = flattenChildren;

/***/ },
/* 274 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule forEachAccumulated
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	var forEachAccumulated = function (arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	};
	
	module.exports = forEachAccumulated;

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getTextContentAccessor
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(12);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ },
/* 276 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextInputElement
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
	}
	
	module.exports = isTextInputElement;

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @providesModule EventListener
	 * @typechecks
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(24);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function (target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function () {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function () {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function (target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function () {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (false) {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function () {}
	};
	
	module.exports = EventListener;

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule containsNode
	 * @typechecks
	 */
	
	'use strict';
	
	var isTextNode = __webpack_require__(487);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 *
	 * @param {?DOMNode} outerNode Outer DOM node.
	 * @param {?DOMNode} innerNode Inner DOM node.
	 * @return {boolean} True if `outerNode` contains or is `innerNode`.
	 */
	function containsNode(_x, _x2) {
	  var _again = true;
	
	  _function: while (_again) {
	    var outerNode = _x,
	        innerNode = _x2;
	    _again = false;
	
	    if (!outerNode || !innerNode) {
	      return false;
	    } else if (outerNode === innerNode) {
	      return true;
	    } else if (isTextNode(outerNode)) {
	      return false;
	    } else if (isTextNode(innerNode)) {
	      _x = outerNode;
	      _x2 = innerNode.parentNode;
	      _again = true;
	      continue _function;
	    } else if (outerNode.contains) {
	      return outerNode.contains(innerNode);
	    } else if (outerNode.compareDocumentPosition) {
	      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	    } else {
	      return false;
	    }
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 279 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule focusNode
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 280 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getActiveElement
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	'use strict';
	
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getMarkupWrap
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(12);
	
	var invariant = __webpack_require__(4);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ?  false ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.resetChoregraphy = exports.startChoregraphy = exports.startTutoChoregraphy = exports.setMovesTimeouts = exports.getChoregraphyEndTime = undefined;
	
	var _constants = __webpack_require__(6);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	var _master = __webpack_require__(94);
	
	var _choregraphies = __webpack_require__(285);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var setTutoChoregraphy = function setTutoChoregraphy() {
		return function (dispatch, getState) {
			var tutoChoregraphy = (0, _choregraphies.getTutoChoregraphy)();
			dispatch({
				type: _constants2.default.CHOREGRAPHY,
				name: tutoChoregraphy.name,
				moves: tutoChoregraphy.moves
			});
		};
	};
	
	var setRandomChoregraphy = function setRandomChoregraphy() {
		return function (dispatch, getState) {
			var randomChoregraphy = (0, _choregraphies.getRandomChoregraphy)();
			dispatch({
				type: _constants2.default.CHOREGRAPHY,
				name: randomChoregraphy.name,
				moves: randomChoregraphy.moves
			});
		};
	};
	
	var getChoregraphyEndTime = exports.getChoregraphyEndTime = function getChoregraphyEndTime(moves) {
		return moves.last().time + _constants2.default.MOVES_END_DELAY;
	};
	
	var setMovesTimeouts = exports.setMovesTimeouts = function setMovesTimeouts() {
		var forward = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	
		return function (dispatch, getState) {
			(0, _master.sendToSlave)({
				function: 'setMovesTimeouts',
				forward: forward
			});
		};
	};
	
	var startTutoChoregraphy = exports.startTutoChoregraphy = function startTutoChoregraphy() {
		return function (dispatch, getState) {
			dispatch(setTutoChoregraphy());
			dispatch(setMovesTimeouts(_constants2.default.TUTO_FORWARD_TIME));
		};
	};
	
	var startChoregraphy = exports.startChoregraphy = function startChoregraphy() {
		return function (dispatch, getState) {
			dispatch(setRandomChoregraphy());
			dispatch(setMovesTimeouts());
		};
	};
	
	var resetChoregraphy = exports.resetChoregraphy = function resetChoregraphy() {
		return function (dispatch, getState) {
			(0, _master.sendToSlave)({ function: 'stopMoves' });
			dispatch({
				type: _constants2.default.CHOREGRAPHY_RESET
			});
		};
	};

/***/ },
/* 283 */,
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.listenToPads = listenToPads;
	
	var _constants = __webpack_require__(6);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	var _game = __webpack_require__(37);
	
	var _steps = __webpack_require__(133);
	
	var _dev = __webpack_require__(38);
	
	var _dev2 = _interopRequireDefault(_dev);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var onPadChange = function onPadChange(eventType, direction) {
		return function (dispatch, getState) {
			var state = getState();
			var status = state.game.get('status');
			var upOrDown = eventType === 'keyup' ? 'up' : 'down';
			dispatch({
				type: _constants2.default.PAD,
				direction: direction,
				upOrDown: upOrDown
			});
			if (status !== 'intro' && status !== 'tuto' && status !== 'play') {
				dispatch((0, _game.checkStatus)(direction));
			} else if (status === 'play' && upOrDown === 'down') {
				dispatch((0, _steps.dispatchStep)(direction));
			}
		};
	};
	function listenToPads() {
		return function (dispatch) {
			// TO BE REPLACED WITH MESSAGES COMING FROM THE ACTUAL PADS
			_dev2.default.listenToDirectionKeys(function (eventType, direction) {
				dispatch(onPadChange(eventType, direction));
			});
			// listen to messages coming from electron main process
			if (window.electron) {
				window.electron.ipcRenderer.on('pad', function (event, data) {
					dispatch(onPadChange(data.eventType, data.direction));
				});
			}
		};
	}

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.getRandomChoregraphy = exports.choregraphies = exports.getTutoChoregraphy = undefined;
	
	var _moment = __webpack_require__(1);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _constants = __webpack_require__(6);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	var _utils = __webpack_require__(40);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _In_TrainingNew = __webpack_require__(331);
	
	var _In_TrainingNew2 = _interopRequireDefault(_In_TrainingNew);
	
	var _Last_ResistanceNew = __webpack_require__(332);
	
	var _Last_ResistanceNew2 = _interopRequireDefault(_Last_ResistanceNew);
	
	var _The_BattleNew = __webpack_require__(333);
	
	var _The_BattleNew2 = _interopRequireDefault(_The_BattleNew);
	
	var _The_Flying_HeroesNew = __webpack_require__(334);
	
	var _The_Flying_HeroesNew2 = _interopRequireDefault(_The_Flying_HeroesNew);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var mapSubsToMoves = function mapSubsToMoves(subs) {
		var nestedMoves = subs.map(function (sub) {
			var directions = sub.text.split('#');
			var showTime = _moment2.default.duration(sub.startTime).asMilliseconds();
			var time = _moment2.default.duration(sub.endTime).asMilliseconds();
			var moves = directions.map(function (direction) {
				var id = time + '_' + direction;
				return {
					id: id,
					direction: direction,
					showTime: showTime,
					time: time
				};
			});
			return moves;
		});
		return _utils2.default.flattenArray(nestedMoves);
	};
	
	var getTutoMoves = function getTutoMoves(moves) {
		return moves.filter(function (move) {
			return move.time < _constants2.default.TUTO_END_TIME + _constants2.default.MOVE_DURATION;
		});
	};
	
	var getTutoChoregraphy = exports.getTutoChoregraphy = function getTutoChoregraphy() {
		return {
			name: 'The_Flying_Heroes',
			moves: getTutoMoves(mapSubsToMoves(_The_Flying_HeroesNew2.default))
		};
	};
	
	var choregraphies = exports.choregraphies = [{
		name: 'In_Training',
		moves: mapSubsToMoves(_In_TrainingNew2.default)
	}, {
		name: 'Last_Resistance',
		moves: mapSubsToMoves(_Last_ResistanceNew2.default)
	}, {
		name: 'The_Battle',
		moves: mapSubsToMoves(_The_BattleNew2.default)
	}, {
		name: 'The_Flying_Heroes',
		moves: mapSubsToMoves(_The_Flying_HeroesNew2.default)
	}];
	
	var getRandomChoregraphy = exports.getRandomChoregraphy = function getRandomChoregraphy() {
		var randomIndex = Math.floor(Math.random() * choregraphies.length);
		return choregraphies[randomIndex];
	};

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Admin = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(15);
	
	var _classnames2 = __webpack_require__(54);
	
	var _classnames3 = _interopRequireDefault(_classnames2);
	
	var _admin = __webpack_require__(132);
	
	var _records = __webpack_require__(71);
	
	var _css = __webpack_require__(314);
	
	var _css2 = _interopRequireDefault(_css);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Admin = exports.Admin = function (_Component) {
		_inherits(Admin, _Component);
	
		function Admin(props) {
			_classCallCheck(this, Admin);
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Admin).call(this, props));
	
			_this.confirmClearRecords = _this.confirmClearRecords.bind(_this);
			_this.exportToJSON = _this.exportToJSON.bind(_this);
			return _this;
		}
	
		_createClass(Admin, [{
			key: 'confirmClearRecords',
			value: function confirmClearRecords() {
				if (window.confirm('Delete records?')) {
					this.props.clearRecords();
				}
			}
		}, {
			key: 'exportToJSON',
			value: function exportToJSON() {
				var data = JSON.stringify(this.props.records);
				var myWindow = window.open('data:text/html,' + encodeURIComponent(data), '_blank');
				myWindow.focus();
			}
		}, {
			key: 'render',
			value: function render() {
				var _classnames;
	
				var soundClass = (0, _classnames3.default)((_classnames = {}, _defineProperty(_classnames, _css2.default.sound, true), _defineProperty(_classnames, _css2.default.muted, this.props.admin.get('muted')), _classnames));
				var soundText = this.props.admin.get('muted') ? 'Unmute sound' : 'Mute sound';
				return _react2.default.createElement(
					'div',
					{ className: _css2.default.admin },
					_react2.default.createElement(
						'h1',
						{ className: _css2.default.h1 },
						'ADMIN'
					),
					_react2.default.createElement(
						'h2',
						{ className: _css2.default.h2 },
						'SOUND'
					),
					_react2.default.createElement(
						'div',
						{ className: soundClass, onClick: this.props.toggleMuted },
						soundText
					),
					_react2.default.createElement(
						'h2',
						{ className: _css2.default.h2 },
						'RANK'
					),
					_react2.default.createElement(
						'div',
						{ className: _css2.default.button, onClick: this.confirmClearRecords },
						'Delete records'
					),
					_react2.default.createElement(
						'div',
						{ className: _css2.default.button, onClick: this.exportToJSON },
						'Export to JSON'
					)
				);
			}
		}]);
	
		return Admin;
	}(_react.Component);
	
	function mapStateToProps(state) {
		return {
			admin: state.admin,
			records: state.records
		};
	}
	
	exports.default = (0, _reactRedux.connect)(mapStateToProps, { toggleMuted: _admin.toggleMuted, clearRecords: _records.clearRecords })(Admin);

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.App = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(15);
	
	var _utils = __webpack_require__(40);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _admin = __webpack_require__(132);
	
	var _pads = __webpack_require__(284);
	
	var _records = __webpack_require__(71);
	
	var _game = __webpack_require__(37);
	
	var gameActions = _interopRequireWildcard(_game);
	
	var _Admin = __webpack_require__(286);
	
	var _Admin2 = _interopRequireDefault(_Admin);
	
	var _Video = __webpack_require__(298);
	
	var _Video2 = _interopRequireDefault(_Video);
	
	var _Audio = __webpack_require__(288);
	
	var _Audio2 = _interopRequireDefault(_Audio);
	
	var _Webgl = __webpack_require__(306);
	
	var _Webgl2 = _interopRequireDefault(_Webgl);
	
	var _Html = __webpack_require__(297);
	
	var _Html2 = _interopRequireDefault(_Html);
	
	var _css = __webpack_require__(315);
	
	var _css2 = _interopRequireDefault(_css);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var App = exports.App = function (_Component) {
		_inherits(App, _Component);
	
		function App(props) {
			_classCallCheck(this, App);
	
			return _possibleConstructorReturn(this, Object.getPrototypeOf(App).call(this, props));
		}
	
		_createClass(App, [{
			key: 'componentDidMount',
			value: function componentDidMount() {
				this.props.listenToClicks();
				this.props.listenToPads();
				this.props.loadRecords();
				// FIXME: FOR DEV PURPOSES, GAME CAN BE STARTED IMMEDIATELY
				if (this.props.game.get('status') === 'devplay') {
					this.props.launchPlay();
				} else if (this.props.game.get('status') === 'devrecap') {
					this.props.launchRecap();
				} else if (this.props.game.get('status') === 'devrank') {
					this.props.launchRank();
				}
			}
		}, {
			key: 'render',
			value: function render() {
				var adminContent = !this.props.admin.get('visible') ? null : _react2.default.createElement(_Admin2.default, null);
				var webGlContent = !_utils2.default.showWebgl(this.props.game) ? null : _react2.default.createElement(
					'div',
					{ className: _css2.default.webgl },
					_react2.default.createElement(_Webgl2.default, null)
				);
				return _react2.default.createElement(
					'div',
					{ className: _css2.default.app },
					_react2.default.createElement(
						'div',
						{ className: _css2.default.video },
						_react2.default.createElement(_Video2.default, null),
						_react2.default.createElement(_Audio2.default, null)
					),
					webGlContent,
					_react2.default.createElement(
						'div',
						{ className: _css2.default.html },
						_react2.default.createElement(_Html2.default, null)
					),
					adminContent
				);
			}
		}]);
	
		return App;
	}(_react.Component);
	
	var mapDispatchToProps = Object.assign({ listenToClicks: _admin.listenToClicks, listenToPads: _pads.listenToPads, loadRecords: _records.loadRecords }, gameActions);
	
	exports.default = (0, _reactRedux.connect)(function (state) {
		return state;
	}, mapDispatchToProps)(App);

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Audio = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(15);
	
	var _css = __webpack_require__(316);
	
	var _css2 = _interopRequireDefault(_css);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Audio = exports.Audio = function (_Component) {
		_inherits(Audio, _Component);
	
		function Audio(props) {
			_classCallCheck(this, Audio);
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Audio).call(this, props));
	
			_this.getAudioSrc = _this.getAudioSrc.bind(_this);
			return _this;
		}
	
		_createClass(Audio, [{
			key: 'componentDidMount',
			value: function componentDidMount() {
				var _this2 = this;
	
				this.refs.audio.addEventListener('play', function () {
					var delay = Date.now() - _this2.props.choregraphy.get('time');
					_this2.refs.audio.currentTime = delay / 1000;
					_this2.refs.audio.muted = _this2.props.admin.get('muted');
				});
			}
		}, {
			key: 'getAudioSrc',
			value: function getAudioSrc() {
				if (this.props.game.get('status') !== 'play' || !this.props.choregraphyName) {
					return null;
				}
				return 'choregraphies/' + this.props.choregraphyName + '.mp3';
			}
		}, {
			key: 'render',
			value: function render() {
				var audioSrc = this.getAudioSrc();
				return _react2.default.createElement(
					'div',
					{ className: _css2.default.audio },
					_react2.default.createElement('audio', {
						ref: 'audio',
						src: audioSrc,
						autoPlay: true,
						muted: this.props.admin.get('muted')
					})
				);
			}
		}]);
	
		return Audio;
	}(_react.Component);
	
	function mapStateToProps(state) {
		return {
			admin: state.admin,
			game: state.game,
			choregraphy: state.choregraphy,
			choregraphyName: state.choregraphy.get('name')
		};
	}
	
	exports.default = (0, _reactRedux.connect)(mapStateToProps)(Audio);

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Rank = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(15);
	
	var _records = __webpack_require__(135);
	
	var _css = __webpack_require__(317);
	
	var _css2 = _interopRequireDefault(_css);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Rank = exports.Rank = function (_Component) {
		_inherits(Rank, _Component);
	
		function Rank(props) {
			_classCallCheck(this, Rank);
	
			return _possibleConstructorReturn(this, Object.getPrototypeOf(Rank).call(this, props));
		}
	
		_createClass(Rank, [{
			key: 'render',
			value: function render() {
				var _this2 = this;
	
				var podiumList = this.props.records.filter(function (record, index) {
					return index < 3;
				});
				var podiumContent = podiumList.map(function (record, index) {
					var suffix = index === 0 ? 'ER' : 'ÈME';
					// apply special class to the current score
					var currentScoreClass = _this2.props.rank === index ? _css2.default.podiumScore : '';
					return _react2.default.createElement(
						'div',
						{ key: index, className: currentScoreClass },
						index + 1,
						suffix,
						' ',
						record.player,
						' ',
						record.score
					);
				});
	
				var rankList = this.props.records.filter(function (record, index) {
					// player is first ranked or last ranked
					if (_this2.props.rank === 0 || _this2.props.rank === _this2.props.records.size - 1) {
						return Math.abs(index - _this2.props.rank) <= 2;
					}
					// otherwise
					return Math.abs(index - _this2.props.rank) <= 1;
				});
				var rankContent = rankList.map(function (record, index) {
					// if the player made the best score, use ER instead of ÈME
					var suffix = _this2.props.rank === index && _this2.props.rank === 0 ? 'ER' : 'ÈME';
					// apply correction to the index of map to get rank position
					var correction = 0;
					// best score needs a rank correction of 1
					if (_this2.props.rank === 0) {
						correction = 1;
					}
					// worst score needs a correction of -1
					else if (_this2.props.rank === _this2.props.records.size - 1) {
							correction = -1;
						}
					// apply special class to the current score
					var currentScoreClass = correction === 1 && index === 0 || correction === 0 && index === 1 || correction === -1 && index === 2 ? _css2.default.ranksScore : '';
					return _react2.default.createElement(
						'div',
						{ key: index, className: currentScoreClass },
						_this2.props.rank + correction + index,
						suffix,
						' ',
						record.player,
						' ',
						record.score
					);
				});
				return _react2.default.createElement(
					'div',
					{ className: _css2.default.rank },
					_react2.default.createElement(
						'div',
						{ className: _css2.default.ranks },
						rankContent
					),
					_react2.default.createElement(
						'div',
						{ className: _css2.default.podium },
						podiumContent
					)
				);
			}
		}]);
	
		return Rank;
	}(_react.Component);
	
	function mapStateToProps(state) {
		return {
			records: (0, _records.getSortedRecords)(state)
		};
	}
	
	exports.default = (0, _reactRedux.connect)(mapStateToProps)(Rank);

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Metric = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _odometer = __webpack_require__(329);
	
	var _odometer2 = _interopRequireDefault(_odometer);
	
	__webpack_require__(313);
	
	var _Text = __webpack_require__(52);
	
	var _Text2 = _interopRequireDefault(_Text);
	
	var _css = __webpack_require__(318);
	
	var _css2 = _interopRequireDefault(_css);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Metric = exports.Metric = function (_Component) {
		_inherits(Metric, _Component);
	
		function Metric(props) {
			_classCallCheck(this, Metric);
	
			return _possibleConstructorReturn(this, Object.getPrototypeOf(Metric).call(this, props));
		}
	
		_createClass(Metric, [{
			key: 'componentDidMount',
			value: function componentDidMount() {
				this.refs.bar.animate([{ transform: 'scaleX(0)' }, { transform: 'scaleX(1)' }], {
					duration: 2000,
					easing: 'cubic-bezier(0,0,0.32,1)'
				});
				var odometer = new _odometer2.default({
					el: this.refs.valueHolder,
					value: 0
				});
				odometer.update(this.props.value);
			}
		}, {
			key: 'render',
			value: function render() {
				var width = this.props.value / this.props.maxValue * 100;
				var inlineStyle = { width: width + '%' };
				return _react2.default.createElement(
					'div',
					{ className: _css2.default.metric },
					_react2.default.createElement(
						'div',
						null,
						_react2.default.createElement(
							_Text2.default,
							{ className: _css2.default.label },
							this.props.label
						)
					),
					_react2.default.createElement(
						'div',
						{
							className: _css2.default.scale
						},
						_react2.default.createElement('div', { ref: 'bar', className: _css2.default.bar, style: inlineStyle })
					),
					_react2.default.createElement(
						'div',
						{ ref: 'valueHolder', className: _css2.default.value },
						'0'
					)
				);
			}
		}]);
	
		return Metric;
	}(_react.Component);

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Recap = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(15);
	
	var _performance = __webpack_require__(39);
	
	var _moves = __webpack_require__(134);
	
	var _Metric = __webpack_require__(290);
	
	var _Text = __webpack_require__(52);
	
	var _Text2 = _interopRequireDefault(_Text);
	
	var _css = __webpack_require__(319);
	
	var _css2 = _interopRequireDefault(_css);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Recap = exports.Recap = function (_Component) {
		_inherits(Recap, _Component);
	
		function Recap(props) {
			_classCallCheck(this, Recap);
	
			return _possibleConstructorReturn(this, Object.getPrototypeOf(Recap).call(this, props));
		}
	
		_createClass(Recap, [{
			key: 'render',
			value: function render() {
				return _react2.default.createElement(
					'div',
					{ className: _css2.default.recap },
					_react2.default.createElement(
						'div',
						{
							className: _css2.default.excellent
						},
						_react2.default.createElement(_Metric.Metric, {
							label: 'EXCELLENT',
							value: this.props.performance.comments.excellent,
							maxValue: this.props.maxComments
						})
					),
					_react2.default.createElement(
						'div',
						{
							className: _css2.default.good
						},
						_react2.default.createElement(_Metric.Metric, {
							label: 'BIEN',
							value: this.props.performance.comments.good,
							maxValue: this.props.maxComments
						})
					),
					_react2.default.createElement(
						'div',
						{
							className: _css2.default.ok
						},
						_react2.default.createElement(_Metric.Metric, {
							label: 'OK',
							value: this.props.performance.comments.ok,
							maxValue: this.props.maxComments
						})
					),
					_react2.default.createElement(
						'div',
						{
							className: _css2.default.combo
						},
						_react2.default.createElement(_Metric.Metric, {
							label: 'COMBO',
							value: this.props.performance.comments.combo,
							maxValue: this.props.maxComments
						})
					),
					_react2.default.createElement(
						'div',
						{ className: _css2.default.hint },
						_react2.default.createElement(
							_Text2.default,
							null,
							'APPUYEZ SUR'
						),
						_react2.default.createElement('div', { className: _css2.default.arrow_right }),
						_react2.default.createElement(
							_Text2.default,
							null,
							'POUR ENREGISTRER VOTRE SCORE'
						)
					)
				);
			}
		}]);
	
		return Recap;
	}(_react.Component);
	
	function mapStateToProps(state) {
		return {
			performance: (0, _performance.getPerformance)(state),
			maxComments: (0, _moves.getMaximumComments)(state)
		};
	}
	
	exports.default = (0, _reactRedux.connect)(mapStateToProps)(Recap);

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Letter = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(15);
	
	var _classnames2 = __webpack_require__(54);
	
	var _classnames3 = _interopRequireDefault(_classnames2);
	
	var _utils = __webpack_require__(40);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _css = __webpack_require__(320);
	
	var _css2 = _interopRequireDefault(_css);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var getCurrentTransform = function getCurrentTransform(height) {
		var currentTranslationY = height * -1.5;
		return 'translateY(' + currentTranslationY + 'px)';
	};
	
	var getNextTransform = function getNextTransform(height, increment) {
		var nextTranslationY = height * (-1.5 - increment);
		return 'translateY(' + nextTranslationY + 'px)';
	};
	
	var Letter = exports.Letter = function (_Component) {
		_inherits(Letter, _Component);
	
		function Letter(props) {
			_classCallCheck(this, Letter);
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Letter).call(this, props));
	
			_this.state = { letter: _this.props.letter };
			_this.inlineStyle = { transform: getCurrentTransform(_this.props.height) };
			_this.onPadDown = _this.onPadDown.bind(_this);
			_this.changeLetter = _this.changeLetter.bind(_this);
			return _this;
		}
	
		_createClass(Letter, [{
			key: 'shouldComponentUpdate',
			value: function shouldComponentUpdate() {
				return this.props.focus;
			}
		}, {
			key: 'componentDidUpdate',
			value: function componentDidUpdate(prevProps) {
				var _this2 = this;
	
				this.props.controls.forEach(function (direction) {
					if (_this2.props.focus && _this2.props.pads.get(direction) === 'down' && _this2.props.pads.get(direction) !== prevProps.pads.get(direction)) {
						setTimeout(function () {
							_this2.onPadDown(direction);
						}, 0);
					}
				});
			}
		}, {
			key: 'onPadDown',
			value: function onPadDown(direction) {
				if (direction === 'left') {
					this.props.onLeft(this.props.index);
				} else if (direction === 'right') {
					this.props.onRight(this.props.index);
				} else {
					this.changeLetter(direction);
				}
			}
		}, {
			key: 'changeLetter',
			value: function changeLetter(direction) {
				var _this3 = this;
	
				var increment = direction === 'top' ? -1 : 1;
				this.refs[direction].classList.add(_css2.default.onPadDown);
				this.animation = this.refs.letter.animate([{ transform: getCurrentTransform(this.props.height) }, { transform: getNextTransform(this.props.height, increment) }], {
					duration: this.props.duration
				});
				this.animation.onfinish = function () {
					_this3.refs[direction].classList.remove(_css2.default.onPadDown);
					var thisIndex = _utils2.default.alphabet.indexOf(_this3.state.letter);
					var letter = _utils2.default.getItemByInfiniteIndex(_utils2.default.alphabet, thisIndex + increment);
					_this3.setState({ letter: letter });
					_this3.props.onLetter(_this3.props.index, _this3.state.letter);
				};
			}
		}, {
			key: 'render',
			value: function render() {
				var _classnames,
				    _this4 = this;
	
				var letterClass = (0, _classnames3.default)((_classnames = {}, _defineProperty(_classnames, _css2.default.letter, true), _defineProperty(_classnames, _css2.default.focus, this.props.focus), _classnames));
				var lettersContent = [-2, -1, 0, 1, 2].map(function (index) {
					var thisIndex = _utils2.default.alphabet.indexOf(_this4.state.letter) + index;
					var thisClass = index === 0 ? _css2.default.activeLetter : null;
					return _react2.default.createElement(
						'div',
						{ key: index, className: thisClass },
						_utils2.default.getItemByInfiniteIndex(_utils2.default.alphabet, thisIndex)
					);
				});
				var controlsContent = this.props.controls.map(function (direction) {
					return _react2.default.createElement('div', {
						key: direction,
						ref: direction,
						className: _css2.default['control_' + direction]
					});
				});
				return _react2.default.createElement(
					'div',
					{ className: letterClass },
					_react2.default.createElement(
						'div',
						{ className: _css2.default.visibleLetters },
						_react2.default.createElement(
							'div',
							{
								ref: 'letter',
								className: _css2.default.allLetters,
								style: this.inlineStyle
							},
							lettersContent
						)
					),
					controlsContent
				);
			}
		}]);
	
		return Letter;
	}(_react.Component);
	
	function mapStateToProps(state) {
		return {
			pads: state.pads
		};
	}
	
	exports.default = (0, _reactRedux.connect)(mapStateToProps)(Letter);

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Save = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(15);
	
	var _records = __webpack_require__(71);
	
	var _performance = __webpack_require__(39);
	
	var _Letter = __webpack_require__(292);
	
	var _Letter2 = _interopRequireDefault(_Letter);
	
	var _css = __webpack_require__(321);
	
	var _css2 = _interopRequireDefault(_css);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Save = exports.Save = function (_Component) {
		_inherits(Save, _Component);
	
		function Save(props) {
			_classCallCheck(this, Save);
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Save).call(this, props));
	
			_this.state = { focusIndex: 0 };
			_this.letters = ['A', 'A', 'A'];
			_this.onLetter = _this.onLetter.bind(_this);
			_this.onLeft = _this.onLeft.bind(_this);
			_this.onRight = _this.onRight.bind(_this);
			return _this;
		}
	
		_createClass(Save, [{
			key: 'onLetter',
			value: function onLetter(index, letter) {
				this.letters[index] = letter;
			}
		}, {
			key: 'onLeft',
			value: function onLeft(index, letter) {
				this.setState({ focusIndex: this.state.focusIndex - 1 });
			}
		}, {
			key: 'onRight',
			value: function onRight(index, letter) {
				if (index < this.letters.length - 1) {
					this.setState({ focusIndex: this.state.focusIndex + 1 });
				} else {
					this.props.saveRecord({
						time: this.props.choregraphy.get('time'),
						name: this.props.choregraphy.get('name'),
						player: this.letters.join(''),
						score: this.props.performance.score,
						comments: this.props.performance.comments
					});
				}
			}
		}, {
			key: 'render',
			value: function render() {
				var _this2 = this;
	
				var controls = [['top', 'bottom', 'right'], ['left', 'top', 'bottom', 'right'], ['left', 'top', 'bottom', 'right']];
				var lettersContent = this.letters.map(function (letter, index) {
					return _react2.default.createElement(_Letter2.default, {
						key: index,
						index: index,
						focus: _this2.state.focusIndex === index,
						letter: letter,
						height: 150,
						duration: 200,
						controls: controls[index],
						onLetter: _this2.onLetter,
						onLeft: _this2.onLeft,
						onRight: _this2.onRight
					});
				});
				return _react2.default.createElement(
					'div',
					{ className: _css2.default.save },
					lettersContent
				);
			}
		}]);
	
		return Save;
	}(_react.Component);
	
	function mapStateToProps(state) {
		return {
			choregraphy: state.choregraphy,
			performance: (0, _performance.getPerformance)(state)
		};
	}
	
	exports.default = (0, _reactRedux.connect)(mapStateToProps, { saveRecord: _records.saveRecord })(Save);

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Final = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(15);
	
	var _performance = __webpack_require__(39);
	
	var _records = __webpack_require__(135);
	
	var _Text = __webpack_require__(52);
	
	var _Text2 = _interopRequireDefault(_Text);
	
	var _Recap = __webpack_require__(291);
	
	var _Recap2 = _interopRequireDefault(_Recap);
	
	var _Save = __webpack_require__(293);
	
	var _Save2 = _interopRequireDefault(_Save);
	
	var _Rank = __webpack_require__(289);
	
	var _Rank2 = _interopRequireDefault(_Rank);
	
	var _css = __webpack_require__(322);
	
	var _css2 = _interopRequireDefault(_css);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Final = exports.Final = function (_Component) {
		_inherits(Final, _Component);
	
		function Final(props) {
			_classCallCheck(this, Final);
	
			return _possibleConstructorReturn(this, Object.getPrototypeOf(Final).call(this, props));
		}
	
		_createClass(Final, [{
			key: 'componentDidMount',
			value: function componentDidMount() {
				var _this2 = this;
	
				this.animation = this.refs.final.animate([{ transform: 'scaleY(0)' }, { transform: 'scaleY(1)' }], {
					duration: 400,
					easing: 'ease-in'
				});
				this.animation.onfinish = function () {
					_this2.refs.final.classList.add(_css2.default.loaded);
				};
			}
		}, {
			key: 'render',
			value: function render() {
				var _this3 = this;
	
				var recapContent = this.props.game.get('status') !== 'recap' ? null : _react2.default.createElement(
					'div',
					null,
					_react2.default.createElement(
						_Text2.default,
						{ className: _css2.default.h1 },
						'PARTIE FINIE'
					),
					_react2.default.createElement(
						'div',
						{ className: _css2.default.score },
						this.props.performance.score,
						' POINTS'
					),
					_react2.default.createElement(_Recap2.default, null)
				);
				var saveContent = this.props.game.get('status') !== 'save' ? null : _react2.default.createElement(
					'div',
					null,
					_react2.default.createElement(
						_Text2.default,
						{ className: _css2.default.h1 },
						'PARTIE FINIE'
					),
					_react2.default.createElement(
						'div',
						{ className: _css2.default.score },
						this.props.performance.score,
						' POINTS'
					),
					_react2.default.createElement(_Save2.default, null)
				);
				var recordIndex = this.props.records.findIndex(function (record) {
					return record.time === _this3.props.choregraphyTime;
				});
				var ranksContent = this.props.game.get('status') !== 'rank' ? null : _react2.default.createElement(
					'div',
					null,
					_react2.default.createElement(
						_Text2.default,
						{ className: _css2.default.h1 },
						'CLASSEMENT'
					),
					_react2.default.createElement(
						'div',
						{ className: _css2.default.rank },
						_react2.default.createElement(
							'span',
							null,
							recordIndex + 1
						),
						_react2.default.createElement(
							'sup',
							{ className: _css2.default.suffix },
							recordIndex === 0 ? 'ER' : 'ÈME'
						),
						_react2.default.createElement(
							'span',
							null,
							' sur ',
							this.props.records.size
						)
					),
					_react2.default.createElement(_Rank2.default, { rank: recordIndex })
				);
				return _react2.default.createElement(
					'div',
					{
						ref: 'final',
						className: _css2.default.final
					},
					recapContent,
					saveContent,
					ranksContent
				);
			}
		}]);
	
		return Final;
	}(_react.Component);
	
	function mapStateToProps(state) {
		return {
			game: state.game,
			performance: (0, _performance.getPerformance)(state),
			records: (0, _records.getSortedRecords)(state),
			choregraphyTime: state.choregraphy.get('time')
		};
	}
	
	exports.default = (0, _reactRedux.connect)(mapStateToProps)(Final);

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames2 = __webpack_require__(54);
	
	var _classnames3 = _interopRequireDefault(_classnames2);
	
	var _Text = __webpack_require__(52);
	
	var _Text2 = _interopRequireDefault(_Text);
	
	var _css = __webpack_require__(323);
	
	var _css2 = _interopRequireDefault(_css);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Headline = function (_Component) {
		_inherits(Headline, _Component);
	
		function Headline(props) {
			_classCallCheck(this, Headline);
	
			return _possibleConstructorReturn(this, Object.getPrototypeOf(Headline).call(this, props));
		}
	
		_createClass(Headline, [{
			key: 'componentDidMount',
			value: function componentDidMount() {
				var _this2 = this;
	
				this.refs.h1.classList.remove(_css2.default.loaded);
				this.timeout = setTimeout(function () {
					_this2.refs.h1.classList.add(_css2.default.loaded);
				}, 100);
			}
		}, {
			key: 'componentWillUnmount',
			value: function componentWillUnmount() {
				clearTimeout(this.timeout);
			}
		}, {
			key: 'render',
			value: function render() {
				var _classnames;
	
				var thisClass = (0, _classnames3.default)((_classnames = {}, _defineProperty(_classnames, _css2.default.h1, true), _defineProperty(_classnames, _css2.default[this.props.lineNumber], true), _classnames));
				return _react2.default.createElement(
					'div',
					{ ref: 'h1', className: thisClass },
					_react2.default.createElement(
						_Text2.default,
						null,
						this.props.children
					)
				);
			}
		}]);
	
		return Headline;
	}(_react.Component);

	exports.default = Headline;

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Performance = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(15);
	
	var _performance = __webpack_require__(39);
	
	var _css = __webpack_require__(324);
	
	var _css2 = _interopRequireDefault(_css);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Performance = exports.Performance = function (_Component) {
		_inherits(Performance, _Component);
	
		function Performance() {
			_classCallCheck(this, Performance);
	
			return _possibleConstructorReturn(this, Object.getPrototypeOf(Performance).apply(this, arguments));
		}
	
		_createClass(Performance, [{
			key: 'shouldComponentUpdate',
			value: function shouldComponentUpdate(nextProps) {
				var tp = this.props.performance;
				var np = nextProps.performance;
				return tp.score !== np.score || tp.comments.last !== np.comments.last || tp.combo !== np.combo;
			}
		}, {
			key: 'render',
			value: function render() {
				return _react2.default.createElement(
					'div',
					{ className: _css2.default.performance },
					_react2.default.createElement(
						'div',
						{ className: _css2.default.score },
						_react2.default.createElement(
							'div',
							{ className: _css2.default.label },
							'score'
						),
						_react2.default.createElement(
							'div',
							{ className: _css2.default.amount },
							this.props.performance.score
						)
					),
					_react2.default.createElement(
						'h1',
						null,
						this.props.performance.comments.last
					),
					_react2.default.createElement(
						'div',
						{ className: _css2.default.combo },
						_react2.default.createElement(
							'div',
							{ className: _css2.default.label },
							'combo'
						),
						_react2.default.createElement(
							'div',
							{ className: _css2.default.amount },
							'X',
							this.props.performance.combo
						)
					)
				);
			}
		}]);
	
		return Performance;
	}(_react.Component);
	
	function mapStateToProps(state) {
		return {
			performance: (0, _performance.getPerformance)(state)
		};
	}
	
	exports.default = (0, _reactRedux.connect)(mapStateToProps)(Performance);

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Html = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(15);
	
	var _reactInlinesvg = __webpack_require__(336);
	
	var _reactInlinesvg2 = _interopRequireDefault(_reactInlinesvg);
	
	var _utils = __webpack_require__(40);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _game = __webpack_require__(37);
	
	var gameActions = _interopRequireWildcard(_game);
	
	var _Headline = __webpack_require__(295);
	
	var _Headline2 = _interopRequireDefault(_Headline);
	
	var _Performance = __webpack_require__(296);
	
	var _Performance2 = _interopRequireDefault(_Performance);
	
	var _Final = __webpack_require__(294);
	
	var _Final2 = _interopRequireDefault(_Final);
	
	var _css = __webpack_require__(326);
	
	var _css2 = _interopRequireDefault(_css);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Html = exports.Html = function (_Component) {
		_inherits(Html, _Component);
	
		function Html(props) {
			_classCallCheck(this, Html);
	
			return _possibleConstructorReturn(this, Object.getPrototypeOf(Html).call(this, props));
		}
	
		_createClass(Html, [{
			key: 'render',
			value: function render() {
				var idleContent = this.props.game.get('status') !== 'idle' ? null : _react2.default.createElement(
					'div',
					null,
					_react2.default.createElement(
						_Headline2.default,
						{ lineNumber: 'line1' },
						'Prenez vos marques sur le tapis'
					),
					_react2.default.createElement(
						_Headline2.default,
						{ lineNumber: 'line2' },
						'Pour entrer dans la danse'
					)
				);
				var waitContent = this.props.game.get('status') !== 'wait' ? null : _react2.default.createElement(
					'div',
					null,
					_react2.default.createElement(
						'div',
						null,
						_react2.default.createElement(
							_Headline2.default,
							{ lineNumber: 'line1' },
							'Maintenez',
							_react2.default.createElement('div', { className: _css2.default.arrow_left }),
							'et',
							_react2.default.createElement('div', { className: _css2.default.arrow_right }),
							'avec vos pieds'
						),
						_react2.default.createElement(
							_Headline2.default,
							{ lineNumber: 'line2' },
							'pour commencer à jouer'
						)
					)
				);
				var loadContent = this.props.game.get('status') !== 'load' ? null : _react2.default.createElement(
					'div',
					{ className: _css2.default.loading },
					_react2.default.createElement('div', { className: _css2.default.loadingBar })
				);
				var performanceContent = !_utils2.default.showPerformance(this.props.game) ? null : _react2.default.createElement(_Performance2.default, null);
				var finalContent = !_utils2.default.showFinal(this.props.game) ? null : _react2.default.createElement(_Final2.default, null);
				return _react2.default.createElement(
					'div',
					{ className: _css2.default.html },
					_react2.default.createElement(
						'div',
						{ className: _css2.default.logo },
						_react2.default.createElement(_reactInlinesvg2.default, { src: 'img/logo.svg' })
					),
					idleContent,
					waitContent,
					loadContent,
					performanceContent,
					finalContent
				);
			}
		}]);
	
		return Html;
	}(_react.Component);
	
	function mapStateToProps(state) {
		return {
			game: state.game
		};
	}
	
	exports.default = (0, _reactRedux.connect)(mapStateToProps, gameActions)(Html);

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Video = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(15);
	
	var _constants = __webpack_require__(6);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	var _css = __webpack_require__(327);
	
	var _css2 = _interopRequireDefault(_css);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Video = exports.Video = function (_Component) {
		_inherits(Video, _Component);
	
		function Video(props) {
			_classCallCheck(this, Video);
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Video).call(this, props));
	
			_this.gameStates = ['idle', 'intro', 'wait', 'warning', 'load', 'play', 'recap', 'save', 'rank', 'end'];
			_this.state = {
				muted: true
			};
			return _this;
		}
	
		_createClass(Video, [{
			key: 'componentDidMount',
			value: function componentDidMount() {
				var video = this.refs[this.props.game.get('status')];
				if (video) {
					video.play();
					video.classList.add(_css2.default.above);
				}
			}
		}, {
			key: 'componentWillReceiveProps',
			value: function componentWillReceiveProps(nextProps) {
				var currentGame = this.props.game.get('status');
				var nextGame = nextProps.game.get('status');
				var currentVideo = currentGame === 'tuto' ? 'intro' : currentGame;
				var nextVideo = nextGame === 'tuto' ? 'intro' : nextGame;
				if (currentVideo === nextVideo) {
					return false;
				}
				var currentVideoEl = this.refs[currentVideo];
				var nextVideoEl = this.refs[nextVideo];
				if (nextVideoEl) {
					nextVideoEl.play();
					nextVideoEl.classList.add(_css2.default.above);
				}
				if (currentVideoEl) {
					currentVideoEl.classList.remove(_css2.default.above);
					currentVideoEl.pause();
				}
			}
		}, {
			key: 'render',
			value: function render() {
				var videosContent = this.gameStates.map(function (state) {
					var videoSrc = 'videos/' + state + '.mp4';
					return _react2.default.createElement('video', {
						ref: state,
						key: state,
						src: videoSrc,
						width: _constants2.default.APP_WIDTH,
						height: _constants2.default.APP_HEIGHT,
						loop: true,
						preload: 'auto'
					});
				});
				return _react2.default.createElement(
					'div',
					{ className: _css2.default.video },
					videosContent
				);
			}
		}]);
	
		return Video;
	}(_react.Component);
	
	function mapStateToProps(state) {
		return {
			game: state.game
		};
	}
	
	exports.default = (0, _reactRedux.connect)(mapStateToProps)(Video);

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Move = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _helpers = __webpack_require__(53);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Move = exports.Move = function (_Component) {
		_inherits(Move, _Component);
	
		function Move(props) {
			_classCallCheck(this, Move);
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Move).call(this, props));
	
			_this.position = (0, _helpers.getPosition)('move', _this.props.move.direction);
			_this.geometry = 'geometry_move_' + _this.props.move.direction;
			_this.material = 'material_move_' + _this.props.move.direction;
			return _this;
		}
	
		_createClass(Move, [{
			key: 'componentDidMount',
			value: function componentDidMount() {
				this.props.sceneMoves.set(this.props.move.id, Object.assign({}, this.props.move, {
					ref: this.refs.move
				}));
			}
		}, {
			key: 'shouldComponentUpdate',
			value: function shouldComponentUpdate(nextProps) {
				return false;
			}
		}, {
			key: 'componentWillUnmount',
			value: function componentWillUnmount() {
				this.props.sceneMoves.delete(this.props.move.id);
			}
		}, {
			key: 'render',
			value: function render() {
				return _react2.default.createElement(
					'mesh',
					{
						ref: 'move',
						position: this.position
					},
					_react2.default.createElement('geometryResource', { resourceId: this.geometry }),
					_react2.default.createElement('materialResource', { resourceId: this.material })
				);
			}
		}]);
	
		return Move;
	}(_react.Component);

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Move = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Moves = function (_Component) {
		_inherits(Moves, _Component);
	
		function Moves(props) {
			_classCallCheck(this, Moves);
	
			return _possibleConstructorReturn(this, Object.getPrototypeOf(Moves).call(this, props));
		}
	
		_createClass(Moves, [{
			key: 'render',
			value: function render() {
				var _this2 = this;
	
				if (!this.props.moves) {
					return _react2.default.createElement('group', null);
				}
				return _react2.default.createElement(
					'group',
					null,
					this.props.moves.map(function (move) {
						return _react2.default.createElement(_Move.Move, {
							key: move.id,
							sceneMoves: _this2.props.sceneMoves,
							move: move
						});
					})
				);
			}
		}]);
	
		return Moves;
	}(_react.Component);

	exports.default = Moves;

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _constants = __webpack_require__(6);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	var _utils = __webpack_require__(40);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _Resources = __webpack_require__(305);
	
	var _Resources2 = _interopRequireDefault(_Resources);
	
	var _Targets = __webpack_require__(304);
	
	var _Targets2 = _interopRequireDefault(_Targets);
	
	var _Moves = __webpack_require__(300);
	
	var _Moves2 = _interopRequireDefault(_Moves);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Scene = function (_Component) {
		_inherits(Scene, _Component);
	
		function Scene() {
			_classCallCheck(this, Scene);
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Scene).call(this));
	
			_this.cameraPosition = new _three2.default.Vector3(0, 0, 1);
			return _this;
		}
	
		_createClass(Scene, [{
			key: 'render',
			value: function render() {
				var playContent = !_utils2.default.showWebgl(this.props.game) ? null : _react2.default.createElement(
					'group',
					null,
					_react2.default.createElement(_Targets2.default, {
						sceneTargets: this.props.sceneTargets
					}),
					_react2.default.createElement(_Moves2.default, {
						sceneMoves: this.props.sceneMoves,
						moves: this.props.moves
					})
				);
				return _react2.default.createElement(
					'scene',
					null,
					_react2.default.createElement('orthographicCamera', {
						name: 'camera',
						near: 0.1,
						far: 1000,
						left: _constants2.default.APP_WIDTH / -2,
						right: _constants2.default.APP_WIDTH / 2,
						top: _constants2.default.APP_HEIGHT / 2,
						bottom: _constants2.default.APP_HEIGHT / -2,
						position: this.cameraPosition
					}),
					_react2.default.createElement(_Resources2.default, null),
					playContent
				);
			}
		}]);
	
		return Scene;
	}(_react.Component);

	exports.default = Scene;

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Sprite = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _helpers = __webpack_require__(53);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Sprite = exports.Sprite = function (_Component) {
		_inherits(Sprite, _Component);
	
		function Sprite(props, context) {
			_classCallCheck(this, Sprite);
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Sprite).call(this, props, context));
	
			_this.position = (0, _helpers.getPosition)('target', _this.props.direction);
			_this.repeat = new _three2.default.Vector2(1 / _this.props.hTiles, 1 / _this.props.vTiles);
			var color = _this.props.direction.match(/left|right/) ? 'blue' : 'red';
			_this.sprite = 'img/target_sprites_' + color + '.png';
			return _this;
		}
	
		_createClass(Sprite, [{
			key: 'componentDidMount',
			value: function componentDidMount() {
				this.props.sceneTargets[this.props.direction] = {
					ref: this.refs.sprite_texture,
					material: this.refs.material,
					hTiles: this.props.hTiles,
					vTiles: this.props.vTiles,
					maxTiles: this.props.hTiles * this.props.vTiles,
					tileIndex: 0,
					shouldAnimate: false
				};
			}
		}, {
			key: 'shouldComponentUpdate',
			value: function shouldComponentUpdate(nextProps) {
				return false;
			}
		}, {
			key: 'render',
			value: function render() {
				return _react2.default.createElement(
					'group',
					null,
					_react2.default.createElement(
						'resources',
						null,
						_react2.default.createElement('texture', {
							ref: 'sprite_texture',
							resourceId: 'sprite_texture',
							url: this.sprite,
							wrapS: _three2.default.RepeatWrapping,
							wrapT: _three2.default.RepeatWrapping,
							repeat: this.repeat,
							offset: new _three2.default.Vector2(0, 0)
						}),
						_react2.default.createElement(
							'meshBasicMaterial',
							{
								ref: 'material',
								opacity: 0,
								transparent: true,
								resourceId: 'sprite_material'
							},
							_react2.default.createElement('textureResource', { resourceId: 'sprite_texture' })
						)
					),
					_react2.default.createElement(
						'mesh',
						{ position: this.position },
						_react2.default.createElement('geometryResource', { resourceId: 'sprite_geometry' }),
						_react2.default.createElement('materialResource', { resourceId: 'sprite_material' })
					)
				);
			}
		}]);
	
		return Sprite;
	}(_react.Component);

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Target = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Sprite = __webpack_require__(302);
	
	var _helpers = __webpack_require__(53);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Target = exports.Target = function (_Component) {
		_inherits(Target, _Component);
	
		function Target(props) {
			_classCallCheck(this, Target);
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Target).call(this, props));
	
			_this.position = (0, _helpers.getPosition)('target', _this.props.target.direction);
			_this.geometry = 'geometry_target_' + _this.props.target.direction;
			_this.material = 'material_target_' + _this.props.target.direction;
			return _this;
		}
	
		_createClass(Target, [{
			key: 'shouldComponentUpdate',
			value: function shouldComponentUpdate() {
				return false;
			}
		}, {
			key: 'render',
			value: function render() {
				return _react2.default.createElement(
					'group',
					null,
					_react2.default.createElement(
						'mesh',
						{ position: this.position },
						_react2.default.createElement('geometryResource', { resourceId: this.geometry }),
						_react2.default.createElement('materialResource', { resourceId: this.material })
					),
					_react2.default.createElement(_Sprite.Sprite, {
						direction: this.props.target.direction,
						ref: 'sprite',
						hTiles: 8,
						vTiles: 9,
						sceneTargets: this.props.sceneTargets
					})
				);
			}
		}]);
	
		return Target;
	}(_react.Component);

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Target = __webpack_require__(303);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Targets = function (_Component) {
		_inherits(Targets, _Component);
	
		function Targets(props) {
			_classCallCheck(this, Targets);
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Targets).call(this, props));
	
			_this.targets = [{ direction: 'left' }, { direction: 'top' }, { direction: 'bottom' }, { direction: 'right' }];
			return _this;
		}
	
		_createClass(Targets, [{
			key: 'shouldComponentUpdate',
			value: function shouldComponentUpdate() {
				return false;
			}
		}, {
			key: 'render',
			value: function render() {
				var _this2 = this;
	
				return _react2.default.createElement(
					'group',
					null,
					this.targets.map(function (target, index) {
						return _react2.default.createElement(_Target.Target, {
							key: index,
							target: target,
							sceneTargets: _this2.props.sceneTargets
						});
					})
				);
			}
		}]);
	
		return Targets;
	}(_react.Component);

	exports.default = Targets;

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Resources = function (_Component) {
		_inherits(Resources, _Component);
	
		function Resources(props) {
			_classCallCheck(this, Resources);
	
			return _possibleConstructorReturn(this, Object.getPrototypeOf(Resources).call(this, props));
		}
	
		_createClass(Resources, [{
			key: 'componentDidMount',
			value: function componentDidMount() {
				this.refs.geometry_move_left.rotateZ(Math.PI / -2);
				this.refs.geometry_move_top.rotateZ(Math.PI);
				this.refs.geometry_move_bottom.rotateZ(0);
				this.refs.geometry_move_right.rotateZ(Math.PI / 2);
			}
		}, {
			key: 'shouldComponentUpdate',
			value: function shouldComponentUpdate() {
				return false;
			}
		}, {
			key: 'render',
			value: function render() {
				return _react2.default.createElement(
					'resources',
					null,
					_react2.default.createElement('texture', {
						resourceId: 'texture_target_left',
						url: 'img/target_left.png',
						wrapS: _three2.default.RepeatWrapping,
						wrapT: _three2.default.RepeatWrapping
					}),
					_react2.default.createElement('texture', {
						resourceId: 'texture_target_top',
						url: 'img/target_top.png',
						wrapS: _three2.default.RepeatWrapping,
						wrapT: _three2.default.RepeatWrapping
					}),
					_react2.default.createElement('texture', {
						resourceId: 'texture_target_right',
						url: 'img/target_right.png',
						wrapS: _three2.default.RepeatWrapping,
						wrapT: _three2.default.RepeatWrapping
					}),
					_react2.default.createElement('texture', {
						resourceId: 'texture_target_bottom',
						url: 'img/target_bottom.png',
						wrapS: _three2.default.RepeatWrapping,
						wrapT: _three2.default.RepeatWrapping
					}),
					_react2.default.createElement(
						'meshBasicMaterial',
						{ transparent: true, resourceId: 'material_target_left' },
						_react2.default.createElement('textureResource', { resourceId: 'texture_target_left' })
					),
					_react2.default.createElement(
						'meshBasicMaterial',
						{ transparent: true, resourceId: 'material_target_top' },
						_react2.default.createElement('textureResource', { resourceId: 'texture_target_top' })
					),
					_react2.default.createElement(
						'meshBasicMaterial',
						{ transparent: true, resourceId: 'material_target_right' },
						_react2.default.createElement('textureResource', { resourceId: 'texture_target_right' })
					),
					_react2.default.createElement(
						'meshBasicMaterial',
						{ transparent: true, resourceId: 'material_target_bottom' },
						_react2.default.createElement('textureResource', { resourceId: 'texture_target_bottom' })
					),
					_react2.default.createElement('planeGeometry', {
						ref: 'geometry_target_left',
						resourceId: 'geometry_target_left',
						width: 128,
						height: 128
					}),
					_react2.default.createElement('planeGeometry', {
						ref: 'geometry_target_top',
						resourceId: 'geometry_target_top',
						width: 128,
						height: 128
					}),
					_react2.default.createElement('planeGeometry', {
						ref: 'geometry_target_right',
						resourceId: 'geometry_target_right',
						width: 128,
						height: 128
					}),
					_react2.default.createElement('planeGeometry', {
						ref: 'geometry_target_bottom',
						resourceId: 'geometry_target_bottom',
						width: 128,
						height: 128
					}),
					_react2.default.createElement('texture', {
						resourceId: 'texture_move_left_right',
						url: 'img/move_left_right.png',
						wrapS: _three2.default.RepeatWrapping,
						wrapT: _three2.default.RepeatWrapping
					}),
					_react2.default.createElement('texture', {
						resourceId: 'texture_move_top_bottom',
						url: 'img/move_top_bottom.png',
						wrapS: _three2.default.RepeatWrapping,
						wrapT: _three2.default.RepeatWrapping
					}),
					_react2.default.createElement(
						'meshBasicMaterial',
						{ transparent: true, resourceId: 'material_move_left' },
						_react2.default.createElement('textureResource', { resourceId: 'texture_move_left_right' })
					),
					_react2.default.createElement(
						'meshBasicMaterial',
						{ transparent: true, resourceId: 'material_move_top' },
						_react2.default.createElement('textureResource', { resourceId: 'texture_move_top_bottom' })
					),
					_react2.default.createElement(
						'meshBasicMaterial',
						{ transparent: true, resourceId: 'material_move_bottom' },
						_react2.default.createElement('textureResource', { resourceId: 'texture_move_top_bottom' })
					),
					_react2.default.createElement(
						'meshBasicMaterial',
						{ transparent: true, resourceId: 'material_move_right' },
						_react2.default.createElement('textureResource', { resourceId: 'texture_move_left_right' })
					),
					_react2.default.createElement('planeGeometry', {
						ref: 'geometry_move_left',
						resourceId: 'geometry_move_left',
						width: 128,
						height: 128
					}),
					_react2.default.createElement('planeGeometry', {
						ref: 'geometry_move_top',
						resourceId: 'geometry_move_top',
						width: 128,
						height: 128
					}),
					_react2.default.createElement('planeGeometry', {
						ref: 'geometry_move_bottom',
						resourceId: 'geometry_move_bottom',
						width: 128,
						height: 128
					}),
					_react2.default.createElement('planeGeometry', {
						ref: 'geometry_move_right',
						resourceId: 'geometry_move_right',
						width: 128,
						height: 128
					}),
					_react2.default.createElement('planeGeometry', {
						resourceId: 'sprite_geometry',
						width: 256,
						height: 256
					})
				);
			}
		}]);
	
		return Resources;
	}(_react.Component);

	exports.default = Resources;

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Webgl = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(15);
	
	var _reactThreeRenderer = __webpack_require__(355);
	
	var _reactThreeRenderer2 = _interopRequireDefault(_reactThreeRenderer);
	
	var _constants = __webpack_require__(6);
	
	var _constants2 = _interopRequireDefault(_constants);
	
	var _game = __webpack_require__(37);
	
	var gameActions = _interopRequireWildcard(_game);
	
	var _moves = __webpack_require__(134);
	
	var _performance = __webpack_require__(39);
	
	var _helpers = __webpack_require__(53);
	
	var _Scene = __webpack_require__(301);
	
	var _Scene2 = _interopRequireDefault(_Scene);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Webgl = exports.Webgl = function (_Component) {
		_inherits(Webgl, _Component);
	
		function Webgl(props) {
			_classCallCheck(this, Webgl);
	
			var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Webgl).call(this, props));
	
			_this._onAnimate = _this._onAnimate.bind(_this);
			_this.sceneMoves = new Map();
			_this.sceneTargets = {};
			return _this;
		}
	
		_createClass(Webgl, [{
			key: 'componentWillReceiveProps',
			value: function componentWillReceiveProps(nextProps) {
				var _this2 = this;
	
				Object.keys(this.props.snapshots).forEach(function (direction) {
					var currentSnapshot = _this2.props.snapshots[direction];
					var nextSnapshot = nextProps.snapshots[direction];
					if ((currentSnapshot.lastComment !== nextSnapshot.lastComment || currentSnapshot.commentCount !== nextSnapshot.commentCount) && nextSnapshot.lastComment.match(/ok|good|excellent/)) {
						_this2.sceneTargets[direction].shouldAnimate = true;
						_this2.sceneTargets[direction].tileIndex = 0;
						_this2.sceneTargets[direction].material.opacity = 1;
					}
				});
			}
		}, {
			key: '_onAnimate',
			value: function _onAnimate() {
				var _this3 = this;
	
				this.gameTime = Date.now() - this.props.choregraphy.get('time');
				this.sceneMoves.forEach(function (move) {
					move.ref.translateY((0, _helpers.getTranslation)(move.ref.position.y, move.showTime, _this3.gameTime));
				});
				Object.keys(this.sceneTargets).forEach(function (direction) {
					if (_this3.sceneTargets[direction].shouldAnimate) {
						_this3.sceneTargets[direction].tileIndex++;
						if (_this3.sceneTargets[direction].tileIndex >= _this3.sceneTargets[direction].maxTiles) {
							_this3.sceneTargets[direction].shouldAnimate = false;
							_this3.sceneTargets[direction].tileIndex = 0;
							_this3.sceneTargets[direction].material.opacity = 0;
						}
						_this3.sceneTargets[direction].ref.offset = (0, _helpers.getSpriteOffset)(_this3.sceneTargets[direction].tileIndex, _this3.sceneTargets[direction].hTiles, _this3.sceneTargets[direction].vTiles);
					}
				});
			}
		}, {
			key: 'render',
			value: function render() {
				return _react2.default.createElement(
					_reactThreeRenderer2.default,
					{
						mainCamera: 'camera',
						width: _constants2.default.APP_WIDTH,
						height: _constants2.default.APP_HEIGHT,
						alpha: true,
						clearAlpha: 0,
						onAnimate: this._onAnimate,
						antialias: true
					},
					_react2.default.createElement(_Scene2.default, {
						sceneMoves: this.sceneMoves,
						sceneTargets: this.sceneTargets,
						game: this.props.game,
						moves: this.props.moves
					})
				);
			}
		}]);
	
		return Webgl;
	}(_react.Component);
	
	function mapStateToProps(state) {
		return {
			game: state.game,
			choregraphy: state.choregraphy,
			moves: (0, _moves.getVisibleMoves)(state),
			snapshots: (0, _performance.getPerformance)(state).snapshots
		};
	}
	
	exports.default = (0, _reactRedux.connect)(mapStateToProps, gameActions)(Webgl);

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(335);
	
	var _reactRedux = __webpack_require__(15);
	
	var _dev = __webpack_require__(38);
	
	var _dev2 = _interopRequireDefault(_dev);
	
	var _master = __webpack_require__(309);
	
	var _master2 = __webpack_require__(94);
	
	var _App = __webpack_require__(287);
	
	var _App2 = _interopRequireDefault(_App);
	
	__webpack_require__(328);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var store = (0, _master.configureStore)();
	store.dispatch((0, _master2.listenToSlave)());
	
	var rootElement = document.querySelector('.root');
	var renderApp = function renderApp() {
		(0, _reactDom.render)(_react2.default.createElement(
			_reactRedux.Provider,
			{ store: store },
			_react2.default.createElement(_App2.default, null)
		), rootElement);
	};
	renderApp();
	
	_dev2.default.moduleHotAccept();
	_dev2.default.scaleBody();
	_dev2.default.installImmutablejsDevtools();

/***/ },
/* 308 */,
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.configureStore = undefined;
	
	var _redux = __webpack_require__(36);
	
	var _reduxThunk = __webpack_require__(124);
	
	var _reduxThunk2 = _interopRequireDefault(_reduxThunk);
	
	var _reducers = __webpack_require__(91);
	
	var _reducers2 = _interopRequireDefault(_reducers);
	
	var _master = __webpack_require__(94);
	
	var _dev = __webpack_require__(38);
	
	var _dev2 = _interopRequireDefault(_dev);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var configureStore = exports.configureStore = function configureStore() {
		var slaveMiddleware = function slaveMiddleware(store) {
			return function (next) {
				return function (action) {
					(0, _master.dispatchToSlave)(action);
					return next(action);
				};
			};
		};
		var middlewares = [_reduxThunk2.default, slaveMiddleware];
	
		_dev2.default.addLoggerToMiddlewares(middlewares);
	
		var createStoreWithMiddleware = _redux.applyMiddleware.apply(undefined, middlewares)(_redux.createStore);
		var store = createStoreWithMiddleware(_reducers2.default);
	
		_dev2.default.replaceReducerOnHotReload(store);
	
		return store;
	};

/***/ },
/* 310 */,
/* 311 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	var flattenArray = exports.flattenArray = function flattenArray(arr) {
		return arr.reduce(function (a, b) {
			return a.concat(b);
		});
	};
	
	var sum = exports.sum = function sum(array) {
		return array.reduce(function (first, second) {
			return first + second;
		}, 0);
	};
	
	var getItemByInfiniteIndex = exports.getItemByInfiniteIndex = function getItemByInfiniteIndex(array, index) {
		var reasonnableIndex = index % array.length;
		if (reasonnableIndex < 0) return array[array.length + reasonnableIndex];
		return array[reasonnableIndex];
	};
	
	var alphabet = exports.alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];

/***/ },
/* 312 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	var showWebglRegexp = /tuto|wait|warning|load|play/;
	var showWebgl = exports.showWebgl = function showWebgl(game) {
		return game.get('status').match(showWebglRegexp);
	};
	
	var showPerformanceRegexp = /tuto|play/;
	var showPerformance = exports.showPerformance = function showPerformance(game) {
		return game.get('status').match(showPerformanceRegexp);
	};
	
	var showFinalRegexp = /recap|save|rank/;
	var showFinal = exports.showFinal = function showFinal(game) {
		return game.get('status').match(showFinalRegexp);
	};

/***/ },
/* 313 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin
	module.exports = {"odometer":"odometer","odometer-auto-theme":"odometer-auto-theme","odometer-theme-minimal":"odometer-theme-minimal","odometer-digit":"odometer-digit","odometer-digit-spacer":"odometer-digit-spacer","odometer-digit-inner":"odometer-digit-inner","odometer-ribbon":"odometer-ribbon","odometer-ribbon-inner":"odometer-ribbon-inner","odometer-value":"odometer-value","odometer-last-value":"odometer-last-value","odometer-animating-up":"odometer-animating-up","odometer-animating":"odometer-animating","odometer-animating-down":"odometer-animating-down"};

/***/ },
/* 314 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin
	module.exports = {"admin":"admin--Fpmfu","h1":"h1--5mRzV","h2":"h2--1K31L","button":"button--2w285","sound":"sound--3HIzi","muted":"muted--2_H2B"};

/***/ },
/* 315 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin
	module.exports = {"app":"app--18gwo","video":"video--3EiSi","webgl":"webgl--1j3-a","html":"html--3JCDT"};

/***/ },
/* 316 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 317 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin
	module.exports = {"rank":"rank--ge1Ge","ranks":"ranks--a1Jba","podium":"podium--1buXR","ranksScore":"ranksScore--1fdQt","podiumScore":"podiumScore--2-My0"};

/***/ },
/* 318 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin
	module.exports = {"metric":"metric--26xcn","label":"label--3aSyq","value":"value--1BD6a","scale":"scale--2WKn9","bar":"bar--nQYTd"};

/***/ },
/* 319 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin
	module.exports = {"recap":"recap--3ye_6","excellent":"excellent--2EMqk","good":"good--1ma-T","ok":"ok--1LH7v","combo":"combo--39Uxl","hint":"hint--2nQsw","arrow_right":"arrow_right--2s4tn arrow_right--2Wkb_"};

/***/ },
/* 320 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin
	module.exports = {"letter":"letter--3gRNV","focus":"focus--1sFKP","visibleLetters":"visibleLetters--2dJ4B","allLetters":"allLetters--1i5yO","activeLetter":"activeLetter--2lX7n","control_left":"control_left--3VhYp","control_top":"control_top--3nq83","control_bottom":"control_bottom--3Xxkr","control_right":"control_right--32zHn","onPadDown":"onPadDown--nZp-X","onpaddown":"onpaddown--1QHK_"};

/***/ },
/* 321 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin
	module.exports = {"save":"save--3QidW"};

/***/ },
/* 322 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin
	module.exports = {"final":"final--1R3hM","loaded":"loaded--26T1x","h1":"h1--36Jle","score":"score--2ROa2","rank":"rank--p9-vN","suffix":"suffix--3fLDj"};

/***/ },
/* 323 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin
	module.exports = {"h1":"h1--139G5","line1":"line1--3outA","line2":"line2--Z84Qc","loaded":"loaded--1iq7x"};

/***/ },
/* 324 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin
	module.exports = {"performance":"performance--2P3sY","score":"score--3Jq4D","combo":"combo--hkKRd","label":"label--2drnE","amount":"amount--_14xK"};

/***/ },
/* 325 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin
	module.exports = {"shade":"shade--hP_Ed"};

/***/ },
/* 326 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin
	module.exports = {"html":"html--2yBNU","logo":"logo--1q1AS","loading":"loading--3Nac3","countdown3s":"countdown3s--enP_q","loadingBar":"loadingBar--2A6HN","arrow_left":"arrow_left--2rbgK arrow_left--3hNai","arrow_right":"arrow_right--UyVo3 arrow_right--2Wkb_"};

/***/ },
/* 327 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin
	module.exports = {"video":"video--2rtnL","above":"above--1hJrZ"};

/***/ },
/* 328 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 329 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	var define = false;
	
	(function() {
	  var COUNT_FRAMERATE, COUNT_MS_PER_FRAME, DIGIT_FORMAT, DIGIT_HTML, DIGIT_SPEEDBOOST, DURATION, FORMAT_MARK_HTML, FORMAT_PARSER, FRAMERATE, FRAMES_PER_VALUE, MS_PER_FRAME, MutationObserver, Odometer, RIBBON_HTML, TRANSITION_END_EVENTS, TRANSITION_SUPPORT, VALUE_HTML, addClass, createFromHTML, fractionalPart, now, removeClass, requestAnimationFrame, round, transitionCheckStyles, trigger, truncate, wrapJQuery, _jQueryWrapped, _old, _ref, _ref1,
	    __slice = [].slice;
	
	  VALUE_HTML = '<span class="odometer-value"></span>';
	
	  RIBBON_HTML = '<span class="odometer-ribbon"><span class="odometer-ribbon-inner">' + VALUE_HTML + '</span></span>';
	
	  DIGIT_HTML = '<span class="odometer-digit"><span class="odometer-digit-spacer">8</span><span class="odometer-digit-inner">' + RIBBON_HTML + '</span></span>';
	
	  FORMAT_MARK_HTML = '<span class="odometer-formatting-mark"></span>';
	
	  DIGIT_FORMAT = '(,ddd).dd';
	
	  FORMAT_PARSER = /^\(?([^)]*)\)?(?:(.)(d+))?$/;
	
	  FRAMERATE = 30;
	
	  DURATION = 2000;
	
	  COUNT_FRAMERATE = 20;
	
	  FRAMES_PER_VALUE = 2;
	
	  DIGIT_SPEEDBOOST = .5;
	
	  MS_PER_FRAME = 1000 / FRAMERATE;
	
	  COUNT_MS_PER_FRAME = 1000 / COUNT_FRAMERATE;
	
	  TRANSITION_END_EVENTS = 'transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd';
	
	  transitionCheckStyles = document.createElement('div').style;
	
	  TRANSITION_SUPPORT = (transitionCheckStyles.transition != null) || (transitionCheckStyles.webkitTransition != null) || (transitionCheckStyles.mozTransition != null) || (transitionCheckStyles.oTransition != null);
	
	  requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
	
	  MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
	
	  createFromHTML = function(html) {
	    var el;
	    el = document.createElement('div');
	    el.innerHTML = html;
	    return el.children[0];
	  };
	
	  removeClass = function(el, name) {
	    return el.className = el.className.replace(new RegExp("(^| )" + (name.split(' ').join('|')) + "( |$)", 'gi'), ' ');
	  };
	
	  addClass = function(el, name) {
	    removeClass(el, name);
	    return el.className += " " + name;
	  };
	
	  trigger = function(el, name) {
	    var evt;
	    if (document.createEvent != null) {
	      evt = document.createEvent('HTMLEvents');
	      evt.initEvent(name, true, true);
	      return el.dispatchEvent(evt);
	    }
	  };
	
	  now = function() {
	    var _ref, _ref1;
	    return (_ref = (_ref1 = window.performance) != null ? typeof _ref1.now === "function" ? _ref1.now() : void 0 : void 0) != null ? _ref : +(new Date);
	  };
	
	  round = function(val, precision) {
	    if (precision == null) {
	      precision = 0;
	    }
	    if (!precision) {
	      return Math.round(val);
	    }
	    val *= Math.pow(10, precision);
	    val += 0.5;
	    val = Math.floor(val);
	    return val /= Math.pow(10, precision);
	  };
	
	  truncate = function(val) {
	    if (val < 0) {
	      return Math.ceil(val);
	    } else {
	      return Math.floor(val);
	    }
	  };
	
	  fractionalPart = function(val) {
	    return val - round(val);
	  };
	
	  _jQueryWrapped = false;
	
	  (wrapJQuery = function() {
	    var property, _i, _len, _ref, _results;
	    if (_jQueryWrapped) {
	      return;
	    }
	    if (window.jQuery != null) {
	      _jQueryWrapped = true;
	      _ref = ['html', 'text'];
	      _results = [];
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        property = _ref[_i];
	        _results.push((function(property) {
	          var old;
	          old = window.jQuery.fn[property];
	          return window.jQuery.fn[property] = function(val) {
	            var _ref1;
	            if ((val == null) || (((_ref1 = this[0]) != null ? _ref1.odometer : void 0) == null)) {
	              return old.apply(this, arguments);
	            }
	            return this[0].odometer.update(val);
	          };
	        })(property));
	      }
	      return _results;
	    }
	  })();
	
	  setTimeout(wrapJQuery, 0);
	
	  Odometer = (function() {
	    function Odometer(options) {
	      var e, k, property, v, _base, _i, _len, _ref, _ref1, _ref2,
	        _this = this;
	      this.options = options;
	      this.el = this.options.el;
	      if (this.el.odometer != null) {
	        return this.el.odometer;
	      }
	      this.el.odometer = this;
	      _ref = Odometer.options;
	      for (k in _ref) {
	        v = _ref[k];
	        if (this.options[k] == null) {
	          this.options[k] = v;
	        }
	      }
	      if ((_base = this.options).duration == null) {
	        _base.duration = DURATION;
	      }
	      this.MAX_VALUES = ((this.options.duration / MS_PER_FRAME) / FRAMES_PER_VALUE) | 0;
	      this.resetFormat();
	      this.value = this.cleanValue((_ref1 = this.options.value) != null ? _ref1 : '');
	      this.renderInside();
	      this.render();
	      try {
	        _ref2 = ['innerHTML', 'innerText', 'textContent'];
	        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
	          property = _ref2[_i];
	          if (this.el[property] != null) {
	            (function(property) {
	              return Object.defineProperty(_this.el, property, {
	                get: function() {
	                  var _ref3;
	                  if (property === 'innerHTML') {
	                    return _this.inside.outerHTML;
	                  } else {
	                    return (_ref3 = _this.inside.innerText) != null ? _ref3 : _this.inside.textContent;
	                  }
	                },
	                set: function(val) {
	                  return _this.update(val);
	                }
	              });
	            })(property);
	          }
	        }
	      } catch (_error) {
	        e = _error;
	        this.watchForMutations();
	      }
	      this;
	    }
	
	    Odometer.prototype.renderInside = function() {
	      this.inside = document.createElement('div');
	      this.inside.className = 'odometer-inside';
	      this.el.innerHTML = '';
	      return this.el.appendChild(this.inside);
	    };
	
	    Odometer.prototype.watchForMutations = function() {
	      var e,
	        _this = this;
	      if (MutationObserver == null) {
	        return;
	      }
	      try {
	        if (this.observer == null) {
	          this.observer = new MutationObserver(function(mutations) {
	            var newVal;
	            newVal = _this.el.innerText;
	            _this.renderInside();
	            _this.render(_this.value);
	            return _this.update(newVal);
	          });
	        }
	        this.watchMutations = true;
	        return this.startWatchingMutations();
	      } catch (_error) {
	        e = _error;
	      }
	    };
	
	    Odometer.prototype.startWatchingMutations = function() {
	      if (this.watchMutations) {
	        return this.observer.observe(this.el, {
	          childList: true
	        });
	      }
	    };
	
	    Odometer.prototype.stopWatchingMutations = function() {
	      var _ref;
	      return (_ref = this.observer) != null ? _ref.disconnect() : void 0;
	    };
	
	    Odometer.prototype.cleanValue = function(val) {
	      var _ref;
	      if (typeof val === 'string') {
	        val = val.replace((_ref = this.format.radix) != null ? _ref : '.', '<radix>');
	        val = val.replace(/[.,]/g, '');
	        val = val.replace('<radix>', '.');
	        val = parseFloat(val, 10) || 0;
	      }
	      return round(val, this.format.precision);
	    };
	
	    Odometer.prototype.bindTransitionEnd = function() {
	      var event, renderEnqueued, _i, _len, _ref, _results,
	        _this = this;
	      if (this.transitionEndBound) {
	        return;
	      }
	      this.transitionEndBound = true;
	      renderEnqueued = false;
	      _ref = TRANSITION_END_EVENTS.split(' ');
	      _results = [];
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        event = _ref[_i];
	        _results.push(this.el.addEventListener(event, function() {
	          if (renderEnqueued) {
	            return true;
	          }
	          renderEnqueued = true;
	          setTimeout(function() {
	            _this.render();
	            renderEnqueued = false;
	            return trigger(_this.el, 'odometerdone');
	          }, 0);
	          return true;
	        }, false));
	      }
	      return _results;
	    };
	
	    Odometer.prototype.resetFormat = function() {
	      var format, fractional, parsed, precision, radix, repeating, _ref, _ref1;
	      format = (_ref = this.options.format) != null ? _ref : DIGIT_FORMAT;
	      format || (format = 'd');
	      parsed = FORMAT_PARSER.exec(format);
	      if (!parsed) {
	        throw new Error("Odometer: Unparsable digit format");
	      }
	      _ref1 = parsed.slice(1, 4), repeating = _ref1[0], radix = _ref1[1], fractional = _ref1[2];
	      precision = (fractional != null ? fractional.length : void 0) || 0;
	      return this.format = {
	        repeating: repeating,
	        radix: radix,
	        precision: precision
	      };
	    };
	
	    Odometer.prototype.render = function(value) {
	      var classes, cls, match, newClasses, theme, _i, _len;
	      if (value == null) {
	        value = this.value;
	      }
	      this.stopWatchingMutations();
	      this.resetFormat();
	      this.inside.innerHTML = '';
	      theme = this.options.theme;
	      classes = this.el.className.split(' ');
	      newClasses = [];
	      for (_i = 0, _len = classes.length; _i < _len; _i++) {
	        cls = classes[_i];
	        if (!cls.length) {
	          continue;
	        }
	        if (match = /^odometer-theme-(.+)$/.exec(cls)) {
	          theme = match[1];
	          continue;
	        }
	        if (/^odometer(-|$)/.test(cls)) {
	          continue;
	        }
	        newClasses.push(cls);
	      }
	      newClasses.push('odometer');
	      if (!TRANSITION_SUPPORT) {
	        newClasses.push('odometer-no-transitions');
	      }
	      if (theme) {
	        newClasses.push("odometer-theme-" + theme);
	      } else {
	        newClasses.push("odometer-auto-theme");
	      }
	      this.el.className = newClasses.join(' ');
	      this.ribbons = {};
	      this.formatDigits(value);
	      return this.startWatchingMutations();
	    };
	
	    Odometer.prototype.formatDigits = function(value) {
	      var digit, valueDigit, valueString, wholePart, _i, _j, _len, _len1, _ref, _ref1;
	      this.digits = [];
	      if (this.options.formatFunction) {
	        valueString = this.options.formatFunction(value);
	        _ref = valueString.split('').reverse();
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          valueDigit = _ref[_i];
	          if (valueDigit.match(/0-9/)) {
	            digit = this.renderDigit();
	            digit.querySelector('.odometer-value').innerHTML = valueDigit;
	            this.digits.push(digit);
	            this.insertDigit(digit);
	          } else {
	            this.addSpacer(valueDigit);
	          }
	        }
	      } else {
	        wholePart = !this.format.precision || !fractionalPart(value) || false;
	        _ref1 = value.toString().split('').reverse();
	        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
	          digit = _ref1[_j];
	          if (digit === '.') {
	            wholePart = true;
	          }
	          this.addDigit(digit, wholePart);
	        }
	      }
	    };
	
	    Odometer.prototype.update = function(newValue) {
	      var diff,
	        _this = this;
	      newValue = this.cleanValue(newValue);
	      if (!(diff = newValue - this.value)) {
	        return;
	      }
	      removeClass(this.el, 'odometer-animating-up odometer-animating-down odometer-animating');
	      if (diff > 0) {
	        addClass(this.el, 'odometer-animating-up');
	      } else {
	        addClass(this.el, 'odometer-animating-down');
	      }
	      this.stopWatchingMutations();
	      this.animate(newValue);
	      this.startWatchingMutations();
	      setTimeout(function() {
	        _this.el.offsetHeight;
	        return addClass(_this.el, 'odometer-animating');
	      }, 0);
	      return this.value = newValue;
	    };
	
	    Odometer.prototype.renderDigit = function() {
	      return createFromHTML(DIGIT_HTML);
	    };
	
	    Odometer.prototype.insertDigit = function(digit, before) {
	      if (before != null) {
	        return this.inside.insertBefore(digit, before);
	      } else if (!this.inside.children.length) {
	        return this.inside.appendChild(digit);
	      } else {
	        return this.inside.insertBefore(digit, this.inside.children[0]);
	      }
	    };
	
	    Odometer.prototype.addSpacer = function(chr, before, extraClasses) {
	      var spacer;
	      spacer = createFromHTML(FORMAT_MARK_HTML);
	      spacer.innerHTML = chr;
	      if (extraClasses) {
	        addClass(spacer, extraClasses);
	      }
	      return this.insertDigit(spacer, before);
	    };
	
	    Odometer.prototype.addDigit = function(value, repeating) {
	      var chr, digit, resetted, _ref;
	      if (repeating == null) {
	        repeating = true;
	      }
	      if (value === '-') {
	        return this.addSpacer(value, null, 'odometer-negation-mark');
	      }
	      if (value === '.') {
	        return this.addSpacer((_ref = this.format.radix) != null ? _ref : '.', null, 'odometer-radix-mark');
	      }
	      if (repeating) {
	        resetted = false;
	        while (true) {
	          if (!this.format.repeating.length) {
	            if (resetted) {
	              throw new Error("Bad odometer format without digits");
	            }
	            this.resetFormat();
	            resetted = true;
	          }
	          chr = this.format.repeating[this.format.repeating.length - 1];
	          this.format.repeating = this.format.repeating.substring(0, this.format.repeating.length - 1);
	          if (chr === 'd') {
	            break;
	          }
	          this.addSpacer(chr);
	        }
	      }
	      digit = this.renderDigit();
	      digit.querySelector('.odometer-value').innerHTML = value;
	      this.digits.push(digit);
	      return this.insertDigit(digit);
	    };
	
	    Odometer.prototype.animate = function(newValue) {
	      if (!TRANSITION_SUPPORT || this.options.animation === 'count') {
	        return this.animateCount(newValue);
	      } else {
	        return this.animateSlide(newValue);
	      }
	    };
	
	    Odometer.prototype.animateCount = function(newValue) {
	      var cur, diff, last, start, tick,
	        _this = this;
	      if (!(diff = +newValue - this.value)) {
	        return;
	      }
	      start = last = now();
	      cur = this.value;
	      return (tick = function() {
	        var delta, dist, fraction;
	        if ((now() - start) > _this.options.duration) {
	          _this.value = newValue;
	          _this.render();
	          trigger(_this.el, 'odometerdone');
	          return;
	        }
	        delta = now() - last;
	        if (delta > COUNT_MS_PER_FRAME) {
	          last = now();
	          fraction = delta / _this.options.duration;
	          dist = diff * fraction;
	          cur += dist;
	          _this.render(Math.round(cur));
	        }
	        if (requestAnimationFrame != null) {
	          return requestAnimationFrame(tick);
	        } else {
	          return setTimeout(tick, COUNT_MS_PER_FRAME);
	        }
	      })();
	    };
	
	    Odometer.prototype.getDigitCount = function() {
	      var i, max, value, values, _i, _len;
	      values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	      for (i = _i = 0, _len = values.length; _i < _len; i = ++_i) {
	        value = values[i];
	        values[i] = Math.abs(value);
	      }
	      max = Math.max.apply(Math, values);
	      return Math.ceil(Math.log(max + 1) / Math.log(10));
	    };
	
	    Odometer.prototype.getFractionalDigitCount = function() {
	      var i, parser, parts, value, values, _i, _len;
	      values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	      parser = /^\-?\d*\.(\d*?)0*$/;
	      for (i = _i = 0, _len = values.length; _i < _len; i = ++_i) {
	        value = values[i];
	        values[i] = value.toString();
	        parts = parser.exec(values[i]);
	        if (parts == null) {
	          values[i] = 0;
	        } else {
	          values[i] = parts[1].length;
	        }
	      }
	      return Math.max.apply(Math, values);
	    };
	
	    Odometer.prototype.resetDigits = function() {
	      this.digits = [];
	      this.ribbons = [];
	      this.inside.innerHTML = '';
	      return this.resetFormat();
	    };
	
	    Odometer.prototype.animateSlide = function(newValue) {
	      var boosted, cur, diff, digitCount, digits, dist, end, fractionalCount, frame, frames, i, incr, j, mark, numEl, oldValue, start, _base, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref, _results;
	      oldValue = this.value;
	      fractionalCount = this.getFractionalDigitCount(oldValue, newValue);
	      if (fractionalCount) {
	        newValue = newValue * Math.pow(10, fractionalCount);
	        oldValue = oldValue * Math.pow(10, fractionalCount);
	      }
	      if (!(diff = newValue - oldValue)) {
	        return;
	      }
	      this.bindTransitionEnd();
	      digitCount = this.getDigitCount(oldValue, newValue);
	      digits = [];
	      boosted = 0;
	      for (i = _i = 0; 0 <= digitCount ? _i < digitCount : _i > digitCount; i = 0 <= digitCount ? ++_i : --_i) {
	        start = truncate(oldValue / Math.pow(10, digitCount - i - 1));
	        end = truncate(newValue / Math.pow(10, digitCount - i - 1));
	        dist = end - start;
	        if (Math.abs(dist) > this.MAX_VALUES) {
	          frames = [];
	          incr = dist / (this.MAX_VALUES + this.MAX_VALUES * boosted * DIGIT_SPEEDBOOST);
	          cur = start;
	          while ((dist > 0 && cur < end) || (dist < 0 && cur > end)) {
	            frames.push(Math.round(cur));
	            cur += incr;
	          }
	          if (frames[frames.length - 1] !== end) {
	            frames.push(end);
	          }
	          boosted++;
	        } else {
	          frames = (function() {
	            _results = [];
	            for (var _j = start; start <= end ? _j <= end : _j >= end; start <= end ? _j++ : _j--){ _results.push(_j); }
	            return _results;
	          }).apply(this);
	        }
	        for (i = _k = 0, _len = frames.length; _k < _len; i = ++_k) {
	          frame = frames[i];
	          frames[i] = Math.abs(frame % 10);
	        }
	        digits.push(frames);
	      }
	      this.resetDigits();
	      _ref = digits.reverse();
	      for (i = _l = 0, _len1 = _ref.length; _l < _len1; i = ++_l) {
	        frames = _ref[i];
	        if (!this.digits[i]) {
	          this.addDigit(' ', i >= fractionalCount);
	        }
	        if ((_base = this.ribbons)[i] == null) {
	          _base[i] = this.digits[i].querySelector('.odometer-ribbon-inner');
	        }
	        this.ribbons[i].innerHTML = '';
	        if (diff < 0) {
	          frames = frames.reverse();
	        }
	        for (j = _m = 0, _len2 = frames.length; _m < _len2; j = ++_m) {
	          frame = frames[j];
	          numEl = document.createElement('div');
	          numEl.className = 'odometer-value';
	          numEl.innerHTML = frame;
	          this.ribbons[i].appendChild(numEl);
	          if (j === frames.length - 1) {
	            addClass(numEl, 'odometer-last-value');
	          }
	          if (j === 0) {
	            addClass(numEl, 'odometer-first-value');
	          }
	        }
	      }
	      if (start < 0) {
	        this.addDigit('-');
	      }
	      mark = this.inside.querySelector('.odometer-radix-mark');
	      if (mark != null) {
	        mark.parent.removeChild(mark);
	      }
	      if (fractionalCount) {
	        return this.addSpacer(this.format.radix, this.digits[fractionalCount - 1], 'odometer-radix-mark');
	      }
	    };
	
	    return Odometer;
	
	  })();
	
	  Odometer.options = (_ref = window.odometerOptions) != null ? _ref : {};
	
	  setTimeout(function() {
	    var k, v, _base, _ref1, _results;
	    if (window.odometerOptions) {
	      _ref1 = window.odometerOptions;
	      _results = [];
	      for (k in _ref1) {
	        v = _ref1[k];
	        _results.push((_base = Odometer.options)[k] != null ? (_base = Odometer.options)[k] : _base[k] = v);
	      }
	      return _results;
	    }
	  }, 0);
	
	  Odometer.init = function() {
	    var el, elements, _i, _len, _ref1, _results;
	    if (document.querySelectorAll == null) {
	      return;
	    }
	    elements = document.querySelectorAll(Odometer.options.selector || '.odometer');
	    _results = [];
	    for (_i = 0, _len = elements.length; _i < _len; _i++) {
	      el = elements[_i];
	      _results.push(el.odometer = new Odometer({
	        el: el,
	        value: (_ref1 = el.innerText) != null ? _ref1 : el.textContent
	      }));
	    }
	    return _results;
	  };
	
	  if ((((_ref1 = document.documentElement) != null ? _ref1.doScroll : void 0) != null) && (document.createEventObject != null)) {
	    _old = document.onreadystatechange;
	    document.onreadystatechange = function() {
	      if (document.readyState === 'complete' && Odometer.options.auto !== false) {
	        Odometer.init();
	      }
	      return _old != null ? _old.apply(this, arguments) : void 0;
	    };
	  } else {
	    document.addEventListener('DOMContentLoaded', function() {
	      if (Odometer.options.auto !== false) {
	        return Odometer.init();
	      }
	    }, false);
	  }
	
	  if (typeof define === 'function' && define.amd) {
	    define(['jquery'], function() {
	      return Odometer;
	    });
	  } else if (typeof exports !== "undefined" && exports !== null) {
	    module.exports = Odometer;
	  } else {
	    window.Odometer = Odometer;
	  }
	
	}).call(this);
	


/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./af": 137,
		"./af.js": 137,
		"./ar": 141,
		"./ar-ma": 138,
		"./ar-ma.js": 138,
		"./ar-sa": 139,
		"./ar-sa.js": 139,
		"./ar-tn": 140,
		"./ar-tn.js": 140,
		"./ar.js": 141,
		"./az": 142,
		"./az.js": 142,
		"./be": 143,
		"./be.js": 143,
		"./bg": 144,
		"./bg.js": 144,
		"./bn": 145,
		"./bn.js": 145,
		"./bo": 146,
		"./bo.js": 146,
		"./br": 147,
		"./br.js": 147,
		"./bs": 148,
		"./bs.js": 148,
		"./ca": 149,
		"./ca.js": 149,
		"./cs": 150,
		"./cs.js": 150,
		"./cv": 151,
		"./cv.js": 151,
		"./cy": 152,
		"./cy.js": 152,
		"./da": 153,
		"./da.js": 153,
		"./de": 155,
		"./de-at": 154,
		"./de-at.js": 154,
		"./de.js": 155,
		"./dv": 156,
		"./dv.js": 156,
		"./el": 157,
		"./el.js": 157,
		"./en-au": 158,
		"./en-au.js": 158,
		"./en-ca": 159,
		"./en-ca.js": 159,
		"./en-gb": 160,
		"./en-gb.js": 160,
		"./en-ie": 161,
		"./en-ie.js": 161,
		"./en-nz": 162,
		"./en-nz.js": 162,
		"./eo": 163,
		"./eo.js": 163,
		"./es": 164,
		"./es.js": 164,
		"./et": 165,
		"./et.js": 165,
		"./eu": 166,
		"./eu.js": 166,
		"./fa": 167,
		"./fa.js": 167,
		"./fi": 168,
		"./fi.js": 168,
		"./fo": 169,
		"./fo.js": 169,
		"./fr": 172,
		"./fr-ca": 170,
		"./fr-ca.js": 170,
		"./fr-ch": 171,
		"./fr-ch.js": 171,
		"./fr.js": 172,
		"./fy": 173,
		"./fy.js": 173,
		"./gd": 174,
		"./gd.js": 174,
		"./gl": 175,
		"./gl.js": 175,
		"./he": 176,
		"./he.js": 176,
		"./hi": 177,
		"./hi.js": 177,
		"./hr": 178,
		"./hr.js": 178,
		"./hu": 179,
		"./hu.js": 179,
		"./hy-am": 180,
		"./hy-am.js": 180,
		"./id": 181,
		"./id.js": 181,
		"./is": 182,
		"./is.js": 182,
		"./it": 183,
		"./it.js": 183,
		"./ja": 184,
		"./ja.js": 184,
		"./jv": 185,
		"./jv.js": 185,
		"./ka": 186,
		"./ka.js": 186,
		"./kk": 187,
		"./kk.js": 187,
		"./km": 188,
		"./km.js": 188,
		"./ko": 189,
		"./ko.js": 189,
		"./lb": 190,
		"./lb.js": 190,
		"./lo": 191,
		"./lo.js": 191,
		"./lt": 192,
		"./lt.js": 192,
		"./lv": 193,
		"./lv.js": 193,
		"./me": 194,
		"./me.js": 194,
		"./mk": 195,
		"./mk.js": 195,
		"./ml": 196,
		"./ml.js": 196,
		"./mr": 197,
		"./mr.js": 197,
		"./ms": 199,
		"./ms-my": 198,
		"./ms-my.js": 198,
		"./ms.js": 199,
		"./my": 200,
		"./my.js": 200,
		"./nb": 201,
		"./nb.js": 201,
		"./ne": 202,
		"./ne.js": 202,
		"./nl": 203,
		"./nl.js": 203,
		"./nn": 204,
		"./nn.js": 204,
		"./pl": 205,
		"./pl.js": 205,
		"./pt": 207,
		"./pt-br": 206,
		"./pt-br.js": 206,
		"./pt.js": 207,
		"./ro": 208,
		"./ro.js": 208,
		"./ru": 209,
		"./ru.js": 209,
		"./se": 210,
		"./se.js": 210,
		"./si": 211,
		"./si.js": 211,
		"./sk": 212,
		"./sk.js": 212,
		"./sl": 213,
		"./sl.js": 213,
		"./sq": 214,
		"./sq.js": 214,
		"./sr": 216,
		"./sr-cyrl": 215,
		"./sr-cyrl.js": 215,
		"./sr.js": 216,
		"./sv": 217,
		"./sv.js": 217,
		"./sw": 218,
		"./sw.js": 218,
		"./ta": 219,
		"./ta.js": 219,
		"./te": 220,
		"./te.js": 220,
		"./th": 221,
		"./th.js": 221,
		"./tl-ph": 222,
		"./tl-ph.js": 222,
		"./tlh": 223,
		"./tlh.js": 223,
		"./tr": 224,
		"./tr.js": 224,
		"./tzl": 225,
		"./tzl.js": 225,
		"./tzm": 227,
		"./tzm-latn": 226,
		"./tzm-latn.js": 226,
		"./tzm.js": 227,
		"./uk": 228,
		"./uk.js": 228,
		"./uz": 229,
		"./uz.js": 229,
		"./vi": 230,
		"./vi.js": 230,
		"./zh-cn": 231,
		"./zh-cn.js": 231,
		"./zh-tw": 232,
		"./zh-tw.js": 232
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 330;


/***/ },
/* 331 */
/***/ function(module, exports) {

	module.exports = [{"id":"1","startTime":4944,"endTime":8944,"text":"top"},{"id":"2","startTime":5276,"endTime":9276,"text":"left"},{"id":"3","startTime":6452,"endTime":10452,"text":"top"},{"id":"4","startTime":7008,"endTime":11008,"text":"right"},{"id":"5","startTime":8365,"endTime":12365,"text":"top"},{"id":"6","startTime":8884,"endTime":12884,"text":"left"},{"id":"7","startTime":10260,"endTime":14260,"text":"top"},{"id":"8","startTime":10822,"endTime":14822,"text":"right"},{"id":"9","startTime":12189,"endTime":16189,"text":"top"},{"id":"10","startTime":12717,"endTime":16717,"text":"left"},{"id":"11","startTime":13157,"endTime":17157,"text":"top"},{"id":"12","startTime":13671,"endTime":17671,"text":"left"},{"id":"13","startTime":14236,"endTime":18236,"text":"top"},{"id":"14","startTime":14682,"endTime":18682,"text":"right"},{"id":"15","startTime":15090,"endTime":19090,"text":"top"},{"id":"16","startTime":15564,"endTime":19564,"text":"right"},{"id":"17","startTime":16047,"endTime":20047,"text":"top"},{"id":"18","startTime":16509,"endTime":20509,"text":"left"},{"id":"19","startTime":16910,"endTime":20910,"text":"top"},{"id":"20","startTime":17479,"endTime":21479,"text":"right"},{"id":"21","startTime":18067,"endTime":22067,"text":"top"},{"id":"22","startTime":18437,"endTime":22437,"text":"left"},{"id":"23","startTime":18888,"endTime":22888,"text":"top"},{"id":"24","startTime":19439,"endTime":23439,"text":"right"},{"id":"25","startTime":21913,"endTime":25913,"text":"top"},{"id":"26","startTime":22342,"endTime":26342,"text":"bottom"},{"id":"27","startTime":22794,"endTime":26794,"text":"left"},{"id":"28","startTime":23280,"endTime":27280,"text":"left"},{"id":"29","startTime":23705,"endTime":27705,"text":"top"},{"id":"30","startTime":24180,"endTime":28180,"text":"bottom"},{"id":"31","startTime":24747,"endTime":28747,"text":"right"},{"id":"32","startTime":25162,"endTime":29162,"text":"right"},{"id":"33","startTime":25733,"endTime":29733,"text":"top"},{"id":"34","startTime":26166,"endTime":30166,"text":"top"},{"id":"35","startTime":26576,"endTime":30576,"text":"left"},{"id":"36","startTime":27040,"endTime":31040,"text":"right"},{"id":"37","startTime":27589,"endTime":31589,"text":"bottom"},{"id":"38","startTime":27991,"endTime":31991,"text":"bottom"},{"id":"39","startTime":28552,"endTime":32552,"text":"right"},{"id":"40","startTime":29078,"endTime":33078,"text":"left"},{"id":"41","startTime":30035,"endTime":34035,"text":"top"},{"id":"42","startTime":30551,"endTime":34551,"text":"bottom"},{"id":"43","startTime":31046,"endTime":35046,"text":"left#right"},{"id":"44","startTime":32017,"endTime":36017,"text":"bottom#top"},{"id":"45","startTime":32907,"endTime":36907,"text":"right"},{"id":"46","startTime":33361,"endTime":37361,"text":"left"},{"id":"47","startTime":33870,"endTime":37870,"text":"right"},{"id":"48","startTime":34375,"endTime":38375,"text":"top"},{"id":"49","startTime":34931,"endTime":38931,"text":"top"},{"id":"50","startTime":35831,"endTime":39831,"text":"left"},{"id":"51","startTime":36679,"endTime":40679,"text":"top"}]

/***/ },
/* 332 */
/***/ function(module, exports) {

	module.exports = [{"id":"1","startTime":5097,"endTime":9097,"text":"top"},{"id":"2","startTime":6391,"endTime":10391,"text":"top"},{"id":"3","startTime":7644,"endTime":11644,"text":"top"},{"id":"4","startTime":8739,"endTime":12739,"text":"top"},{"id":"5","startTime":9951,"endTime":13951,"text":"left"},{"id":"6","startTime":11083,"endTime":15083,"text":"left"},{"id":"7","startTime":12282,"endTime":16282,"text":"right"},{"id":"8","startTime":13416,"endTime":17416,"text":"right"},{"id":"9","startTime":14539,"endTime":18539,"text":"top"},{"id":"10","startTime":15066,"endTime":19066,"text":"bottom"},{"id":"11","startTime":15702,"endTime":19702,"text":"left"},{"id":"12","startTime":16305,"endTime":20305,"text":"right"},{"id":"13","startTime":16927,"endTime":20927,"text":"bottom"},{"id":"14","startTime":17523,"endTime":21523,"text":"top"},{"id":"15","startTime":18039,"endTime":22039,"text":"left"},{"id":"16","startTime":18642,"endTime":22642,"text":"right"},{"id":"17","startTime":19322,"endTime":23322,"text":"top"},{"id":"18","startTime":19898,"endTime":23898,"text":"bottom"},{"id":"19","startTime":20458,"endTime":24458,"text":"left"},{"id":"20","startTime":21042,"endTime":25042,"text":"bottom"},{"id":"21","startTime":21630,"endTime":25630,"text":"left"},{"id":"22","startTime":22166,"endTime":26166,"text":"top"},{"id":"23","startTime":22715,"endTime":26715,"text":"left"},{"id":"24","startTime":23376,"endTime":27376,"text":"right"},{"id":"25","startTime":25854,"endTime":29854,"text":"bottom"},{"id":"26","startTime":26352,"endTime":30352,"text":"left"},{"id":"27","startTime":26972,"endTime":30972,"text":"top"},{"id":"28","startTime":27555,"endTime":31555,"text":"left#right"},{"id":"29","startTime":28751,"endTime":32751,"text":"top"},{"id":"30","startTime":29371,"endTime":33371,"text":"left"},{"id":"31","startTime":29957,"endTime":33957,"text":"left#right"},{"id":"32","startTime":31068,"endTime":35068,"text":"top"},{"id":"33","startTime":31326,"endTime":35326,"text":"top"},{"id":"34","startTime":31730,"endTime":35730,"text":"left"},{"id":"35","startTime":32233,"endTime":36233,"text":"top"},{"id":"36","startTime":32794,"endTime":36794,"text":"left"},{"id":"37","startTime":34053,"endTime":38053,"text":"top"},{"id":"38","startTime":34532,"endTime":38532,"text":"bottom"},{"id":"39","startTime":35179,"endTime":39179,"text":"top"},{"id":"40","startTime":35722,"endTime":39722,"text":"left"},{"id":"41","startTime":35940,"endTime":39940,"text":"left"},{"id":"42","startTime":36414,"endTime":40414,"text":"right"},{"id":"43","startTime":36973,"endTime":40973,"text":"left"},{"id":"44","startTime":37156,"endTime":41156,"text":"left"},{"id":"45","startTime":37721,"endTime":41721,"text":"right"},{"id":"46","startTime":38144,"endTime":42144,"text":"top"},{"id":"47","startTime":38458,"endTime":42458,"text":"top"},{"id":"48","startTime":38865,"endTime":42865,"text":"bottom"},{"id":"49","startTime":39350,"endTime":43350,"text":"top"},{"id":"50","startTime":39589,"endTime":43589,"text":"top"},{"id":"51","startTime":40003,"endTime":44003,"text":"bottom"},{"id":"52","startTime":40549,"endTime":44549,"text":"right"},{"id":"53","startTime":41069,"endTime":45069,"text":"left"},{"id":"54","startTime":41676,"endTime":45676,"text":"top"},{"id":"55","startTime":42371,"endTime":46371,"text":"right"},{"id":"56","startTime":44061,"endTime":48061,"text":"top"},{"id":"57","startTime":44590,"endTime":48590,"text":"left"},{"id":"58","startTime":45189,"endTime":49189,"text":"top"},{"id":"59","startTime":45763,"endTime":49763,"text":"left#right"},{"id":"60","startTime":46109,"endTime":50109,"text":"left#right"},{"id":"61","startTime":46948,"endTime":50948,"text":"top"},{"id":"62","startTime":47564,"endTime":51564,"text":"top#bottom"},{"id":"63","startTime":47888,"endTime":51888,"text":"top#bottom"},{"id":"64","startTime":48314,"endTime":52314,"text":"left#right"},{"id":"65","startTime":48903,"endTime":52903,"text":"top#bottom"},{"id":"66","startTime":49368,"endTime":53368,"text":"left#right"},{"id":"67","startTime":49906,"endTime":53906,"text":"top#bottom"},{"id":"68","startTime":50162,"endTime":54162,"text":"top#bottom"},{"id":"69","startTime":50571,"endTime":54571,"text":"left#right"},{"id":"70","startTime":51032,"endTime":55032,"text":"right"},{"id":"71","startTime":51363,"endTime":55363,"text":"right"},{"id":"72","startTime":52305,"endTime":56305,"text":"top"},{"id":"73","startTime":52808,"endTime":56808,"text":"bottom"},{"id":"74","startTime":53324,"endTime":57324,"text":"top"},{"id":"75","startTime":53647,"endTime":57647,"text":"top"},{"id":"76","startTime":54083,"endTime":58083,"text":"bottom"},{"id":"77","startTime":54608,"endTime":58608,"text":"top"},{"id":"78","startTime":55295,"endTime":59295,"text":"left"},{"id":"79","startTime":55694,"endTime":59694,"text":"right"},{"id":"80","startTime":55960,"endTime":59960,"text":"right"},{"id":"81","startTime":56412,"endTime":60412,"text":"left"},{"id":"82","startTime":56901,"endTime":60901,"text":"right"},{"id":"83","startTime":57151,"endTime":61151,"text":"right"},{"id":"84","startTime":57592,"endTime":61592,"text":"left"},{"id":"85","startTime":58075,"endTime":62075,"text":"top"},{"id":"86","startTime":58675,"endTime":62675,"text":"left"},{"id":"87","startTime":59258,"endTime":63258,"text":"top"},{"id":"88","startTime":59811,"endTime":63811,"text":"left"},{"id":"89","startTime":60378,"endTime":64378,"text":"top"},{"id":"90","startTime":61021,"endTime":65021,"text":"left#right"}]

/***/ },
/* 333 */
/***/ function(module, exports) {

	module.exports = [{"id":"1","startTime":5734,"endTime":9734,"text":"top"},{"id":"2","startTime":6635,"endTime":10635,"text":"left"},{"id":"3","startTime":7676,"endTime":11676,"text":"top"},{"id":"4","startTime":8640,"endTime":12640,"text":"right"},{"id":"5","startTime":9585,"endTime":13585,"text":"top"},{"id":"6","startTime":10619,"endTime":14619,"text":"left"},{"id":"7","startTime":11513,"endTime":15513,"text":"top"},{"id":"8","startTime":12545,"endTime":16545,"text":"right"},{"id":"9","startTime":13539,"endTime":17539,"text":"top"},{"id":"10","startTime":14045,"endTime":18045,"text":"left"},{"id":"11","startTime":14928,"endTime":18928,"text":"bottom"},{"id":"12","startTime":15520,"endTime":19520,"text":"top"},{"id":"13","startTime":15989,"endTime":19989,"text":"right"},{"id":"14","startTime":16781,"endTime":20781,"text":"bottom"},{"id":"15","startTime":17464,"endTime":21464,"text":"top"},{"id":"16","startTime":17940,"endTime":21940,"text":"left"},{"id":"17","startTime":18723,"endTime":22723,"text":"bottom"},{"id":"18","startTime":19508,"endTime":23508,"text":"top"},{"id":"19","startTime":19947,"endTime":23947,"text":"right"},{"id":"20","startTime":20667,"endTime":24667,"text":"bottom"},{"id":"21","startTime":21397,"endTime":25397,"text":"top"},{"id":"22","startTime":21876,"endTime":25876,"text":"left"},{"id":"23","startTime":22359,"endTime":26359,"text":"bottom"},{"id":"24","startTime":22953,"endTime":26953,"text":"right"},{"id":"25","startTime":23432,"endTime":27432,"text":"top"},{"id":"26","startTime":23887,"endTime":27887,"text":"left"},{"id":"27","startTime":24255,"endTime":28255,"text":"bottom"},{"id":"28","startTime":24807,"endTime":28807,"text":"right"},{"id":"29","startTime":25336,"endTime":29336,"text":"top"},{"id":"30","startTime":25822,"endTime":29822,"text":"bottom"},{"id":"31","startTime":26334,"endTime":30334,"text":"left"},{"id":"32","startTime":26847,"endTime":30847,"text":"right"},{"id":"33","startTime":27272,"endTime":31272,"text":"top"},{"id":"34","startTime":27724,"endTime":31724,"text":"bottom"},{"id":"35","startTime":28182,"endTime":32182,"text":"left"},{"id":"36","startTime":28599,"endTime":32599,"text":"right"},{"id":"37","startTime":29311,"endTime":33311,"text":"top"},{"id":"38","startTime":29762,"endTime":33762,"text":"bottom"},{"id":"39","startTime":30309,"endTime":34309,"text":"top"},{"id":"40","startTime":30742,"endTime":34742,"text":"bottom"},{"id":"41","startTime":31230,"endTime":35230,"text":"top"},{"id":"42","startTime":31787,"endTime":35787,"text":"left#right"},{"id":"43","startTime":32703,"endTime":36703,"text":"top"},{"id":"44","startTime":33216,"endTime":37216,"text":"bottom"},{"id":"45","startTime":33770,"endTime":37770,"text":"left#right"},{"id":"46","startTime":34683,"endTime":38683,"text":"top"},{"id":"47","startTime":35228,"endTime":39228,"text":"bottom"},{"id":"48","startTime":35636,"endTime":39636,"text":"top"},{"id":"49","startTime":36144,"endTime":40144,"text":"left"},{"id":"50","startTime":36642,"endTime":40642,"text":"top"},{"id":"51","startTime":37601,"endTime":41601,"text":"right"},{"id":"52","startTime":38121,"endTime":42121,"text":"top"},{"id":"53","startTime":38573,"endTime":42573,"text":"right"},{"id":"54","startTime":39081,"endTime":43081,"text":"bottom"},{"id":"55","startTime":39580,"endTime":43580,"text":"right"},{"id":"56","startTime":40686,"endTime":44686,"text":"left#right"},{"id":"57","startTime":41637,"endTime":45637,"text":"top#bottom"},{"id":"58","startTime":42144,"endTime":46144,"text":"top#bottom"},{"id":"59","startTime":42613,"endTime":46613,"text":"left#right"},{"id":"60","startTime":43594,"endTime":47594,"text":"top"},{"id":"61","startTime":44063,"endTime":48063,"text":"bottom"},{"id":"62","startTime":44510,"endTime":48510,"text":"left"},{"id":"63","startTime":44956,"endTime":48956,"text":"top"},{"id":"64","startTime":45483,"endTime":49483,"text":"right"},{"id":"65","startTime":46010,"endTime":50010,"text":"left"},{"id":"66","startTime":46524,"endTime":50524,"text":"right"},{"id":"67","startTime":46975,"endTime":50975,"text":"left"},{"id":"68","startTime":47470,"endTime":51470,"text":"right"},{"id":"69","startTime":47932,"endTime":51932,"text":"top"},{"id":"70","startTime":48486,"endTime":52486,"text":"top"},{"id":"71","startTime":49500,"endTime":53500,"text":"top"},{"id":"72","startTime":49949,"endTime":53949,"text":"bottom"},{"id":"73","startTime":50384,"endTime":54384,"text":"bottom"},{"id":"74","startTime":50984,"endTime":54984,"text":"top"},{"id":"75","startTime":51461,"endTime":55461,"text":"left"},{"id":"76","startTime":51884,"endTime":55884,"text":"bottom"},{"id":"77","startTime":52444,"endTime":56444,"text":"bottom"},{"id":"78","startTime":53405,"endTime":57405,"text":"left"},{"id":"79","startTime":53852,"endTime":57852,"text":"right"},{"id":"80","startTime":54379,"endTime":58379,"text":"left"},{"id":"81","startTime":54907,"endTime":58907,"text":"top"},{"id":"82","startTime":55404,"endTime":59404,"text":"left#right"},{"id":"83","startTime":55919,"endTime":59919,"text":"top#bottom"},{"id":"84","startTime":56410,"endTime":60410,"text":"left#right"},{"id":"85","startTime":57302,"endTime":61302,"text":"top"},{"id":"86","startTime":57851,"endTime":61851,"text":"left"},{"id":"87","startTime":58764,"endTime":62764,"text":"right"},{"id":"88","startTime":59309,"endTime":63309,"text":"top"},{"id":"89","startTime":59840,"endTime":63840,"text":"left#right"},{"id":"90","startTime":60365,"endTime":64365,"text":"left#right"}]

/***/ },
/* 334 */
/***/ function(module, exports) {

	module.exports = [{"id":"1","startTime":3986,"endTime":7986,"text":"top"},{"id":"2","startTime":6149,"endTime":10149,"text":"left"},{"id":"3","startTime":8377,"endTime":12377,"text":"top"},{"id":"4","startTime":10619,"endTime":14619,"text":"right"},{"id":"5","startTime":13073,"endTime":17073,"text":"top"},{"id":"6","startTime":14117,"endTime":18117,"text":"left"},{"id":"7","startTime":15233,"endTime":19233,"text":"top"},{"id":"8","startTime":16454,"endTime":20454,"text":"right"},{"id":"9","startTime":17595,"endTime":21595,"text":"top"},{"id":"10","startTime":18694,"endTime":22694,"text":"left"},{"id":"11","startTime":19869,"endTime":23869,"text":"top"},{"id":"12","startTime":21028,"endTime":25028,"text":"right"},{"id":"13","startTime":22143,"endTime":26143,"text":"bottom"},{"id":"14","startTime":23292,"endTime":27292,"text":"left"},{"id":"15","startTime":24397,"endTime":28397,"text":"bottom"},{"id":"16","startTime":25532,"endTime":29532,"text":"right"},{"id":"17","startTime":26725,"endTime":30725,"text":"bottom"},{"id":"18","startTime":27802,"endTime":31802,"text":"left"},{"id":"19","startTime":28976,"endTime":32976,"text":"bottom"},{"id":"20","startTime":30106,"endTime":34106,"text":"right"},{"id":"21","startTime":31271,"endTime":35271,"text":"top"},{"id":"22","startTime":31821,"endTime":35821,"text":"left"},{"id":"23","startTime":32371,"endTime":36371,"text":"bottom"},{"id":"24","startTime":33040,"endTime":37040,"text":"left"},{"id":"25","startTime":33546,"endTime":37546,"text":"top"},{"id":"26","startTime":34157,"endTime":38157,"text":"right"},{"id":"27","startTime":34643,"endTime":38643,"text":"bottom"},{"id":"28","startTime":35249,"endTime":39249,"text":"right"},{"id":"29","startTime":35909,"endTime":39909,"text":"top"},{"id":"30","startTime":36396,"endTime":40396,"text":"left"},{"id":"31","startTime":36927,"endTime":40927,"text":"bottom"},{"id":"32","startTime":37552,"endTime":41552,"text":"left"},{"id":"33","startTime":38076,"endTime":42076,"text":"top"},{"id":"34","startTime":40352,"endTime":44352,"text":"top"},{"id":"35","startTime":40617,"endTime":44617,"text":"top"},{"id":"36","startTime":41098,"endTime":45098,"text":"left"},{"id":"37","startTime":41502,"endTime":45502,"text":"bottom"},{"id":"38","startTime":41756,"endTime":45756,"text":"bottom"},{"id":"39","startTime":42176,"endTime":46176,"text":"left"},{"id":"40","startTime":42667,"endTime":46667,"text":"top"},{"id":"41","startTime":42980,"endTime":46980,"text":"top"},{"id":"42","startTime":43376,"endTime":47376,"text":"right"},{"id":"43","startTime":43819,"endTime":47819,"text":"bottom"},{"id":"44","startTime":44094,"endTime":48094,"text":"bottom"},{"id":"45","startTime":44481,"endTime":48481,"text":"right"},{"id":"46","startTime":44960,"endTime":48960,"text":"top"},{"id":"47","startTime":45207,"endTime":49207,"text":"top"},{"id":"48","startTime":45609,"endTime":49609,"text":"left"},{"id":"49","startTime":46051,"endTime":50051,"text":"bottom"},{"id":"50","startTime":46288,"endTime":50288,"text":"bottom"},{"id":"51","startTime":46739,"endTime":50739,"text":"left"},{"id":"52","startTime":47170,"endTime":51170,"text":"top"},{"id":"53","startTime":47404,"endTime":51404,"text":"top"},{"id":"54","startTime":47861,"endTime":51861,"text":"right"},{"id":"55","startTime":48341,"endTime":52341,"text":"bottom"},{"id":"56","startTime":48579,"endTime":52579,"text":"bottom"},{"id":"57","startTime":48989,"endTime":52989,"text":"right"},{"id":"58","startTime":49546,"endTime":53546,"text":"top"},{"id":"59","startTime":50082,"endTime":54082,"text":"bottom"},{"id":"60","startTime":50551,"endTime":54551,"text":"left"},{"id":"61","startTime":50860,"endTime":54860,"text":"top"},{"id":"62","startTime":51295,"endTime":55295,"text":"left"},{"id":"63","startTime":51872,"endTime":55872,"text":"top"},{"id":"64","startTime":52410,"endTime":56410,"text":"bottom"},{"id":"65","startTime":52903,"endTime":56903,"text":"top"},{"id":"66","startTime":53228,"endTime":57228,"text":"left"},{"id":"67","startTime":53691,"endTime":57691,"text":"top"},{"id":"68","startTime":54201,"endTime":58201,"text":"left#right"},{"id":"69","startTime":54705,"endTime":58705,"text":"top#bottom"},{"id":"70","startTime":55370,"endTime":59370,"text":"left#right"},{"id":"71","startTime":55860,"endTime":59860,"text":"top#bottom"},{"id":"72","startTime":56492,"endTime":60492,"text":"left#right"},{"id":"73","startTime":57419,"endTime":61419,"text":"top"},{"id":"74","startTime":57707,"endTime":61707,"text":"top"},{"id":"75","startTime":58178,"endTime":62178,"text":"bottom"},{"id":"76","startTime":58704,"endTime":62704,"text":"top"},{"id":"77","startTime":59250,"endTime":63250,"text":"left"},{"id":"78","startTime":59843,"endTime":63843,"text":"top"},{"id":"79","startTime":60550,"endTime":64550,"text":"top#bottom"},{"id":"80","startTime":61012,"endTime":65012,"text":"left#right"},{"id":"81","startTime":61327,"endTime":65327,"text":"left#right"},{"id":"82","startTime":61689,"endTime":65689,"text":"top#bottom"},{"id":"83","startTime":62338,"endTime":66338,"text":"left#right"},{"id":"84","startTime":62857,"endTime":66857,"text":"top#bottom"},{"id":"85","startTime":63882,"endTime":67882,"text":"left"},{"id":"86","startTime":65031,"endTime":69031,"text":"top"},{"id":"87","startTime":65575,"endTime":69575,"text":"bottom"},{"id":"88","startTime":66179,"endTime":70179,"text":"left"},{"id":"89","startTime":66776,"endTime":70776,"text":"left#right"},{"id":"90","startTime":67368,"endTime":71368,"text":"top#bottom"}]

/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(255);


/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	var InlineSVGError, PropTypes, React, Status, configurationError, createError, delay, getHash, http, httpplease, ieXDomain, isSupportedEnvironment, me, once, span, supportsInlineSVG, uniquifyIDs, unsupportedBrowserError,
	  __slice = [].slice,
	  __hasProp = {}.hasOwnProperty,
	  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	React = __webpack_require__(5);
	
	once = __webpack_require__(345);
	
	httpplease = __webpack_require__(338);
	
	ieXDomain = __webpack_require__(343);
	
	PropTypes = React.PropTypes;
	
	span = React.DOM.span;
	
	http = httpplease.use(ieXDomain);
	
	Status = {
	  PENDING: 'pending',
	  LOADING: 'loading',
	  LOADED: 'loaded',
	  FAILED: 'failed',
	  UNSUPPORTED: 'unsupported'
	};
	
	supportsInlineSVG = once(function() {
	  var div;
	  if (!document) {
	    return false;
	  }
	  div = document.createElement('div');
	  div.innerHTML = '<svg />';
	  return div.firstChild && div.firstChild.namespaceURI === 'http://www.w3.org/2000/svg';
	});
	
	delay = function(fn) {
	  return function() {
	    var args, newFunc;
	    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	    newFunc = function() {
	      return fn.apply(null, args);
	    };
	    setTimeout(newFunc, 0);
	  };
	};
	
	isSupportedEnvironment = once(function() {
	  return ((typeof window !== "undefined" && window !== null ? window.XMLHttpRequest : void 0) || (typeof window !== "undefined" && window !== null ? window.XDomainRequest : void 0)) && supportsInlineSVG();
	});
	
	uniquifyIDs = (function() {
	  var idPattern, mkAttributePattern;
	  mkAttributePattern = function(attr) {
	    return "(?:(?:\\s|\\:)" + attr + ")";
	  };
	  idPattern = RegExp("(?:(" + (mkAttributePattern('id')) + ")=\"([^\"]+)\")|(?:(" + (mkAttributePattern('href')) + "|" + (mkAttributePattern('role')) + "|" + (mkAttributePattern('arcrole')) + ")=\"\\#([^\"]+)\")|(?:=\"url\\(\\#([^\\)]+)\\)\")", "g");
	  return function(svgText, svgID) {
	    var uniquifyID;
	    uniquifyID = function(id) {
	      return "" + id + "___" + svgID;
	    };
	    return svgText.replace(idPattern, function(m, p1, p2, p3, p4, p5) {
	      if (p2) {
	        return "" + p1 + "=\"" + (uniquifyID(p2)) + "\"";
	      } else if (p4) {
	        return "" + p3 + "=\"#" + (uniquifyID(p4)) + "\"";
	      } else if (p5) {
	        return "=\"url(#" + (uniquifyID(p5)) + ")\"";
	      }
	    });
	  };
	})();
	
	getHash = function(str) {
	  var chr, hash, i, _i, _ref;
	  hash = 0;
	  if (!str) {
	    return hash;
	  }
	  for (i = _i = 0, _ref = str.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	    chr = str.charCodeAt(i);
	    hash = (hash << 5) - hash + chr;
	    hash = hash & hash;
	  }
	  return hash;
	};
	
	InlineSVGError = (function(_super) {
	  __extends(InlineSVGError, _super);
	
	  InlineSVGError.prototype.name = 'InlineSVGError';
	
	  InlineSVGError.prototype.isSupportedBrowser = true;
	
	  InlineSVGError.prototype.isConfigurationError = false;
	
	  InlineSVGError.prototype.isUnsupportedBrowserError = false;
	
	  function InlineSVGError(message) {
	    this.message = message;
	  }
	
	  return InlineSVGError;
	
	})(Error);
	
	createError = function(message, attrs) {
	  var err, k, v;
	  err = new InlineSVGError(message);
	  for (k in attrs) {
	    if (!__hasProp.call(attrs, k)) continue;
	    v = attrs[k];
	    err[k] = v;
	  }
	  return err;
	};
	
	unsupportedBrowserError = function(message) {
	  if (message == null) {
	    message = 'Unsupported Browser';
	  }
	  return createError(message, {
	    isSupportedBrowser: false,
	    isUnsupportedBrowserError: true
	  });
	};
	
	configurationError = function(message) {
	  return createError(message, {
	    isConfigurationError: true
	  });
	};
	
	module.exports = me = React.createClass({
	  statics: {
	    Status: Status
	  },
	  displayName: 'InlineSVG',
	  propTypes: {
	    wrapper: PropTypes.func,
	    src: PropTypes.string.isRequired,
	    className: PropTypes.string,
	    preloader: PropTypes.func,
	    onLoad: PropTypes.func,
	    onError: PropTypes.func,
	    supportTest: PropTypes.func,
	    uniquifyIDs: PropTypes.bool
	  },
	  getDefaultProps: function() {
	    return {
	      wrapper: span,
	      supportTest: isSupportedEnvironment,
	      uniquifyIDs: true
	    };
	  },
	  getInitialState: function() {
	    return {
	      status: Status.PENDING
	    };
	  },
	  componentDidMount: function() {
	    if (this.state.status !== Status.PENDING) {
	      return;
	    }
	    if (this.props.supportTest()) {
	      if (this.props.src) {
	        return this.setState({
	          status: Status.LOADING
	        }, this.load);
	      } else {
	        return delay((function(_this) {
	          return function() {
	            return _this.fail(configurationError('Missing source'));
	          };
	        })(this))();
	      }
	    } else {
	      return delay((function(_this) {
	        return function() {
	          return _this.fail(unsupportedBrowserError());
	        };
	      })(this))();
	    }
	  },
	  fail: function(error) {
	    var status;
	    status = error.isUnsupportedBrowserError ? Status.UNSUPPORTED : Status.FAILED;
	    return this.setState({
	      status: status
	    }, (function(_this) {
	      return function() {
	        var _base;
	        return typeof (_base = _this.props).onError === "function" ? _base.onError(error) : void 0;
	      };
	    })(this));
	  },
	  handleLoad: function(err, res) {
	    if (err) {
	      return this.fail(err);
	    }
	    if (!this.isMounted()) {
	      return;
	    }
	    return this.setState({
	      loadedText: res.text,
	      status: Status.LOADED
	    }, (function(_this) {
	      return function() {
	        var _base;
	        return typeof (_base = _this.props).onLoad === "function" ? _base.onLoad() : void 0;
	      };
	    })(this));
	  },
	  load: function() {
	    var m, text;
	    if (m = this.props.src.match(/data:image\/svg[^,]*?(;base64)?,(.*)/)) {
	      text = m[1] ? atob(m[2]) : decodeURIComponent(m[2]);
	      return this.handleLoad(null, {
	        text: text
	      });
	    } else {
	      return http.get(this.props.src, this.handleLoad);
	    }
	  },
	  getClassName: function() {
	    var className;
	    className = "isvg " + this.state.status;
	    if (this.props.className) {
	      className += " " + this.props.className;
	    }
	    return className;
	  },
	  render: function() {
	    return this.props.wrapper({
	      className: this.getClassName(),
	      dangerouslySetInnerHTML: this.state.loadedText ? {
	        __html: this.processSVG(this.state.loadedText)
	      } : void 0
	    }, this.renderContents());
	  },
	  processSVG: function(svgText) {
	    if (this.props.uniquifyIDs) {
	      return uniquifyIDs(svgText, getHash(this.props.src));
	    } else {
	      return svgText;
	    }
	  },
	  renderContents: function() {
	    switch (this.state.status) {
	      case Status.UNSUPPORTED:
	        return this.props.children;
	      case Status.PENDING:
	      case Status.LOADING:
	        if (this.props.preloader) {
	          return new this.props.preloader;
	        }
	    }
	  }
	});


/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Response = __webpack_require__(234);
	var extractResponseProps = __webpack_require__(235);
	var extend = __webpack_require__(97);
	
	function RequestError(message, props) {
	  var err = new Error(message);
	  err.name = 'RequestError';
	  this.name = err.name;
	  this.message = err.message;
	  if (err.stack) {
	    this.stack = err.stack;
	  }
	
	  this.toString = function() {
	    return this.message;
	  };
	
	  for (var k in props) {
	    if (props.hasOwnProperty(k)) {
	      this[k] = props[k];
	    }
	  }
	}
	
	RequestError.prototype = extend(Error.prototype);
	RequestError.prototype.constructor = RequestError;
	
	RequestError.create = function(message, req, props) {
	  var err = new RequestError(message, props);
	  Response.call(err, extractResponseProps(req));
	  return err;
	};
	
	module.exports = RequestError;


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var
	  cleanURL = __webpack_require__(342),
	  XHR = __webpack_require__(340),
	  delay = __webpack_require__(339),
	  RequestError = __webpack_require__(337),
	  Response = __webpack_require__(234),
	  Request = __webpack_require__(233),
	  extend = __webpack_require__(97),
	  once = __webpack_require__(236);
	
	var i,
	    createError = RequestError.create;
	
	function factory(defaults, plugins) {
	  defaults = defaults || {};
	  plugins = plugins || [];
	
	  function http(req, cb) {
	    var xhr, plugin, done, k, timeoutId, supportsLoadAndErrorEvents;
	
	    req = new Request(extend(defaults, req));
	
	    for (i = 0; i < plugins.length; i++) {
	      plugin = plugins[i];
	      if (plugin.processRequest) {
	        plugin.processRequest(req);
	      }
	    }
	
	    // Give the plugins a chance to create the XHR object
	    for (i = 0; i < plugins.length; i++) {
	      plugin = plugins[i];
	      if (plugin.createXHR) {
	        xhr = plugin.createXHR(req);
	        break; // First come, first serve
	      }
	    }
	    xhr = xhr || new XHR();
	
	    req.xhr = xhr;
	
	    // Use a single completion callback. This can be called with or without
	    // an error. If no error is passed, the request will be examined to see
	    // if it was successful.
	    done = once(delay(function(rawError) {
	      clearTimeout(timeoutId);
	      xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = xhr.ontimeout = xhr.onprogress = null;
	
	      var err = getError(req, rawError);
	
	      var res = err || Response.fromRequest(req);
	      for (i = 0; i < plugins.length; i++) {
	        plugin = plugins[i];
	        if (plugin.processResponse) {
	          plugin.processResponse(res);
	        }
	      }
	
	      // Invoke callbacks
	      if (err && req.onerror) req.onerror(err);
	      if (!err && req.onload) req.onload(res);
	      if (cb) cb(err, err ? undefined : res);
	
	    }));
	
	    supportsLoadAndErrorEvents = ('onload' in xhr) && ('onerror' in xhr);
	    xhr.onload = function() { done(); };
	    xhr.onerror = done;
	    xhr.onabort = function() { done(); };
	
	    // We'd rather use `onload`, `onerror`, and `onabort` since they're the
	    // only way to reliably detect successes and failures but, if they
	    // aren't available, we fall back to using `onreadystatechange`.
	    xhr.onreadystatechange = function() {
	      if (xhr.readyState !== 4) return;
	
	      if (req.aborted) return done();
	
	      if (!supportsLoadAndErrorEvents) {
	        // Assume a status of 0 is an error. This could be a false
	        // positive, but there's no way to tell when using
	        // `onreadystatechange` ):
	        // See matthewwithanm/react-inlinesvg#10.
	
	        // Some browsers don't like you reading XHR properties when the
	        // XHR has been aborted. In case we've gotten here as a result
	        // of that (either our calling `about()` in the timeout handler
	        // or the user calling it directly even though they shouldn't),
	        // be careful about accessing it.
	        var status;
	        try {
	          status = xhr.status;
	        } catch (err) {}
	        var err = status === 0 ? new Error('Internal XHR Error') : null;
	        return done(err);
	      }
	    };
	
	    // IE sometimes fails if you don't specify every handler.
	    // See http://social.msdn.microsoft.com/Forums/ie/en-US/30ef3add-767c-4436-b8a9-f1ca19b4812e/ie9-rtm-xdomainrequest-issued-requests-may-abort-if-all-event-handlers-not-specified?forum=iewebdevelopment
	    xhr.ontimeout = function() { /* noop */ };
	    xhr.onprogress = function() { /* noop */ };
	
	    xhr.open(req.method, req.url);
	
	    if (req.timeout) {
	      // If we use the normal XHR timeout mechanism (`xhr.timeout` and
	      // `xhr.ontimeout`), `onreadystatechange` will be triggered before
	      // `ontimeout`. There's no way to recognize that it was triggered by
	      // a timeout, and we'd be unable to dispatch the right error.
	      timeoutId = setTimeout(function() {
	        req.timedOut = true;
	        done();
	        try {
	          xhr.abort();
	        } catch (err) {}
	      }, req.timeout);
	    }
	
	    for (k in req.headers) {
	      if (req.headers.hasOwnProperty(k)) {
	        xhr.setRequestHeader(k, req.headers[k]);
	      }
	    }
	
	    xhr.send(req.body);
	
	    return req;
	  }
	
	  var method,
	    methods = ['get', 'post', 'put', 'head', 'patch', 'delete'],
	    verb = function(method) {
	      return function(req, cb) {
	        req = new Request(req);
	        req.method = method;
	        return http(req, cb);
	      };
	    };
	  for (i = 0; i < methods.length; i++) {
	    method = methods[i];
	    http[method] = verb(method);
	  }
	
	  http.plugins = function() {
	    return plugins;
	  };
	
	  http.defaults = function(newValues) {
	    if (newValues) {
	      return factory(extend(defaults, newValues), plugins);
	    }
	    return defaults;
	  };
	
	  http.use = function() {
	    var newPlugins = Array.prototype.slice.call(arguments, 0);
	    return factory(defaults, plugins.concat(newPlugins));
	  };
	
	  http.bare = function() {
	    return factory();
	  };
	
	  http.Request = Request;
	  http.Response = Response;
	  http.RequestError = RequestError;
	
	  return http;
	}
	
	module.exports = factory({}, [cleanURL]);
	
	/**
	 * Analyze the request to see if it represents an error. If so, return it! An
	 * original error object can be passed as a hint.
	 */
	function getError(req, err) {
	  if (req.aborted) return createError('Request aborted', req, {name: 'Abort'});
	
	  if (req.timedOut) return createError('Request timeout', req, {name: 'Timeout'});
	
	  var xhr = req.xhr;
	  var type = Math.floor(xhr.status / 100);
	
	  var kind;
	  switch (type) {
	    case 0:
	    case 2:
	      // These don't represent errors unless the function was passed an
	      // error object explicitly.
	      if (!err) return;
	      return createError(err.message, req);
	    case 4:
	      // Sometimes 4XX statuses aren't errors.
	      if (xhr.status === 404 && !req.errorOn404) return;
	      kind = 'Client';
	      break;
	    case 5:
	      kind = 'Server';
	      break;
	    default:
	      kind = 'HTTP';
	  }
	  var msg = kind + ' Error: ' +
	        'The server returned a status of ' + xhr.status +
	        ' for the request "' +
	        req.method.toUpperCase() + ' ' + req.url + '"';
	  return createError(msg, req);
	}


/***/ },
/* 339 */
/***/ function(module, exports) {

	'use strict';
	
	// Wrap a function in a `setTimeout` call. This is used to guarantee async
	// behavior, which can avoid unexpected errors.
	
	module.exports = function(fn) {
	  return function() {
	    var
	      args = Array.prototype.slice.call(arguments, 0),
	      newFunc = function() {
	        return fn.apply(null, args);
	      };
	    setTimeout(newFunc, 0);
	  };
	};


/***/ },
/* 340 */
/***/ function(module, exports) {

	module.exports = window.XMLHttpRequest;


/***/ },
/* 341 */
/***/ function(module, exports) {

	(function() {
	  var URL, URL_PATTERN, defaults, urllite,
	    __hasProp = {}.hasOwnProperty;
	
	  URL_PATTERN = /^(?:(?:([^:\/?\#]+:)\/+|(\/\/))(?:([a-z0-9-\._~%]+)(?::([a-z0-9-\._~%]+))?@)?(([a-z0-9-\._~%!$&'()*+,;=]+)(?::([0-9]+))?)?)?([^?\#]*?)(\?[^\#]*)?(\#.*)?$/;
	
	  urllite = function(raw, opts) {
	    return urllite.URL.parse(raw, opts);
	  };
	
	  urllite.URL = URL = (function() {
	    function URL(props) {
	      var k, v, _ref;
	      for (k in defaults) {
	        if (!__hasProp.call(defaults, k)) continue;
	        v = defaults[k];
	        this[k] = (_ref = props[k]) != null ? _ref : v;
	      }
	      this.host || (this.host = this.hostname && this.port ? "" + this.hostname + ":" + this.port : this.hostname ? this.hostname : '');
	      this.origin || (this.origin = this.protocol ? "" + this.protocol + "//" + this.host : '');
	      this.isAbsolutePathRelative = !this.host && this.pathname.charAt(0) === '/';
	      this.isPathRelative = !this.host && this.pathname.charAt(0) !== '/';
	      this.isRelative = this.isSchemeRelative || this.isAbsolutePathRelative || this.isPathRelative;
	      this.isAbsolute = !this.isRelative;
	    }
	
	    URL.parse = function(raw) {
	      var m, pathname, protocol;
	      m = raw.toString().match(URL_PATTERN);
	      pathname = m[8] || '';
	      protocol = m[1];
	      return new urllite.URL({
	        protocol: protocol,
	        username: m[3],
	        password: m[4],
	        hostname: m[6],
	        port: m[7],
	        pathname: protocol && pathname.charAt(0) !== '/' ? "/" + pathname : pathname,
	        search: m[9],
	        hash: m[10],
	        isSchemeRelative: m[2] != null
	      });
	    };
	
	    return URL;
	
	  })();
	
	  defaults = {
	    protocol: '',
	    username: '',
	    password: '',
	    host: '',
	    hostname: '',
	    port: '',
	    pathname: '',
	    search: '',
	    hash: '',
	    origin: '',
	    isSchemeRelative: false
	  };
	
	  module.exports = urllite;
	
	}).call(this);


/***/ },
/* 342 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	  processRequest: function(req) {
	    req.url = req.url.replace(/[^%]+/g, function(s) {
	      return encodeURI(s);
	    });
	  }
	};


/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var
	  urllite = __webpack_require__(341),
	  once = __webpack_require__(236);
	
	var warningShown = false;
	
	var supportsXHR = once(function() {
	  return (
	    typeof window !== 'undefined' &&
	    window !== null &&
	    window.XMLHttpRequest &&
	    'withCredentials' in new window.XMLHttpRequest()
	  );
	});
	
	// This plugin creates a Microsoft `XDomainRequest` in supporting browsers when
	// the URL being requested is on a different domain. This is necessary to
	// support IE9, which only supports CORS via its proprietary `XDomainRequest`
	// object. We need to check the URL because `XDomainRequest` *doesn't* work for
	// same domain requests (unless your server sends CORS headers).
	// `XDomainRequest` also has other limitations (no custom headers), so we try to
	// catch those and error.
	module.exports = {
	  createXHR: function(req) {
	    var a, b, k;
	
	    if (typeof window === 'undefined' || window === null) {
	      return;
	    }
	
	    a = urllite(req.url);
	    b = urllite(window.location.href);
	
	    // Don't do anything for same-domain requests.
	    if (!a.host) {
	      return;
	    }
	    if (a.protocol === b.protocol && a.host === b.host && a.port === b.port) {
	      return;
	    }
	
	    // Show a warning if there are custom headers. We do this even in
	    // browsers that won't use XDomainRequest so that users know there's an
	    // issue right away, instead of if/when they test in IE9.
	    if (!warningShown && req.headers) {
	      for (k in req.headers) {
	        if (req.headers.hasOwnProperty(k)) {
	          warningShown = true;
	          if (window && window.console && window.console.warn) {
	            window.console.warn('Request headers are ignored in old IE when using the oldiexdomain plugin.');
	          }
	          break;
	        }
	      }
	    }
	
	    // Don't do anything if we can't do anything (:
	    // Don't do anything if the browser supports proper XHR.
	    if (window.XDomainRequest && !supportsXHR()) {
	      // We've come this far. Might as well make an XDomainRequest.
	      var xdr = new window.XDomainRequest();
	      xdr.setRequestHeader = function() {}; // Ignore request headers.
	      return xdr;
	    }
	  }
	};


/***/ },
/* 344 */
/***/ function(module, exports) {

	// Returns a wrapper function that returns a wrapped callback
	// The wrapper function should do some stuff, and return a
	// presumably different callback function.
	// This makes sure that own properties are retained, so that
	// decorations and such are not lost along the way.
	module.exports = wrappy
	function wrappy (fn, cb) {
	  if (fn && cb) return wrappy(fn)(cb)
	
	  if (typeof fn !== 'function')
	    throw new TypeError('need wrapper function')
	
	  Object.keys(fn).forEach(function (k) {
	    wrapper[k] = fn[k]
	  })
	
	  return wrapper
	
	  function wrapper() {
	    var args = new Array(arguments.length)
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i]
	    }
	    var ret = fn.apply(this, args)
	    var cb = args[args.length-1]
	    if (typeof ret === 'function' && ret !== cb) {
	      Object.keys(cb).forEach(function (k) {
	        ret[k] = cb[k]
	      })
	    }
	    return ret
	  }
	}


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	var wrappy = __webpack_require__(344)
	module.exports = wrappy(once)
	
	once.proto = once(function () {
	  Object.defineProperty(Function.prototype, 'once', {
	    value: function () {
	      return once(this)
	    },
	    configurable: true
	  })
	})
	
	function once (fn) {
	  var f = function () {
	    if (f.called) return f.value
	    f.called = true
	    return f.value = fn.apply(this, arguments)
	  }
	  f.called = false
	  return f
	}


/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _require = __webpack_require__(5);
	
	var Component = _require.Component;
	var PropTypes = _require.PropTypes;
	var Children = _require.Children;
	
	var storeShape = __webpack_require__(237);
	
	var didWarnAboutReceivingStore = false;
	function warnAboutReceivingStore() {
	  if (didWarnAboutReceivingStore) {
	    return;
	  }
	
	  didWarnAboutReceivingStore = true;
	  console.error( // eslint-disable-line no-console
	  '<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/rackt/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
	}
	
	var Provider = (function (_Component) {
	  _inherits(Provider, _Component);
	
	  Provider.prototype.getChildContext = function getChildContext() {
	    return { store: this.store };
	  };
	
	  function Provider(props, context) {
	    _classCallCheck(this, Provider);
	
	    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
	
	    _this.store = props.store;
	    return _this;
	  }
	
	  Provider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    var store = this.store;
	    var nextStore = nextProps.store;
	
	    if (store !== nextStore) {
	      warnAboutReceivingStore();
	    }
	  };
	
	  Provider.prototype.render = function render() {
	    var children = this.props.children;
	
	    return Children.only(children);
	  };
	
	  return Provider;
	})(Component);
	
	Provider.propTypes = {
	  store: storeShape.isRequired,
	  children: PropTypes.element.isRequired
	};
	Provider.childContextTypes = {
	  store: storeShape.isRequired
	};
	
	module.exports = Provider;

/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _require = __webpack_require__(5);
	
	var Component = _require.Component;
	var createElement = _require.createElement;
	
	var storeShape = __webpack_require__(237);
	var shallowEqual = __webpack_require__(349);
	var isPlainObject = __webpack_require__(348);
	var wrapActionCreators = __webpack_require__(350);
	var hoistStatics = __webpack_require__(351);
	var invariant = __webpack_require__(352);
	
	var defaultMapStateToProps = function defaultMapStateToProps(state) {
	  return {};
	}; // eslint-disable-line no-unused-vars
	var defaultMapDispatchToProps = function defaultMapDispatchToProps(dispatch) {
	  return { dispatch: dispatch };
	};
	var defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, parentProps) {
	  return _extends({}, parentProps, stateProps, dispatchProps);
	};
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	// Helps track hot reloading.
	var nextVersion = 0;
	
	function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
	  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
	
	  var shouldSubscribe = Boolean(mapStateToProps);
	  var finalMapStateToProps = mapStateToProps || defaultMapStateToProps;
	  var finalMapDispatchToProps = isPlainObject(mapDispatchToProps) ? wrapActionCreators(mapDispatchToProps) : mapDispatchToProps || defaultMapDispatchToProps;
	  var finalMergeProps = mergeProps || defaultMergeProps;
	  var doStatePropsDependOnOwnProps = finalMapStateToProps.length !== 1;
	  var doDispatchPropsDependOnOwnProps = finalMapDispatchToProps.length !== 1;
	  var _options$pure = options.pure;
	  var pure = _options$pure === undefined ? true : _options$pure;
	  var _options$withRef = options.withRef;
	  var withRef = _options$withRef === undefined ? false : _options$withRef;
	
	  // Helps track hot reloading.
	
	  var version = nextVersion++;
	
	  function computeStateProps(store, props) {
	    var state = store.getState();
	    var stateProps = doStatePropsDependOnOwnProps ? finalMapStateToProps(state, props) : finalMapStateToProps(state);
	
	    invariant(isPlainObject(stateProps), '`mapStateToProps` must return an object. Instead received %s.', stateProps);
	    return stateProps;
	  }
	
	  function computeDispatchProps(store, props) {
	    var dispatch = store.dispatch;
	
	    var dispatchProps = doDispatchPropsDependOnOwnProps ? finalMapDispatchToProps(dispatch, props) : finalMapDispatchToProps(dispatch);
	
	    invariant(isPlainObject(dispatchProps), '`mapDispatchToProps` must return an object. Instead received %s.', dispatchProps);
	    return dispatchProps;
	  }
	
	  function computeMergedProps(stateProps, dispatchProps, parentProps) {
	    var mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps);
	    invariant(isPlainObject(mergedProps), '`mergeProps` must return an object. Instead received %s.', mergedProps);
	    return mergedProps;
	  }
	
	  return function wrapWithConnect(WrappedComponent) {
	    var Connect = (function (_Component) {
	      _inherits(Connect, _Component);
	
	      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
	        return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged;
	      };
	
	      function Connect(props, context) {
	        _classCallCheck(this, Connect);
	
	        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
	
	        _this.version = version;
	        _this.store = props.store || context.store;
	
	        invariant(_this.store, 'Could not find "store" in either the context or ' + ('props of "' + _this.constructor.displayName + '". ') + 'Either wrap the root component in a <Provider>, ' + ('or explicitly pass "store" as a prop to "' + _this.constructor.displayName + '".'));
	
	        var storeState = _this.store.getState();
	        _this.state = { storeState: storeState };
	        _this.clearCache();
	        return _this;
	      }
	
	      Connect.prototype.updateStatePropsIfNeeded = function updateStatePropsIfNeeded() {
	        var nextStateProps = computeStateProps(this.store, this.props);
	        if (this.stateProps && shallowEqual(nextStateProps, this.stateProps)) {
	          return false;
	        }
	
	        this.stateProps = nextStateProps;
	        return true;
	      };
	
	      Connect.prototype.updateDispatchPropsIfNeeded = function updateDispatchPropsIfNeeded() {
	        var nextDispatchProps = computeDispatchProps(this.store, this.props);
	        if (this.dispatchProps && shallowEqual(nextDispatchProps, this.dispatchProps)) {
	          return false;
	        }
	
	        this.dispatchProps = nextDispatchProps;
	        return true;
	      };
	
	      Connect.prototype.updateMergedProps = function updateMergedProps() {
	        this.mergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props);
	      };
	
	      Connect.prototype.isSubscribed = function isSubscribed() {
	        return typeof this.unsubscribe === 'function';
	      };
	
	      Connect.prototype.trySubscribe = function trySubscribe() {
	        if (shouldSubscribe && !this.unsubscribe) {
	          this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));
	          this.handleChange();
	        }
	      };
	
	      Connect.prototype.tryUnsubscribe = function tryUnsubscribe() {
	        if (this.unsubscribe) {
	          this.unsubscribe();
	          this.unsubscribe = null;
	        }
	      };
	
	      Connect.prototype.componentDidMount = function componentDidMount() {
	        this.trySubscribe();
	      };
	
	      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        if (!pure || !shallowEqual(nextProps, this.props)) {
	          this.haveOwnPropsChanged = true;
	        }
	      };
	
	      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
	        this.tryUnsubscribe();
	        this.clearCache();
	      };
	
	      Connect.prototype.clearCache = function clearCache() {
	        this.dispatchProps = null;
	        this.stateProps = null;
	        this.mergedProps = null;
	        this.haveOwnPropsChanged = true;
	        this.hasStoreStateChanged = true;
	        this.renderedElement = null;
	      };
	
	      Connect.prototype.handleChange = function handleChange() {
	        if (!this.unsubscribe) {
	          return;
	        }
	
	        var prevStoreState = this.state.storeState;
	        var storeState = this.store.getState();
	
	        if (!pure || prevStoreState !== storeState) {
	          this.hasStoreStateChanged = true;
	          this.setState({ storeState: storeState });
	        }
	      };
	
	      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
	        invariant(withRef, 'To access the wrapped instance, you need to specify ' + '{ withRef: true } as the fourth argument of the connect() call.');
	
	        return this.refs.wrappedInstance;
	      };
	
	      Connect.prototype.render = function render() {
	        var haveOwnPropsChanged = this.haveOwnPropsChanged;
	        var hasStoreStateChanged = this.hasStoreStateChanged;
	        var renderedElement = this.renderedElement;
	
	        this.haveOwnPropsChanged = false;
	        this.hasStoreStateChanged = false;
	
	        var shouldUpdateStateProps = true;
	        var shouldUpdateDispatchProps = true;
	        if (pure && renderedElement) {
	          shouldUpdateStateProps = hasStoreStateChanged || haveOwnPropsChanged && doStatePropsDependOnOwnProps;
	          shouldUpdateDispatchProps = haveOwnPropsChanged && doDispatchPropsDependOnOwnProps;
	        }
	
	        var haveStatePropsChanged = false;
	        var haveDispatchPropsChanged = false;
	        if (shouldUpdateStateProps) {
	          haveStatePropsChanged = this.updateStatePropsIfNeeded();
	        }
	        if (shouldUpdateDispatchProps) {
	          haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded();
	        }
	
	        var haveMergedPropsChanged = true;
	        if (haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged) {
	          this.updateMergedProps();
	        } else {
	          haveMergedPropsChanged = false;
	        }
	
	        if (!haveMergedPropsChanged && renderedElement) {
	          return renderedElement;
	        }
	
	        if (withRef) {
	          this.renderedElement = createElement(WrappedComponent, _extends({}, this.mergedProps, {
	            ref: 'wrappedInstance'
	          }));
	        } else {
	          this.renderedElement = createElement(WrappedComponent, this.mergedProps);
	        }
	
	        return this.renderedElement;
	      };
	
	      return Connect;
	    })(Component);
	
	    Connect.displayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';
	    Connect.WrappedComponent = WrappedComponent;
	    Connect.contextTypes = {
	      store: storeShape
	    };
	    Connect.propTypes = {
	      store: storeShape
	    };
	
	    if (false) {
	      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
	        if (this.version === version) {
	          return;
	        }
	
	        // We are hot reloading!
	        this.version = version;
	        this.trySubscribe();
	        this.clearCache();
	      };
	    }
	
	    return hoistStatics(Connect, WrappedComponent);
	  };
	}
	
	module.exports = connect;

/***/ },
/* 348 */
/***/ function(module, exports) {

	'use strict';
	
	function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }
	
	var fnToString = function fnToString(fn) {
	  return Function.prototype.toString.call(fn);
	};
	
	/**
	 * @param {any} obj The object to inspect.
	 * @returns {boolean} True if the argument appears to be a plain object.
	 */
	function isPlainObject(obj) {
	  if (!obj || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
	    return false;
	  }
	
	  var proto = typeof obj.constructor === 'function' ? Object.getPrototypeOf(obj) : Object.prototype;
	
	  if (proto === null) {
	    return true;
	  }
	
	  var constructor = proto.constructor;
	
	  return typeof constructor === 'function' && constructor instanceof constructor && fnToString(constructor) === fnToString(Object);
	}
	
	module.exports = isPlainObject;

/***/ },
/* 349 */
/***/ function(module, exports) {

	"use strict";
	
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var hasOwn = Object.prototype.hasOwnProperty;
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _redux = __webpack_require__(36);
	
	function wrapActionCreators(actionCreators) {
	  return function (dispatch) {
	    return (0, _redux.bindActionCreators)(actionCreators, dispatch);
	  };
	}
	
	module.exports = wrapActionCreators;

/***/ },
/* 351 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';
	
	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};
	
	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};
	
	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent) {
	    var keys = Object.getOwnPropertyNames(sourceComponent);
	    for (var i=0; i<keys.length; ++i) {
	        if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]]) {
	            targetComponent[keys[i]] = sourceComponent[keys[i]];
	        }
	    }
	
	    return targetComponent;
	};


/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (false) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _React3Descriptor = __webpack_require__(418);
	
	var _React3Descriptor2 = _interopRequireDefault(_React3Descriptor);
	
	var _ModuleDescriptor = __webpack_require__(407);
	
	var _ModuleDescriptor2 = _interopRequireDefault(_ModuleDescriptor);
	
	var _ViewportDescriptor = __webpack_require__(424);
	
	var _ViewportDescriptor2 = _interopRequireDefault(_ViewportDescriptor);
	
	var _SceneDescriptor = __webpack_require__(417);
	
	var _SceneDescriptor2 = _interopRequireDefault(_SceneDescriptor);
	
	var _Object3DDescriptor = __webpack_require__(22);
	
	var _Object3DDescriptor2 = _interopRequireDefault(_Object3DDescriptor);
	
	var _GroupDescriptor = __webpack_require__(411);
	
	var _GroupDescriptor2 = _interopRequireDefault(_GroupDescriptor);
	
	var _OrthographicCameraDescriptor = __webpack_require__(409);
	
	var _OrthographicCameraDescriptor2 = _interopRequireDefault(_OrthographicCameraDescriptor);
	
	var _PerspectiveCameraDescriptor = __webpack_require__(410);
	
	var _PerspectiveCameraDescriptor2 = _interopRequireDefault(_PerspectiveCameraDescriptor);
	
	var _CubeCameraDescriptor = __webpack_require__(408);
	
	var _CubeCameraDescriptor2 = _interopRequireDefault(_CubeCameraDescriptor);
	
	var _MeshDescriptor = __webpack_require__(102);
	
	var _MeshDescriptor2 = _interopRequireDefault(_MeshDescriptor);
	
	var _LineDescriptor = __webpack_require__(415);
	
	var _LineDescriptor2 = _interopRequireDefault(_LineDescriptor);
	
	var _PointsDescriptor = __webpack_require__(416);
	
	var _PointsDescriptor2 = _interopRequireDefault(_PointsDescriptor);
	
	var _AmbientLightDescriptor = __webpack_require__(390);
	
	var _AmbientLightDescriptor2 = _interopRequireDefault(_AmbientLightDescriptor);
	
	var _DirectionalLightDescriptor = __webpack_require__(391);
	
	var _DirectionalLightDescriptor2 = _interopRequireDefault(_DirectionalLightDescriptor);
	
	var _SpotLightDescriptor = __webpack_require__(393);
	
	var _SpotLightDescriptor2 = _interopRequireDefault(_SpotLightDescriptor);
	
	var _PointLightDescriptor = __webpack_require__(392);
	
	var _PointLightDescriptor2 = _interopRequireDefault(_PointLightDescriptor);
	
	var _ResourcesDescriptor = __webpack_require__(420);
	
	var _ResourcesDescriptor2 = _interopRequireDefault(_ResourcesDescriptor);
	
	var _GeometryResourceDescriptor = __webpack_require__(245);
	
	var _GeometryResourceDescriptor2 = _interopRequireDefault(_GeometryResourceDescriptor);
	
	var _ShapeGeometryResourceDescriptor = __webpack_require__(421);
	
	var _ShapeGeometryResourceDescriptor2 = _interopRequireDefault(_ShapeGeometryResourceDescriptor);
	
	var _TextureResourceDescriptor = __webpack_require__(423);
	
	var _TextureResourceDescriptor2 = _interopRequireDefault(_TextureResourceDescriptor);
	
	var _ShapeResourceDescriptor = __webpack_require__(422);
	
	var _ShapeResourceDescriptor2 = _interopRequireDefault(_ShapeResourceDescriptor);
	
	var _GeometryDescriptor = __webpack_require__(368);
	
	var _GeometryDescriptor2 = _interopRequireDefault(_GeometryDescriptor);
	
	var _BoxGeometryDescriptor = __webpack_require__(363);
	
	var _BoxGeometryDescriptor2 = _interopRequireDefault(_BoxGeometryDescriptor);
	
	var _SphereGeometryDescriptor = __webpack_require__(386);
	
	var _SphereGeometryDescriptor2 = _interopRequireDefault(_SphereGeometryDescriptor);
	
	var _ParametricGeometryDescriptor = __webpack_require__(372);
	
	var _ParametricGeometryDescriptor2 = _interopRequireDefault(_ParametricGeometryDescriptor);
	
	var _PlaneBufferGeometryDescriptor = __webpack_require__(373);
	
	var _PlaneBufferGeometryDescriptor2 = _interopRequireDefault(_PlaneBufferGeometryDescriptor);
	
	var _PlaneGeometryDescriptor = __webpack_require__(374);
	
	var _PlaneGeometryDescriptor2 = _interopRequireDefault(_PlaneGeometryDescriptor);
	
	var _PolyhedronGeometryDescriptor = __webpack_require__(375);
	
	var _PolyhedronGeometryDescriptor2 = _interopRequireDefault(_PolyhedronGeometryDescriptor);
	
	var _IcosahedronGeometryDescriptor = __webpack_require__(369);
	
	var _IcosahedronGeometryDescriptor2 = _interopRequireDefault(_IcosahedronGeometryDescriptor);
	
	var _OctahedronGeometryDescriptor = __webpack_require__(371);
	
	var _OctahedronGeometryDescriptor2 = _interopRequireDefault(_OctahedronGeometryDescriptor);
	
	var _TetrahedronGeometryDescriptor = __webpack_require__(387);
	
	var _TetrahedronGeometryDescriptor2 = _interopRequireDefault(_TetrahedronGeometryDescriptor);
	
	var _CircleGeometryDescriptor = __webpack_require__(365);
	
	var _CircleGeometryDescriptor2 = _interopRequireDefault(_CircleGeometryDescriptor);
	
	var _CircleBufferGeometryDescriptor = __webpack_require__(364);
	
	var _CircleBufferGeometryDescriptor2 = _interopRequireDefault(_CircleBufferGeometryDescriptor);
	
	var _RingGeometryDescriptor = __webpack_require__(376);
	
	var _RingGeometryDescriptor2 = _interopRequireDefault(_RingGeometryDescriptor);
	
	var _CylinderGeometryDescriptor = __webpack_require__(366);
	
	var _CylinderGeometryDescriptor2 = _interopRequireDefault(_CylinderGeometryDescriptor);
	
	var _LatheGeometryDescriptor = __webpack_require__(370);
	
	var _LatheGeometryDescriptor2 = _interopRequireDefault(_LatheGeometryDescriptor);
	
	var _TorusGeometryDescriptor = __webpack_require__(388);
	
	var _TorusGeometryDescriptor2 = _interopRequireDefault(_TorusGeometryDescriptor);
	
	var _TorusKnotGeometryDescriptor = __webpack_require__(389);
	
	var _TorusKnotGeometryDescriptor2 = _interopRequireDefault(_TorusKnotGeometryDescriptor);
	
	var _ExtrudeGeometryDescriptor = __webpack_require__(367);
	
	var _ExtrudeGeometryDescriptor2 = _interopRequireDefault(_ExtrudeGeometryDescriptor);
	
	var _ShapeDescriptor = __webpack_require__(384);
	
	var _ShapeDescriptor2 = _interopRequireDefault(_ShapeDescriptor);
	
	var _MoveToDescriptor = __webpack_require__(382);
	
	var _MoveToDescriptor2 = _interopRequireDefault(_MoveToDescriptor);
	
	var _LineToDescriptor = __webpack_require__(381);
	
	var _LineToDescriptor2 = _interopRequireDefault(_LineToDescriptor);
	
	var _BezierCurveToDescriptor = __webpack_require__(379);
	
	var _BezierCurveToDescriptor2 = _interopRequireDefault(_BezierCurveToDescriptor);
	
	var _QuadraticCurveToDescriptor = __webpack_require__(383);
	
	var _QuadraticCurveToDescriptor2 = _interopRequireDefault(_QuadraticCurveToDescriptor);
	
	var _AbsArcDescriptor = __webpack_require__(377);
	
	var _AbsArcDescriptor2 = _interopRequireDefault(_AbsArcDescriptor);
	
	var _AbsEllipseDescriptor = __webpack_require__(378);
	
	var _AbsEllipseDescriptor2 = _interopRequireDefault(_AbsEllipseDescriptor);
	
	var _HoleDescriptor = __webpack_require__(380);
	
	var _HoleDescriptor2 = _interopRequireDefault(_HoleDescriptor);
	
	var _SplineThruDescriptor = __webpack_require__(385);
	
	var _SplineThruDescriptor2 = _interopRequireDefault(_SplineThruDescriptor);
	
	var _PointsMaterialDescriptor = __webpack_require__(401);
	
	var _PointsMaterialDescriptor2 = _interopRequireDefault(_PointsMaterialDescriptor);
	
	var _MeshBasicMaterialDescriptor = __webpack_require__(396);
	
	var _MeshBasicMaterialDescriptor2 = _interopRequireDefault(_MeshBasicMaterialDescriptor);
	
	var _MeshPhongMaterialDescriptor = __webpack_require__(400);
	
	var _MeshPhongMaterialDescriptor2 = _interopRequireDefault(_MeshPhongMaterialDescriptor);
	
	var _MeshLambertMaterialDescriptor = __webpack_require__(398);
	
	var _MeshLambertMaterialDescriptor2 = _interopRequireDefault(_MeshLambertMaterialDescriptor);
	
	var _ShaderMaterialDescriptor = __webpack_require__(402);
	
	var _ShaderMaterialDescriptor2 = _interopRequireDefault(_ShaderMaterialDescriptor);
	
	var _TextureDescriptor = __webpack_require__(404);
	
	var _TextureDescriptor2 = _interopRequireDefault(_TextureDescriptor);
	
	var _MaterialResourceDescriptor = __webpack_require__(419);
	
	var _MaterialResourceDescriptor2 = _interopRequireDefault(_MaterialResourceDescriptor);
	
	var _UniformsDescriptor = __webpack_require__(406);
	
	var _UniformsDescriptor2 = _interopRequireDefault(_UniformsDescriptor);
	
	var _UniformDescriptor = __webpack_require__(405);
	
	var _UniformDescriptor2 = _interopRequireDefault(_UniformDescriptor);
	
	var _LineBasicMaterialDescriptor = __webpack_require__(394);
	
	var _LineBasicMaterialDescriptor2 = _interopRequireDefault(_LineBasicMaterialDescriptor);
	
	var _LineDashedMaterialDescriptor = __webpack_require__(395);
	
	var _LineDashedMaterialDescriptor2 = _interopRequireDefault(_LineDashedMaterialDescriptor);
	
	var _MeshDepthMaterialDescriptor = __webpack_require__(397);
	
	var _MeshDepthMaterialDescriptor2 = _interopRequireDefault(_MeshDepthMaterialDescriptor);
	
	var _MeshNormalMaterialDescriptor = __webpack_require__(399);
	
	var _MeshNormalMaterialDescriptor2 = _interopRequireDefault(_MeshNormalMaterialDescriptor);
	
	var _SpriteMaterialDescriptor = __webpack_require__(403);
	
	var _SpriteMaterialDescriptor2 = _interopRequireDefault(_SpriteMaterialDescriptor);
	
	var _CameraHelperDescriptor = __webpack_require__(414);
	
	var _CameraHelperDescriptor2 = _interopRequireDefault(_CameraHelperDescriptor);
	
	var _AxisHelperDescriptor = __webpack_require__(413);
	
	var _AxisHelperDescriptor2 = _interopRequireDefault(_AxisHelperDescriptor);
	
	var _ArrowHelperDescriptor = __webpack_require__(412);
	
	var _ArrowHelperDescriptor2 = _interopRequireDefault(_ArrowHelperDescriptor);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ElementDescriptorContainer = function ElementDescriptorContainer(react3RendererInstance) {
	      _classCallCheck(this, ElementDescriptorContainer);
	
	      this.react3RendererInstance = react3RendererInstance;
	
	      /**
	       * @type {Object.<string, THREEElementDescriptor>}
	       */
	      this.descriptors = {
	            react3: new _React3Descriptor2.default(react3RendererInstance),
	
	            module: new _ModuleDescriptor2.default(react3RendererInstance),
	
	            viewport: new _ViewportDescriptor2.default(react3RendererInstance),
	            scene: new _SceneDescriptor2.default(react3RendererInstance),
	
	            object3D: new _Object3DDescriptor2.default(react3RendererInstance),
	            group: new _GroupDescriptor2.default(react3RendererInstance),
	
	            orthographicCamera: new _OrthographicCameraDescriptor2.default(react3RendererInstance),
	            perspectiveCamera: new _PerspectiveCameraDescriptor2.default(react3RendererInstance),
	            cubeCamera: new _CubeCameraDescriptor2.default(react3RendererInstance),
	
	            mesh: new _MeshDescriptor2.default(react3RendererInstance),
	            line: new _LineDescriptor2.default(react3RendererInstance),
	            points: new _PointsDescriptor2.default(react3RendererInstance),
	
	            meshBasicMaterial: new _MeshBasicMaterialDescriptor2.default(react3RendererInstance),
	            meshPhongMaterial: new _MeshPhongMaterialDescriptor2.default(react3RendererInstance),
	            meshLambertMaterial: new _MeshLambertMaterialDescriptor2.default(react3RendererInstance),
	            pointsMaterial: new _PointsMaterialDescriptor2.default(react3RendererInstance),
	            shaderMaterial: new _ShaderMaterialDescriptor2.default(react3RendererInstance),
	            lineBasicMaterial: new _LineBasicMaterialDescriptor2.default(react3RendererInstance),
	            lineDashedMaterial: new _LineDashedMaterialDescriptor2.default(react3RendererInstance),
	            meshDepthMaterial: new _MeshDepthMaterialDescriptor2.default(react3RendererInstance),
	            meshNormalMaterial: new _MeshNormalMaterialDescriptor2.default(react3RendererInstance),
	            spriteMaterial: new _SpriteMaterialDescriptor2.default(react3RendererInstance),
	
	            texture: new _TextureDescriptor2.default(react3RendererInstance),
	
	            geometry: new _GeometryDescriptor2.default(react3RendererInstance),
	            boxGeometry: new _BoxGeometryDescriptor2.default(react3RendererInstance),
	            sphereGeometry: new _SphereGeometryDescriptor2.default(react3RendererInstance),
	            parametricGeometry: new _ParametricGeometryDescriptor2.default(react3RendererInstance),
	            planeBufferGeometry: new _PlaneBufferGeometryDescriptor2.default(react3RendererInstance),
	            planeGeometry: new _PlaneGeometryDescriptor2.default(react3RendererInstance),
	            polyhedronGeometry: new _PolyhedronGeometryDescriptor2.default(react3RendererInstance),
	            icosahedronGeometry: new _IcosahedronGeometryDescriptor2.default(react3RendererInstance),
	            octahedronGeometry: new _OctahedronGeometryDescriptor2.default(react3RendererInstance),
	            tetrahedronGeometry: new _TetrahedronGeometryDescriptor2.default(react3RendererInstance),
	            circleGeometry: new _CircleGeometryDescriptor2.default(react3RendererInstance),
	            circleBufferGeometry: new _CircleBufferGeometryDescriptor2.default(react3RendererInstance),
	            ringGeometry: new _RingGeometryDescriptor2.default(react3RendererInstance),
	            cylinderGeometry: new _CylinderGeometryDescriptor2.default(react3RendererInstance),
	            latheGeometry: new _LatheGeometryDescriptor2.default(react3RendererInstance),
	            torusGeometry: new _TorusGeometryDescriptor2.default(react3RendererInstance),
	            torusKnotGeometry: new _TorusKnotGeometryDescriptor2.default(react3RendererInstance),
	            extrudeGeometry: new _ExtrudeGeometryDescriptor2.default(react3RendererInstance),
	
	            shape: new _ShapeDescriptor2.default(react3RendererInstance),
	            moveTo: new _MoveToDescriptor2.default(react3RendererInstance),
	            lineTo: new _LineToDescriptor2.default(react3RendererInstance),
	            bezierCurveTo: new _BezierCurveToDescriptor2.default(react3RendererInstance),
	            quadraticCurveTo: new _QuadraticCurveToDescriptor2.default(react3RendererInstance),
	            absArc: new _AbsArcDescriptor2.default(react3RendererInstance),
	            absEllipse: new _AbsEllipseDescriptor2.default(react3RendererInstance),
	            hole: new _HoleDescriptor2.default(react3RendererInstance),
	            splineThru: new _SplineThruDescriptor2.default(react3RendererInstance),
	
	            ambientLight: new _AmbientLightDescriptor2.default(react3RendererInstance),
	            directionalLight: new _DirectionalLightDescriptor2.default(react3RendererInstance),
	            spotLight: new _SpotLightDescriptor2.default(react3RendererInstance),
	            pointLight: new _PointLightDescriptor2.default(react3RendererInstance),
	
	            resources: new _ResourcesDescriptor2.default(react3RendererInstance),
	            materialResource: new _MaterialResourceDescriptor2.default(react3RendererInstance),
	            geometryResource: new _GeometryResourceDescriptor2.default(react3RendererInstance),
	            shapeGeometryResource: new _ShapeGeometryResourceDescriptor2.default(react3RendererInstance),
	            textureResource: new _TextureResourceDescriptor2.default(react3RendererInstance),
	            shapeResource: new _ShapeResourceDescriptor2.default(react3RendererInstance),
	
	            uniforms: new _UniformsDescriptor2.default(react3RendererInstance),
	            uniform: new _UniformDescriptor2.default(react3RendererInstance),
	
	            cameraHelper: new _CameraHelperDescriptor2.default(react3RendererInstance),
	            axisHelper: new _AxisHelperDescriptor2.default(react3RendererInstance),
	            arrowHelper: new _ArrowHelperDescriptor2.default(react3RendererInstance)
	      };
	};
	
	module.exports = ElementDescriptorContainer;

/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _ReactReconciler = __webpack_require__(23);
	
	var _ReactReconciler2 = _interopRequireDefault(_ReactReconciler);
	
	var _ReactMultiChild = __webpack_require__(265);
	
	var _ReactMultiChild2 = _interopRequireDefault(_ReactMultiChild);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _flattenChildren = __webpack_require__(273);
	
	var _flattenChildren2 = _interopRequireDefault(_flattenChildren);
	
	var _ReactCurrentOwner = __webpack_require__(19);
	
	var _ReactCurrentOwner2 = _interopRequireDefault(_ReactCurrentOwner);
	
	var _idPropertyName = __webpack_require__(247);
	
	var _idPropertyName2 = _interopRequireDefault(_idPropertyName);
	
	var _React3CompositeComponentWrapper = __webpack_require__(239);
	
	var _React3CompositeComponentWrapper2 = _interopRequireDefault(_React3CompositeComponentWrapper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function processChildContext(context) {
	  // if (process.env.NODE_ENV !== 'production') {
	  //   // // Pass down our tag name to child components for validation purposes
	  //   // context = assign({}, context);
	  //   // const info = context[validateDOMNesting.ancestorInfoContextKey];
	  //   // context[validateDOMNesting.ancestorInfoContextKey] =
	  //        validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
	  // }
	  return context;
	}
	
	var RemountTrigger = function RemountTrigger() {
	  var _this = this;
	
	  _classCallCheck(this, RemountTrigger);
	
	  this.wantRemount = false;
	  this.onTrigger = function () {};
	
	  this.trigger = function () {
	    _this.wantRemount = true;
	
	    _this.onTrigger();
	  };
	};
	
	var registrationNameModules = {};
	
	function deleteListener(rootNodeID, propKey) {
	  console.log('deleteListener', rootNodeID, propKey); // eslint-disable-line
	  debugger; // eslint-disable-line
	}
	
	function enqueuePutListener(rootNodeID, propKey, nextProp, transaction) {
	  console.log('enqueuePutListener', rootNodeID, propKey, nextProp, transaction); // eslint-disable-line
	  debugger; // eslint-disable-line
	}
	
	function _arrayMove(array, oldIndex, newIndex) {
	  array.splice(newIndex, 0, array.splice(oldIndex, 1)[0]);
	}
	
	var getThreeObjectFromMountImage = function getThreeObjectFromMountImage(img) {
	  return img.threeObject;
	};
	
	var ReactMultiChildMixin = _ReactMultiChild2.default.Mixin;
	
	var InternalComponent = (_temp = _class = function () {
	  function InternalComponent(element, react3RendererInstance) {
	    var _this2 = this;
	
	    _classCallCheck(this, InternalComponent);
	
	    this.updateChildren = ReactMultiChildMixin.updateChildren.bind(this);
	    this._mountChildByNameAtIndex = ReactMultiChildMixin._mountChildByNameAtIndex.bind(this);
	    this._unmountChild = ReactMultiChildMixin._unmountChild.bind(this);
	    this.unmountChildren = ReactMultiChildMixin.unmountChildren.bind(this);
	
	    this._currentElement = element;
	    /**
	     * @type React3Renderer
	     */
	    this._react3RendererInstance = react3RendererInstance;
	
	    // console.log("internal: ", element);
	
	    this._elementType = element.type;
	    this._renderedChildren = [];
	    this._rootNodeID = null;
	    this._threeObject = null;
	    this._topLevelWrapper = null;
	    this._markup = null;
	    this._nodeWithLegacyProperties = null;
	    this._forceRemountOfComponent = false;
	
	    this.threeElementDescriptor = react3RendererInstance.threeElementDescriptors[element.type];
	    if (!this.threeElementDescriptor) {
	      if (false) {
	        (0, _invariant2.default)(false, 'No constructor for ' + element.type);
	      } else {
	        (0, _invariant2.default)(false);
	      }
	    }
	
	    if (("production") !== 'production' || ({"NODE_ENV":"production"}).ENABLE_REACT_ADDON_HOOKS === 'true') {
	      this.highlightComponent = function () {
	        _this2.threeElementDescriptor.highlight(_this2._threeObject);
	      };
	
	      this.hideHighlight = function () {
	        _this2.threeElementDescriptor.hideHighlight(_this2._threeObject);
	      };
	    }
	
	    this.remountTrigger = new RemountTrigger();
	
	    this.remountTrigger.onTrigger = function () {
	      _this2._forceRemountOfComponent = true;
	    };
	  }
	
	  _createClass(InternalComponent, [{
	    key: 'construct',
	    value: function construct(element) {
	      // console.log('constructing', element);
	      this._currentElement = element;
	    }
	  }, {
	    key: 'mountComponent',
	    value: function mountComponent(rootID, transaction, context) {
	      var _markup;
	
	      // console.log("mount component", rootID);
	
	      var element = this._currentElement;
	      this._rootNodeID = rootID;
	
	      if (false) {
	        this.threeElementDescriptor.checkPropTypes(element.type, this._currentElement._owner, element.props);
	      }
	
	      this._threeObject = this.threeElementDescriptor.construct(element.props);
	      this.threeElementDescriptor.applyInitialProps(this._threeObject, element.props);
	
	      this.threeElementDescriptor.placeRemountTrigger(this._threeObject, this.remountTrigger.trigger);
	
	      var childrenToUse = element.props.children;
	
	      var mountImages = this.mountChildren(childrenToUse, transaction, processChildContext(context, this));
	
	      var markup = (_markup = {}, _defineProperty(_markup, _idPropertyName2.default, rootID), _defineProperty(_markup, '_rootInstance', null), _defineProperty(_markup, 'elementType', element.type), _defineProperty(_markup, 'threeObject', this._threeObject), _defineProperty(_markup, 'parentMarkup', null), _defineProperty(_markup, 'childrenMarkup', mountImages), _defineProperty(_markup, 'toJSON', function toJSON() {
	        return '---MARKUP---';
	      }), _markup);
	
	      if (false) {
	        (0, _invariant2.default)(!!this._threeObject.userData, 'No userdata present in threeobject for %s', element.type);
	      } else {
	        (0, _invariant2.default)(!!this._threeObject.userData);
	      }
	
	      Object.assign(this._threeObject.userData, {
	        object3D: this._threeObject,
	        react3internalComponent: this, // used for highlighting etc
	        toJSON: function toJSON() {
	          return '---USERDATA---';
	        },
	        markup: markup
	      });
	
	      var threeElementDescriptors = this._react3RendererInstance.threeElementDescriptors;
	
	      if (mountImages && mountImages.length > 0) {
	        this.threeElementDescriptor.addChildren(this._threeObject, mountImages.map(getThreeObjectFromMountImage));
	
	        for (var i = 0; i < mountImages.length; ++i) {
	          var mountImage = mountImages[i];
	
	          var descriptorForChild = threeElementDescriptors[mountImage.elementType];
	
	          mountImage.parentMarkup = markup;
	
	          descriptorForChild.setParent(mountImage.threeObject, this._threeObject);
	        }
	      }
	
	      this._markup = markup;
	
	      return markup;
	    }
	  }, {
	    key: '_reconcilerInstantiateChildren',
	    value: function _reconcilerInstantiateChildren(nestedChildren, transaction, context) {
	      if (false) {
	        if (this._currentElement) {
	          var previousCurrent = _ReactCurrentOwner2.default.current;
	
	          try {
	            _ReactCurrentOwner2.default.current = this._currentElement._owner;
	            return this._react3RendererInstance.instantiateChildren(nestedChildren, transaction, context);
	          } finally {
	            _ReactCurrentOwner2.default.current = previousCurrent;
	          }
	        }
	      }
	      return this._react3RendererInstance.instantiateChildren(nestedChildren, transaction, context);
	    }
	  }, {
	    key: '_reconcilerUpdateChildren',
	    value: function _reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context) {
	      var nextChildren = undefined;
	      if (false) {
	        if (this._currentElement) {
	          var previousCurrent = _ReactCurrentOwner2.default.current;
	
	          try {
	            _ReactCurrentOwner2.default.current = this._currentElement._owner;
	            nextChildren = (0, _flattenChildren2.default)(nextNestedChildrenElements);
	          } finally {
	            _ReactCurrentOwner2.default.current = previousCurrent;
	          }
	
	          return this._react3RendererInstance.updateChildren(prevChildren, nextChildren, transaction, context);
	        }
	      }
	
	      nextChildren = (0, _flattenChildren2.default)(nextNestedChildrenElements);
	      return this._react3RendererInstance.updateChildren(prevChildren, nextChildren, transaction, context);
	    }
	  }, {
	    key: 'mountChildren',
	    value: function mountChildren(nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	      var mountImages = [];
	      var index = 0;
	
	      if (!!children) {
	        var childrenNames = Object.keys(children);
	        for (var i = 0; i < childrenNames.length; ++i) {
	          var name = childrenNames[i];
	
	          var child = children[name];
	          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	          var rootID = this._rootNodeID + name;
	          var mountImage = _ReactReconciler2.default.mountComponent(child, rootID, transaction, context);
	          child._mountIndex = index;
	          mountImages.push(mountImage);
	          index++;
	        }
	      }
	
	      return mountImages;
	    }
	  }, {
	    key: 'moveChild',
	    value: function moveChild(child, toIndex, lastIndex) {
	      if (child._mountIndex === toIndex) {
	        return;
	      }
	
	      this.threeElementDescriptor.moveChild(this._threeObject, child._threeObject, toIndex, child._mountIndex);
	
	      var markup = this._markup;
	
	      _arrayMove(markup.childrenMarkup, lastIndex, toIndex);
	    }
	  }, {
	    key: 'receiveComponent',
	    value: function receiveComponent(nextElement, transaction, context) {
	      // console.log('receive component');
	
	      var prevElement = this._currentElement;
	      this._currentElement = nextElement;
	
	      this.updateComponent(transaction, prevElement, nextElement, context);
	    }
	  }, {
	    key: 'updateComponent',
	    value: function updateComponent(transaction, prevElement, nextElement, context) {
	      var lastProps = prevElement.props;
	      var nextProps = this._currentElement.props;
	
	      if (prevElement.type !== nextElement.type) {
	        if (false) {
	          (0, _invariant2.default)(false, 'The component type changed unexpectedly');
	        } else {
	          (0, _invariant2.default)(false);
	        }
	      }
	
	      this._updateObjectProperties(lastProps, nextProps, transaction, context);
	      this._updateChildrenObjects(nextProps, transaction, processChildContext(context, this));
	    }
	  }, {
	    key: '_updateChildrenObjects',
	    value: function _updateChildrenObjects(nextProps, transaction, context) {
	      var nextChildren = nextProps.children || null;
	
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  }, {
	    key: '_updateObjectProperties',
	    value: function _updateObjectProperties(lastProps, nextProps, transaction) {
	      var remountTrigger = this.remountTrigger;
	
	      remountTrigger.wantRemount = false;
	
	      this.threeElementDescriptor.beginPropertyUpdates(this._threeObject);
	
	      if (false) {
	        this.threeElementDescriptor.checkPropTypes(this._currentElement.type, this._currentElement._owner, nextProps);
	      }
	
	      var lastPropKeys = Object.keys(lastProps);
	
	      // https://jsperf.com/object-keys-vs-for-in-with-closure/3
	      for (var i = 0; i < lastPropKeys.length; ++i) {
	        var propKey = lastPropKeys[i];
	
	        if (nextProps.hasOwnProperty(propKey)) {
	          continue;
	        }
	
	        if (propKey === 'children') {
	          continue;
	        }
	
	        if (remountTrigger.wantRemount) {
	          break;
	        }
	
	        if (registrationNameModules.hasOwnProperty(propKey)) {
	          if (lastProps[propKey]) {
	            // Only call deleteListener if there was a listener previously or
	            // else willDeleteListener gets called when there wasn't actually a
	            // listener (e.g., onClick={null})
	            deleteListener(this._rootNodeID, propKey);
	          }
	        } else {
	          this.threeElementDescriptor.deleteProperty(this._threeObject, propKey);
	        }
	      }
	
	      var nextPropKeys = Object.keys(nextProps);
	
	      for (var i = 0; i < nextPropKeys.length; ++i) {
	        var propKey = nextPropKeys[i];
	
	        if (propKey === 'children') {
	          continue;
	        }
	
	        if (remountTrigger.wantRemount) {
	          break;
	        }
	
	        var nextProp = nextProps[propKey];
	        var lastProp = lastProps[propKey];
	
	        if (nextProp === lastProp) {
	          continue;
	        }
	
	        if (registrationNameModules.hasOwnProperty(propKey)) {
	          if (nextProp) {
	            enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
	          } else if (lastProp) {
	            deleteListener(this._rootNodeID, propKey);
	          }
	        } else {
	          this.threeElementDescriptor.updateProperty(this._threeObject, propKey, nextProp);
	        }
	      }
	
	      this.threeElementDescriptor.completePropertyUpdates(this._threeObject);
	    }
	
	    /**
	     * @see ReactDOMComponent.Mixin.unmountComponent
	     * node_modules/react/lib/ReactDOMComponent.js:732
	     */
	
	  }, {
	    key: 'unmountComponent',
	    value: function unmountComponent() {
	      if (this._threeObject !== null) {
	        this.threeElementDescriptor.componentWillUnmount(this._threeObject);
	      }
	      this.unmountChildren();
	      if (this._threeObject !== null) {
	        this.threeElementDescriptor.unmount(this._threeObject);
	        // delete this._threeObject.userData.markup;
	      }
	
	      this._markup = null;
	      this._rootNodeID = null;
	      if (this._nodeWithLegacyProperties) {
	        var node = this._nodeWithLegacyProperties;
	        node._reactInternalComponent = null;
	        this._nodeWithLegacyProperties = null;
	      }
	    }
	  }, {
	    key: 'emptyJson',
	    value: function emptyJson() {
	      debugger; // eslint-disable-line
	      return '...';
	    }
	  }, {
	    key: 'getPublicInstance',
	    value: function getPublicInstance() {
	      var markup = this._react3RendererInstance.getMarkup(this._rootNodeID);
	
	      if (markup.threeObject) {
	        markup.threeObject.toJSON = this.emptyJson;
	        return markup.threeObject;
	      }
	
	      if (false) {
	        (0, _invariant2.default)(false, 'Node has no threeObject?');
	      } else {
	        (0, _invariant2.default)(false);
	      }
	    }
	
	    /**
	     * @see ReactMultiChildMixin._updateChildren
	     *
	     * Improve performance by isolating this hot code path from the try/catch
	     * block in `updateChildren`.
	     *
	     * @param {?object} nextNestedChildren Nested child maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @param {any} context
	     * @final
	     * @protected
	     */
	
	  }, {
	    key: '_updateChildren',
	    value: function _updateChildren(nextNestedChildren, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildren, transaction, context);
	
	      this._renderedChildren = nextChildren;
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	
	      var remountTrigger = this.remountTrigger;
	
	      remountTrigger.wantRemount = false;
	
	      this.threeElementDescriptor.beginChildUpdates(this._threeObject);
	
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var lastIndex = 0;
	      var nextIndex = 0;
	
	      if (!!nextChildren) {
	        var nextChildrenNames = Object.keys(nextChildren);
	
	        for (var i = 0; i < nextChildrenNames.length; ++i) {
	          var childName = nextChildrenNames[i];
	
	          if (remountTrigger.wantRemount) {
	            // This component will be remounted, (see extrude geometry)
	            // No need to update children any more as they will also be remounted!
	            continue;
	          }
	
	          var prevChild = prevChildren && prevChildren[childName];
	          var nextChild = nextChildren[childName];
	
	          if (prevChild === nextChild) {
	            this.moveChild(prevChild, nextIndex, lastIndex);
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            prevChild._mountIndex = nextIndex;
	          } else {
	            if (prevChild) {
	              // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	              lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	              this._unmountChild(prevChild);
	            }
	
	            if (remountTrigger.wantRemount) {
	              // The remount can be triggered by unmountChild as well (see extrude geometry)
	              continue;
	            }
	
	            // The child must be instantiated before it's mounted.
	            this._mountChildByNameAtIndex(nextChild, childName, nextIndex, transaction, context);
	          }
	
	          nextIndex++;
	        }
	      }
	
	      if (!!prevChildren) {
	        // Remove children that are no longer present.
	        var prevChildrenNames = Object.keys(prevChildren);
	
	        for (var i = 0; i < prevChildrenNames.length; ++i) {
	          var childName = prevChildrenNames[i];
	
	          if (remountTrigger.wantRemount) {
	            continue;
	          }
	
	          if (!(nextChildren && nextChildren.hasOwnProperty(childName))) {
	            this._unmountChild(prevChildren[childName]);
	          }
	        }
	      }
	
	      this.threeElementDescriptor.completeChildUpdates(this._threeObject);
	    }
	  }, {
	    key: 'createChild',
	    value: function createChild(child, mountImage) {
	      var mountIndex = child._mountIndex;
	
	      this._markup.childrenMarkup.splice(mountIndex, 0, mountImage);
	      mountImage.parentMarkup = this._markup;
	
	      this.threeElementDescriptor.addChild(this._threeObject, mountImage.threeObject, mountIndex);
	
	      var descriptorForChild = this._react3RendererInstance.threeElementDescriptors[mountImage.elementType];
	
	      descriptorForChild.setParent(mountImage.threeObject, this._threeObject);
	    }
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	
	  }, {
	    key: 'removeChild',
	    value: function removeChild(child) {
	      this.threeElementDescriptor.removeChild(this._threeObject, child._threeObject);
	
	      if (child instanceof InternalComponent) {
	        child.threeElementDescriptor.removedFromParent(child._threeObject);
	      } else if (child instanceof _React3CompositeComponentWrapper2.default) {
	        child._threeObject.userData.react3internalComponent.threeElementDescriptor.removedFromParent(child._threeObject);
	      } else {
	        if (false) {
	          (0, _invariant2.default)(false, 'Cannot remove child because it is not a known component type');
	        } else {
	          (0, _invariant2.default)(false);
	        }
	      }
	
	      var childrenMarkup = this._markup.childrenMarkup;
	
	      for (var i = 0; i < childrenMarkup.length; i++) {
	        var childMarkup = childrenMarkup[i];
	
	        if (childMarkup.threeObject === child._threeObject) {
	          childrenMarkup.splice(i, 1);
	
	          delete childMarkup.parentMarkup;
	          return;
	        }
	      }
	
	      if (false) {
	        (0, _invariant2.default)(false, 'Trying to remove a child that is not mounted');
	      } else {
	        (0, _invariant2.default)(false);
	      }
	    }
	  }]);
	
	  return InternalComponent;
	}(), _class.displayName = 'React3Component', _temp);
	
	module.exports = InternalComponent;

/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class, _temp;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _React3Renderer = __webpack_require__(55);
	
	var _React3Renderer2 = _interopRequireDefault(_React3Renderer);
	
	var _ReactComponentWithPureRenderMixin = __webpack_require__(441);
	
	var _ReactComponentWithPureRenderMixin2 = _interopRequireDefault(_ReactComponentWithPureRenderMixin);
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _propTypeInstanceOf = __webpack_require__(17);
	
	var _propTypeInstanceOf2 = _interopRequireDefault(_propTypeInstanceOf);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var PropTypes = _react2.default.PropTypes;
	var React3 = (_temp = _class = function (_React$Component) {
	  _inherits(React3, _React$Component);
	
	  function React3(props, context) {
	    _classCallCheck(this, React3);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(React3).call(this, props, context));
	
	    _this.shouldComponentUpdate = _ReactComponentWithPureRenderMixin2.default.shouldComponentUpdate;
	
	    _this._onRecreateCanvas = function () {
	      _this.setState({
	        // changing the key will recreate the element
	        canvasKey: _this.state.canvasKey + 1
	      });
	    };
	
	    _this.state = {
	      canvasKey: 0
	    };
	    return _this;
	  }
	
	  _createClass(React3, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      this.react3Renderer = new _React3Renderer2.default();
	
	      this._render();
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate() {
	      this._render();
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      this.react3Renderer.dispose();
	      delete this.react3Renderer;
	    }
	  }, {
	    key: '_render',
	    value: function _render() {
	      var canvas = this.refs.canvas;
	
	      var propsToClone = _extends({}, this.props);
	
	      delete propsToClone.canvasStyle;
	
	      this.react3Renderer.render(_react2.default.createElement(
	        'react3',
	        _extends({}, propsToClone, {
	          onRecreateCanvas: this._onRecreateCanvas
	        }),
	        this.props.children
	      ), canvas);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var canvasKey = this.state.canvasKey;
	
	      return _react2.default.createElement('canvas', {
	        ref: 'canvas',
	        key: canvasKey,
	        width: this.props.width,
	        height: this.props.height,
	        style: _extends({}, this.props.canvasStyle, {
	          width: this.props.width,
	          height: this.props.height
	        })
	      });
	    }
	  }]);
	
	  return React3;
	}(_react2.default.Component), _class.propTypes = {
	  context: PropTypes.string,
	  width: PropTypes.number.isRequired,
	  height: PropTypes.number.isRequired,
	  children: PropTypes.any,
	  canvasStyle: PropTypes.any,
	  gammaInput: PropTypes.bool,
	  gammaOutput: PropTypes.bool,
	  sortObjects: PropTypes.bool,
	  mainCamera: PropTypes.string,
	  onAnimate: PropTypes.func,
	  clearColor: PropTypes.oneOfType([(0, _propTypeInstanceOf2.default)(_three2.default.Color), PropTypes.number, PropTypes.string]),
	  shadowMapEnabled: PropTypes.bool,
	  shadowMapType: PropTypes.oneOf([_three2.default.BasicShadowMap, _three2.default.PCFShadowMap, _three2.default.PCFSoftShadowMap]),
	  shadowMapCullFace: PropTypes.oneOf([_three2.default.CullFaceNone, _three2.default.CullFaceBack, _three2.default.CullFaceFront, _three2.default.CullFaceFrontBack]),
	  shadowMapDebug: PropTypes.bool,
	  pixelRatio: PropTypes.number,
	  antialias: PropTypes.oneOfType([PropTypes.bool, PropTypes.number])
	}, _class.defaultProps = {
	  context: '3d'
	}, _class.findTHREEObject = _React3Renderer2.default.findTHREEObject, _class.eventDispatcher = _React3Renderer2.default.eventDispatcher, _temp);
	
	module.exports = React3;

/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ShapeAction2 = __webpack_require__(25);
	
	var _ShapeAction3 = _interopRequireDefault(_ShapeAction2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var AbsArcAction = function (_ShapeAction) {
	  _inherits(AbsArcAction, _ShapeAction);
	
	  function AbsArcAction(x, y, radius, startAngle, endAngle, clockwise) {
	    _classCallCheck(this, AbsArcAction);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AbsArcAction).call(this));
	
	    _this.x = x;
	    _this.y = y;
	    _this.radius = radius;
	    _this.startAngle = startAngle;
	    _this.endAngle = endAngle;
	    _this.clockwise = clockwise;
	    return _this;
	  }
	
	  _createClass(AbsArcAction, [{
	    key: 'performAction',
	    value: function performAction(shape) {
	      shape.absarc(this.x, this.y, this.radius, this.startAngle, this.endAngle, this.clockwise);
	    }
	  }]);
	
	  return AbsArcAction;
	}(_ShapeAction3.default);
	
	module.exports = AbsArcAction;

/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ShapeAction2 = __webpack_require__(25);
	
	var _ShapeAction3 = _interopRequireDefault(_ShapeAction2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var AbsEllipseAction = function (_ShapeAction) {
	  _inherits(AbsEllipseAction, _ShapeAction);
	
	  function AbsEllipseAction(x, y, xRadius, yRadius, startAngle, endAngle, clockwise, rotation) {
	    _classCallCheck(this, AbsEllipseAction);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AbsEllipseAction).call(this));
	
	    _this.x = x;
	    _this.y = y;
	    _this.xRadius = xRadius;
	    _this.yRadius = yRadius;
	    _this.startAngle = startAngle;
	    _this.endAngle = endAngle;
	    _this.clockwise = clockwise;
	    _this.rotation = rotation;
	    return _this;
	  }
	
	  _createClass(AbsEllipseAction, [{
	    key: 'performAction',
	    value: function performAction(shape) {
	      shape.absellipse(this.x, this.y, this.xRadius, this.yRadius, this.startAngle, this.endAngle, this.clockwise, this.rotation);
	    }
	  }]);
	
	  return AbsEllipseAction;
	}(_ShapeAction3.default);
	
	module.exports = AbsEllipseAction;

/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ShapeAction2 = __webpack_require__(25);
	
	var _ShapeAction3 = _interopRequireDefault(_ShapeAction2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var BezierCurveToAction = function (_ShapeAction) {
	  _inherits(BezierCurveToAction, _ShapeAction);
	
	  function BezierCurveToAction(cp1X, cp1Y, cp2X, cp2Y, aX, aY) {
	    _classCallCheck(this, BezierCurveToAction);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(BezierCurveToAction).call(this));
	
	    _this.cp1X = cp1X;
	    _this.cp1Y = cp1Y;
	    _this.cp2X = cp2X;
	    _this.cp2Y = cp2Y;
	    _this.aX = aX;
	    _this.aY = aY;
	    return _this;
	  }
	
	  _createClass(BezierCurveToAction, [{
	    key: 'performAction',
	    value: function performAction(shape) {
	      shape.bezierCurveTo(this.cp1X, this.cp1Y, this.cp2X, this.cp2Y, this.aX, this.aY);
	    }
	  }]);
	
	  return BezierCurveToAction;
	}(_ShapeAction3.default);
	
	module.exports = BezierCurveToAction;

/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ShapeAction2 = __webpack_require__(25);
	
	var _ShapeAction3 = _interopRequireDefault(_ShapeAction2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var LineToAction = function (_ShapeAction) {
	  _inherits(LineToAction, _ShapeAction);
	
	  function LineToAction(x, y) {
	    _classCallCheck(this, LineToAction);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(LineToAction).call(this));
	
	    _this.x = x;
	    _this.y = y;
	    return _this;
	  }
	
	  _createClass(LineToAction, [{
	    key: 'performAction',
	    value: function performAction(shape) {
	      shape.lineTo(this.x, this.y);
	    }
	  }]);
	
	  return LineToAction;
	}(_ShapeAction3.default);
	
	module.exports = LineToAction;

/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ShapeAction2 = __webpack_require__(25);
	
	var _ShapeAction3 = _interopRequireDefault(_ShapeAction2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MoveToAction = function (_ShapeAction) {
	  _inherits(MoveToAction, _ShapeAction);
	
	  function MoveToAction(x, y) {
	    _classCallCheck(this, MoveToAction);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MoveToAction).call(this));
	
	    _this.x = x;
	    _this.y = y;
	    return _this;
	  }
	
	  _createClass(MoveToAction, [{
	    key: 'performAction',
	    value: function performAction(shape) {
	      shape.moveTo(this.x, this.y);
	    }
	  }]);
	
	  return MoveToAction;
	}(_ShapeAction3.default);
	
	module.exports = MoveToAction;

/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ShapeAction2 = __webpack_require__(25);
	
	var _ShapeAction3 = _interopRequireDefault(_ShapeAction2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var QuadraticCurveToAction = function (_ShapeAction) {
	  _inherits(QuadraticCurveToAction, _ShapeAction);
	
	  function QuadraticCurveToAction(cpX, cpY, x, y) {
	    _classCallCheck(this, QuadraticCurveToAction);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(QuadraticCurveToAction).call(this));
	
	    _this.cpX = cpX;
	    _this.cpY = cpY;
	    _this.x = x;
	    _this.y = y;
	    return _this;
	  }
	
	  _createClass(QuadraticCurveToAction, [{
	    key: 'performAction',
	    value: function performAction(shape) {
	      shape.quadraticCurveTo(this.cpX, this.cpY, this.x, this.y);
	    }
	  }]);
	
	  return QuadraticCurveToAction;
	}(_ShapeAction3.default);
	
	module.exports = QuadraticCurveToAction;

/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ShapeAction2 = __webpack_require__(25);
	
	var _ShapeAction3 = _interopRequireDefault(_ShapeAction2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var SplineThruAction = function (_ShapeAction) {
	  _inherits(SplineThruAction, _ShapeAction);
	
	  function SplineThruAction(points) {
	    _classCallCheck(this, SplineThruAction);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SplineThruAction).call(this));
	
	    _this.points = points;
	    return _this;
	  }
	
	  _createClass(SplineThruAction, [{
	    key: 'performAction',
	    value: function performAction(shape) {
	      shape.splineThru(this.points);
	    }
	  }]);
	
	  return SplineThruAction;
	}(_ShapeAction3.default);
	
	module.exports = SplineThruAction;

/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _GeometryDescriptorBase = __webpack_require__(16);
	
	var _GeometryDescriptorBase2 = _interopRequireDefault(_GeometryDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var BoxGeometryDescriptor = function (_GeometryDescriptorBa) {
	  _inherits(BoxGeometryDescriptor, _GeometryDescriptorBa);
	
	  function BoxGeometryDescriptor(react3RendererInstance) {
	    _classCallCheck(this, BoxGeometryDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(BoxGeometryDescriptor).call(this, react3RendererInstance));
	
	    ['width', 'height', 'depth'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number.isRequired,
	        update: _this.triggerRemount,
	        default: undefined
	      });
	    });
	
	    ['widthSegments', 'heightSegments', 'depthSegments'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number,
	        update: _this.triggerRemount,
	        default: undefined
	      });
	    });
	    return _this;
	  }
	
	  _createClass(BoxGeometryDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var width = props.width;
	      var height = props.height;
	      var depth = props.depth;
	      var widthSegments = props.widthSegments;
	      var heightSegments = props.heightSegments;
	      var depthSegments = props.depthSegments;
	
	      return new _three2.default.BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments);
	    }
	  }]);
	
	  return BoxGeometryDescriptor;
	}(_GeometryDescriptorBase2.default);
	
	module.exports = BoxGeometryDescriptor;

/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _BufferGeometryDescriptorBase = __webpack_require__(101);
	
	var _BufferGeometryDescriptorBase2 = _interopRequireDefault(_BufferGeometryDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var CircleBufferGeometryDescriptor = function (_BufferGeometryDescri) {
	  _inherits(CircleBufferGeometryDescriptor, _BufferGeometryDescri);
	
	  function CircleBufferGeometryDescriptor(react3RendererInstance) {
	    _classCallCheck(this, CircleBufferGeometryDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CircleBufferGeometryDescriptor).call(this, react3RendererInstance));
	
	    ['radius', 'segments', 'thetaStart', 'thetaLength'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number,
	        update: _this.updateCacheAndReplace.bind(_this, propName),
	        default: undefined
	      });
	    });
	    return _this;
	  }
	
	  _createClass(CircleBufferGeometryDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var radius = props.radius;
	      var segments = props.segments;
	      var thetaStart = props.thetaStart;
	      var thetaLength = props.thetaLength;
	
	      return new _three2.default.CircleBufferGeometry(radius, segments, thetaStart, thetaLength);
	    }
	  }]);
	
	  return CircleBufferGeometryDescriptor;
	}(_BufferGeometryDescriptorBase2.default);
	
	module.exports = CircleBufferGeometryDescriptor;

/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _GeometryDescriptorBase = __webpack_require__(16);
	
	var _GeometryDescriptorBase2 = _interopRequireDefault(_GeometryDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var CircleGeometryDescriptor = function (_GeometryDescriptorBa) {
	  _inherits(CircleGeometryDescriptor, _GeometryDescriptorBa);
	
	  function CircleGeometryDescriptor(react3RendererInstance) {
	    _classCallCheck(this, CircleGeometryDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CircleGeometryDescriptor).call(this, react3RendererInstance));
	
	    ['radius', 'segments', 'thetaStart', 'thetaLength'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number,
	        update: _this.triggerRemount,
	        default: undefined
	      });
	    });
	    return _this;
	  }
	
	  _createClass(CircleGeometryDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var radius = props.radius;
	      var segments = props.segments;
	      var thetaStart = props.thetaStart;
	      var thetaLength = props.thetaLength;
	
	      return new _three2.default.CircleGeometry(radius, segments, thetaStart, thetaLength);
	    }
	  }]);
	
	  return CircleGeometryDescriptor;
	}(_GeometryDescriptorBase2.default);
	
	module.exports = CircleGeometryDescriptor;

/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _GeometryDescriptorBase = __webpack_require__(16);
	
	var _GeometryDescriptorBase2 = _interopRequireDefault(_GeometryDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var CylinderGeometryDescriptor = function (_GeometryDescriptorBa) {
	  _inherits(CylinderGeometryDescriptor, _GeometryDescriptorBa);
	
	  function CylinderGeometryDescriptor(react3RendererInstance) {
	    _classCallCheck(this, CylinderGeometryDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CylinderGeometryDescriptor).call(this, react3RendererInstance));
	
	    ['radiusTop', 'radiusBottom', 'height', 'radialSegments', 'heightSegments', 'openEnded', 'thetaStart', 'thetaLength'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number,
	        update: _this.triggerRemount,
	        default: undefined
	      });
	    });
	    return _this;
	  }
	
	  _createClass(CylinderGeometryDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var radiusTop = props.radiusTop;
	      var radiusBottom = props.radiusBottom;
	      var height = props.height;
	      var radialSegments = props.radialSegments;
	      var heightSegments = props.heightSegments;
	      var openEnded = props.openEnded;
	      var thetaStart = props.thetaStart;
	      var thetaLength = props.thetaLength;
	
	      return new _three2.default.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
	    }
	  }]);
	
	  return CylinderGeometryDescriptor;
	}(_GeometryDescriptorBase2.default);
	
	module.exports = CylinderGeometryDescriptor;

/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _GeometryDescriptorBase = __webpack_require__(16);
	
	var _GeometryDescriptorBase2 = _interopRequireDefault(_GeometryDescriptorBase);
	
	var _ShapeResourceReference = __webpack_require__(240);
	
	var _ShapeResourceReference2 = _interopRequireDefault(_ShapeResourceReference);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _propTypeInstanceOf = __webpack_require__(17);
	
	var _propTypeInstanceOf2 = _interopRequireDefault(_propTypeInstanceOf);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ExtrudeGeometryDescriptor = function (_GeometryDescriptorBa) {
	  _inherits(ExtrudeGeometryDescriptor, _GeometryDescriptorBa);
	
	  function ExtrudeGeometryDescriptor(react3RendererInstance) {
	    _classCallCheck(this, ExtrudeGeometryDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ExtrudeGeometryDescriptor).call(this, react3RendererInstance));
	
	    _this._invalidChild = function (child) {
	      var invalid = !(child instanceof _three2.default.Shape || child instanceof _ShapeResourceReference2.default);
	
	      return invalid;
	    };
	
	    _this.hasProp('shapes', {
	      type: _ReactPropTypes2.default.arrayOf((0, _propTypeInstanceOf2.default)(_three2.default.Shape)),
	      updateInitial: true,
	      update: function update(threeObject, shapes) {
	        threeObject.userData._shapesFromProps = shapes || [];
	
	        // if the root instance exists, then it can be refreshed
	        if (threeObject.userData._rootInstance) {
	          _this._refreshGeometry(threeObject);
	        }
	      },
	      default: []
	    });
	
	    _this.hasProp('settings', {
	      type: _ReactPropTypes2.default.any,
	      update: function update(threeObject, settings) {
	        threeObject.userData._settings = settings;
	      },
	
	      updateInitial: true,
	      default: undefined
	    });
	
	    ['amount', 'bevelThickness', 'bevelSize', 'bevelSegments', 'bevelEnabled', 'curveSegments', 'steps', 'extrudePath', 'UVGenerator', 'frames'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.any,
	        update: function update(threeObject, value) {
	          if (value === undefined) {
	            delete threeObject.userData._options[propName];
	          } else {
	            threeObject.userData._options[propName] = value;
	          }
	
	          _this._refreshGeometry(threeObject);
	        },
	        default: undefined
	      });
	    });
	    return _this;
	  }
	
	  _createClass(ExtrudeGeometryDescriptor, [{
	    key: 'construct',
	    value: function construct() {
	      return new _three2.default.BufferGeometry();
	    }
	  }, {
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(ExtrudeGeometryDescriptor.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	
	      var options = {};
	
	      ['amount', 'bevelThickness', 'bevelSize', 'bevelSegments', 'bevelEnabled', 'curveSegments', 'steps', 'extrudePath', 'UVGenerator', 'frames'].forEach(function (propName) {
	        if (props.hasOwnProperty(propName)) {
	          options[propName] = props[propName];
	        }
	      });
	
	      threeObject.userData._shapeCache = [];
	      threeObject.userData._options = options;
	      threeObject.userData._resourceListenerCleanupFunctions = [];
	
	      this._refreshGeometry(threeObject);
	    }
	  }, {
	    key: '_onShapeResourceUpdate',
	    value: function _onShapeResourceUpdate(threeObject, shapeIndex, shape) {
	      threeObject.userData._shapeCache[shapeIndex] = shape;
	
	      this._refreshGeometry(threeObject);
	    }
	  }, {
	    key: '_refreshGeometry',
	    value: function _refreshGeometry(threeObject) {
	      var shapes = threeObject.userData._shapeCache.filter(function (shape) {
	        return !!shape;
	      }).concat(threeObject.userData._shapesFromProps);
	
	      threeObject.fromGeometry(new _three2.default.ExtrudeGeometry(shapes, _extends({}, threeObject.userData._options, threeObject.userData._settings)));
	    }
	  }, {
	    key: 'addChildren',
	    value: function addChildren(threeObject, children) {
	      var _this2 = this;
	
	      // TODO: add shapes here!
	
	      if (false) {
	        (0, _invariant2.default)(children.filter(this._invalidChild).length === 0, 'Extrude geometry children' + ' can only be shapes!');
	      } else {
	        (0, _invariant2.default)(children.filter(this._invalidChild).length === 0, false);
	      }
	
	      var shapeCache = [];
	
	      children.forEach(function (child) {
	        if (child instanceof _ShapeResourceReference2.default) {
	          (function () {
	            var shapeIndex = shapeCache.length;
	
	            var resourceListener = _this2._onShapeResourceUpdate.bind(_this2, threeObject, shapeIndex);
	
	            resourceListener.target = child;
	
	            var cleanupFunction = function cleanupFunction() {
	              child.userData.events.removeListener('resource.set', resourceListener);
	
	              threeObject.userData._resourceListenerCleanupFunctions.splice(threeObject.userData._resourceListenerCleanupFunctions.indexOf(cleanupFunction), 1);
	            };
	
	            threeObject.userData._resourceListenerCleanupFunctions.push(cleanupFunction);
	
	            child.userData.events.on('resource.set', resourceListener);
	            child.userData.events.once('dispose', function () {
	              cleanupFunction();
	            });
	
	            shapeCache.push(null);
	          })();
	        } else {
	          shapeCache.push(child);
	        }
	      });
	
	      threeObject.userData._shapeCache = shapeCache;
	
	      this._refreshGeometry(threeObject);
	    }
	  }, {
	    key: 'addChild',
	    value: function addChild(threeObject) {
	      // new shape was added
	      // TODO optimize
	
	      this.triggerRemount(threeObject);
	    }
	  }, {
	    key: 'removeChild',
	    value: function removeChild(threeObject) {
	      // shape was removed
	      // TODO optimize
	
	      this.triggerRemount(threeObject);
	    }
	  }, {
	    key: 'unmount',
	    value: function unmount(geometry) {
	      geometry.userData._resourceListenerCleanupFunctions.forEach(function (listener) {
	        listener();
	      });
	
	      delete geometry.userData._resourceListenerCleanupFunctions;
	      delete geometry.userData._options;
	      delete geometry.userData._shapesFromProps;
	
	      return _get(Object.getPrototypeOf(ExtrudeGeometryDescriptor.prototype), 'unmount', this).call(this, geometry);
	    }
	  }]);
	
	  return ExtrudeGeometryDescriptor;
	}(_GeometryDescriptorBase2.default);
	
	module.exports = ExtrudeGeometryDescriptor;

/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _GeometryDescriptorBase = __webpack_require__(16);
	
	var _GeometryDescriptorBase2 = _interopRequireDefault(_GeometryDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _propTypeInstanceOf = __webpack_require__(17);
	
	var _propTypeInstanceOf2 = _interopRequireDefault(_propTypeInstanceOf);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var GeometryDescriptor = function (_GeometryDescriptorBa) {
	  _inherits(GeometryDescriptor, _GeometryDescriptorBa);
	
	  function GeometryDescriptor(react3RendererInstance) {
	    _classCallCheck(this, GeometryDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(GeometryDescriptor).call(this, react3RendererInstance));
	
	    _this.hasProp('vertices', {
	      type: _ReactPropTypes2.default.arrayOf((0, _propTypeInstanceOf2.default)(_three2.default.Vector3)).isRequired,
	      update: function update(threeObject, vertices) {
	        if (threeObject.vertices !== vertices) {
	          threeObject.vertices = vertices;
	
	          threeObject.verticesNeedUpdate = true;
	        }
	      },
	
	      updateInitial: true,
	      default: []
	    });
	
	    _this.hasProp('colors', {
	      type: _ReactPropTypes2.default.arrayOf((0, _propTypeInstanceOf2.default)(_three2.default.Color)),
	      update: function update(threeObject, colors, hasProp) {
	        if (hasProp) {
	          if (threeObject.colors !== colors) {
	            threeObject.colors = colors;
	
	            threeObject.colorsNeedUpdate = true;
	          }
	        }
	      },
	
	      updateInitial: true,
	      default: []
	    });
	
	    _this.hasProp('faceVertexUvs', {
	      type: _ReactPropTypes2.default.arrayOf(_ReactPropTypes2.default.arrayOf(_three2.default.Vector2)),
	      update: function update(threeObject, faceVertexUvs, hasProp) {
	        if (hasProp) {
	          if (threeObject.faceVertexUvs !== faceVertexUvs) {
	            threeObject.faceVertexUvs = faceVertexUvs;
	
	            threeObject.uvsNeedUpdate = true;
	          }
	        }
	      },
	
	      updateInitial: true,
	      default: []
	    });
	
	    _this.hasProp('faces', {
	      type: _ReactPropTypes2.default.arrayOf((0, _propTypeInstanceOf2.default)(_three2.default.Face3)),
	      update: function update(threeObject, faces) {
	        if (threeObject.faces !== faces) {
	          threeObject.faces = faces;
	
	          threeObject.verticesNeedUpdate = true;
	          threeObject.elementsNeedUpdate = true;
	        }
	      },
	
	      updateInitial: true,
	      default: []
	    });
	    return _this;
	  }
	
	  _createClass(GeometryDescriptor, [{
	    key: 'construct',
	    value: function construct() {
	      return new _three2.default.Geometry();
	    }
	  }]);
	
	  return GeometryDescriptor;
	}(_GeometryDescriptorBase2.default);
	
	module.exports = GeometryDescriptor;

/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _PolyhedronGeometryDescriptorBase = __webpack_require__(57);
	
	var _PolyhedronGeometryDescriptorBase2 = _interopRequireDefault(_PolyhedronGeometryDescriptorBase);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var IcosahedronGeometryDescriptor = function (_PolyhedronGeometryDe) {
	  _inherits(IcosahedronGeometryDescriptor, _PolyhedronGeometryDe);
	
	  function IcosahedronGeometryDescriptor() {
	    _classCallCheck(this, IcosahedronGeometryDescriptor);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(IcosahedronGeometryDescriptor).apply(this, arguments));
	  }
	
	  _createClass(IcosahedronGeometryDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var radius = props.radius;
	      var detail = props.detail;
	
	      return new _three2.default.IcosahedronGeometry(radius, detail);
	    }
	  }]);
	
	  return IcosahedronGeometryDescriptor;
	}(_PolyhedronGeometryDescriptorBase2.default);
	
	module.exports = IcosahedronGeometryDescriptor;

/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _GeometryDescriptorBase = __webpack_require__(16);
	
	var _GeometryDescriptorBase2 = _interopRequireDefault(_GeometryDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _propTypeInstanceOf = __webpack_require__(17);
	
	var _propTypeInstanceOf2 = _interopRequireDefault(_propTypeInstanceOf);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var LatheGeometryDescriptor = function (_GeometryDescriptorBa) {
	  _inherits(LatheGeometryDescriptor, _GeometryDescriptorBa);
	
	  function LatheGeometryDescriptor(react3RendererInstance) {
	    _classCallCheck(this, LatheGeometryDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(LatheGeometryDescriptor).call(this, react3RendererInstance));
	
	    ['segments', 'phiStart', 'phiLength'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number,
	        update: _this.triggerRemount,
	        default: undefined
	      });
	    });
	
	    _this.hasProp('points', {
	      type: _ReactPropTypes2.default.arrayOf((0, _propTypeInstanceOf2.default)(_three2.default.Vector3)).isRequired,
	      update: _this.triggerRemount,
	      default: undefined
	    });
	    return _this;
	  }
	
	  _createClass(LatheGeometryDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var points = props.points;
	      var segments = props.segments;
	      var phiStart = props.phiStart;
	      var phiLength = props.phiLength;
	
	      return new _three2.default.LatheGeometry(points, segments, phiStart, phiLength);
	    }
	  }]);
	
	  return LatheGeometryDescriptor;
	}(_GeometryDescriptorBase2.default);
	
	module.exports = LatheGeometryDescriptor;

/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _PolyhedronGeometryDescriptorBase = __webpack_require__(57);
	
	var _PolyhedronGeometryDescriptorBase2 = _interopRequireDefault(_PolyhedronGeometryDescriptorBase);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var OctahedronGeometryDescriptor = function (_PolyhedronGeometryDe) {
	  _inherits(OctahedronGeometryDescriptor, _PolyhedronGeometryDe);
	
	  function OctahedronGeometryDescriptor() {
	    _classCallCheck(this, OctahedronGeometryDescriptor);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(OctahedronGeometryDescriptor).apply(this, arguments));
	  }
	
	  _createClass(OctahedronGeometryDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var radius = props.radius;
	      var detail = props.detail;
	
	      return new _three2.default.OctahedronGeometry(radius, detail);
	    }
	  }]);
	
	  return OctahedronGeometryDescriptor;
	}(_PolyhedronGeometryDescriptorBase2.default);
	
	module.exports = OctahedronGeometryDescriptor;

/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _GeometryDescriptorBase = __webpack_require__(16);
	
	var _GeometryDescriptorBase2 = _interopRequireDefault(_GeometryDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ParametricGeometryDescriptor = function (_GeometryDescriptorBa) {
	  _inherits(ParametricGeometryDescriptor, _GeometryDescriptorBa);
	
	  function ParametricGeometryDescriptor(react3Instance) {
	    _classCallCheck(this, ParametricGeometryDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ParametricGeometryDescriptor).call(this, react3Instance));
	
	    ['slices', 'stacks'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number.isRequired,
	        update: _this.triggerRemount,
	        default: undefined
	      });
	    });
	
	    _this.hasProp('parametricFunction', {
	      type: _ReactPropTypes2.default.func.isRequired,
	      update: _this.triggerRemount,
	      default: undefined
	    });
	    return _this;
	  }
	
	  _createClass(ParametricGeometryDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var parametricFunction = props.parametricFunction;
	      var slices = props.slices;
	      var stacks = props.stacks;
	
	      return new _three2.default.ParametricGeometry(parametricFunction, slices, stacks);
	    }
	  }]);
	
	  return ParametricGeometryDescriptor;
	}(_GeometryDescriptorBase2.default);
	
	module.exports = ParametricGeometryDescriptor;

/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _BufferGeometryDescriptorBase = __webpack_require__(101);
	
	var _BufferGeometryDescriptorBase2 = _interopRequireDefault(_BufferGeometryDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var PlaneBufferGeometryDescriptor = function (_BufferGeometryDescri) {
	  _inherits(PlaneBufferGeometryDescriptor, _BufferGeometryDescri);
	
	  function PlaneBufferGeometryDescriptor(react3Instance) {
	    _classCallCheck(this, PlaneBufferGeometryDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PlaneBufferGeometryDescriptor).call(this, react3Instance));
	
	    ['width', 'height'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number.isRequired,
	        update: _this.updateCacheAndReplace.bind(_this, propName)
	      });
	    });
	
	    ['widthSegments', 'heightSegments'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number,
	        update: _this.triggerRemount,
	        default: undefined
	      });
	    });
	    return _this;
	  }
	
	  _createClass(PlaneBufferGeometryDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var width = props.width;
	      var height = props.height;
	      var widthSegments = props.widthSegments;
	      var heightSegments = props.heightSegments;
	
	      return new _three2.default.PlaneBufferGeometry(width, height, widthSegments, heightSegments);
	    }
	  }]);
	
	  return PlaneBufferGeometryDescriptor;
	}(_BufferGeometryDescriptorBase2.default);
	
	module.exports = PlaneBufferGeometryDescriptor;

/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _GeometryDescriptorBase = __webpack_require__(16);
	
	var _GeometryDescriptorBase2 = _interopRequireDefault(_GeometryDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var PlaneGeometryDescriptor = function (_GeometryDescriptorBa) {
	  _inherits(PlaneGeometryDescriptor, _GeometryDescriptorBa);
	
	  function PlaneGeometryDescriptor(react3RendererInstance) {
	    _classCallCheck(this, PlaneGeometryDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PlaneGeometryDescriptor).call(this, react3RendererInstance));
	
	    ['width', 'height'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number.isRequired,
	        update: _this.triggerRemount,
	        default: undefined
	      });
	    });
	
	    ['widthSegments', 'heightSegments'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number,
	        update: _this.triggerRemount,
	        default: undefined
	      });
	    });
	    return _this;
	  }
	
	  _createClass(PlaneGeometryDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var width = props.width;
	      var height = props.height;
	      var widthSegments = props.widthSegments;
	      var heightSegments = props.heightSegments;
	
	      return new _three2.default.PlaneGeometry(width, height, widthSegments, heightSegments);
	    }
	  }]);
	
	  return PlaneGeometryDescriptor;
	}(_GeometryDescriptorBase2.default);
	
	module.exports = PlaneGeometryDescriptor;

/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _PolyhedronGeometryDescriptorBase = __webpack_require__(57);
	
	var _PolyhedronGeometryDescriptorBase2 = _interopRequireDefault(_PolyhedronGeometryDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var PolyhedronGeometryDescriptor = function (_PolyhedronGeometryDe) {
	  _inherits(PolyhedronGeometryDescriptor, _PolyhedronGeometryDe);
	
	  function PolyhedronGeometryDescriptor(react3RendererInstance) {
	    _classCallCheck(this, PolyhedronGeometryDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PolyhedronGeometryDescriptor).call(this, react3RendererInstance));
	
	    ['vertices', 'indices'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.arrayOf(_ReactPropTypes2.default.number).isRequired,
	        update: _this.triggerRemount,
	        default: undefined
	      });
	    });
	    return _this;
	  }
	
	  _createClass(PolyhedronGeometryDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var vertices = props.vertices;
	      var indices = props.indices;
	      var radius = props.radius;
	      var detail = props.detail;
	
	      return new _three2.default.PolyhedronGeometry(vertices, indices, radius, detail);
	    }
	  }]);
	
	  return PolyhedronGeometryDescriptor;
	}(_PolyhedronGeometryDescriptorBase2.default);
	
	module.exports = PolyhedronGeometryDescriptor;

/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _GeometryDescriptorBase = __webpack_require__(16);
	
	var _GeometryDescriptorBase2 = _interopRequireDefault(_GeometryDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var RingGeometryDescriptor = function (_GeometryDescriptorBa) {
	  _inherits(RingGeometryDescriptor, _GeometryDescriptorBa);
	
	  function RingGeometryDescriptor(react3RendererInstance) {
	    _classCallCheck(this, RingGeometryDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(RingGeometryDescriptor).call(this, react3RendererInstance));
	
	    ['innerRadius', 'outerRadius', 'thetaSegments', 'phiSegments', 'thetaStart', 'thetaLength'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number,
	        update: _this.triggerRemount,
	        default: undefined
	      });
	    });
	    return _this;
	  }
	
	  _createClass(RingGeometryDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var innerRadius = props.innerRadius;
	      var outerRadius = props.outerRadius;
	      var thetaSegments = props.thetaSegments;
	      var phiSegments = props.phiSegments;
	      var thetaStart = props.thetaStart;
	      var thetaLength = props.thetaLength;
	
	      return new _three2.default.RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength);
	    }
	  }]);
	
	  return RingGeometryDescriptor;
	}(_GeometryDescriptorBase2.default);
	
	module.exports = RingGeometryDescriptor;

/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _ShapeActionDescriptorBase = __webpack_require__(29);
	
	var _ShapeActionDescriptorBase2 = _interopRequireDefault(_ShapeActionDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _AbsArcAction = __webpack_require__(356);
	
	var _AbsArcAction2 = _interopRequireDefault(_AbsArcAction);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var AbsArcDescriptor = function (_ShapeActionDescripto) {
	  _inherits(AbsArcDescriptor, _ShapeActionDescripto);
	
	  function AbsArcDescriptor(react3RendererInstance) {
	    _classCallCheck(this, AbsArcDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AbsArcDescriptor).call(this, react3RendererInstance));
	
	    ['x', 'y', 'radius', 'startAngle', 'endAngle'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number.isRequired,
	        update: _this.triggerRemount,
	        default: 0
	      });
	    });
	
	    _this.hasProp('clockwise', {
	      type: _ReactPropTypes2.default.bool.isRequired,
	      update: _this.triggerRemount,
	      default: false
	    });
	    return _this;
	  }
	
	  _createClass(AbsArcDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var x = props.x;
	      var y = props.y;
	      var radius = props.radius;
	      var startAngle = props.startAngle;
	      var endAngle = props.endAngle;
	      var clockwise = props.clockwise;
	
	      return new _AbsArcAction2.default(x, y, radius, startAngle, endAngle, clockwise);
	    }
	  }]);
	
	  return AbsArcDescriptor;
	}(_ShapeActionDescriptorBase2.default);
	
	module.exports = AbsArcDescriptor;

/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _ShapeActionDescriptorBase = __webpack_require__(29);
	
	var _ShapeActionDescriptorBase2 = _interopRequireDefault(_ShapeActionDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _AbsEllipseAction = __webpack_require__(357);
	
	var _AbsEllipseAction2 = _interopRequireDefault(_AbsEllipseAction);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var AbsEllipseDescriptor = function (_ShapeActionDescripto) {
	  _inherits(AbsEllipseDescriptor, _ShapeActionDescripto);
	
	  function AbsEllipseDescriptor(react3RendererInstance) {
	    _classCallCheck(this, AbsEllipseDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AbsEllipseDescriptor).call(this, react3RendererInstance));
	
	    ['x', 'y', 'xRadius', 'yRadius', 'startAngle', 'endAngle'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number.isRequired,
	        update: _this.triggerRemount,
	        default: 0
	      });
	    });
	
	    _this.hasProp('clockwise', {
	      type: _ReactPropTypes2.default.bool,
	      update: _this.triggerRemount,
	      default: false
	    });
	
	    _this.hasProp('rotation', {
	      type: _ReactPropTypes2.default.number,
	      update: _this.triggerRemount,
	      default: false
	    });
	    return _this;
	  }
	
	  _createClass(AbsEllipseDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var x = props.x;
	      var y = props.y;
	      var xRadius = props.xRadius;
	      var yRadius = props.yRadius;
	      var startAngle = props.startAngle;
	      var endAngle = props.endAngle;
	      var clockwise = props.clockwise;
	      var rotation = props.rotation;
	
	      return new _AbsEllipseAction2.default(x, y, xRadius, yRadius, startAngle, endAngle, clockwise, rotation);
	    }
	  }]);
	
	  return AbsEllipseDescriptor;
	}(_ShapeActionDescriptorBase2.default);
	
	module.exports = AbsEllipseDescriptor;

/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _ShapeActionDescriptorBase = __webpack_require__(29);
	
	var _ShapeActionDescriptorBase2 = _interopRequireDefault(_ShapeActionDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _BezierCurveToAction = __webpack_require__(358);
	
	var _BezierCurveToAction2 = _interopRequireDefault(_BezierCurveToAction);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var BezierCurveToDescriptor = function (_ShapeActionDescripto) {
	  _inherits(BezierCurveToDescriptor, _ShapeActionDescripto);
	
	  function BezierCurveToDescriptor(react3RendererInstance) {
	    _classCallCheck(this, BezierCurveToDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(BezierCurveToDescriptor).call(this, react3RendererInstance));
	
	    ['cp1X', 'cp1Y', 'cp2X', 'cp2Y', 'aX', 'aY'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number.isRequired,
	        update: _this.triggerRemount,
	        default: 0
	      });
	    });
	    return _this;
	  }
	
	  _createClass(BezierCurveToDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var cp1X = props.cp1X;
	      var cp1Y = props.cp1Y;
	      var cp2X = props.cp2X;
	      var cp2Y = props.cp2Y;
	      var aX = props.aX;
	      var aY = props.aY;
	
	      return new _BezierCurveToAction2.default(cp1X, cp1Y, cp2X, cp2Y, aX, aY);
	    }
	  }]);
	
	  return BezierCurveToDescriptor;
	}(_ShapeActionDescriptorBase2.default);
	
	module.exports = BezierCurveToDescriptor;

/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _PathDescriptorBase2 = __webpack_require__(243);
	
	var _PathDescriptorBase3 = _interopRequireDefault(_PathDescriptorBase2);
	
	var _HoleAction = __webpack_require__(241);
	
	var _HoleAction2 = _interopRequireDefault(_HoleAction);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var HoleDescriptor = function (_PathDescriptorBase) {
	  _inherits(HoleDescriptor, _PathDescriptorBase);
	
	  function HoleDescriptor() {
	    _classCallCheck(this, HoleDescriptor);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(HoleDescriptor).apply(this, arguments));
	  }
	
	  _createClass(HoleDescriptor, [{
	    key: 'construct',
	    value: function construct() {
	      return new _HoleAction2.default();
	    }
	  }, {
	    key: 'performChildAction',
	    value: function performChildAction(threeObject, child) {
	      child.performAction(threeObject.path);
	    }
	  }, {
	    key: 'setParent',
	    value: function setParent(threeObject, parentObject3D) {
	      (0, _invariant2.default)(parentObject3D instanceof _three2.default.Shape, 'Holes can only be added to shapes.');
	
	      return _get(Object.getPrototypeOf(HoleDescriptor.prototype), 'setParent', this).call(this, threeObject, parentObject3D);
	    }
	  }]);
	
	  return HoleDescriptor;
	}(_PathDescriptorBase3.default);
	
	module.exports = HoleDescriptor;

/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _ShapeActionDescriptorBase = __webpack_require__(29);
	
	var _ShapeActionDescriptorBase2 = _interopRequireDefault(_ShapeActionDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _LineToAction = __webpack_require__(359);
	
	var _LineToAction2 = _interopRequireDefault(_LineToAction);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var LineToDescriptor = function (_ShapeActionDescripto) {
	  _inherits(LineToDescriptor, _ShapeActionDescripto);
	
	  function LineToDescriptor(react3RendererInstance) {
	    _classCallCheck(this, LineToDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(LineToDescriptor).call(this, react3RendererInstance));
	
	    ['x', 'y'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number.isRequired,
	        update: _this.triggerRemount,
	        default: 0
	      });
	    });
	    return _this;
	  }
	
	  _createClass(LineToDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      return new _LineToAction2.default(props.x, props.y);
	    }
	  }]);
	
	  return LineToDescriptor;
	}(_ShapeActionDescriptorBase2.default);
	
	module.exports = LineToDescriptor;

/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _ShapeActionDescriptorBase = __webpack_require__(29);
	
	var _ShapeActionDescriptorBase2 = _interopRequireDefault(_ShapeActionDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _MoveToAction = __webpack_require__(360);
	
	var _MoveToAction2 = _interopRequireDefault(_MoveToAction);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MoveToDescriptor = function (_ShapeActionDescripto) {
	  _inherits(MoveToDescriptor, _ShapeActionDescripto);
	
	  function MoveToDescriptor(react3RendererInstance) {
	    _classCallCheck(this, MoveToDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MoveToDescriptor).call(this, react3RendererInstance));
	
	    ['x', 'y'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number.isRequired,
	        update: _this.triggerRemount,
	        default: 0
	      });
	    });
	    return _this;
	  }
	
	  _createClass(MoveToDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      return new _MoveToAction2.default(props.x, props.y);
	    }
	  }]);
	
	  return MoveToDescriptor;
	}(_ShapeActionDescriptorBase2.default);
	
	module.exports = MoveToDescriptor;

/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _ShapeActionDescriptorBase = __webpack_require__(29);
	
	var _ShapeActionDescriptorBase2 = _interopRequireDefault(_ShapeActionDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _QuadraticCurveToAction = __webpack_require__(361);
	
	var _QuadraticCurveToAction2 = _interopRequireDefault(_QuadraticCurveToAction);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var QuadraticCurveToDescriptor = function (_ShapeActionDescripto) {
	  _inherits(QuadraticCurveToDescriptor, _ShapeActionDescripto);
	
	  function QuadraticCurveToDescriptor(react3RendererInstance) {
	    _classCallCheck(this, QuadraticCurveToDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(QuadraticCurveToDescriptor).call(this, react3RendererInstance));
	
	    ['cpX', 'cpY', 'x', 'y'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number.isRequired,
	        update: _this.triggerRemount,
	        default: 0
	      });
	    });
	    return _this;
	  }
	
	  _createClass(QuadraticCurveToDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var cpX = props.cpX;
	      var cpY = props.cpY;
	      var x = props.x;
	      var y = props.y;
	
	      return new _QuadraticCurveToAction2.default(cpX, cpY, x, y);
	    }
	  }]);
	
	  return QuadraticCurveToDescriptor;
	}(_ShapeActionDescriptorBase2.default);
	
	module.exports = QuadraticCurveToDescriptor;

/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _class;
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _PathDescriptorBase2 = __webpack_require__(243);
	
	var _PathDescriptorBase3 = _interopRequireDefault(_PathDescriptorBase2);
	
	var _resource = __webpack_require__(60);
	
	var _resource2 = _interopRequireDefault(_resource);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ShapeDescriptor = (0, _resource2.default)(_class = function (_PathDescriptorBase) {
	  _inherits(ShapeDescriptor, _PathDescriptorBase);
	
	  function ShapeDescriptor() {
	    _classCallCheck(this, ShapeDescriptor);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(ShapeDescriptor).apply(this, arguments));
	  }
	
	  _createClass(ShapeDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      if (props.hasOwnProperty('points')) {
	        return new _three2.default.Shape(props.points);
	      }
	
	      return new _three2.default.Shape();
	    }
	  }]);
	
	  return ShapeDescriptor;
	}(_PathDescriptorBase3.default)) || _class;
	
	module.exports = ShapeDescriptor;

/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ShapeActionDescriptorBase = __webpack_require__(29);
	
	var _ShapeActionDescriptorBase2 = _interopRequireDefault(_ShapeActionDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _SplineThruAction = __webpack_require__(362);
	
	var _SplineThruAction2 = _interopRequireDefault(_SplineThruAction);
	
	var _propTypeInstanceOf = __webpack_require__(17);
	
	var _propTypeInstanceOf2 = _interopRequireDefault(_propTypeInstanceOf);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var SplineThruDescriptor = function (_ShapeActionDescripto) {
	  _inherits(SplineThruDescriptor, _ShapeActionDescripto);
	
	  function SplineThruDescriptor(react3RendererInstance) {
	    _classCallCheck(this, SplineThruDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SplineThruDescriptor).call(this, react3RendererInstance));
	
	    _this.hasProp('points', {
	      type: _ReactPropTypes2.default.arrayOf((0, _propTypeInstanceOf2.default)(_three2.default.Vector2)).isRequired,
	      update: _this.triggerRemount,
	      default: []
	    });
	    return _this;
	  }
	
	  _createClass(SplineThruDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      return new _SplineThruAction2.default(props.points);
	    }
	  }]);
	
	  return SplineThruDescriptor;
	}(_ShapeActionDescriptorBase2.default);
	
	module.exports = SplineThruDescriptor;

/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _BufferGeometryDescriptorBase = __webpack_require__(101);
	
	var _BufferGeometryDescriptorBase2 = _interopRequireDefault(_BufferGeometryDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var SphereGeometryDescriptor = function (_BufferGeometryDescri) {
	  _inherits(SphereGeometryDescriptor, _BufferGeometryDescri);
	
	  function SphereGeometryDescriptor(react3Instance) {
	    _classCallCheck(this, SphereGeometryDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SphereGeometryDescriptor).call(this, react3Instance));
	
	    _this.hasProp('radius', {
	      type: _ReactPropTypes2.default.number,
	      update: _this.updateCacheAndReplace.bind(_this, 'radius'),
	      default: undefined
	    });
	
	    ['widthSegments', 'heightSegments'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number,
	        update: _this.triggerRemount,
	        default: undefined
	      });
	    });
	
	    ['phiStart', 'phiLength', 'thetaStart', 'thetaLength'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number,
	        update: _this.updateCacheAndReplace.bind(_this, propName),
	        default: undefined
	      });
	    });
	    return _this;
	  }
	
	  _createClass(SphereGeometryDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var radius = props.radius;
	      var widthSegments = props.widthSegments;
	      var heightSegments = props.heightSegments;
	      var phiStart = props.phiStart;
	      var phiLength = props.phiLength;
	      var thetaStart = props.thetaStart;
	      var thetaLength = props.thetaLength;
	
	      return new _three2.default.SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength);
	    }
	  }]);
	
	  return SphereGeometryDescriptor;
	}(_BufferGeometryDescriptorBase2.default);
	
	module.exports = SphereGeometryDescriptor;

/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _PolyhedronGeometryDescriptorBase = __webpack_require__(57);
	
	var _PolyhedronGeometryDescriptorBase2 = _interopRequireDefault(_PolyhedronGeometryDescriptorBase);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var TetrahedronGeometryDescriptor = function (_PolyhedronGeometryDe) {
	  _inherits(TetrahedronGeometryDescriptor, _PolyhedronGeometryDe);
	
	  function TetrahedronGeometryDescriptor() {
	    _classCallCheck(this, TetrahedronGeometryDescriptor);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(TetrahedronGeometryDescriptor).apply(this, arguments));
	  }
	
	  _createClass(TetrahedronGeometryDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var radius = props.radius;
	      var detail = props.detail;
	
	      return new _three2.default.TetrahedronGeometry(radius, detail);
	    }
	  }]);
	
	  return TetrahedronGeometryDescriptor;
	}(_PolyhedronGeometryDescriptorBase2.default);
	
	module.exports = TetrahedronGeometryDescriptor;

/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _GeometryDescriptorBase = __webpack_require__(16);
	
	var _GeometryDescriptorBase2 = _interopRequireDefault(_GeometryDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var TorusGeometryDescriptor = function (_GeometryDescriptorBa) {
	  _inherits(TorusGeometryDescriptor, _GeometryDescriptorBa);
	
	  function TorusGeometryDescriptor(react3RendererInstance) {
	    _classCallCheck(this, TorusGeometryDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TorusGeometryDescriptor).call(this, react3RendererInstance));
	
	    ['radius', 'tube', 'radialSegments', 'tubularSegments', 'arc'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number,
	        update: _this.triggerRemount,
	        default: undefined
	      });
	    });
	    return _this;
	  }
	
	  _createClass(TorusGeometryDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var radius = props.radius;
	      var tube = props.tube;
	      var radialSegments = props.radialSegments;
	      var tubularSegments = props.tubularSegments;
	      var arc = props.arc;
	
	      return new _three2.default.TorusGeometry(radius, tube, radialSegments, tubularSegments, arc);
	    }
	  }]);
	
	  return TorusGeometryDescriptor;
	}(_GeometryDescriptorBase2.default);
	
	module.exports = TorusGeometryDescriptor;

/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _GeometryDescriptorBase = __webpack_require__(16);
	
	var _GeometryDescriptorBase2 = _interopRequireDefault(_GeometryDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var TorusKnotGeometryDescriptor = function (_GeometryDescriptorBa) {
	  _inherits(TorusKnotGeometryDescriptor, _GeometryDescriptorBa);
	
	  function TorusKnotGeometryDescriptor(react3RendererInstance) {
	    _classCallCheck(this, TorusKnotGeometryDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TorusKnotGeometryDescriptor).call(this, react3RendererInstance));
	
	    ['radius', 'tube', 'radialSegments', 'tubularSegments', 'p', 'q', 'heightScale'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number,
	        update: _this.triggerRemount,
	        default: undefined
	      });
	    });
	    return _this;
	  }
	
	  _createClass(TorusKnotGeometryDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var radius = props.radius;
	      var tube = props.tube;
	      var radialSegments = props.radialSegments;
	      var tubularSegments = props.tubularSegments;
	      var p = props.p;
	      var q = props.q;
	      var heightScale = props.heightScale;
	
	      return new _three2.default.TorusKnotGeometry(radius, tube, radialSegments, tubularSegments, p, q, heightScale);
	    }
	  }]);
	
	  return TorusKnotGeometryDescriptor;
	}(_GeometryDescriptorBase2.default);
	
	module.exports = TorusKnotGeometryDescriptor;

/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _LightDescriptorBase2 = __webpack_require__(58);
	
	var _LightDescriptorBase3 = _interopRequireDefault(_LightDescriptorBase2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var AmbientLightDescriptor = function (_LightDescriptorBase) {
	  _inherits(AmbientLightDescriptor, _LightDescriptorBase);
	
	  function AmbientLightDescriptor(react3Instance) {
	    _classCallCheck(this, AmbientLightDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AmbientLightDescriptor).call(this, react3Instance));
	
	    _this.hasColor();
	    return _this;
	  }
	
	  _createClass(AmbientLightDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var color = props.color;
	
	      return new _three2.default.AmbientLight(color);
	    }
	  }]);
	
	  return AmbientLightDescriptor;
	}(_LightDescriptorBase3.default);
	
	module.exports = AmbientLightDescriptor;

/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _LightDescriptorBase2 = __webpack_require__(58);
	
	var _LightDescriptorBase3 = _interopRequireDefault(_LightDescriptorBase2);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var DirectionalLightDescriptor = function (_LightDescriptorBase) {
	  _inherits(DirectionalLightDescriptor, _LightDescriptorBase);
	
	  function DirectionalLightDescriptor(react3Instance) {
	    _classCallCheck(this, DirectionalLightDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(DirectionalLightDescriptor).call(this, react3Instance));
	
	    _this.hasProp('intensity', {
	      type: _ReactPropTypes2.default.number,
	      simple: true,
	      default: 1
	    });
	
	    ['shadowCameraLeft', 'shadowCameraBottom'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number,
	        updateInitial: true,
	        update: function update(threeObject, value, hasProp) {
	          if (hasProp) {
	            threeObject[propName] = value;
	          }
	          // threeObject.shadow.camera.updateProjectionMatrix();
	        },
	
	        default: -500
	      });
	    });
	
	    ['shadowCameraRight', 'shadowCameraTop'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number,
	        updateInitial: true,
	        update: function update(threeObject, value, hasProp) {
	          if (hasProp) {
	            threeObject[propName] = value;
	          }
	          // threeObject.shadow.camera.updateProjectionMatrix();
	        },
	
	        default: 500
	      });
	    });
	
	    _this.hasColor();
	    return _this;
	  }
	
	  _createClass(DirectionalLightDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var color = props.color;
	      var intensity = props.intensity;
	
	      return new _three2.default.DirectionalLight(color, intensity);
	    }
	  }, {
	    key: 'unmount',
	    value: function unmount(threeObject) {
	      _get(Object.getPrototypeOf(DirectionalLightDescriptor.prototype), 'unmount', this).call(this, threeObject);
	    }
	  }]);
	
	  return DirectionalLightDescriptor;
	}(_LightDescriptorBase3.default);
	
	module.exports = DirectionalLightDescriptor;

/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _LightDescriptorBase2 = __webpack_require__(58);
	
	var _LightDescriptorBase3 = _interopRequireDefault(_LightDescriptorBase2);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var PointLightDescriptor = function (_LightDescriptorBase) {
	  _inherits(PointLightDescriptor, _LightDescriptorBase);
	
	  function PointLightDescriptor(react3Instance) {
	    _classCallCheck(this, PointLightDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PointLightDescriptor).call(this, react3Instance));
	
	    _this.hasColor();
	
	    ['intensity', 'decay'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number,
	        simple: true,
	        default: 1
	      });
	    });
	
	    _this.hasProp('distance', {
	      type: _ReactPropTypes2.default.number,
	      simple: true,
	      default: 0
	    });
	    return _this;
	  }
	
	  _createClass(PointLightDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var color = props.color;
	      var intensity = props.intensity;
	      var distance = props.distance;
	      var decay = props.decay;
	
	      return new _three2.default.PointLight(color, intensity, distance, decay);
	    }
	  }]);
	
	  return PointLightDescriptor;
	}(_LightDescriptorBase3.default);
	
	module.exports = PointLightDescriptor;

/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _LightDescriptorBase2 = __webpack_require__(58);
	
	var _LightDescriptorBase3 = _interopRequireDefault(_LightDescriptorBase2);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var SpotLightDescriptor = function (_LightDescriptorBase) {
	  _inherits(SpotLightDescriptor, _LightDescriptorBase);
	
	  function SpotLightDescriptor(react3Instance) {
	    _classCallCheck(this, SpotLightDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SpotLightDescriptor).call(this, react3Instance));
	
	    var defaults = [1, 0, Math.PI / 3, 10, 1];
	
	    ['intensity', 'distance', 'angle', 'exponent', 'decay'].forEach(function (propName, i) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number,
	        simple: true,
	        default: defaults[i]
	      });
	    });
	
	    _this.hasProp('shadowCameraFov', {
	      type: _ReactPropTypes2.default.number,
	      updateInitial: true,
	      update: function update(threeObject, value, hasProp) {
	        if (hasProp) {
	          threeObject.shadow.camera.fov = value;
	        }
	      },
	
	      default: 50
	    });
	
	    _this.hasColor();
	    return _this;
	  }
	
	  _createClass(SpotLightDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var color = props.color;
	      var intensity = props.intensity;
	      var distance = props.distance;
	      var angle = props.angle;
	      var exponent = props.exponent;
	      var decay = props.decay;
	
	      return new _three2.default.SpotLight(color, intensity, distance, angle, exponent, decay);
	    }
	  }]);
	
	  return SpotLightDescriptor;
	}(_LightDescriptorBase3.default);
	
	module.exports = SpotLightDescriptor;

/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _MaterialDescriptorBase = __webpack_require__(21);
	
	var _MaterialDescriptorBase2 = _interopRequireDefault(_MaterialDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var LineBasicMaterialDescriptor = function (_MaterialDescriptorBa) {
	  _inherits(LineBasicMaterialDescriptor, _MaterialDescriptorBa);
	
	  function LineBasicMaterialDescriptor(react3RendererInstance) {
	    _classCallCheck(this, LineBasicMaterialDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(LineBasicMaterialDescriptor).call(this, react3RendererInstance));
	
	    _this.hasColor();
	
	    _this.hasProp('linewidth', {
	      type: _ReactPropTypes2.default.number,
	      simple: true,
	      default: 1
	    });
	
	    // what are these properties used for?
	    ['linecap', 'linejoin'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.oneOf(['round']),
	        simple: true,
	        default: 'round'
	      });
	    });
	
	    _this.hasProp('vertexColors', {
	      type: _ReactPropTypes2.default.oneOf([_three2.default.NoColors, _three2.default.FaceColors, _three2.default.VertexColors]),
	      simple: true,
	      default: _three2.default.NoColors
	    });
	
	    _this.hasProp('fog', {
	      type: _ReactPropTypes2.default.bool,
	      update: function update(threeObject, fog, existsInProps) {
	        if (existsInProps) {
	          threeObject.fog = fog;
	        }
	        threeObject.needsUpdate = true;
	      },
	
	      updateInitial: true,
	      default: true
	    });
	    return _this;
	  }
	
	  _createClass(LineBasicMaterialDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var materialDescription = this.getMaterialDescription(props);
	
	      return new _three2.default.LineBasicMaterial(materialDescription);
	    }
	  }]);
	
	  return LineBasicMaterialDescriptor;
	}(_MaterialDescriptorBase2.default);
	
	module.exports = LineBasicMaterialDescriptor;

/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _MaterialDescriptorBase = __webpack_require__(21);
	
	var _MaterialDescriptorBase2 = _interopRequireDefault(_MaterialDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var LineDashedMaterialDescriptor = function (_MaterialDescriptorBa) {
	  _inherits(LineDashedMaterialDescriptor, _MaterialDescriptorBa);
	
	  function LineDashedMaterialDescriptor(react3RendererInstance) {
	    _classCallCheck(this, LineDashedMaterialDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(LineDashedMaterialDescriptor).call(this, react3RendererInstance));
	
	    _this.hasColor();
	
	    ['linewidth', 'scale', 'gapSize'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number,
	        simple: true,
	        default: 1
	      });
	    });
	
	    _this.hasProp('dashSize', {
	      type: _ReactPropTypes2.default.number,
	      simple: true,
	      default: 3
	    });
	
	    // what are these properties used for?
	    ['linecap', 'linejoin'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.oneOf(['round']),
	        simple: true,
	        default: 'round'
	      });
	    });
	
	    _this.hasProp('vertexColors', {
	      type: _ReactPropTypes2.default.oneOf([_three2.default.NoColors, _three2.default.FaceColors, _three2.default.VertexColors]),
	      simple: true,
	      default: _three2.default.NoColors
	    });
	
	    _this.hasProp('fog', {
	      type: _ReactPropTypes2.default.bool,
	      update: function update(threeObject, fog, existsInProps) {
	        if (existsInProps) {
	          threeObject.fog = fog;
	        }
	        threeObject.needsUpdate = true;
	      },
	
	      updateInitial: true,
	      default: true
	    });
	    return _this;
	  }
	
	  _createClass(LineDashedMaterialDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var materialDescription = this.getMaterialDescription(props);
	
	      return new _three2.default.LineDashedMaterial(materialDescription);
	    }
	  }]);
	
	  return LineDashedMaterialDescriptor;
	}(_MaterialDescriptorBase2.default);
	
	module.exports = LineDashedMaterialDescriptor;

/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _MaterialDescriptorBase = __webpack_require__(21);
	
	var _MaterialDescriptorBase2 = _interopRequireDefault(_MaterialDescriptorBase);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MeshBasicMaterialDescriptor = function (_MaterialDescriptorBa) {
	  _inherits(MeshBasicMaterialDescriptor, _MaterialDescriptorBa);
	
	  function MeshBasicMaterialDescriptor(react3RendererInstance) {
	    _classCallCheck(this, MeshBasicMaterialDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MeshBasicMaterialDescriptor).call(this, react3RendererInstance));
	
	    _this.hasColor();
	    _this.hasWireframe();
	    return _this;
	  }
	
	  _createClass(MeshBasicMaterialDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var materialDescription = this.getMaterialDescription(props);
	
	      if (props.hasOwnProperty('map')) {
	        materialDescription.map = props.map;
	      }
	
	      return new _three2.default.MeshBasicMaterial(materialDescription);
	    }
	  }]);
	
	  return MeshBasicMaterialDescriptor;
	}(_MaterialDescriptorBase2.default);
	
	module.exports = MeshBasicMaterialDescriptor;

/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _MaterialDescriptorBase = __webpack_require__(21);
	
	var _MaterialDescriptorBase2 = _interopRequireDefault(_MaterialDescriptorBase);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MeshDepthMaterialDescriptor = function (_MaterialDescriptorBa) {
	  _inherits(MeshDepthMaterialDescriptor, _MaterialDescriptorBa);
	
	  function MeshDepthMaterialDescriptor(react3RendererInstance) {
	    _classCallCheck(this, MeshDepthMaterialDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MeshDepthMaterialDescriptor).call(this, react3RendererInstance));
	
	    _this.hasWireframe();
	    return _this;
	  }
	
	  _createClass(MeshDepthMaterialDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var materialDescription = this.getMaterialDescription(props);
	
	      return new _three2.default.MeshDepthMaterial(materialDescription);
	    }
	  }]);
	
	  return MeshDepthMaterialDescriptor;
	}(_MaterialDescriptorBase2.default);
	
	module.exports = MeshDepthMaterialDescriptor;

/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _MaterialDescriptorBase = __webpack_require__(21);
	
	var _MaterialDescriptorBase2 = _interopRequireDefault(_MaterialDescriptorBase);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MeshLambertMaterialDescriptor = function (_MaterialDescriptorBa) {
	  _inherits(MeshLambertMaterialDescriptor, _MaterialDescriptorBa);
	
	  function MeshLambertMaterialDescriptor(react3RendererInstance) {
	    _classCallCheck(this, MeshLambertMaterialDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MeshLambertMaterialDescriptor).call(this, react3RendererInstance));
	
	    _this.hasColor();
	    _this.hasColor('emissive', 0);
	    _this.hasWireframe();
	    return _this;
	  }
	
	  _createClass(MeshLambertMaterialDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var materialDescription = this.getMaterialDescription(props);
	
	      return new _three2.default.MeshLambertMaterial(materialDescription);
	    }
	  }, {
	    key: 'getMaterialDescription',
	    value: function getMaterialDescription(props) {
	      var materialDescription = _get(Object.getPrototypeOf(MeshLambertMaterialDescriptor.prototype), 'getMaterialDescription', this).call(this, props);
	
	      if (props.hasOwnProperty('shininess')) {
	        materialDescription.shininess = props.shininess;
	      }
	
	      if (props.hasOwnProperty('map')) {
	        materialDescription.map = props.map;
	      }
	
	      return materialDescription;
	    }
	  }, {
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(MeshLambertMaterialDescriptor.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	
	      if (!props.hasOwnProperty('map')) {
	        threeObject.map = undefined;
	      }
	    }
	  }]);
	
	  return MeshLambertMaterialDescriptor;
	}(_MaterialDescriptorBase2.default);
	
	module.exports = MeshLambertMaterialDescriptor;

/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _MaterialDescriptorBase = __webpack_require__(21);
	
	var _MaterialDescriptorBase2 = _interopRequireDefault(_MaterialDescriptorBase);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MeshNormalMaterialDescriptor = function (_MaterialDescriptorBa) {
	  _inherits(MeshNormalMaterialDescriptor, _MaterialDescriptorBa);
	
	  function MeshNormalMaterialDescriptor(react3RendererInstance) {
	    _classCallCheck(this, MeshNormalMaterialDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MeshNormalMaterialDescriptor).call(this, react3RendererInstance));
	
	    _this.hasWireframe();
	    return _this;
	  }
	
	  _createClass(MeshNormalMaterialDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var materialDescription = this.getMaterialDescription(props);
	
	      return new _three2.default.MeshNormalMaterial(materialDescription);
	    }
	  }]);
	
	  return MeshNormalMaterialDescriptor;
	}(_MaterialDescriptorBase2.default);
	
	module.exports = MeshNormalMaterialDescriptor;

/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _MaterialDescriptorBase = __webpack_require__(21);
	
	var _MaterialDescriptorBase2 = _interopRequireDefault(_MaterialDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MeshPhongMaterialDescriptor = function (_MaterialDescriptorBa) {
	  _inherits(MeshPhongMaterialDescriptor, _MaterialDescriptorBa);
	
	  function MeshPhongMaterialDescriptor(react3RendererInstance) {
	    _classCallCheck(this, MeshPhongMaterialDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MeshPhongMaterialDescriptor).call(this, react3RendererInstance));
	
	    _this.propTypes = _extends({}, _this.propTypes, {
	
	      side: _ReactPropTypes2.default.number
	    });
	
	    _this.hasColor();
	    _this.hasColor('specular', 0x111111);
	    _this.hasColor('emissive', 0x000000);
	    _this.hasWireframe();
	
	    _this.hasProp('shininess', {
	      type: _ReactPropTypes2.default.number,
	      simple: true,
	      default: 30
	    });
	
	    _this.hasProp('metal', {
	      type: _ReactPropTypes2.default.bool,
	      update: function update(threeObject, metal) {
	        threeObject.metal = metal;
	        threeObject.needsUpdate = true;
	      },
	      default: false
	    });
	    return _this;
	  }
	
	  _createClass(MeshPhongMaterialDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var materialDescription = this.getMaterialDescription(props);
	
	      if (props.hasOwnProperty('shininess')) {
	        materialDescription.shininess = props.shininess;
	      }
	
	      return new _three2.default.MeshPhongMaterial(materialDescription);
	    }
	  }]);
	
	  return MeshPhongMaterialDescriptor;
	}(_MaterialDescriptorBase2.default);
	
	module.exports = MeshPhongMaterialDescriptor;

/***/ },
/* 401 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _MaterialDescriptorBase = __webpack_require__(21);
	
	var _MaterialDescriptorBase2 = _interopRequireDefault(_MaterialDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var PointsMaterialDescriptor = function (_MaterialDescriptorBa) {
	  _inherits(PointsMaterialDescriptor, _MaterialDescriptorBa);
	
	  function PointsMaterialDescriptor(react3RendererInstance) {
	    _classCallCheck(this, PointsMaterialDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PointsMaterialDescriptor).call(this, react3RendererInstance));
	
	    _this.hasColor();
	
	    _this.hasProp('size', {
	      type: _ReactPropTypes2.default.number,
	      simple: true,
	      default: 1
	    });
	
	    _this.hasProp('sizeAttenuation', {
	      type: _ReactPropTypes2.default.bool,
	      update: function update(threeObject, sizeAttenuation, existsInProps) {
	        if (existsInProps) {
	          threeObject.sizeAttenuation = sizeAttenuation;
	        }
	        threeObject.needsUpdate = true;
	      },
	
	      updateInitial: true,
	      default: true
	    });
	
	    _this.hasProp('fog', {
	      type: _ReactPropTypes2.default.bool,
	      update: function update(threeObject, fog, existsInProps) {
	        if (existsInProps) {
	          threeObject.fog = fog;
	        }
	        threeObject.needsUpdate = true;
	      },
	
	      updateInitial: true,
	      default: true
	    });
	
	    _this.hasProp('vertexColors', {
	      type: _ReactPropTypes2.default.oneOf([_three2.default.NoColors, _three2.default.FaceColors, _three2.default.VertexColors]),
	      simple: true,
	      default: _three2.default.NoColors
	    });
	    return _this;
	  }
	
	  _createClass(PointsMaterialDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var materialDescription = this.getMaterialDescription(props);
	
	      return new _three2.default.PointsMaterial(materialDescription);
	    }
	  }]);
	
	  return PointsMaterialDescriptor;
	}(_MaterialDescriptorBase2.default);
	
	module.exports = PointsMaterialDescriptor;

/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _MaterialDescriptorBase = __webpack_require__(21);
	
	var _MaterialDescriptorBase2 = _interopRequireDefault(_MaterialDescriptorBase);
	
	var _UniformContainer = __webpack_require__(100);
	
	var _UniformContainer2 = _interopRequireDefault(_UniformContainer);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ShaderMaterialDescriptor = function (_MaterialDescriptorBa) {
	  _inherits(ShaderMaterialDescriptor, _MaterialDescriptorBa);
	
	  function ShaderMaterialDescriptor(react3RendererInstance) {
	    _classCallCheck(this, ShaderMaterialDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ShaderMaterialDescriptor).call(this, react3RendererInstance));
	
	    ['vertexShader', 'fragmentShader'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.string.isRequired,
	        update: _this.triggerRemount
	      });
	    });
	
	    _this.hasWireframe();
	    return _this;
	  }
	
	  _createClass(ShaderMaterialDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var materialDescription = this.getMaterialDescription(props);
	
	      if (props.hasOwnProperty('uniforms')) {
	        materialDescription.uniforms = props.uniforms;
	      }
	
	      if (props.hasOwnProperty('vertexShader')) {
	        materialDescription.vertexShader = props.vertexShader;
	      }
	
	      if (props.hasOwnProperty('fragmentShader')) {
	        materialDescription.fragmentShader = props.fragmentShader;
	      }
	
	      return new _three2.default.ShaderMaterial(materialDescription);
	    }
	  }, {
	    key: 'invalidChildInternal',
	    value: function invalidChildInternal(child) {
	      var invalid = !(child instanceof _UniformContainer2.default || _get(Object.getPrototypeOf(ShaderMaterialDescriptor.prototype), 'invalidChildInternal', this).call(this, child));
	
	      return invalid;
	    }
	  }, {
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(ShaderMaterialDescriptor.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	
	      if (!props.hasOwnProperty('uniforms')) {
	        threeObject.uniforms = undefined;
	      }
	    }
	  }]);
	
	  return ShaderMaterialDescriptor;
	}(_MaterialDescriptorBase2.default);
	
	module.exports = ShaderMaterialDescriptor;

/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _MaterialDescriptorBase = __webpack_require__(21);
	
	var _MaterialDescriptorBase2 = _interopRequireDefault(_MaterialDescriptorBase);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var SpriteMaterialDescriptor = function (_MaterialDescriptorBa) {
	  _inherits(SpriteMaterialDescriptor, _MaterialDescriptorBa);
	
	  function SpriteMaterialDescriptor(react3RendererInstance) {
	    _classCallCheck(this, SpriteMaterialDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SpriteMaterialDescriptor).call(this, react3RendererInstance));
	
	    _this.hasColor();
	
	    _this.hasProp('rotation', {
	      type: _ReactPropTypes2.default.number,
	      simple: true,
	      default: 0
	    });
	
	    _this.hasProp('fog', {
	      type: _ReactPropTypes2.default.bool,
	      update: function update(threeObject, fog, existsInProps) {
	        if (existsInProps) {
	          threeObject.fog = fog;
	        }
	        threeObject.needsUpdate = true;
	      },
	
	      updateInitial: true,
	      default: false
	    });
	    return _this;
	  }
	
	  _createClass(SpriteMaterialDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var materialDescription = this.getMaterialDescription(props);
	
	      return new _three2.default.SpriteMaterial(materialDescription);
	    }
	  }]);
	
	  return SpriteMaterialDescriptor;
	}(_MaterialDescriptorBase2.default);
	
	module.exports = SpriteMaterialDescriptor;

/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _class;
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _THREEElementDescriptor = __webpack_require__(13);
	
	var _THREEElementDescriptor2 = _interopRequireDefault(_THREEElementDescriptor);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _resource = __webpack_require__(60);
	
	var _resource2 = _interopRequireDefault(_resource);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _Uniform = __webpack_require__(56);
	
	var _Uniform2 = _interopRequireDefault(_Uniform);
	
	var _React3Renderer = __webpack_require__(55);
	
	var _React3Renderer2 = _interopRequireDefault(_React3Renderer);
	
	var _propTypeInstanceOf = __webpack_require__(17);
	
	var _propTypeInstanceOf2 = _interopRequireDefault(_propTypeInstanceOf);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var TextureDescriptor = (0, _resource2.default)(_class = function (_THREEElementDescript) {
	  _inherits(TextureDescriptor, _THREEElementDescript);
	
	  function TextureDescriptor(react3RendererInstance) {
	    _classCallCheck(this, TextureDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TextureDescriptor).call(this, react3RendererInstance));
	
	    _this.hasProp('repeat', {
	      type: (0, _propTypeInstanceOf2.default)(_three2.default.Vector2),
	      updateInitial: true,
	      update: function update(threeObject, repeat) {
	        if (repeat) {
	          threeObject.repeat.copy(repeat);
	        } else {
	          threeObject.repeat.set(1, 1);
	        }
	      },
	
	      default: new _three2.default.Vector2(1, 1)
	    });
	
	    _this.hasProp('offset', {
	      type: (0, _propTypeInstanceOf2.default)(_three2.default.Vector2),
	      updateInitial: true,
	      update: function update(threeObject, offset) {
	        if (offset) {
	          threeObject.offset.copy(offset);
	        } else {
	          threeObject.offset.set(0, 0);
	        }
	      },
	
	      default: new _three2.default.Vector2(0, 0)
	    });
	
	    ['wrapS', 'wrapT'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.oneOf([_three2.default.RepeatWrapping, _three2.default.ClampToEdgeWrapping, _three2.default.MirroredRepeatWrapping]),
	        updateInitial: true,
	        update: function update(threeObject, value) {
	          threeObject[propName] = value;
	          if (threeObject.image) {
	            threeObject.needsUpdate = true;
	          }
	        },
	
	        default: _three2.default.ClampToEdgeWrapping
	      });
	    });
	
	    _this.hasProp('anisotropy', {
	      type: _ReactPropTypes2.default.number,
	      updateInitial: true,
	      update: function update(threeObject, value) {
	        threeObject.anisotropy = value;
	        if (threeObject.image) {
	          threeObject.needsUpdate = true;
	        }
	      },
	
	      default: 1
	    });
	
	    _this.hasProp('url', {
	      type: _ReactPropTypes2.default.string.isRequired,
	      update: _this.triggerRemount,
	      default: ''
	    });
	
	    _this.hasProp('crossOrigin', {
	      type: _ReactPropTypes2.default.string,
	      update: _this.triggerRemount,
	      default: undefined
	    });
	
	    ['onLoad', 'onProgress', 'onError'].forEach(function (eventName) {
	      _this.hasProp(eventName, {
	        type: _ReactPropTypes2.default.func
	      });
	    });
	    return _this;
	  }
	
	  _createClass(TextureDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      if (props.hasOwnProperty('url')) {
	        var textureLoader = new _three2.default.TextureLoader();
	
	        if (props.hasOwnProperty('crossOrigin')) {
	          textureLoader.crossOrigin = props.crossOrigin;
	        }
	
	        var onLoad = undefined;
	        var onProgress = undefined;
	        var onError = undefined;
	
	        if (props.hasOwnProperty('onLoad')) {
	          onLoad = props.onLoad;
	        }
	
	        if (props.hasOwnProperty('onProgress')) {
	          onProgress = props.onProgress;
	        }
	
	        if (props.hasOwnProperty('onError')) {
	          onError = props.onError;
	        }
	
	        return textureLoader.load(props.url, onLoad, onProgress, onError);
	      }
	
	      (0, _invariant2.default)(false, 'The texture needs a url property.');
	    }
	  }, {
	    key: 'setParent',
	    value: function setParent(texture, parentObject3D) {
	      (0, _invariant2.default)(parentObject3D instanceof _three2.default.Material || parentObject3D instanceof _Uniform2.default, 'Parent is not a material or a uniform');
	
	      if (parentObject3D instanceof _three2.default.Material) {
	        (0, _invariant2.default)(parentObject3D.map === null || parentObject3D.map === undefined, 'Parent already has a texture');
	        parentObject3D.map = texture;
	        // dispose to force a recreate
	        parentObject3D.needsUpdate = true;
	      } else {
	        // Uniform as per the assert above
	        parentObject3D.setValue(texture);
	      }
	
	      _get(Object.getPrototypeOf(TextureDescriptor.prototype), 'setParent', this).call(this, texture, parentObject3D);
	    }
	  }, {
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      threeObject.userData = _extends({}, threeObject.userData);
	
	      _get(Object.getPrototypeOf(TextureDescriptor.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	    }
	  }, {
	    key: 'unmount',
	    value: function unmount(texture) {
	      var parent = texture.userData.markup.parentMarkup.threeObject;
	
	      // could either be a resource description or an actual texture
	      if (parent instanceof _three2.default.Material) {
	        if (parent.map === texture) {
	          parent.map = null;
	          // dispose to force a recreate
	          parent.needsUpdate = true;
	        }
	      } else if (parent instanceof _Uniform2.default) {
	        if (parent.value === texture) {
	          parent.setValue(null);
	        }
	      }
	
	      texture.dispose();
	
	      _get(Object.getPrototypeOf(TextureDescriptor.prototype), 'unmount', this).call(this, texture);
	    }
	  }, {
	    key: 'highlight',
	    value: function highlight(threeObject) {
	      var parent = threeObject.userData.markup.parentMarkup.threeObject;
	      parent.userData._descriptor.highlight(parent);
	    }
	  }, {
	    key: 'hideHighlight',
	    value: function hideHighlight(threeObject) {
	      var parent = threeObject.userData.markup.parentMarkup.threeObject;
	      parent.userData._descriptor.hideHighlight(parent);
	    }
	  }]);
	
	  return TextureDescriptor;
	}(_THREEElementDescriptor2.default)) || _class;
	
	module.exports = TextureDescriptor;

/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _THREEElementDescriptor = __webpack_require__(13);
	
	var _THREEElementDescriptor2 = _interopRequireDefault(_THREEElementDescriptor);
	
	var _Uniform = __webpack_require__(56);
	
	var _Uniform2 = _interopRequireDefault(_Uniform);
	
	var _UniformContainer = __webpack_require__(100);
	
	var _UniformContainer2 = _interopRequireDefault(_UniformContainer);
	
	var _ResourceReference = __webpack_require__(41);
	
	var _ResourceReference2 = _interopRequireDefault(_ResourceReference);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var UniformDescriptor = function (_THREEElementDescript) {
	  _inherits(UniformDescriptor, _THREEElementDescript);
	
	  function UniformDescriptor(react3Instance) {
	    _classCallCheck(this, UniformDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(UniformDescriptor).call(this, react3Instance));
	
	    _this._invalidChild = function (child) {
	      return _this.invalidChildInternal(child);
	    };
	
	    _this.hasProp('type', {
	      type: _ReactPropTypes2.default.string.isRequired,
	      simple: true
	    });
	
	    _this.hasProp('value', {
	      type: _ReactPropTypes2.default.any,
	      update: function update(threeObject, value) {
	        threeObject.setValue(value);
	      },
	
	      default: null
	    });
	
	    _this.hasProp('name', {
	      type: _ReactPropTypes2.default.string.isRequired
	    });
	    return _this;
	  }
	
	  _createClass(UniformDescriptor, [{
	    key: 'construct',
	    value: function construct() {
	      return new _Uniform2.default();
	    }
	  }, {
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(UniformDescriptor.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	
	      (0, _invariant2.default)(props.hasOwnProperty('name'), 'The <uniform/> should have a \'name\' property');
	      threeObject.name = props.name;
	      threeObject.value = props.value;
	    }
	  }, {
	    key: 'setParent',
	    value: function setParent(threeObject, parentObject3D) {
	      (0, _invariant2.default)(parentObject3D instanceof _UniformContainer2.default, 'Parent is not a Uniform Container (<uniforms/>)');
	
	      var name = threeObject.name;
	
	      (0, _invariant2.default)(parentObject3D[name] === undefined, 'Parent already has uniforms');
	
	      _get(Object.getPrototypeOf(UniformDescriptor.prototype), 'setParent', this).call(this, threeObject, parentObject3D);
	
	      parentObject3D.uniforms[name] = {
	        type: threeObject.type,
	        value: threeObject.value
	      };
	
	      threeObject.userData._onValueChanged = function (newValue) {
	        parentObject3D.uniforms[name].value = newValue;
	      };
	
	      threeObject.userData.events.on('valueChanged', threeObject.userData._onValueChanged);
	    }
	  }, {
	    key: 'addChildren',
	    value: function addChildren(threeObject, children) {
	      (0, _invariant2.default)(children.filter(this._invalidChild).length === 0, 'Uniform children can only be textures or resource references');
	    }
	  }, {
	    key: 'addChild',
	    value: function addChild(threeObject, child) {
	      this.addChildren(threeObject, [child]);
	    }
	  }, {
	    key: 'removeChild',
	    value: function removeChild() {
	      // do nothing
	    }
	  }, {
	    key: 'invalidChildInternal',
	    value: function invalidChildInternal(child) {
	      var invalid = !(child instanceof _three2.default.Texture || child instanceof _ResourceReference2.default);
	
	      return invalid;
	    }
	  }, {
	    key: 'unmount',
	    value: function unmount(threeObject) {
	      threeObject.userData.events.removeListener('valueChanged', threeObject.userData._onValueChanged);
	
	      delete threeObject.userData._onValueChanged;
	
	      _get(Object.getPrototypeOf(UniformDescriptor.prototype), 'unmount', this).call(this, threeObject);
	    }
	  }, {
	    key: 'highlight',
	    value: function highlight(threeObject) {
	      var parent = threeObject.userData.markup.parentMarkup.threeObject;
	      parent.userData._descriptor.highlight(parent);
	    }
	  }, {
	    key: 'getBoundingBoxes',
	    value: function getBoundingBoxes(threeObject) {
	      var parent = threeObject.userData.markup.parentMarkup.threeObject;
	      return parent.userData._descriptor.getBoundingBoxes(parent);
	    }
	  }, {
	    key: 'hideHighlight',
	    value: function hideHighlight(threeObject) {
	      var parent = threeObject.userData.markup.parentMarkup.threeObject;
	      parent.userData._descriptor.hideHighlight(parent);
	    }
	  }]);
	
	  return UniformDescriptor;
	}(_THREEElementDescriptor2.default);
	
	module.exports = UniformDescriptor;

/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _THREEElementDescriptor = __webpack_require__(13);
	
	var _THREEElementDescriptor2 = _interopRequireDefault(_THREEElementDescriptor);
	
	var _UniformContainer = __webpack_require__(100);
	
	var _UniformContainer2 = _interopRequireDefault(_UniformContainer);
	
	var _Uniform = __webpack_require__(56);
	
	var _Uniform2 = _interopRequireDefault(_Uniform);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var UniformsDescriptor = function (_THREEElementDescript) {
	  _inherits(UniformsDescriptor, _THREEElementDescript);
	
	  function UniformsDescriptor(react3Instance) {
	    _classCallCheck(this, UniformsDescriptor);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(UniformsDescriptor).call(this, react3Instance));
	  }
	
	  _createClass(UniformsDescriptor, [{
	    key: 'construct',
	    value: function construct() {
	      return new _UniformContainer2.default();
	    }
	  }, {
	    key: 'setParent',
	    value: function setParent(threeObject, parentObject3D) {
	      (0, _invariant2.default)(parentObject3D instanceof _three2.default.ShaderMaterial, 'Parent of <uniforms/> is not a shader material');
	      (0, _invariant2.default)(parentObject3D.uniforms === undefined, 'Parent already has uniforms');
	
	      _get(Object.getPrototypeOf(UniformsDescriptor.prototype), 'setParent', this).call(this, threeObject, parentObject3D);
	
	      parentObject3D.uniforms = threeObject.uniforms;
	    }
	  }, {
	    key: 'addChildren',
	    value: function addChildren(threeObject, children) {
	      children.forEach(function (child) {
	        (0, _invariant2.default)(child instanceof _Uniform2.default, 'The <uniforms/> component can only have <uniform/> elements as children.');
	      });
	    }
	  }, {
	    key: 'highlight',
	    value: function highlight(threeObject) {
	      var parent = threeObject.userData.markup.parentMarkup.threeObject;
	      parent.userData._descriptor.highlight(parent);
	    }
	  }, {
	    key: 'getBoundingBoxes',
	    value: function getBoundingBoxes(threeObject) {
	      var parent = threeObject.userData.markup.parentMarkup.threeObject;
	      return parent.userData._descriptor.getBoundingBoxes(parent);
	    }
	  }, {
	    key: 'hideHighlight',
	    value: function hideHighlight(threeObject) {
	      var parent = threeObject.userData.markup.parentMarkup.threeObject;
	      parent.userData._descriptor.hideHighlight(parent);
	    }
	  }]);
	
	  return UniformsDescriptor;
	}(_THREEElementDescriptor2.default);
	
	module.exports = UniformsDescriptor;

/***/ },
/* 407 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _THREEElementDescriptor = __webpack_require__(13);
	
	var _THREEElementDescriptor2 = _interopRequireDefault(_THREEElementDescriptor);
	
	var _Module = __webpack_require__(238);
	
	var _Module2 = _interopRequireDefault(_Module);
	
	var _ReactPropTypeLocationNames = __webpack_require__(33);
	
	var _ReactPropTypeLocationNames2 = _interopRequireDefault(_ReactPropTypeLocationNames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// Returns class name of the object, if any.
	// Used for the subclass proptype checker
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return '<<anonymous>>';
	  }
	  return propValue.constructor.name;
	}
	
	var ModuleDescriptor = function (_THREEElementDescript) {
	  _inherits(ModuleDescriptor, _THREEElementDescript);
	
	  function ModuleDescriptor(react3RendererInstance) {
	    _classCallCheck(this, ModuleDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ModuleDescriptor).call(this, react3RendererInstance));
	
	    var moduleSubclassValidator = function moduleSubclassValidator(props, propName, componentName, location, propFullName) {
	      var locationName = _ReactPropTypeLocationNames2.default[location];
	
	      if (!props[propName]) {
	        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	
	      if (!(props[propName].prototype instanceof _Module2.default)) {
	        var actualClassName = getClassName(props[propName]);
	
	        return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + 'subclass of `Module`.');
	      }
	    };
	
	    moduleSubclassValidator.toString = function () {
	      return '```' + ' subclass of ReactThreeRenderer.Module ' + '```' + ' *' + '```' + ' required ' + '```' + '*';
	    };
	
	    _this.hasProp('descriptor', {
	      type: moduleSubclassValidator,
	      update: _this.triggerRemount,
	      default: undefined
	    });
	    return _this;
	  }
	
	  _createClass(ModuleDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      // going insane here but... let's... just do this.
	      var ModuleClass = props.descriptor;
	      return new ModuleClass();
	    }
	  }, {
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(ModuleDescriptor.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	
	      threeObject.setup(this.react3RendererInstance);
	    }
	  }, {
	    key: 'unmount',
	    value: function unmount(threeObject) {
	      threeObject.dispose();
	
	      _get(Object.getPrototypeOf(ModuleDescriptor.prototype), 'unmount', this).call(this, threeObject);
	    }
	  }]);
	
	  return ModuleDescriptor;
	}(_THREEElementDescriptor2.default);
	
	module.exports = ModuleDescriptor;

/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Object3DDescriptor2 = __webpack_require__(22);
	
	var _Object3DDescriptor3 = _interopRequireDefault(_Object3DDescriptor2);
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var CubeCameraDescriptor = function (_Object3DDescriptor) {
	  _inherits(CubeCameraDescriptor, _Object3DDescriptor);
	
	  function CubeCameraDescriptor(react3Instance) {
	    _classCallCheck(this, CubeCameraDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CubeCameraDescriptor).call(this, react3Instance));
	
	    _this.propTypes = _extends({}, _this.propTypes, {
	
	      near: _ReactPropTypes2.default.number,
	      far: _ReactPropTypes2.default.number,
	      cubeResolution: _ReactPropTypes2.default.number.isRequired
	    });
	    return _this;
	  }
	
	  _createClass(CubeCameraDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      return new _three2.default.CubeCamera(props.near, props.far, props.cubeResolution);
	    }
	  }]);
	
	  return CubeCameraDescriptor;
	}(_Object3DDescriptor3.default);
	
	module.exports = CubeCameraDescriptor;

/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _CameraDescriptorBase2 = __webpack_require__(244);
	
	var _CameraDescriptorBase3 = _interopRequireDefault(_CameraDescriptorBase2);
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var OrthographicCameraDescriptor = function (_CameraDescriptorBase) {
	  _inherits(OrthographicCameraDescriptor, _CameraDescriptorBase);
	
	  function OrthographicCameraDescriptor(react3Instance) {
	    _classCallCheck(this, OrthographicCameraDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(OrthographicCameraDescriptor).call(this, react3Instance));
	
	    _this.propTypes = _extends({}, _this.propTypes, {
	
	      left: _ReactPropTypes2.default.number.isRequired,
	      right: _ReactPropTypes2.default.number.isRequired,
	      top: _ReactPropTypes2.default.number.isRequired,
	      bottom: _ReactPropTypes2.default.number.isRequired,
	      near: _ReactPropTypes2.default.number,
	      far: _ReactPropTypes2.default.number
	    });
	
	    _this.propUpdates = _extends({}, _this.propUpdates, {
	
	      left: _this._updateAndRefreshProjection.bind(_this, 'left'),
	      right: _this._updateAndRefreshProjection.bind(_this, 'right'),
	      top: _this._updateAndRefreshProjection.bind(_this, 'top'),
	      bottom: _this._updateAndRefreshProjection.bind(_this, 'bottom'),
	      fov: _this._updateFov,
	      far: _this._updateFar
	    });
	    return _this;
	  }
	
	  _createClass(OrthographicCameraDescriptor, [{
	    key: '_updateFov',
	    value: function _updateFov(threeObject, fov) {
	      threeObject.fov = fov;
	
	      threeObject.userData._needsProjectionMatrixUpdate = true;
	    }
	  }, {
	    key: '_updateFar',
	    value: function _updateFar(threeObject, far) {
	      threeObject.far = far;
	
	      threeObject.userData._needsProjectionMatrixUpdate = true;
	    }
	  }, {
	    key: 'construct',
	    value: function construct(props) {
	      return new _three2.default.OrthographicCamera(props.left, props.right, props.top, props.bottom, props.near, props.far);
	    }
	  }, {
	    key: '_updateAndRefreshProjection',
	    value: function _updateAndRefreshProjection(propName, camera, value) {
	      camera[propName] = value;
	
	      camera.userData._needsProjectionMatrixUpdate = true;
	    }
	  }]);
	
	  return OrthographicCameraDescriptor;
	}(_CameraDescriptorBase3.default);
	
	module.exports = OrthographicCameraDescriptor;

/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _CameraDescriptorBase2 = __webpack_require__(244);
	
	var _CameraDescriptorBase3 = _interopRequireDefault(_CameraDescriptorBase2);
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var PerspectiveCameraDescriptor = function (_CameraDescriptorBase) {
	  _inherits(PerspectiveCameraDescriptor, _CameraDescriptorBase);
	
	  function PerspectiveCameraDescriptor(react3Instance) {
	    _classCallCheck(this, PerspectiveCameraDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PerspectiveCameraDescriptor).call(this, react3Instance));
	
	    _this.propTypes = _extends({}, _this.propTypes, {
	
	      fov: _ReactPropTypes2.default.number,
	      aspect: _ReactPropTypes2.default.number,
	      near: _ReactPropTypes2.default.number,
	      far: _ReactPropTypes2.default.number
	    });
	
	    _this.propUpdates = _extends({}, _this.propUpdates, {
	      aspect: _this._updateAspect,
	      fov: _this._updateFov,
	      far: _this._updateFar,
	      near: _this._updateNear
	    });
	    return _this;
	  }
	
	  _createClass(PerspectiveCameraDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      return new _three2.default.PerspectiveCamera(props.fov, props.aspect, props.near, props.far);
	    }
	  }, {
	    key: '_updateFov',
	    value: function _updateFov(threeObject, fov) {
	      threeObject.fov = fov;
	
	      threeObject.userData._needsProjectionMatrixUpdate = true;
	    }
	  }, {
	    key: '_updateNear',
	    value: function _updateNear(threeObject, near) {
	      threeObject.near = near;
	
	      threeObject.userData._needsProjectionMatrixUpdate = true;
	    }
	  }, {
	    key: '_updateFar',
	    value: function _updateFar(threeObject, far) {
	      threeObject.far = far;
	
	      threeObject.userData._needsProjectionMatrixUpdate = true;
	    }
	
	    /**
	     * @param {THREE.PerspectiveCamera} threeObject
	     * @param newAspect
	     * @private
	     */
	
	  }, {
	    key: '_updateAspect',
	    value: function _updateAspect(threeObject, newAspect) {
	      threeObject.aspect = newAspect;
	
	      threeObject.userData._needsProjectionMatrixUpdate = true;
	    }
	  }]);
	
	  return PerspectiveCameraDescriptor;
	}(_CameraDescriptorBase3.default);
	
	module.exports = PerspectiveCameraDescriptor;

/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _Object3DDescriptor2 = __webpack_require__(22);
	
	var _Object3DDescriptor3 = _interopRequireDefault(_Object3DDescriptor2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var GroupDescriptor = function (_Object3DDescriptor) {
	  _inherits(GroupDescriptor, _Object3DDescriptor);
	
	  function GroupDescriptor() {
	    _classCallCheck(this, GroupDescriptor);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(GroupDescriptor).apply(this, arguments));
	  }
	
	  _createClass(GroupDescriptor, [{
	    key: 'construct',
	    value: function construct() {
	      return new _three2.default.Group();
	    }
	  }]);
	
	  return GroupDescriptor;
	}(_Object3DDescriptor3.default);
	
	module.exports = GroupDescriptor;

/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _Object3DDescriptor2 = __webpack_require__(22);
	
	var _Object3DDescriptor3 = _interopRequireDefault(_Object3DDescriptor2);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _propTypeInstanceOf = __webpack_require__(17);
	
	var _propTypeInstanceOf2 = _interopRequireDefault(_propTypeInstanceOf);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ArrowHelperDescriptor = function (_Object3DDescriptor) {
	  _inherits(ArrowHelperDescriptor, _Object3DDescriptor);
	
	  function ArrowHelperDescriptor(react3Instance) {
	    _classCallCheck(this, ArrowHelperDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ArrowHelperDescriptor).call(this, react3Instance));
	
	    _this.propTypes = _extends({}, _this.propTypes, {
	
	      dir: (0, _propTypeInstanceOf2.default)(_three2.default.Vector3),
	      origin: (0, _propTypeInstanceOf2.default)(_three2.default.Vector3),
	      length: _ReactPropTypes2.default.number,
	      color: _ReactPropTypes2.default.number,
	      headLength: _ReactPropTypes2.default.number,
	      headWidth: _ReactPropTypes2.default.number
	    });
	    return _this;
	  }
	
	  _createClass(ArrowHelperDescriptor, [{
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(ArrowHelperDescriptor.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	    }
	  }, {
	    key: 'construct',
	    value: function construct(props) {
	      var dir = props.dir;
	      var origin = props.origin;
	      var length = props.length;
	      var color = props.color;
	      var headLength = props.headLength;
	      var headWidth = props.headWidth;
	
	      return new _three2.default.ArrowHelper(dir, origin, length, color, headLength, headWidth);
	    }
	  }, {
	    key: 'unmount',
	    value: function unmount(threeObject) {
	      if (threeObject.line) {
	        threeObject.line.geometry.dispose();
	        threeObject.line.material.dispose();
	      }
	
	      if (threeObject.cone) {
	        threeObject.cone.geometry.dispose();
	        threeObject.cone.material.dispose();
	      }
	
	      _get(Object.getPrototypeOf(ArrowHelperDescriptor.prototype), 'unmount', this).call(this, threeObject);
	    }
	  }]);
	
	  return ArrowHelperDescriptor;
	}(_Object3DDescriptor3.default);
	
	module.exports = ArrowHelperDescriptor;

/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _Object3DDescriptor2 = __webpack_require__(22);
	
	var _Object3DDescriptor3 = _interopRequireDefault(_Object3DDescriptor2);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var AxisHelperDescriptor = function (_Object3DDescriptor) {
	  _inherits(AxisHelperDescriptor, _Object3DDescriptor);
	
	  function AxisHelperDescriptor(react3Instance) {
	    _classCallCheck(this, AxisHelperDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AxisHelperDescriptor).call(this, react3Instance));
	
	    _this.propTypes = _extends({}, _this.propTypes, {
	
	      size: _ReactPropTypes2.default.number
	    });
	    return _this;
	  }
	
	  _createClass(AxisHelperDescriptor, [{
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(AxisHelperDescriptor.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	    }
	  }, {
	    key: 'construct',
	    value: function construct(props) {
	      var size = props.size;
	
	      return new _three2.default.AxisHelper(size);
	    }
	  }, {
	    key: 'unmount',
	    value: function unmount(threeObject) {
	      threeObject.geometry.dispose();
	      threeObject.material.dispose();
	
	      _get(Object.getPrototypeOf(AxisHelperDescriptor.prototype), 'unmount', this).call(this, threeObject);
	    }
	  }]);
	
	  return AxisHelperDescriptor;
	}(_Object3DDescriptor3.default);
	
	module.exports = AxisHelperDescriptor;

/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _CameraUtils = __webpack_require__(246);
	
	var _CameraUtils2 = _interopRequireDefault(_CameraUtils);
	
	var _Object3DDescriptor2 = __webpack_require__(22);
	
	var _Object3DDescriptor3 = _interopRequireDefault(_Object3DDescriptor2);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var CameraHelperDescriptor = function (_Object3DDescriptor) {
	  _inherits(CameraHelperDescriptor, _Object3DDescriptor);
	
	  function CameraHelperDescriptor(react3Instance) {
	    _classCallCheck(this, CameraHelperDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CameraHelperDescriptor).call(this, react3Instance));
	
	    _this.hasProp('visible', {
	      type: _ReactPropTypes2.default.bool,
	      override: true,
	      update: function update(threeObject, visible) {
	        threeObject.userData._visible = visible;
	
	        threeObject.visible = threeObject.userData._hasCamera && visible;
	      },
	
	      updateInitial: true,
	      default: true
	    });
	
	    _this.hasProp('cameraName', {
	      type: _ReactPropTypes2.default.string.isRequired,
	      update: function update(threeObject, cameraName) {
	        _this._clearCameraEvents(threeObject);
	
	        threeObject.userData._cameraName = cameraName;
	
	        _this._startCameraFinder(threeObject);
	      },
	      default: undefined
	    });
	    return _this;
	  }
	
	  _createClass(CameraHelperDescriptor, [{
	    key: 'construct',
	    value: function construct() {
	      return new _three2.default.CameraHelper(new _three2.default.PerspectiveCamera());
	    }
	  }, {
	    key: 'applyInitialProps',
	    value: function applyInitialProps(cameraHelper, props) {
	      var _this2 = this;
	
	      _get(Object.getPrototypeOf(CameraHelperDescriptor.prototype), 'applyInitialProps', this).call(this, cameraHelper, props);
	
	      cameraHelper.userData._onCameraProjectionUpdate = function () {
	        cameraHelper.update();
	      };
	
	      cameraHelper.userData._onCameraDispose = function () {
	        _this2._startCameraFinder(cameraHelper);
	      };
	
	      cameraHelper.userData._onCameraRename = function (payload) {
	        if (payload.oldName === cameraHelper.userData._cameraName) {
	          _this2._startCameraFinder(cameraHelper);
	        }
	      };
	
	      cameraHelper.userData._onBeforeRender = function () {
	        cameraHelper.visible = cameraHelper.userData._hasCamera && cameraHelper.userData._visible && _CameraUtils2.default.current !== cameraHelper.userData._camera;
	      };
	
	      cameraHelper.userData._cameraName = props.cameraName;
	      cameraHelper.userData._visible = props.hasOwnProperty('visible') ? props.visible : true;
	
	      cameraHelper.userData.events.once('addedIntoRoot', function () {
	        var rootInstance = cameraHelper.userData.markup._rootInstance;
	
	        rootInstance.addBeforeRenderListener(cameraHelper.userData._onBeforeRender);
	
	        _this2._startCameraFinder(cameraHelper);
	      });
	    }
	  }, {
	    key: 'unmount',
	    value: function unmount(threeObject) {
	      this._clearCameraEvents(threeObject);
	
	      delete threeObject.userData._onCameraProjectionUpdate;
	
	      return _get(Object.getPrototypeOf(CameraHelperDescriptor.prototype), 'unmount', this).call(this, threeObject);
	    }
	  }, {
	    key: '_getCamera',
	    value: function _getCamera(rootInstance, cameraName) {
	      var camera = null;
	
	      if (cameraName) {
	        var camerasByName = rootInstance.getObjectsByName(cameraName).filter(function (obj) {
	          return obj instanceof _three2.default.Camera;
	        });
	
	        if (camerasByName.length > 0) {
	          camera = camerasByName[0];
	        }
	      }
	
	      return camera;
	    }
	  }, {
	    key: '_clearCameraEvents',
	    value: function _clearCameraEvents(helper) {
	      if (helper.userData._hasCamera) {
	        helper.userData._camera.userData.events.removeListener('updateProjectionMatrix', helper.userData._onCameraProjectionUpdate);
	        helper.userData._camera.userData.events.removeListener('dispose', helper.userData._onCameraDispose);
	        helper.userData._camera.userData.events.removeListener('rename', helper.userData._onCameraRename);
	      }
	    }
	  }, {
	    key: '_setCamera',
	    value: function _setCamera(helper, camera) {
	      var userData = helper.userData;
	
	      if (userData._camera === camera) {
	        return;
	      }
	
	      this._clearCameraEvents(helper);
	
	      userData._hasCamera = true;
	      userData._camera = camera;
	      helper.camera = camera;
	      helper.matrix = camera.matrixWorld;
	      helper.update();
	      helper.visible = userData._visible;
	      var cameraEvents = helper.userData._camera.userData.events;
	
	      cameraEvents.on('rename', userData._onCameraRename);
	      cameraEvents.on('updateProjectionMatrix', userData._onCameraProjectionUpdate);
	      cameraEvents.once('dispose', userData._onCameraDispose);
	    }
	  }, {
	    key: '_startCameraFinder',
	    value: function _startCameraFinder(helper) {
	      var _this3 = this;
	
	      this._clearCameraEvents(helper);
	
	      var rootInstance = helper.userData.markup && helper.userData.markup._rootInstance;
	
	      if (!rootInstance) {
	        return;
	      }
	
	      helper.userData._hasCamera = false;
	      helper.userData._camera = null;
	      helper.camera = new _three2.default.PerspectiveCamera();
	      helper.visible = false;
	
	      var camera = this._getCamera(rootInstance, helper.userData._cameraName);
	
	      if (camera) {
	        this._setCamera(helper, camera);
	      } else {
	        (function () {
	          // try to find camera before renders
	          var findCamera = function findCamera() {
	            var foundCamera = _this3._getCamera(rootInstance, helper.userData._cameraName);
	
	            if (foundCamera) {
	              rootInstance.removeAnimateListener(findCamera);
	
	              _this3._setCamera(helper, foundCamera);
	            }
	          };
	
	          rootInstance.addAnimateListener(findCamera);
	        })();
	      }
	    }
	  }]);
	
	  return CameraHelperDescriptor;
	}(_Object3DDescriptor3.default);
	
	module.exports = CameraHelperDescriptor;

/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _MeshDescriptor2 = __webpack_require__(102);
	
	var _MeshDescriptor3 = _interopRequireDefault(_MeshDescriptor2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var LineDescriptor = function (_MeshDescriptor) {
	  _inherits(LineDescriptor, _MeshDescriptor);
	
	  function LineDescriptor() {
	    _classCallCheck(this, LineDescriptor);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(LineDescriptor).apply(this, arguments));
	  }
	
	  _createClass(LineDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      var geometry = props.hasOwnProperty('geometry') ? props.geometry : undefined;
	      var material = props.hasOwnProperty('material') ? props.material : undefined;
	
	      var mesh = new _three2.default.Line(geometry, material);
	
	      if (!geometry) {
	        mesh.geometry.dispose();
	        mesh.geometry = undefined;
	      }
	
	      if (!material) {
	        mesh.material.dispose();
	        mesh.material = undefined;
	      }
	
	      return mesh;
	    }
	  }]);
	
	  return LineDescriptor;
	}(_MeshDescriptor3.default);
	
	module.exports = LineDescriptor;

/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _MeshDescriptor2 = __webpack_require__(102);
	
	var _MeshDescriptor3 = _interopRequireDefault(_MeshDescriptor2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var PointsDescriptor = function (_MeshDescriptor) {
	  _inherits(PointsDescriptor, _MeshDescriptor);
	
	  function PointsDescriptor(react3Instance) {
	    _classCallCheck(this, PointsDescriptor);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(PointsDescriptor).call(this, react3Instance));
	  }
	
	  _createClass(PointsDescriptor, [{
	    key: 'construct',
	    value: function construct() {
	      var points = new _three2.default.Points();
	
	      points.geometry.dispose();
	      points.material.dispose();
	
	      points.geometry = undefined;
	      points.material = undefined;
	
	      return points;
	    }
	  }]);
	
	  return PointsDescriptor;
	}(_MeshDescriptor3.default);
	
	module.exports = PointsDescriptor;

/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _Object3DDescriptor2 = __webpack_require__(22);
	
	var _Object3DDescriptor3 = _interopRequireDefault(_Object3DDescriptor2);
	
	var _propTypeInstanceOf = __webpack_require__(17);
	
	var _propTypeInstanceOf2 = _interopRequireDefault(_propTypeInstanceOf);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var SceneDescriptor = function (_Object3DDescriptor) {
	  _inherits(SceneDescriptor, _Object3DDescriptor);
	
	  function SceneDescriptor(react3Instance) {
	    _classCallCheck(this, SceneDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SceneDescriptor).call(this, react3Instance));
	
	    _this.hasProp('fog', {
	      type: (0, _propTypeInstanceOf2.default)(_three2.default.Fog),
	      simple: true,
	      default: undefined
	    });
	    return _this;
	  }
	
	  _createClass(SceneDescriptor, [{
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(SceneDescriptor.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	    }
	  }, {
	    key: 'construct',
	    value: function construct() {
	      return new _three2.default.Scene();
	    }
	  }]);
	
	  return SceneDescriptor;
	}(_Object3DDescriptor3.default);
	
	module.exports = SceneDescriptor;

/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _React3Instance = __webpack_require__(98);
	
	var _React3Instance2 = _interopRequireDefault(_React3Instance);
	
	var _THREEElementDescriptor = __webpack_require__(13);
	
	var _THREEElementDescriptor2 = _interopRequireDefault(_THREEElementDescriptor);
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _warning = __webpack_require__(30);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _propTypeInstanceOf = __webpack_require__(17);
	
	var _propTypeInstanceOf2 = _interopRequireDefault(_propTypeInstanceOf);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var propProxy = {
	  gammaInput: {
	    type: _ReactPropTypes2.default.bool,
	    default: false
	  },
	  gammaOutput: {
	    type: _ReactPropTypes2.default.bool,
	    default: false
	  },
	  sortObjects: {
	    type: _ReactPropTypes2.default.bool,
	    default: true
	  },
	  context: {
	    type: _ReactPropTypes2.default.oneOf(['2d', '3d']).isRequired
	  },
	  mainCamera: {
	    type: _ReactPropTypes2.default.string,
	    default: undefined
	  },
	  onAnimate: {
	    type: _ReactPropTypes2.default.func,
	    default: undefined
	  },
	  clearColor: {
	    type: _ReactPropTypes2.default.oneOfType([(0, _propTypeInstanceOf2.default)(_three2.default.Color), _ReactPropTypes2.default.number, _ReactPropTypes2.default.string]),
	    default: 0x000000
	  },
	  clearAlpha: {
	    type: _ReactPropTypes2.default.number,
	    default: undefined
	  },
	  shadowMapEnabled: {
	    type: _ReactPropTypes2.default.bool,
	    default: false
	  },
	  shadowMapType: {
	    type: _ReactPropTypes2.default.oneOf([_three2.default.BasicShadowMap, _three2.default.PCFShadowMap, _three2.default.PCFSoftShadowMap]),
	    default: _three2.default.PCFShadowMap
	  },
	  shadowMapCullFace: {
	    type: _ReactPropTypes2.default.oneOf([_three2.default.CullFaceNone, _three2.default.CullFaceBack, _three2.default.CullFaceFront, _three2.default.CullFaceFrontBack]),
	    default: _three2.default.CullFaceFront
	  },
	  shadowMapDebug: {
	    type: _ReactPropTypes2.default.bool,
	    default: false
	  },
	  onRecreateCanvas: {
	    type: _ReactPropTypes2.default.func.isRequired,
	    default: undefined
	  },
	  pixelRatio: {
	    type: _ReactPropTypes2.default.number,
	    default: 1
	  },
	  width: {
	    type: _ReactPropTypes2.default.number.isRequired
	  },
	  height: {
	    type: _ReactPropTypes2.default.number.isRequired
	  },
	  precision: {
	    type: _ReactPropTypes2.default.oneOf(['highp', 'mediump', 'lowp']),
	    default: 'highp'
	  },
	  alpha: {
	    type: _ReactPropTypes2.default.bool,
	    default: false
	  },
	  premultipliedAlpha: {
	    type: _ReactPropTypes2.default.bool,
	    default: true
	  },
	  antialias: {
	    type: _ReactPropTypes2.default.oneOfType([_ReactPropTypes2.default.bool, _ReactPropTypes2.default.number]),
	    default: false
	  },
	  stencil: {
	    type: _ReactPropTypes2.default.bool,
	    default: true
	  },
	  preserveDrawingBuffer: {
	    type: _ReactPropTypes2.default.bool,
	    default: false
	  },
	  depth: {
	    type: _ReactPropTypes2.default.bool,
	    default: true
	  },
	  logarithmicDepthBuffer: {
	    type: _ReactPropTypes2.default.bool,
	    default: false
	  }
	};
	
	var React3Descriptor = function (_THREEElementDescript) {
	  _inherits(React3Descriptor, _THREEElementDescript);
	
	  function React3Descriptor(react3RendererInstance) {
	    _classCallCheck(this, React3Descriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(React3Descriptor).call(this, react3RendererInstance));
	
	    Object.keys(propProxy).forEach(function (propName) {
	      var info = propProxy[propName];
	      var propNameFirstLetterCapital = propName[0].toUpperCase() + propName.substr(1);
	
	      var updateFunctionName = 'update' + propNameFirstLetterCapital;
	
	      if (false) {
	        (0, _warning2.default)(_React3Instance2.default.prototype.hasOwnProperty(updateFunctionName), 'Missing function %s in React3DInstance class.', updateFunctionName);
	      }
	
	      var propInfo = {
	        type: info.type,
	        update: function update(threeObject, newValue) {
	          threeObject[updateFunctionName](newValue);
	        }
	      };
	
	      if (info.hasOwnProperty('default')) {
	        propInfo.default = info.default;
	      }
	
	      _this.hasProp(propName, propInfo);
	    });
	    return _this;
	  }
	
	  _createClass(React3Descriptor, [{
	    key: 'setParent',
	    value: function setParent(threeObject, parentObject3D) {
	      (0, _invariant2.default)(parentObject3D instanceof HTMLCanvasElement, 'The `react3` element can only be rendered into a canvas.');
	
	      _get(Object.getPrototypeOf(React3Descriptor.prototype), 'setParent', this).call(this, threeObject, parentObject3D);
	
	      threeObject.updateCanvas(parentObject3D);
	    }
	  }, {
	    key: 'construct',
	    value: function construct(props) {
	      return new _React3Instance2.default(props, this.react3RendererInstance);
	    }
	  }, {
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(React3Descriptor.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	
	      threeObject.initialize();
	    }
	
	    // gets called every time there are children to be added
	    // this can be called multiple times as more children are added.
	
	  }, {
	    key: 'addChildren',
	    value: function addChildren(threeObject, children) {
	      threeObject.addChildren(children);
	    }
	  }, {
	    key: 'addChild',
	    value: function addChild(threeObject, child) {
	      threeObject.addChildren([child]);
	    }
	  }, {
	    key: 'moveChild',
	    value: function moveChild() {
	      // do nothing
	    }
	  }, {
	    key: 'removeChild',
	    value: function removeChild(threeObject, child) {
	      threeObject.removeChild(child);
	    }
	  }, {
	    key: '_updateOnRecreateCanvas',
	    value: function _updateOnRecreateCanvas(threeObject, callback) {
	      threeObject.updateOnRecreateCanvas(callback);
	    }
	  }, {
	    key: '_updateHeight',
	    value: function _updateHeight(threeObject, newHeight) {
	      threeObject.updateHeight(newHeight);
	    }
	  }, {
	    key: 'unmount',
	    value: function unmount(threeObject) {
	      // call super unmount first so react3instance can clean itself up
	      _get(Object.getPrototypeOf(React3Descriptor.prototype), 'unmount', this).call(this, threeObject);
	
	      threeObject.unmount();
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount(threeObject) {
	      threeObject.willUnmount();
	
	      return _get(Object.getPrototypeOf(React3Descriptor.prototype), 'componentWillUnmount', this).call(this, threeObject);
	    }
	  }]);
	
	  return React3Descriptor;
	}(_THREEElementDescriptor2.default);
	
	module.exports = React3Descriptor;

/***/ },
/* 419 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _ResourceDescriptorBase = __webpack_require__(59);
	
	var _ResourceDescriptorBase2 = _interopRequireDefault(_ResourceDescriptorBase);
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MaterialResourceDescriptor = function (_ResourceDescriptorBa) {
	  _inherits(MaterialResourceDescriptor, _ResourceDescriptorBa);
	
	  function MaterialResourceDescriptor() {
	    _classCallCheck(this, MaterialResourceDescriptor);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(MaterialResourceDescriptor).apply(this, arguments));
	  }
	
	  _createClass(MaterialResourceDescriptor, [{
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(MaterialResourceDescriptor.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	
	      if (props.hasOwnProperty('slot')) {
	        threeObject.userData._propertySlot = props.slot;
	      } else {
	        threeObject.userData._propertySlot = 'material';
	      }
	    }
	  }, {
	    key: 'setParent',
	    value: function setParent(threeObject, parentObject3D) {
	      (0, _invariant2.default)(parentObject3D instanceof _three2.default.Mesh || parentObject3D instanceof _three2.default.Points || parentObject3D instanceof _three2.default.Line, 'Parent is not a mesh');
	
	      _get(Object.getPrototypeOf(MaterialResourceDescriptor.prototype), 'setParent', this).call(this, threeObject, parentObject3D);
	    }
	  }]);
	
	  return MaterialResourceDescriptor;
	}(_ResourceDescriptorBase2.default);
	
	module.exports = MaterialResourceDescriptor;

/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _THREEElementDescriptor = __webpack_require__(13);
	
	var _THREEElementDescriptor2 = _interopRequireDefault(_THREEElementDescriptor);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ResourceContainer = __webpack_require__(99);
	
	var _ResourceContainer2 = _interopRequireDefault(_ResourceContainer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ResourcesDescriptor = function (_THREEElementDescript) {
	  _inherits(ResourcesDescriptor, _THREEElementDescript);
	
	  function ResourcesDescriptor() {
	    _classCallCheck(this, ResourcesDescriptor);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(ResourcesDescriptor).apply(this, arguments));
	  }
	
	  _createClass(ResourcesDescriptor, [{
	    key: 'construct',
	    value: function construct() {
	      return new _ResourceContainer2.default();
	    }
	  }, {
	    key: 'unmount',
	    value: function unmount(threeObject) {
	      var parentMarkup = threeObject.userData.markup.parentMarkup;
	      var parentEvents = parentMarkup.threeObject.userData.events;
	
	      threeObject.resourceIds.forEach(function (id) {
	        parentEvents.emit('resource.removed', {
	          id: id,
	          distance: 0,
	          resource: threeObject.resourceMap[id]
	        });
	      });
	
	      _get(Object.getPrototypeOf(ResourcesDescriptor.prototype), 'unmount', this).call(this, threeObject);
	    }
	  }, {
	    key: 'addChildren',
	    value: function addChildren(threeObject, children) {
	      children.forEach(function (child) {
	        var resourceId = child.userData._resourceId;
	
	        if (false) {
	          (0, _invariant2.default)(!!resourceId, 'Resource container can only hold resources.' + ' Found children without `resourceId` properties: ' + children.filter(function (currentChild) {
	            return !currentChild.userData._resourceId;
	          }).map(function (currentChild) {
	            return '<' + currentChild.userData.react3internalComponent._elementType + '/>';
	          }).join(', ') + '.');
	        } else {
	          (0, _invariant2.default)(!!resourceId);
	        }
	
	        threeObject.resourceIds.push(resourceId);
	
	        threeObject.resourceMap[resourceId] = child;
	
	        var parentMarkup = threeObject.userData.markup.parentMarkup;
	        if (parentMarkup) {
	          parentMarkup.threeObject.userData.events.emit('resource.added', {
	            id: resourceId,
	            distance: 0,
	            resource: child
	          });
	        }
	      });
	    }
	  }, {
	    key: 'addChild',
	    value: function addChild(threeObject, child) {
	      this.addChildren(threeObject, [child]);
	    }
	  }, {
	    key: 'removeChild',
	    value: function removeChild(threeObject, child) {
	      var resourceId = child.userData._resourceId;
	
	      delete threeObject.resourceIds[resourceId];
	
	      var parentMarkup = threeObject.userData.markup.parentMarkup;
	      if (parentMarkup) {
	        parentMarkup.threeObject.userData.events.emit('resource.removed', {
	          id: resourceId,
	          distance: 0,
	          resource: child
	        });
	      }
	    }
	  }, {
	    key: 'setParent',
	    value: function setParent(threeObject, parentObject) {
	      _get(Object.getPrototypeOf(ResourcesDescriptor.prototype), 'setParent', this).call(this, threeObject, parentObject);
	
	      var parentEvents = parentObject.userData.events;
	
	      parentObject.userData._resources = threeObject;
	
	      threeObject.resourceIds.forEach(function (id) {
	        parentEvents.emit('resource.added', {
	          id: id,
	          distance: 0,
	          resource: threeObject.resourceMap[id]
	        });
	      });
	    }
	  }, {
	    key: 'highlight',
	    value: function highlight(threeObject) {
	      var ownerObject = threeObject.userData.markup.parentMarkup.threeObject;
	
	      if (!(ownerObject.updateMatrixWorld && ownerObject.traverse)) {
	        return;
	      }
	
	      threeObject.userData.events.emit('highlight', {
	        uuid: threeObject.uuid,
	        boundingBoxFunc: function boundingBoxFunc() {
	          var boundingBox = new _three2.default.Box3();
	
	          boundingBox.setFromObject(ownerObject);
	
	          return [boundingBox];
	        }
	      });
	    }
	  }, {
	    key: 'hideHighlight',
	    value: function hideHighlight(threeObject) {
	      threeObject.userData.events.emit('hideHighlight');
	    }
	  }]);
	
	  return ResourcesDescriptor;
	}(_THREEElementDescriptor2.default);
	
	module.exports = ResourcesDescriptor;

/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _GeometryResourceDescriptor = __webpack_require__(245);
	
	var _GeometryResourceDescriptor2 = _interopRequireDefault(_GeometryResourceDescriptor);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ShapeGeometryResourceDescriptor = function (_GeometryResourceDesc) {
	  _inherits(ShapeGeometryResourceDescriptor, _GeometryResourceDesc);
	
	  function ShapeGeometryResourceDescriptor(react3RendererInstance) {
	    _classCallCheck(this, ShapeGeometryResourceDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ShapeGeometryResourceDescriptor).call(this, react3RendererInstance));
	
	    _this.hasProp('type', {
	      type: _ReactPropTypes2.default.oneOf(['points', 'spacedPoints', 'shape']).isRequired,
	      update: _this.triggerRemount,
	      default: ''
	    });
	
	    _this.hasProp('divisions', {
	      type: _ReactPropTypes2.default.number,
	      update: _this.triggerRemount,
	      default: 5
	    });
	    return _this;
	  }
	
	  _createClass(ShapeGeometryResourceDescriptor, [{
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(ShapeGeometryResourceDescriptor.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	
	      threeObject.userData._divisions = props.divisions;
	
	      threeObject.userData._type = props.type;
	    }
	  }, {
	    key: 'applyToSlot',
	    value: function applyToSlot(threeObject, parentObject, shape) {
	      if (!shape) {
	        return _get(Object.getPrototypeOf(ShapeGeometryResourceDescriptor.prototype), 'applyToSlot', this).call(this, threeObject, parentObject, null);
	      }
	
	      var geometry = undefined;
	
	      switch (threeObject.userData._type) {
	        case 'points':
	          geometry = shape.createPointsGeometry();
	          break;
	        case 'spacedPoints':
	          geometry = shape.createSpacedPointsGeometry(threeObject.userData._divisions);
	          break;
	        case 'shape':
	          // TODO shapeGeometryDescriptor
	          geometry = new _three2.default.ShapeGeometry(shape);
	          break;
	        default:
	          break;
	      }
	
	      return _get(Object.getPrototypeOf(ShapeGeometryResourceDescriptor.prototype), 'applyToSlot', this).call(this, threeObject, parentObject, geometry);
	    }
	  }]);
	
	  return ShapeGeometryResourceDescriptor;
	}(_GeometryResourceDescriptor2.default);
	
	module.exports = ShapeGeometryResourceDescriptor;

/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _ResourceDescriptorBase = __webpack_require__(59);
	
	var _ResourceDescriptorBase2 = _interopRequireDefault(_ResourceDescriptorBase);
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ShapeResourceReference = __webpack_require__(240);
	
	var _ShapeResourceReference2 = _interopRequireDefault(_ShapeResourceReference);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ShapeResourceDescriptor = function (_ResourceDescriptorBa) {
	  _inherits(ShapeResourceDescriptor, _ResourceDescriptorBa);
	
	  function ShapeResourceDescriptor() {
	    _classCallCheck(this, ShapeResourceDescriptor);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(ShapeResourceDescriptor).apply(this, arguments));
	  }
	
	  _createClass(ShapeResourceDescriptor, [{
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(ShapeResourceDescriptor.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	
	      threeObject.userData._remountOnUpdate = true;
	    }
	  }, {
	    key: 'construct',
	    value: function construct(props) {
	      return new _ShapeResourceReference2.default(props.resourceId);
	    }
	  }, {
	    key: 'setParent',
	    value: function setParent(threeObject, parentObject3D) {
	      (0, _invariant2.default)(parentObject3D instanceof _three2.default.ExtrudeGeometry || parentObject3D instanceof _three2.default.BufferGeometry, 'Parent is not an extrude geometry');
	
	      _get(Object.getPrototypeOf(ShapeResourceDescriptor.prototype), 'setParent', this).call(this, threeObject, parentObject3D);
	    }
	  }, {
	    key: 'applyToSlot',
	    value: function applyToSlot(threeObject, parentObject, newResource) {
	      threeObject.userData.events.emit('resource.set', newResource);
	    }
	  }]);
	
	  return ShapeResourceDescriptor;
	}(_ResourceDescriptorBase2.default);
	
	module.exports = ShapeResourceDescriptor;

/***/ },
/* 423 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _ResourceDescriptorBase = __webpack_require__(59);
	
	var _ResourceDescriptorBase2 = _interopRequireDefault(_ResourceDescriptorBase);
	
	var _three = __webpack_require__(2);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _invariant = __webpack_require__(9);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Uniform = __webpack_require__(56);
	
	var _Uniform2 = _interopRequireDefault(_Uniform);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var TextureResourceDescriptor = function (_ResourceDescriptorBa) {
	  _inherits(TextureResourceDescriptor, _ResourceDescriptorBa);
	
	  function TextureResourceDescriptor() {
	    _classCallCheck(this, TextureResourceDescriptor);
	
	    return _possibleConstructorReturn(this, Object.getPrototypeOf(TextureResourceDescriptor).apply(this, arguments));
	  }
	
	  _createClass(TextureResourceDescriptor, [{
	    key: 'applyInitialProps',
	    value: function applyInitialProps(threeObject, props) {
	      _get(Object.getPrototypeOf(TextureResourceDescriptor.prototype), 'applyInitialProps', this).call(this, threeObject, props);
	
	      threeObject.userData._propertySlot = 'map';
	    }
	  }, {
	    key: 'applyToSlot',
	    value: function applyToSlot(threeObject, parentObject3D, newResource) {
	      if (parentObject3D instanceof _three2.default.Material) {
	        _get(Object.getPrototypeOf(TextureResourceDescriptor.prototype), 'applyToSlot', this).call(this, threeObject, parentObject3D, newResource);
	        parentObject3D.dispose();
	      } else if (parentObject3D instanceof _Uniform2.default) {
	        parentObject3D.setValue(newResource);
	      } else {
	        (0, _invariant2.default)(false, 'Parent is not a material or a uniform');
	      }
	    }
	  }, {
	    key: 'setParent',
	    value: function setParent(threeObject, parentObject3D) {
	      if (parentObject3D instanceof _three2.default.Material) {
	        _get(Object.getPrototypeOf(TextureResourceDescriptor.prototype), 'setParent', this).call(this, threeObject, parentObject3D);
	      } else if (parentObject3D instanceof _Uniform2.default) {
	        threeObject.userData._propertySlot = 'value';
	        _get(Object.getPrototypeOf(TextureResourceDescriptor.prototype), 'setParent', this).call(this, threeObject, parentObject3D);
	      } else {
	        (0, _invariant2.default)(false, 'Parent is not a material or a uniform');
	      }
	    }
	  }]);
	
	  return TextureResourceDescriptor;
	}(_ResourceDescriptorBase2.default);
	
	module.exports = TextureResourceDescriptor;

/***/ },
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Viewport = __webpack_require__(242);
	
	var _Viewport2 = _interopRequireDefault(_Viewport);
	
	var _THREEElementDescriptor = __webpack_require__(13);
	
	var _THREEElementDescriptor2 = _interopRequireDefault(_THREEElementDescriptor);
	
	var _ReactPropTypes = __webpack_require__(3);
	
	var _ReactPropTypes2 = _interopRequireDefault(_ReactPropTypes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ViewportDescriptor = function (_THREEElementDescript) {
	  _inherits(ViewportDescriptor, _THREEElementDescript);
	
	  function ViewportDescriptor(react3Instance) {
	    _classCallCheck(this, ViewportDescriptor);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ViewportDescriptor).call(this, react3Instance));
	
	    ['x', 'y', 'width', 'height'].forEach(function (propName) {
	      _this.hasProp(propName, {
	        type: _ReactPropTypes2.default.number.isRequired,
	        simple: true
	      });
	    });
	
	    _this.hasProp('cameraName', {
	      type: _ReactPropTypes2.default.string.isRequired,
	      simple: true
	    });
	    return _this;
	  }
	
	  _createClass(ViewportDescriptor, [{
	    key: 'construct',
	    value: function construct(props) {
	      return new _Viewport2.default(props);
	    }
	  }]);
	
	  return ViewportDescriptor;
	}(_THREEElementDescriptor2.default);
	
	module.exports = ViewportDescriptor;

/***/ },
/* 425 */
/***/ function(module, exports) {

	"use strict";
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var EventDispatcher = function () {
	  function EventDispatcher() {
	    _classCallCheck(this, EventDispatcher);
	  }
	
	  _createClass(EventDispatcher, [{
	    key: "dispatchEvent",
	    value: function dispatchEvent(threeObject, eventName) {
	      var eventCallbacks = threeObject.userData._eventCallbacks;
	      var callback = eventCallbacks && eventCallbacks[eventName];
	
	      if (callback) {
	        for (var _len = arguments.length, params = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	          params[_key - 2] = arguments[_key];
	        }
	
	        callback.apply(undefined, params);
	      }
	    }
	  }]);
	
	  return EventDispatcher;
	}();
	
	module.exports = EventDispatcher;

/***/ },
/* 426 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	"use strict";
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	function emptyFunction() {}
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule AutoFocusUtils
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactMount = __webpack_require__(14);
	
	var findDOMNode = __webpack_require__(113);
	var focusNode = __webpack_require__(279);
	
	var Mixin = {
	  componentDidMount: function () {
	    if (this.props.autoFocus) {
	      focusNode(findDOMNode(this));
	    }
	  }
	};
	
	var AutoFocusUtils = {
	  Mixin: Mixin,
	
	  focusDOMComponent: function () {
	    focusNode(ReactMount.getNode(this._rootNodeID));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ },
/* 428 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015 Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule BeforeInputEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(26);
	var EventPropagators = __webpack_require__(43);
	var ExecutionEnvironment = __webpack_require__(12);
	var FallbackCompositionState = __webpack_require__(436);
	var SyntheticCompositionEvent = __webpack_require__(463);
	var SyntheticInputEvent = __webpack_require__(466);
	
	var keyOf = __webpack_require__(28);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBeforeInput: null }),
	      captured: keyOf({ onBeforeInputCapture: null })
	    },
	    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionEnd: null }),
	      captured: keyOf({ onCompositionEndCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionStart: null }),
	      captured: keyOf({ onCompositionStartCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionUpdate: null }),
	      captured: keyOf({ onCompositionUpdateCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionStart:
	      return eventTypes.compositionStart;
	    case topLevelTypes.topCompositionEnd:
	      return eventTypes.compositionEnd;
	    case topLevelTypes.topCompositionUpdate:
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topKeyUp:
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case topLevelTypes.topKeyDown:
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case topLevelTypes.topKeyPress:
	    case topLevelTypes.topMouseDown:
	    case topLevelTypes.topBlur:
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if (typeof detail === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionEnd:
	      return getDataFromCustomEvent(nativeEvent);
	    case topLevelTypes.topKeyPress:
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case topLevelTypes.topTextInput:
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  if (currentComposition) {
	    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case topLevelTypes.topPaste:
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case topLevelTypes.topKeyPress:
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case topLevelTypes.topCompositionEnd:
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ },
/* 429 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(249);
	var ExecutionEnvironment = __webpack_require__(12);
	var ReactPerf = __webpack_require__(20);
	
	var camelizeStyleName = __webpack_require__(480);
	var dangerousStyleValue = __webpack_require__(471);
	var hyphenateStyleName = __webpack_require__(485);
	var memoizeStringOnly = __webpack_require__(489);
	var warning = __webpack_require__(8);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (false) {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	
	  var warnHyphenatedStyleName = function (name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
	  };
	
	  var warnBadVendoredStyleName = function (name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
	  };
	
	  var warnStyleValueWithSemicolon = function (name, value) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   */
	  var warnValidStyle = function (name, value) {
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @return {?string}
	   */
	  createMarkupForStyles: function (styles) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (false) {
	        warnValidStyle(styleName, styleValue);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   */
	  setValueForStyles: function (node, styles) {
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (false) {
	        warnValidStyle(styleName, styles[styleName]);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
	      if (styleName === 'float') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {
	  setValueForStyles: 'setValueForStyles'
	});
	
	module.exports = CSSPropertyOperations;

/***/ },
/* 430 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ChangeEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(26);
	var EventPluginHub = __webpack_require__(42);
	var EventPropagators = __webpack_require__(43);
	var ExecutionEnvironment = __webpack_require__(12);
	var ReactUpdates = __webpack_require__(18);
	var SyntheticEvent = __webpack_require__(34);
	
	var getEventTarget = __webpack_require__(116);
	var isEventSupported = __webpack_require__(119);
	var isTextInputElement = __webpack_require__(276);
	var keyOf = __webpack_require__(28);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onChange: null }),
	      captured: keyOf({ onChangeCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementID = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementID = null;
	}
	
	function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topChange) {
	    return topLevelTargetID;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events
	  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
	}
	
	/**
	 * (For old IE.) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function () {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function (val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For old IE.) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
	
	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  activeElement.attachEvent('onpropertychange', handlePropertyChange);
	}
	
	/**
	 * (For old IE.) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	  activeElement.detachEvent('onpropertychange', handlePropertyChange);
	
	  activeElement = null;
	  activeElementID = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For old IE.) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topInput) {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return topLevelTargetID;
	  }
	}
	
	// For IE8 and IE9.
	function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementID;
	    }
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topClick) {
	    return topLevelTargetID;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	
	    var getTargetIDFunc, handleEventFunc;
	    if (shouldUseChangeEvent(topLevelTarget)) {
	      if (doesChangeEventBubble) {
	        getTargetIDFunc = getTargetIDForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(topLevelTarget)) {
	      if (isInputEventSupported) {
	        getTargetIDFunc = getTargetIDForInputEvent;
	      } else {
	        getTargetIDFunc = getTargetIDForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(topLevelTarget)) {
	      getTargetIDFunc = getTargetIDForClickEvent;
	    }
	
	    if (getTargetIDFunc) {
	      var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
	      if (targetID) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;

/***/ },
/* 431 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ClientReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	var nextReactRootIndex = 0;
	
	var ClientReactRootIndex = {
	  createReactRootIndex: function () {
	    return nextReactRootIndex++;
	  }
	};
	
	module.exports = ClientReactRootIndex;

/***/ },
/* 432 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Danger
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(12);
	
	var createNodesFromMarkup = __webpack_require__(482);
	var emptyFunction = __webpack_require__(24);
	var getMarkupWrap = __webpack_require__(281);
	var invariant = __webpack_require__(4);
	
	var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
	var RESULT_INDEX_ATTR = 'data-danger-index';
	
	/**
	 * Extracts the `nodeName` from a string of markup.
	 *
	 * NOTE: Extracting the `nodeName` does not require a regular expression match
	 * because we make assumptions about React-generated markup (i.e. there are no
	 * spaces surrounding the opening tag and there is at least one attribute).
	 *
	 * @param {string} markup String of markup.
	 * @return {string} Node name of the supplied markup.
	 * @see http://jsperf.com/extract-nodename
	 */
	function getNodeName(markup) {
	  return markup.substring(1, markup.indexOf(' '));
	}
	
	var Danger = {
	
	  /**
	   * Renders markup into an array of nodes. The markup is expected to render
	   * into a list of root nodes. Also, the length of `resultList` and
	   * `markupList` should be the same.
	   *
	   * @param {array<string>} markupList List of markup strings to render.
	   * @return {array<DOMElement>} List of rendered nodes.
	   * @internal
	   */
	  dangerouslyRenderMarkup: function (markupList) {
	    !ExecutionEnvironment.canUseDOM ?  false ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : undefined;
	    var nodeName;
	    var markupByNodeName = {};
	    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
	    for (var i = 0; i < markupList.length; i++) {
	      !markupList[i] ?  false ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
	      nodeName = getNodeName(markupList[i]);
	      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
	      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
	      markupByNodeName[nodeName][i] = markupList[i];
	    }
	    var resultList = [];
	    var resultListAssignmentCount = 0;
	    for (nodeName in markupByNodeName) {
	      if (!markupByNodeName.hasOwnProperty(nodeName)) {
	        continue;
	      }
	      var markupListByNodeName = markupByNodeName[nodeName];
	
	      // This for-in loop skips the holes of the sparse array. The order of
	      // iteration should follow the order of assignment, which happens to match
	      // numerical index order, but we don't rely on that.
	      var resultIndex;
	      for (resultIndex in markupListByNodeName) {
	        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
	          var markup = markupListByNodeName[resultIndex];
	
	          // Push the requested markup with an additional RESULT_INDEX_ATTR
	          // attribute.  If the markup does not start with a < character, it
	          // will be discarded below (with an appropriate console.error).
	          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
	          // This index will be parsed back out below.
	          '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
	        }
	      }
	
	      // Render each group of markup with similar wrapping `nodeName`.
	      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
	      );
	
	      for (var j = 0; j < renderNodes.length; ++j) {
	        var renderNode = renderNodes[j];
	        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
	
	          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
	          renderNode.removeAttribute(RESULT_INDEX_ATTR);
	
	          !!resultList.hasOwnProperty(resultIndex) ?  false ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;
	
	          resultList[resultIndex] = renderNode;
	
	          // This should match resultList.length and markupList.length when
	          // we're done.
	          resultListAssignmentCount += 1;
	        } else if (false) {
	          console.error('Danger: Discarding unexpected node:', renderNode);
	        }
	      }
	    }
	
	    // Although resultList was populated out of order, it should now be a dense
	    // array.
	    !(resultListAssignmentCount === resultList.length) ?  false ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;
	
	    !(resultList.length === markupList.length) ?  false ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;
	
	    return resultList;
	  },
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ?  false ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
	    !markup ?  false ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
	    !(oldChild.tagName.toLowerCase() !== 'html') ?  false ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : undefined;
	
	    var newChild;
	    if (typeof markup === 'string') {
	      newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	    } else {
	      newChild = markup;
	    }
	    oldChild.parentNode.replaceChild(newChild, oldChild);
	  }
	
	};
	
	module.exports = Danger;

/***/ },
/* 433 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DefaultEventPluginOrder
	 */
	
	'use strict';
	
	var keyOf = __webpack_require__(28);
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];
	
	module.exports = DefaultEventPluginOrder;

/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EnterLeaveEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(26);
	var EventPropagators = __webpack_require__(43);
	var SyntheticMouseEvent = __webpack_require__(63);
	
	var ReactMount = __webpack_require__(14);
	var keyOf = __webpack_require__(28);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	var getFirstReactDOM = ReactMount.getFirstReactDOM;
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: keyOf({ onMouseEnter: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  },
	  mouseLeave: {
	    registrationName: keyOf({ onMouseLeave: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  }
	};
	
	var extractedEvents = [null, null];
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (topLevelTarget.window === topLevelTarget) {
	      // `topLevelTarget` is probably a window object.
	      win = topLevelTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = topLevelTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    var fromID = '';
	    var toID = '';
	    if (topLevelType === topLevelTypes.topMouseOut) {
	      from = topLevelTarget;
	      fromID = topLevelTargetID;
	      to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement);
	      if (to) {
	        toID = ReactMount.getID(to);
	      } else {
	        to = win;
	      }
	      to = to || win;
	    } else {
	      from = win;
	      to = topLevelTarget;
	      toID = topLevelTargetID;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = from;
	    leave.relatedTarget = to;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = to;
	    enter.relatedTarget = from;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
	
	    extractedEvents[0] = leave;
	    extractedEvents[1] = enter;
	
	    return extractedEvents;
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 435 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginUtils
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(26);
	var ReactErrorUtils = __webpack_require__(261);
	
	var invariant = __webpack_require__(4);
	var warning = __webpack_require__(8);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `Mount`: [required] Module that can convert between React dom IDs and
	 *   actual node references.
	 */
	var injection = {
	  Mount: null,
	  injectMount: function (InjectedMount) {
	    injection.Mount = InjectedMount;
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
	    }
	  }
	};
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	function isEndish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
	}
	function isStartish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
	}
	
	var validateEventDispatches;
	if (false) {
	  validateEventDispatches = function (event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchIDs = event._dispatchIDs;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var idsIsArr = Array.isArray(dispatchIDs);
	    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {string} domID DOM id to pass to the callback.
	 */
	function executeDispatch(event, simulated, listener, domID) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = injection.Mount.getNode(domID);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (false) {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);
	  }
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (false) {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchIDs[i])) {
	        return dispatchIDs[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchIDs)) {
	      return dispatchIDs;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchIDs = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (false) {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchID = event._dispatchIDs;
	  !!Array.isArray(dispatchListener) ?  false ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
	  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getNode: function (id) {
	    return injection.Mount.getNode(id);
	  },
	  getID: function (node) {
	    return injection.Mount.getID(node);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;

/***/ },
/* 436 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FallbackCompositionState
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(27);
	
	var assign = __webpack_require__(7);
	var getTextContentAccessor = __webpack_require__(275);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	assign(FallbackCompositionState.prototype, {
	  destructor: function () {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function () {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function () {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ },
/* 437 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule HTMLDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(35);
	var ExecutionEnvironment = __webpack_require__(12);
	
	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var hasSVG;
	if (ExecutionEnvironment.canUseDOM) {
	  var implementation = document.implementation;
	  hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
	}
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: null,
	    acceptCharset: null,
	    accessKey: null,
	    action: null,
	    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    allowTransparency: MUST_USE_ATTRIBUTE,
	    alt: null,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: null,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    cellPadding: null,
	    cellSpacing: null,
	    charSet: MUST_USE_ATTRIBUTE,
	    challenge: MUST_USE_ATTRIBUTE,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    classID: MUST_USE_ATTRIBUTE,
	    // To set className on SVG elements, it's necessary to use .setAttribute;
	    // this works on HTML elements too in all browsers except IE8. Conveniently,
	    // IE8 doesn't support SVG and so we can simply use the attribute in
	    // browsers that support SVG and the property in browsers that don't,
	    // regardless of whether the element is HTML or SVG.
	    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
	    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: null,
	    content: null,
	    contentEditable: null,
	    contextMenu: MUST_USE_ATTRIBUTE,
	    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    coords: null,
	    crossOrigin: null,
	    data: null, // For `<object />` acts as `src`.
	    dateTime: MUST_USE_ATTRIBUTE,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: null,
	    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: null,
	    encType: null,
	    form: MUST_USE_ATTRIBUTE,
	    formAction: MUST_USE_ATTRIBUTE,
	    formEncType: MUST_USE_ATTRIBUTE,
	    formMethod: MUST_USE_ATTRIBUTE,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: MUST_USE_ATTRIBUTE,
	    frameBorder: MUST_USE_ATTRIBUTE,
	    headers: null,
	    height: MUST_USE_ATTRIBUTE,
	    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    high: null,
	    href: null,
	    hrefLang: null,
	    htmlFor: null,
	    httpEquiv: null,
	    icon: null,
	    id: MUST_USE_PROPERTY,
	    inputMode: MUST_USE_ATTRIBUTE,
	    integrity: null,
	    is: MUST_USE_ATTRIBUTE,
	    keyParams: MUST_USE_ATTRIBUTE,
	    keyType: MUST_USE_ATTRIBUTE,
	    kind: null,
	    label: null,
	    lang: null,
	    list: MUST_USE_ATTRIBUTE,
	    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    low: null,
	    manifest: MUST_USE_ATTRIBUTE,
	    marginHeight: null,
	    marginWidth: null,
	    max: null,
	    maxLength: MUST_USE_ATTRIBUTE,
	    media: MUST_USE_ATTRIBUTE,
	    mediaGroup: null,
	    method: null,
	    min: null,
	    minLength: MUST_USE_ATTRIBUTE,
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: null,
	    nonce: MUST_USE_ATTRIBUTE,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: null,
	    pattern: null,
	    placeholder: null,
	    poster: null,
	    preload: null,
	    radioGroup: null,
	    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    rel: null,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: MUST_USE_ATTRIBUTE,
	    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: null,
	    sandbox: null,
	    scope: null,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: null,
	    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: null,
	    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: MUST_USE_ATTRIBUTE,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: null,
	    src: null,
	    srcDoc: MUST_USE_PROPERTY,
	    srcLang: null,
	    srcSet: MUST_USE_ATTRIBUTE,
	    start: HAS_NUMERIC_VALUE,
	    step: null,
	    style: null,
	    summary: null,
	    tabIndex: null,
	    target: null,
	    title: null,
	    type: null,
	    useMap: null,
	    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
	    width: MUST_USE_ATTRIBUTE,
	    wmode: MUST_USE_ATTRIBUTE,
	    wrap: null,
	
	    /**
	     * RDFa Properties
	     */
	    about: MUST_USE_ATTRIBUTE,
	    datatype: MUST_USE_ATTRIBUTE,
	    inlist: MUST_USE_ATTRIBUTE,
	    prefix: MUST_USE_ATTRIBUTE,
	    // property is also supported for OpenGraph in meta tags.
	    property: MUST_USE_ATTRIBUTE,
	    resource: MUST_USE_ATTRIBUTE,
	    'typeof': MUST_USE_ATTRIBUTE,
	    vocab: MUST_USE_ATTRIBUTE,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: MUST_USE_ATTRIBUTE,
	    autoCorrect: MUST_USE_ATTRIBUTE,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: null,
	    // color is for Safari mask-icon link
	    color: null,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: MUST_USE_ATTRIBUTE,
	    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    itemType: MUST_USE_ATTRIBUTE,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: MUST_USE_ATTRIBUTE,
	    itemRef: MUST_USE_ATTRIBUTE,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: null,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: MUST_USE_ATTRIBUTE,
	    // IE-only attribute that controls focus behavior
	    unselectable: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {
	    autoComplete: 'autocomplete',
	    autoFocus: 'autofocus',
	    autoPlay: 'autoplay',
	    autoSave: 'autosave',
	    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
	    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
	    encType: 'encoding',
	    hrefLang: 'hreflang',
	    radioGroup: 'radiogroup',
	    spellCheck: 'spellcheck',
	    srcDoc: 'srcdoc',
	    srcSet: 'srcset'
	  }
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 438 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */
	
	'use strict';
	
	var ReactDOM = __webpack_require__(255);
	var ReactDOMServer = __webpack_require__(448);
	var ReactIsomorphic = __webpack_require__(452);
	
	var assign = __webpack_require__(7);
	var deprecated = __webpack_require__(472);
	
	// `version` will be added here by ReactIsomorphic.
	var React = {};
	
	assign(React, ReactIsomorphic);
	
	assign(React, {
	  // ReactDOM
	  findDOMNode: deprecated('findDOMNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.findDOMNode),
	  render: deprecated('render', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.render),
	  unmountComponentAtNode: deprecated('unmountComponentAtNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.unmountComponentAtNode),
	
	  // ReactDOMServer
	  renderToString: deprecated('renderToString', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToString),
	  renderToStaticMarkup: deprecated('renderToStaticMarkup', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToStaticMarkup)
	});
	
	React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOM;
	React.__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOMServer;
	
	module.exports = React;

/***/ },
/* 439 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserComponentMixin
	 */
	
	'use strict';
	
	var ReactInstanceMap = __webpack_require__(32);
	
	var findDOMNode = __webpack_require__(113);
	var warning = __webpack_require__(8);
	
	var didWarnKey = '_getDOMNodeDidWarn';
	
	var ReactBrowserComponentMixin = {
	  /**
	   * Returns the DOM node rendered by this component.
	   *
	   * @return {DOMElement} The root node of this component.
	   * @final
	   * @protected
	   */
	  getDOMNode: function () {
	     false ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'ReactDOM.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
	    this.constructor[didWarnKey] = true;
	    return findDOMNode(this);
	  }
	};
	
	module.exports = ReactBrowserComponentMixin;

/***/ },
/* 440 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildReconciler
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(23);
	
	var instantiateReactComponent = __webpack_require__(118);
	var shouldUpdateReactComponent = __webpack_require__(68);
	var traverseAllChildren = __webpack_require__(69);
	var warning = __webpack_require__(8);
	
	function instantiateChild(childInstances, child, name) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, null);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function (nestedChildNodes, transaction, context) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function (prevChildren, nextChildren, transaction, context) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return null;
	    }
	    var name;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      var prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          ReactReconciler.unmountComponent(prevChild, name);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, null);
	        nextChildren[name] = nextChildInstance;
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        ReactReconciler.unmountComponent(prevChildren[name]);
	      }
	    }
	    return nextChildren;
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function (renderedChildren) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;

/***/ },
/* 441 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentWithPureRenderMixin
	 */
	
	'use strict';
	
	var shallowCompare = __webpack_require__(478);
	
	/**
	 * If your React component's render function is "pure", e.g. it will render the
	 * same result given the same props and state, provide this Mixin for a
	 * considerable performance boost.
	 *
	 * Most React components have pure render functions.
	 *
	 * Example:
	 *
	 *   var ReactComponentWithPureRenderMixin =
	 *     require('ReactComponentWithPureRenderMixin');
	 *   React.createClass({
	 *     mixins: [ReactComponentWithPureRenderMixin],
	 *
	 *     render: function() {
	 *       return <div className={this.props.className}>foo</div>;
	 *     }
	 *   });
	 *
	 * Note: This only checks shallow equality for props and state. If these contain
	 * complex data structures this mixin may have false-negatives for deeper
	 * differences. Only mixin to components which have simple props and state, or
	 * use `forceUpdate()` when you know deep data structures have changed.
	 */
	var ReactComponentWithPureRenderMixin = {
	  shouldComponentUpdate: function (nextProps, nextState) {
	    return shallowCompare(this, nextProps, nextState);
	  }
	};
	
	module.exports = ReactComponentWithPureRenderMixin;

/***/ },
/* 442 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMButton
	 */
	
	'use strict';
	
	var mouseListenerNames = {
	  onClick: true,
	  onDoubleClick: true,
	  onMouseDown: true,
	  onMouseMove: true,
	  onMouseUp: true,
	
	  onClickCapture: true,
	  onDoubleClickCapture: true,
	  onMouseDownCapture: true,
	  onMouseMoveCapture: true,
	  onMouseUpCapture: true
	};
	
	/**
	 * Implements a <button> native component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var ReactDOMButton = {
	  getNativeProps: function (inst, props, context) {
	    if (!props.disabled) {
	      return props;
	    }
	
	    // Copy the props, except the mouse listeners
	    var nativeProps = {};
	    for (var key in props) {
	      if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {
	        nativeProps[key] = props[key];
	      }
	    }
	
	    return nativeProps;
	  }
	};
	
	module.exports = ReactDOMButton;

/***/ },
/* 443 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponent
	 * @typechecks static-only
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var AutoFocusUtils = __webpack_require__(427);
	var CSSPropertyOperations = __webpack_require__(429);
	var DOMProperty = __webpack_require__(35);
	var DOMPropertyOperations = __webpack_require__(104);
	var EventConstants = __webpack_require__(26);
	var ReactBrowserEventEmitter = __webpack_require__(61);
	var ReactComponentBrowserEnvironment = __webpack_require__(106);
	var ReactDOMButton = __webpack_require__(442);
	var ReactDOMInput = __webpack_require__(445);
	var ReactDOMOption = __webpack_require__(446);
	var ReactDOMSelect = __webpack_require__(257);
	var ReactDOMTextarea = __webpack_require__(449);
	var ReactMount = __webpack_require__(14);
	var ReactMultiChild = __webpack_require__(265);
	var ReactPerf = __webpack_require__(20);
	var ReactUpdateQueue = __webpack_require__(45);
	
	var assign = __webpack_require__(7);
	var canDefineProperty = __webpack_require__(65);
	var escapeTextContentForBrowser = __webpack_require__(66);
	var invariant = __webpack_require__(4);
	var isEventSupported = __webpack_require__(119);
	var keyOf = __webpack_require__(28);
	var setInnerHTML = __webpack_require__(67);
	var setTextContent = __webpack_require__(120);
	var shallowEqual = __webpack_require__(122);
	var validateDOMNesting = __webpack_require__(121);
	var warning = __webpack_require__(8);
	
	var deleteListener = ReactBrowserEventEmitter.deleteListener;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };
	
	var CHILDREN = keyOf({ children: null });
	var STYLE = keyOf({ style: null });
	var HTML = keyOf({ __html: null });
	
	var ELEMENT_NODE_TYPE = 1;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	var legacyPropsDescriptor;
	if (false) {
	  legacyPropsDescriptor = {
	    props: {
	      enumerable: false,
	      get: function () {
	        var component = this._reactInternalComponent;
	        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;
	        return component._currentElement.props;
	      }
	    }
	  };
	}
	
	function legacyGetDOMNode() {
	  if (false) {
	    var component = this._reactInternalComponent;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return this;
	}
	
	function legacyIsMounted() {
	  var component = this._reactInternalComponent;
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return !!component;
	}
	
	function legacySetStateEtc() {
	  if (false) {
	    var component = this._reactInternalComponent;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	}
	
	function legacySetProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}
	
	function legacyReplaceProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}
	
	function friendlyStringify(obj) {
	  if (typeof obj === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined becauses undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	   false ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : undefined;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (false) {
	    if (voidElementTags[component._tag]) {
	      process.env.NODE_ENV !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;
	    }
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ?  false ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
	    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ?  false ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
	  }
	  if (false) {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
	    process.env.NODE_ENV !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
	  }
	  !(props.style == null || typeof props.style === 'object') ?  false ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : undefined;
	}
	
	function enqueuePutListener(id, registrationName, listener, transaction) {
	  if (false) {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
	  }
	  var container = ReactMount.findReactContainerForID(id);
	  if (container) {
	    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
	    listenTo(registrationName, doc);
	  }
	  transaction.getReactMountReady().enqueue(putListener, {
	    id: id,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ?  false ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
	  var node = ReactMount.getNode(inst._rootNodeID);
	  !node ?  false ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;
	
	  switch (inst._tag) {
	    case 'iframe':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	
	      inst._wrapperState.listeners = [];
	      // create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
	        }
	      }
	
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
	      break;
	  }
	}
	
	function mountReadyInputWrapper() {
	  ReactDOMInput.mountReadyWrapper(this);
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special cased tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};
	
	// NOTE: menuitem's close tag should be omitted, but that causes problems.
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = assign({
	  'menuitem': true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = ({}).hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ?  false ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function processChildContextDev(context, inst) {
	  // Pass down our tag name to child components for validation purposes
	  context = assign({}, context);
	  var info = context[validateDOMNesting.ancestorInfoContextKey];
	  context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
	  return context;
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(tag) {
	  validateDangerousTag(tag);
	  this._tag = tag.toLowerCase();
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._rootNodeID = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._nodeWithLegacyProperties = null;
	  if (false) {
	    this._unprocessedContextDev = null;
	    this._processedContextDev = null;
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  construct: function (element) {
	    this._currentElement = element;
	  },
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {string} rootID The root DOM ID for this node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function (rootID, transaction, context) {
	    this._rootNodeID = rootID;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'button':
	        props = ReactDOMButton.getNativeProps(this, props, context);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, context);
	        props = ReactDOMInput.getNativeProps(this, props, context);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, context);
	        props = ReactDOMOption.getNativeProps(this, props, context);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, context);
	        props = ReactDOMSelect.getNativeProps(this, props, context);
	        context = ReactDOMSelect.processChildContext(this, props, context);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, context);
	        props = ReactDOMTextarea.getNativeProps(this, props, context);
	        break;
	    }
	
	    assertValidProps(this, props);
	    if (false) {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }
	
	    if (false) {
	      this._unprocessedContextDev = context;
	      this._processedContextDev = processChildContextDev(context, this);
	      context = this._processedContextDev;
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElement(this._currentElement.type);
	      DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);
	      // Populate node cache
	      ReactMount.getID(el);
	      this._updateDOMProperties({}, props, transaction, el);
	      this._createInitialChildren(transaction, props, context, el);
	      mountImage = el;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);
	      // falls through
	      case 'button':
	      case 'select':
	      case 'textarea':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (false) {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (propKey !== CHILDREN) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
	    return ret + ' ' + markupForID;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function (transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function (transaction, props, context, el) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        setInnerHTML(el, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        setTextContent(el, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          el.appendChild(mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function (nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a native DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'button':
	        lastProps = ReactDOMButton.getNativeProps(this, lastProps);
	        nextProps = ReactDOMButton.getNativeProps(this, nextProps);
	        break;
	      case 'input':
	        ReactDOMInput.updateWrapper(this);
	        lastProps = ReactDOMInput.getNativeProps(this, lastProps);
	        nextProps = ReactDOMInput.getNativeProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getNativeProps(this, lastProps);
	        nextProps = ReactDOMOption.getNativeProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
	        nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
	        break;
	    }
	
	    if (false) {
	      // If the context is reference-equal to the old one, pass down the same
	      // processed object so the update bailout in ReactReconciler behaves
	      // correctly (and identically in dev and prod). See #5005.
	      if (this._unprocessedContextDev !== context) {
	        this._unprocessedContextDev = context;
	        this._processedContextDev = processChildContextDev(context, this);
	      }
	      context = this._processedContextDev;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction, null);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    if (!canDefineProperty && this._nodeWithLegacyProperties) {
	      this._nodeWithLegacyProperties.props = nextProps;
	    }
	
	    if (this._tag === 'select') {
	      // <select> value update needs to occur after <option> children
	      // reconciliation
	      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function (lastProps, nextProps, transaction, node) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        DOMPropertyOperations.deleteValueForProperty(node, propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (false) {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        if (propKey === CHILDREN) {
	          nextProp = null;
	        }
	        DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertantly setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      if (!node) {
	        node = ReactMount.getNode(this._rootNodeID);
	      }
	      CSSPropertyOperations.setValueForStyles(node, styleUpdates);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	    } else if (nextChildren != null) {
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function () {
	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'input':
	        ReactDOMInput.unmountWrapper(this);
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ?  false ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;
	        break;
	    }
	
	    this.unmountChildren();
	    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	    this._rootNodeID = null;
	    this._wrapperState = null;
	    if (this._nodeWithLegacyProperties) {
	      var node = this._nodeWithLegacyProperties;
	      node._reactInternalComponent = null;
	      this._nodeWithLegacyProperties = null;
	    }
	  },
	
	  getPublicInstance: function () {
	    if (!this._nodeWithLegacyProperties) {
	      var node = ReactMount.getNode(this._rootNodeID);
	
	      node._reactInternalComponent = this;
	      node.getDOMNode = legacyGetDOMNode;
	      node.isMounted = legacyIsMounted;
	      node.setState = legacySetStateEtc;
	      node.replaceState = legacySetStateEtc;
	      node.forceUpdate = legacySetStateEtc;
	      node.setProps = legacySetProps;
	      node.replaceProps = legacyReplaceProps;
	
	      if (false) {
	        if (canDefineProperty) {
	          Object.defineProperties(node, legacyPropsDescriptor);
	        } else {
	          // updateComponent will update this property on subsequent renders
	          node.props = this._currentElement.props;
	        }
	      } else {
	        // updateComponent will update this property on subsequent renders
	        node.props = this._currentElement.props;
	      }
	
	      this._nodeWithLegacyProperties = node;
	    }
	    return this._nodeWithLegacyProperties;
	  }
	
	};
	
	ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent'
	});
	
	assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;

/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFactories
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(11);
	var ReactElementValidator = __webpack_require__(260);
	
	var mapObject = __webpack_require__(488);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @param {string} tag Tag name (e.g. `div`).
	 * @private
	 */
	function createDOMFactory(tag) {
	  if (false) {
	    return ReactElementValidator.createFactory(tag);
	  }
	  return ReactElement.createFactory(tag);
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = mapObject({
	  a: 'a',
	  abbr: 'abbr',
	  address: 'address',
	  area: 'area',
	  article: 'article',
	  aside: 'aside',
	  audio: 'audio',
	  b: 'b',
	  base: 'base',
	  bdi: 'bdi',
	  bdo: 'bdo',
	  big: 'big',
	  blockquote: 'blockquote',
	  body: 'body',
	  br: 'br',
	  button: 'button',
	  canvas: 'canvas',
	  caption: 'caption',
	  cite: 'cite',
	  code: 'code',
	  col: 'col',
	  colgroup: 'colgroup',
	  data: 'data',
	  datalist: 'datalist',
	  dd: 'dd',
	  del: 'del',
	  details: 'details',
	  dfn: 'dfn',
	  dialog: 'dialog',
	  div: 'div',
	  dl: 'dl',
	  dt: 'dt',
	  em: 'em',
	  embed: 'embed',
	  fieldset: 'fieldset',
	  figcaption: 'figcaption',
	  figure: 'figure',
	  footer: 'footer',
	  form: 'form',
	  h1: 'h1',
	  h2: 'h2',
	  h3: 'h3',
	  h4: 'h4',
	  h5: 'h5',
	  h6: 'h6',
	  head: 'head',
	  header: 'header',
	  hgroup: 'hgroup',
	  hr: 'hr',
	  html: 'html',
	  i: 'i',
	  iframe: 'iframe',
	  img: 'img',
	  input: 'input',
	  ins: 'ins',
	  kbd: 'kbd',
	  keygen: 'keygen',
	  label: 'label',
	  legend: 'legend',
	  li: 'li',
	  link: 'link',
	  main: 'main',
	  map: 'map',
	  mark: 'mark',
	  menu: 'menu',
	  menuitem: 'menuitem',
	  meta: 'meta',
	  meter: 'meter',
	  nav: 'nav',
	  noscript: 'noscript',
	  object: 'object',
	  ol: 'ol',
	  optgroup: 'optgroup',
	  option: 'option',
	  output: 'output',
	  p: 'p',
	  param: 'param',
	  picture: 'picture',
	  pre: 'pre',
	  progress: 'progress',
	  q: 'q',
	  rp: 'rp',
	  rt: 'rt',
	  ruby: 'ruby',
	  s: 's',
	  samp: 'samp',
	  script: 'script',
	  section: 'section',
	  select: 'select',
	  small: 'small',
	  source: 'source',
	  span: 'span',
	  strong: 'strong',
	  style: 'style',
	  sub: 'sub',
	  summary: 'summary',
	  sup: 'sup',
	  table: 'table',
	  tbody: 'tbody',
	  td: 'td',
	  textarea: 'textarea',
	  tfoot: 'tfoot',
	  th: 'th',
	  thead: 'thead',
	  time: 'time',
	  title: 'title',
	  tr: 'tr',
	  track: 'track',
	  u: 'u',
	  ul: 'ul',
	  'var': 'var',
	  video: 'video',
	  wbr: 'wbr',
	
	  // SVG
	  circle: 'circle',
	  clipPath: 'clipPath',
	  defs: 'defs',
	  ellipse: 'ellipse',
	  g: 'g',
	  image: 'image',
	  line: 'line',
	  linearGradient: 'linearGradient',
	  mask: 'mask',
	  path: 'path',
	  pattern: 'pattern',
	  polygon: 'polygon',
	  polyline: 'polyline',
	  radialGradient: 'radialGradient',
	  rect: 'rect',
	  stop: 'stop',
	  svg: 'svg',
	  text: 'text',
	  tspan: 'tspan'
	
	}, createDOMFactory);
	
	module.exports = ReactDOMFactories;

/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMInput
	 */
	
	'use strict';
	
	var ReactDOMIDOperations = __webpack_require__(108);
	var LinkedValueUtils = __webpack_require__(105);
	var ReactMount = __webpack_require__(14);
	var ReactUpdates = __webpack_require__(18);
	
	var assign = __webpack_require__(7);
	var invariant = __webpack_require__(4);
	
	var instancesByReactID = {};
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements an <input> native component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getNativeProps: function (inst, props, context) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var nativeProps = assign({}, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return nativeProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (false) {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.defaultChecked || false,
	      initialValue: defaultValue != null ? defaultValue : null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  mountReadyWrapper: function (inst) {
	    // Can't be in mountWrapper or else server rendering leaks.
	    instancesByReactID[inst._rootNodeID] = inst;
	  },
	
	  unmountWrapper: function (inst) {
	    delete instancesByReactID[inst._rootNodeID];
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactMount.getNode(this._rootNodeID);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React with non-React.
	      var otherID = ReactMount.getID(otherNode);
	      !otherID ?  false ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
	      var otherInstance = instancesByReactID[otherID];
	      !otherInstance ?  false ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;

/***/ },
/* 446 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMOption
	 */
	
	'use strict';
	
	var ReactChildren = __webpack_require__(252);
	var ReactDOMSelect = __webpack_require__(257);
	
	var assign = __webpack_require__(7);
	var warning = __webpack_require__(8);
	
	var valueContextKey = ReactDOMSelect.valueContextKey;
	
	/**
	 * Implements an <option> native component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function (inst, props, context) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (false) {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
	    }
	
	    // Look up whether this option is 'selected' via context
	    var selectValue = context[valueContextKey];
	
	    // If context key is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === '' + props.value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === '' + props.value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  getNativeProps: function (inst, props, context) {
	    var nativeProps = assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      nativeProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = '';
	
	    // Flatten children and warn if they aren't strings or numbers;
	    // invalid types are ignored.
	    ReactChildren.forEach(props.children, function (child) {
	      if (child == null) {
	        return;
	      }
	      if (typeof child === 'string' || typeof child === 'number') {
	        content += child;
	      } else {
	         false ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
	      }
	    });
	
	    nativeProps.children = content;
	    return nativeProps;
	  }
	
	};
	
	module.exports = ReactDOMOption;

/***/ },
/* 447 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelection
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(12);
	
	var getNodeForCharacterOffset = __webpack_require__(474);
	var getTextContentAccessor = __webpack_require__(275);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (typeof offsets.end === 'undefined') {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMServer
	 */
	
	'use strict';
	
	var ReactDefaultInjection = __webpack_require__(259);
	var ReactServerRendering = __webpack_require__(456);
	var ReactVersion = __webpack_require__(112);
	
	ReactDefaultInjection.inject();
	
	var ReactDOMServer = {
	  renderToString: ReactServerRendering.renderToString,
	  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
	  version: ReactVersion
	};
	
	module.exports = ReactDOMServer;

/***/ },
/* 449 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextarea
	 */
	
	'use strict';
	
	var LinkedValueUtils = __webpack_require__(105);
	var ReactDOMIDOperations = __webpack_require__(108);
	var ReactUpdates = __webpack_require__(18);
	
	var assign = __webpack_require__(7);
	var invariant = __webpack_require__(4);
	var warning = __webpack_require__(8);
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> native component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getNativeProps: function (inst, props, context) {
	    !(props.dangerouslySetInnerHTML == null) ?  false ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.
	    var nativeProps = assign({}, props, {
	      defaultValue: undefined,
	      value: undefined,
	      children: inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return nativeProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (false) {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	    }
	
	    var defaultValue = props.defaultValue;
	    // TODO (yungsters): Remove support for children content in <textarea>.
	    var children = props.children;
	    if (children != null) {
	      if (false) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
	      }
	      !(defaultValue == null) ?  false ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
	      if (Array.isArray(children)) {
	        !(children.length <= 1) ?  false ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
	        children = children[0];
	      }
	
	      defaultValue = '' + children;
	    }
	    if (defaultValue == null) {
	      defaultValue = '';
	    }
	    var value = LinkedValueUtils.getValue(props);
	
	    inst._wrapperState = {
	      // We save the initial value so that `ReactDOMComponent` doesn't update
	      // `textContent` (unnecessary since we update value).
	      // The initial value can be a boolean or object so that's why it's
	      // forced to be a string.
	      initialValue: '' + (value != null ? value : defaultValue),
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;

/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventEmitterMixin
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(42);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {object} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native environment event.
	   */
	  handleTopLevel: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventListener
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventListener = __webpack_require__(277);
	var ExecutionEnvironment = __webpack_require__(12);
	var PooledClass = __webpack_require__(27);
	var ReactInstanceHandles = __webpack_require__(31);
	var ReactMount = __webpack_require__(14);
	var ReactUpdates = __webpack_require__(18);
	
	var assign = __webpack_require__(7);
	var getEventTarget = __webpack_require__(116);
	var getUnboundedScrollPosition = __webpack_require__(483);
	
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * Finds the parent React component of `node`.
	 *
	 * @param {*} node
	 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
	 *                           is not nested.
	 */
	function findParent(node) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  var nodeID = ReactMount.getID(node);
	  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	  var container = ReactMount.findReactContainerForID(rootID);
	  var parent = ReactMount.getFirstReactDOM(container);
	  return parent;
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function () {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  // TODO: Re-enable event.path handling
	  //
	  // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {
	  //   // New browsers have a path attribute on native events
	  //   handleTopLevelWithPath(bookKeeping);
	  // } else {
	  //   // Legacy browsers don't have a path attribute on native events
	  //   handleTopLevelWithoutPath(bookKeeping);
	  // }
	
	  void handleTopLevelWithPath; // temporarily unused
	  handleTopLevelWithoutPath(bookKeeping);
	}
	
	// Legacy browsers don't have a path attribute on native events
	function handleTopLevelWithoutPath(bookKeeping) {
	  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = topLevelTarget;
	  while (ancestor) {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = findParent(ancestor);
	  }
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    topLevelTarget = bookKeeping.ancestors[i];
	    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	// New browsers have a path attribute on native events
	function handleTopLevelWithPath(bookKeeping) {
	  var path = bookKeeping.nativeEvent.path;
	  var currentNativeTarget = path[0];
	  var eventsFired = 0;
	  for (var i = 0; i < path.length; i++) {
	    var currentPathElement = path[i];
	    if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
	      currentNativeTarget = path[i + 1];
	    }
	    // TODO: slow
	    var reactParent = ReactMount.getFirstReactDOM(currentPathElement);
	    if (reactParent === currentPathElement) {
	      var currentPathElementID = ReactMount.getID(currentPathElement);
	      var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
	      bookKeeping.ancestors.push(currentPathElement);
	
	      var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
	      eventsFired++;
	      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);
	
	      // Jump to the root of this React render tree
	      while (currentPathElementID !== newRootID) {
	        i++;
	        currentPathElement = path[i];
	        currentPathElementID = ReactMount.getID(currentPathElement);
	      }
	    }
	  }
	  if (eventsFired === 0) {
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function (handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function (enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function () {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function (refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function (topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactIsomorphic
	 */
	
	'use strict';
	
	var ReactChildren = __webpack_require__(252);
	var ReactComponent = __webpack_require__(62);
	var ReactClass = __webpack_require__(253);
	var ReactDOMFactories = __webpack_require__(444);
	var ReactElement = __webpack_require__(11);
	var ReactElementValidator = __webpack_require__(260);
	var ReactPropTypes = __webpack_require__(3);
	var ReactVersion = __webpack_require__(112);
	
	var assign = __webpack_require__(7);
	var onlyChild = __webpack_require__(475);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (false) {
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var React = {
	
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function (mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Hook for JSX spread, don't use this for anything else.
	  __spread: assign
	};
	
	module.exports = React;

/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactOwner
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(4);
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	
	  /**
	   * @param {?object} object
	   * @return {boolean} True if `object` is a valid owner.
	   * @final
	   */
	  isValidOwner: function (object) {
	    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	  },
	
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ?  false ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ?  false ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    // Check that `component` is still the current ref because we do not want to
	    // detach the ref if another component stole it.
	    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;

/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRef
	 */
	
	'use strict';
	
	var ReactOwner = __webpack_require__(453);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	
	  return(
	    // This has a few false positives w/r/t empty components.
	    prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref
	  );
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ },
/* 455 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerBatchingStrategy
	 * @typechecks
	 */
	
	'use strict';
	
	var ReactServerBatchingStrategy = {
	  isBatchingUpdates: false,
	  batchedUpdates: function (callback) {
	    // Don't do anything here. During the server rendering we don't want to
	    // schedule any updates. We will simply ignore them.
	  }
	};
	
	module.exports = ReactServerBatchingStrategy;

/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 * @providesModule ReactServerRendering
	 */
	'use strict';
	
	var ReactDefaultBatchingStrategy = __webpack_require__(109);
	var ReactElement = __webpack_require__(11);
	var ReactInstanceHandles = __webpack_require__(31);
	var ReactMarkupChecksum = __webpack_require__(264);
	var ReactServerBatchingStrategy = __webpack_require__(455);
	var ReactServerRenderingTransaction = __webpack_require__(457);
	var ReactUpdates = __webpack_require__(18);
	
	var emptyObject = __webpack_require__(47);
	var instantiateReactComponent = __webpack_require__(118);
	var invariant = __webpack_require__(4);
	
	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup
	 */
	function renderToString(element) {
	  !ReactElement.isValidElement(element) ?  false ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;
	
	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
	
	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(false);
	
	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      var markup = componentInstance.mountComponent(id, transaction, emptyObject);
	      return ReactMarkupChecksum.addChecksumToMarkup(markup);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}
	
	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup, without the extra React ID and checksum
	 * (for generating static pages)
	 */
	function renderToStaticMarkup(element) {
	  !ReactElement.isValidElement(element) ?  false ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;
	
	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
	
	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(true);
	
	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      return componentInstance.mountComponent(id, transaction, emptyObject);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}
	
	module.exports = {
	  renderToString: renderToString,
	  renderToStaticMarkup: renderToStaticMarkup
	};

/***/ },
/* 457 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerRenderingTransaction
	 * @typechecks
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(27);
	var CallbackQueue = __webpack_require__(103);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(7);
	var emptyFunction = __webpack_require__(24);
	
	/**
	 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
	 * during the performing of the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },
	
	  close: emptyFunction
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = false;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;

/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SVGDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(35);
	
	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {
	    clipPath: MUST_USE_ATTRIBUTE,
	    cx: MUST_USE_ATTRIBUTE,
	    cy: MUST_USE_ATTRIBUTE,
	    d: MUST_USE_ATTRIBUTE,
	    dx: MUST_USE_ATTRIBUTE,
	    dy: MUST_USE_ATTRIBUTE,
	    fill: MUST_USE_ATTRIBUTE,
	    fillOpacity: MUST_USE_ATTRIBUTE,
	    fontFamily: MUST_USE_ATTRIBUTE,
	    fontSize: MUST_USE_ATTRIBUTE,
	    fx: MUST_USE_ATTRIBUTE,
	    fy: MUST_USE_ATTRIBUTE,
	    gradientTransform: MUST_USE_ATTRIBUTE,
	    gradientUnits: MUST_USE_ATTRIBUTE,
	    markerEnd: MUST_USE_ATTRIBUTE,
	    markerMid: MUST_USE_ATTRIBUTE,
	    markerStart: MUST_USE_ATTRIBUTE,
	    offset: MUST_USE_ATTRIBUTE,
	    opacity: MUST_USE_ATTRIBUTE,
	    patternContentUnits: MUST_USE_ATTRIBUTE,
	    patternUnits: MUST_USE_ATTRIBUTE,
	    points: MUST_USE_ATTRIBUTE,
	    preserveAspectRatio: MUST_USE_ATTRIBUTE,
	    r: MUST_USE_ATTRIBUTE,
	    rx: MUST_USE_ATTRIBUTE,
	    ry: MUST_USE_ATTRIBUTE,
	    spreadMethod: MUST_USE_ATTRIBUTE,
	    stopColor: MUST_USE_ATTRIBUTE,
	    stopOpacity: MUST_USE_ATTRIBUTE,
	    stroke: MUST_USE_ATTRIBUTE,
	    strokeDasharray: MUST_USE_ATTRIBUTE,
	    strokeLinecap: MUST_USE_ATTRIBUTE,
	    strokeOpacity: MUST_USE_ATTRIBUTE,
	    strokeWidth: MUST_USE_ATTRIBUTE,
	    textAnchor: MUST_USE_ATTRIBUTE,
	    transform: MUST_USE_ATTRIBUTE,
	    version: MUST_USE_ATTRIBUTE,
	    viewBox: MUST_USE_ATTRIBUTE,
	    x1: MUST_USE_ATTRIBUTE,
	    x2: MUST_USE_ATTRIBUTE,
	    x: MUST_USE_ATTRIBUTE,
	    xlinkActuate: MUST_USE_ATTRIBUTE,
	    xlinkArcrole: MUST_USE_ATTRIBUTE,
	    xlinkHref: MUST_USE_ATTRIBUTE,
	    xlinkRole: MUST_USE_ATTRIBUTE,
	    xlinkShow: MUST_USE_ATTRIBUTE,
	    xlinkTitle: MUST_USE_ATTRIBUTE,
	    xlinkType: MUST_USE_ATTRIBUTE,
	    xmlBase: MUST_USE_ATTRIBUTE,
	    xmlLang: MUST_USE_ATTRIBUTE,
	    xmlSpace: MUST_USE_ATTRIBUTE,
	    y1: MUST_USE_ATTRIBUTE,
	    y2: MUST_USE_ATTRIBUTE,
	    y: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {
	    clipPath: 'clip-path',
	    fillOpacity: 'fill-opacity',
	    fontFamily: 'font-family',
	    fontSize: 'font-size',
	    gradientTransform: 'gradientTransform',
	    gradientUnits: 'gradientUnits',
	    markerEnd: 'marker-end',
	    markerMid: 'marker-mid',
	    markerStart: 'marker-start',
	    patternContentUnits: 'patternContentUnits',
	    patternUnits: 'patternUnits',
	    preserveAspectRatio: 'preserveAspectRatio',
	    spreadMethod: 'spreadMethod',
	    stopColor: 'stop-color',
	    stopOpacity: 'stop-opacity',
	    strokeDasharray: 'stroke-dasharray',
	    strokeLinecap: 'stroke-linecap',
	    strokeOpacity: 'stroke-opacity',
	    strokeWidth: 'stroke-width',
	    textAnchor: 'text-anchor',
	    viewBox: 'viewBox',
	    xlinkActuate: 'xlink:actuate',
	    xlinkArcrole: 'xlink:arcrole',
	    xlinkHref: 'xlink:href',
	    xlinkRole: 'xlink:role',
	    xlinkShow: 'xlink:show',
	    xlinkTitle: 'xlink:title',
	    xlinkType: 'xlink:type',
	    xmlBase: 'xml:base',
	    xmlLang: 'xml:lang',
	    xmlSpace: 'xml:space'
	  }
	};
	
	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 459 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SelectEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(26);
	var EventPropagators = __webpack_require__(43);
	var ExecutionEnvironment = __webpack_require__(12);
	var ReactInputSelection = __webpack_require__(263);
	var SyntheticEvent = __webpack_require__(34);
	
	var getActiveElement = __webpack_require__(280);
	var isTextInputElement = __webpack_require__(276);
	var keyOf = __webpack_require__(28);
	var shallowEqual = __webpack_require__(122);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSelect: null }),
	      captured: keyOf({ onSelectCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	var activeElement = null;
	var activeElementID = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events.
	var hasListener = false;
	var ON_SELECT_KEY = keyOf({ onSelect: null });
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case topLevelTypes.topFocus:
	        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
	          activeElement = topLevelTarget;
	          activeElementID = topLevelTargetID;
	          lastSelection = null;
	        }
	        break;
	      case topLevelTypes.topBlur:
	        activeElement = null;
	        activeElementID = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case topLevelTypes.topMouseDown:
	        mouseDown = true;
	        break;
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topMouseUp:
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case topLevelTypes.topSelectionChange:
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function (id, registrationName, listener) {
	    if (registrationName === ON_SELECT_KEY) {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ },
/* 460 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ServerReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Size of the reactRoot ID space. We generate random numbers for React root
	 * IDs and if there's a collision the events and DOM update system will
	 * get confused. In the future we need a way to generate GUIDs but for
	 * now this will work on a smaller scale.
	 */
	var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
	
	var ServerReactRootIndex = {
	  createReactRootIndex: function () {
	    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
	  }
	};
	
	module.exports = ServerReactRootIndex;

/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SimpleEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(26);
	var EventListener = __webpack_require__(277);
	var EventPropagators = __webpack_require__(43);
	var ReactMount = __webpack_require__(14);
	var SyntheticClipboardEvent = __webpack_require__(462);
	var SyntheticEvent = __webpack_require__(34);
	var SyntheticFocusEvent = __webpack_require__(465);
	var SyntheticKeyboardEvent = __webpack_require__(467);
	var SyntheticMouseEvent = __webpack_require__(63);
	var SyntheticDragEvent = __webpack_require__(464);
	var SyntheticTouchEvent = __webpack_require__(468);
	var SyntheticUIEvent = __webpack_require__(46);
	var SyntheticWheelEvent = __webpack_require__(469);
	
	var emptyFunction = __webpack_require__(24);
	var getEventCharCode = __webpack_require__(114);
	var invariant = __webpack_require__(4);
	var keyOf = __webpack_require__(28);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  abort: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAbort: true }),
	      captured: keyOf({ onAbortCapture: true })
	    }
	  },
	  blur: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBlur: true }),
	      captured: keyOf({ onBlurCapture: true })
	    }
	  },
	  canPlay: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlay: true }),
	      captured: keyOf({ onCanPlayCapture: true })
	    }
	  },
	  canPlayThrough: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlayThrough: true }),
	      captured: keyOf({ onCanPlayThroughCapture: true })
	    }
	  },
	  click: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onClick: true }),
	      captured: keyOf({ onClickCapture: true })
	    }
	  },
	  contextMenu: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onContextMenu: true }),
	      captured: keyOf({ onContextMenuCapture: true })
	    }
	  },
	  copy: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCopy: true }),
	      captured: keyOf({ onCopyCapture: true })
	    }
	  },
	  cut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCut: true }),
	      captured: keyOf({ onCutCapture: true })
	    }
	  },
	  doubleClick: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDoubleClick: true }),
	      captured: keyOf({ onDoubleClickCapture: true })
	    }
	  },
	  drag: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrag: true }),
	      captured: keyOf({ onDragCapture: true })
	    }
	  },
	  dragEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnd: true }),
	      captured: keyOf({ onDragEndCapture: true })
	    }
	  },
	  dragEnter: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnter: true }),
	      captured: keyOf({ onDragEnterCapture: true })
	    }
	  },
	  dragExit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragExit: true }),
	      captured: keyOf({ onDragExitCapture: true })
	    }
	  },
	  dragLeave: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragLeave: true }),
	      captured: keyOf({ onDragLeaveCapture: true })
	    }
	  },
	  dragOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragOver: true }),
	      captured: keyOf({ onDragOverCapture: true })
	    }
	  },
	  dragStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragStart: true }),
	      captured: keyOf({ onDragStartCapture: true })
	    }
	  },
	  drop: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrop: true }),
	      captured: keyOf({ onDropCapture: true })
	    }
	  },
	  durationChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDurationChange: true }),
	      captured: keyOf({ onDurationChangeCapture: true })
	    }
	  },
	  emptied: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEmptied: true }),
	      captured: keyOf({ onEmptiedCapture: true })
	    }
	  },
	  encrypted: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEncrypted: true }),
	      captured: keyOf({ onEncryptedCapture: true })
	    }
	  },
	  ended: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEnded: true }),
	      captured: keyOf({ onEndedCapture: true })
	    }
	  },
	  error: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onError: true }),
	      captured: keyOf({ onErrorCapture: true })
	    }
	  },
	  focus: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onFocus: true }),
	      captured: keyOf({ onFocusCapture: true })
	    }
	  },
	  input: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInput: true }),
	      captured: keyOf({ onInputCapture: true })
	    }
	  },
	  keyDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyDown: true }),
	      captured: keyOf({ onKeyDownCapture: true })
	    }
	  },
	  keyPress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyPress: true }),
	      captured: keyOf({ onKeyPressCapture: true })
	    }
	  },
	  keyUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyUp: true }),
	      captured: keyOf({ onKeyUpCapture: true })
	    }
	  },
	  load: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoad: true }),
	      captured: keyOf({ onLoadCapture: true })
	    }
	  },
	  loadedData: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedData: true }),
	      captured: keyOf({ onLoadedDataCapture: true })
	    }
	  },
	  loadedMetadata: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedMetadata: true }),
	      captured: keyOf({ onLoadedMetadataCapture: true })
	    }
	  },
	  loadStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadStart: true }),
	      captured: keyOf({ onLoadStartCapture: true })
	    }
	  },
	  // Note: We do not allow listening to mouseOver events. Instead, use the
	  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
	  mouseDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseDown: true }),
	      captured: keyOf({ onMouseDownCapture: true })
	    }
	  },
	  mouseMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseMove: true }),
	      captured: keyOf({ onMouseMoveCapture: true })
	    }
	  },
	  mouseOut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOut: true }),
	      captured: keyOf({ onMouseOutCapture: true })
	    }
	  },
	  mouseOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOver: true }),
	      captured: keyOf({ onMouseOverCapture: true })
	    }
	  },
	  mouseUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseUp: true }),
	      captured: keyOf({ onMouseUpCapture: true })
	    }
	  },
	  paste: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPaste: true }),
	      captured: keyOf({ onPasteCapture: true })
	    }
	  },
	  pause: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPause: true }),
	      captured: keyOf({ onPauseCapture: true })
	    }
	  },
	  play: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlay: true }),
	      captured: keyOf({ onPlayCapture: true })
	    }
	  },
	  playing: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlaying: true }),
	      captured: keyOf({ onPlayingCapture: true })
	    }
	  },
	  progress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onProgress: true }),
	      captured: keyOf({ onProgressCapture: true })
	    }
	  },
	  rateChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onRateChange: true }),
	      captured: keyOf({ onRateChangeCapture: true })
	    }
	  },
	  reset: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onReset: true }),
	      captured: keyOf({ onResetCapture: true })
	    }
	  },
	  scroll: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onScroll: true }),
	      captured: keyOf({ onScrollCapture: true })
	    }
	  },
	  seeked: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeked: true }),
	      captured: keyOf({ onSeekedCapture: true })
	    }
	  },
	  seeking: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeking: true }),
	      captured: keyOf({ onSeekingCapture: true })
	    }
	  },
	  stalled: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onStalled: true }),
	      captured: keyOf({ onStalledCapture: true })
	    }
	  },
	  submit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSubmit: true }),
	      captured: keyOf({ onSubmitCapture: true })
	    }
	  },
	  suspend: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSuspend: true }),
	      captured: keyOf({ onSuspendCapture: true })
	    }
	  },
	  timeUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTimeUpdate: true }),
	      captured: keyOf({ onTimeUpdateCapture: true })
	    }
	  },
	  touchCancel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchCancel: true }),
	      captured: keyOf({ onTouchCancelCapture: true })
	    }
	  },
	  touchEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchEnd: true }),
	      captured: keyOf({ onTouchEndCapture: true })
	    }
	  },
	  touchMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchMove: true }),
	      captured: keyOf({ onTouchMoveCapture: true })
	    }
	  },
	  touchStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchStart: true }),
	      captured: keyOf({ onTouchStartCapture: true })
	    }
	  },
	  volumeChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onVolumeChange: true }),
	      captured: keyOf({ onVolumeChangeCapture: true })
	    }
	  },
	  waiting: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWaiting: true }),
	      captured: keyOf({ onWaitingCapture: true })
	    }
	  },
	  wheel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWheel: true }),
	      captured: keyOf({ onWheelCapture: true })
	    }
	  }
	};
	
	var topLevelEventsToDispatchConfig = {
	  topAbort: eventTypes.abort,
	  topBlur: eventTypes.blur,
	  topCanPlay: eventTypes.canPlay,
	  topCanPlayThrough: eventTypes.canPlayThrough,
	  topClick: eventTypes.click,
	  topContextMenu: eventTypes.contextMenu,
	  topCopy: eventTypes.copy,
	  topCut: eventTypes.cut,
	  topDoubleClick: eventTypes.doubleClick,
	  topDrag: eventTypes.drag,
	  topDragEnd: eventTypes.dragEnd,
	  topDragEnter: eventTypes.dragEnter,
	  topDragExit: eventTypes.dragExit,
	  topDragLeave: eventTypes.dragLeave,
	  topDragOver: eventTypes.dragOver,
	  topDragStart: eventTypes.dragStart,
	  topDrop: eventTypes.drop,
	  topDurationChange: eventTypes.durationChange,
	  topEmptied: eventTypes.emptied,
	  topEncrypted: eventTypes.encrypted,
	  topEnded: eventTypes.ended,
	  topError: eventTypes.error,
	  topFocus: eventTypes.focus,
	  topInput: eventTypes.input,
	  topKeyDown: eventTypes.keyDown,
	  topKeyPress: eventTypes.keyPress,
	  topKeyUp: eventTypes.keyUp,
	  topLoad: eventTypes.load,
	  topLoadedData: eventTypes.loadedData,
	  topLoadedMetadata: eventTypes.loadedMetadata,
	  topLoadStart: eventTypes.loadStart,
	  topMouseDown: eventTypes.mouseDown,
	  topMouseMove: eventTypes.mouseMove,
	  topMouseOut: eventTypes.mouseOut,
	  topMouseOver: eventTypes.mouseOver,
	  topMouseUp: eventTypes.mouseUp,
	  topPaste: eventTypes.paste,
	  topPause: eventTypes.pause,
	  topPlay: eventTypes.play,
	  topPlaying: eventTypes.playing,
	  topProgress: eventTypes.progress,
	  topRateChange: eventTypes.rateChange,
	  topReset: eventTypes.reset,
	  topScroll: eventTypes.scroll,
	  topSeeked: eventTypes.seeked,
	  topSeeking: eventTypes.seeking,
	  topStalled: eventTypes.stalled,
	  topSubmit: eventTypes.submit,
	  topSuspend: eventTypes.suspend,
	  topTimeUpdate: eventTypes.timeUpdate,
	  topTouchCancel: eventTypes.touchCancel,
	  topTouchEnd: eventTypes.touchEnd,
	  topTouchMove: eventTypes.touchMove,
	  topTouchStart: eventTypes.touchStart,
	  topVolumeChange: eventTypes.volumeChange,
	  topWaiting: eventTypes.waiting,
	  topWheel: eventTypes.wheel
	};
	
	for (var type in topLevelEventsToDispatchConfig) {
	  topLevelEventsToDispatchConfig[type].dependencies = [type];
	}
	
	var ON_CLICK_KEY = keyOf({ onClick: null });
	var onClickListeners = {};
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case topLevelTypes.topAbort:
	      case topLevelTypes.topCanPlay:
	      case topLevelTypes.topCanPlayThrough:
	      case topLevelTypes.topDurationChange:
	      case topLevelTypes.topEmptied:
	      case topLevelTypes.topEncrypted:
	      case topLevelTypes.topEnded:
	      case topLevelTypes.topError:
	      case topLevelTypes.topInput:
	      case topLevelTypes.topLoad:
	      case topLevelTypes.topLoadedData:
	      case topLevelTypes.topLoadedMetadata:
	      case topLevelTypes.topLoadStart:
	      case topLevelTypes.topPause:
	      case topLevelTypes.topPlay:
	      case topLevelTypes.topPlaying:
	      case topLevelTypes.topProgress:
	      case topLevelTypes.topRateChange:
	      case topLevelTypes.topReset:
	      case topLevelTypes.topSeeked:
	      case topLevelTypes.topSeeking:
	      case topLevelTypes.topStalled:
	      case topLevelTypes.topSubmit:
	      case topLevelTypes.topSuspend:
	      case topLevelTypes.topTimeUpdate:
	      case topLevelTypes.topVolumeChange:
	      case topLevelTypes.topWaiting:
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case topLevelTypes.topKeyPress:
	        // FireFox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case topLevelTypes.topBlur:
	      case topLevelTypes.topFocus:
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case topLevelTypes.topClick:
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topDoubleClick:
	      case topLevelTypes.topMouseDown:
	      case topLevelTypes.topMouseMove:
	      case topLevelTypes.topMouseOut:
	      case topLevelTypes.topMouseOver:
	      case topLevelTypes.topMouseUp:
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case topLevelTypes.topDrag:
	      case topLevelTypes.topDragEnd:
	      case topLevelTypes.topDragEnter:
	      case topLevelTypes.topDragExit:
	      case topLevelTypes.topDragLeave:
	      case topLevelTypes.topDragOver:
	      case topLevelTypes.topDragStart:
	      case topLevelTypes.topDrop:
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case topLevelTypes.topTouchCancel:
	      case topLevelTypes.topTouchEnd:
	      case topLevelTypes.topTouchMove:
	      case topLevelTypes.topTouchStart:
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case topLevelTypes.topScroll:
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case topLevelTypes.topWheel:
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case topLevelTypes.topCopy:
	      case topLevelTypes.topCut:
	      case topLevelTypes.topPaste:
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ?  false ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
	    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function (id, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    if (registrationName === ON_CLICK_KEY) {
	      var node = ReactMount.getNode(id);
	      if (!onClickListeners[id]) {
	        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function (id, registrationName) {
	    if (registrationName === ON_CLICK_KEY) {
	      onClickListeners[id].remove();
	      delete onClickListeners[id];
	    }
	  }
	
	};
	
	module.exports = SimpleEventPlugin;

/***/ },
/* 462 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticClipboardEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(34);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function (event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ },
/* 463 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticCompositionEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(34);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ },
/* 464 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticDragEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(63);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ },
/* 465 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticFocusEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(46);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ },
/* 466 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticInputEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(34);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ },
/* 467 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticKeyboardEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(46);
	
	var getEventCharCode = __webpack_require__(114);
	var getEventKey = __webpack_require__(473);
	var getEventModifierState = __webpack_require__(115);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function (event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function (event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function (event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTouchEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(46);
	
	var getEventModifierState = __webpack_require__(115);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ },
/* 469 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticWheelEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(63);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function (event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function (event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ },
/* 470 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule adler32
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    for (; i < Math.min(i + 4096, m); i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ },
/* 471 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule dangerousStyleValue
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(249);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;

/***/ },
/* 472 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule deprecated
	 */
	
	'use strict';
	
	var assign = __webpack_require__(7);
	var warning = __webpack_require__(8);
	
	/**
	 * This will log a single deprecation notice per function and forward the call
	 * on to the new API.
	 *
	 * @param {string} fnName The name of the function
	 * @param {string} newModule The module that fn will exist in
	 * @param {string} newPackage The module that fn will exist in
	 * @param {*} ctx The context this forwarded call should run in
	 * @param {function} fn The function to forward on to
	 * @return {function} The function that will warn once and then call fn
	 */
	function deprecated(fnName, newModule, newPackage, ctx, fn) {
	  var warned = false;
	  if (false) {
	    var newFn = function () {
	      process.env.NODE_ENV !== 'production' ? warning(warned,
	      // Require examples in this string must be split to prevent React's
	      // build tools from mistaking them for real requires.
	      // Otherwise the build tools will attempt to build a '%s' module.
	      'React.%s is deprecated. Please use %s.%s from require' + '(\'%s\') ' + 'instead.', fnName, newModule, fnName, newPackage) : undefined;
	      warned = true;
	      return fn.apply(ctx, arguments);
	    };
	    // We need to make sure all properties of the original fn are copied over.
	    // In particular, this is needed to support PropTypes
	    return assign(newFn, fn);
	  }
	
	  return fn;
	}
	
	module.exports = deprecated;

/***/ },
/* 473 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventKey
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(114);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ },
/* 474 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getNodeForCharacterOffset
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ },
/* 475 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule onlyChild
	 */
	'use strict';
	
	var ReactElement = __webpack_require__(11);
	
	var invariant = __webpack_require__(4);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection. The current implementation of this
	 * function assumes that a single child gets passed without a wrapper, but the
	 * purpose of this helper function is to abstract away the particular structure
	 * of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactComponent} The first and only `ReactComponent` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ?  false ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
	  return children;
	}
	
	module.exports = onlyChild;

/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule quoteAttributeValueForBrowser
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(66);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 477 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule renderSubtreeIntoContainer
	*/
	
	'use strict';
	
	var ReactMount = __webpack_require__(14);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule shallowCompare
	*/
	
	'use strict';
	
	var shallowEqual = __webpack_require__(122);
	
	/**
	 * Does a shallow comparison for props and state.
	 * See ReactComponentWithPureRenderMixin
	 */
	function shallowCompare(instance, nextProps, nextState) {
	  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
	}
	
	module.exports = shallowCompare;

/***/ },
/* 479 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelize
	 * @typechecks
	 */
	
	"use strict";
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 480 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelizeStyleName
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(479);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 481 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createArrayFromMixed
	 * @typechecks
	 */
	
	'use strict';
	
	var toArray = __webpack_require__(490);
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return(
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    typeof obj == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;

/***/ },
/* 482 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createNodesFromMarkup
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(12);
	
	var createArrayFromMixed = __webpack_require__(481);
	var getMarkupWrap = __webpack_require__(281);
	var invariant = __webpack_require__(4);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ?  false ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ?  false ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = createArrayFromMixed(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;

/***/ },
/* 483 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getUnboundedScrollPosition
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ },
/* 484 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenate
	 * @typechecks
	 */
	
	'use strict';
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 485 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenateStyleName
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(484);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 486 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isNode
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	'use strict';
	
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 487 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextNode
	 * @typechecks
	 */
	
	'use strict';
	
	var isNode = __webpack_require__(486);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 488 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule mapObject
	 */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Executes the provided `callback` once for each enumerable own property in the
	 * object and constructs a new object from the results. The `callback` is
	 * invoked with three arguments:
	 *
	 *  - the property value
	 *  - the property name
	 *  - the object being traversed
	 *
	 * Properties that are added after the call to `mapObject` will not be visited
	 * by `callback`. If the values of existing properties are changed, the value
	 * passed to `callback` will be the value at the time `mapObject` visits them.
	 * Properties that are deleted before being visited are not visited.
	 *
	 * @grep function objectMap()
	 * @grep function objMap()
	 *
	 * @param {?object} object
	 * @param {function} callback
	 * @param {*} context
	 * @return {?object}
	 */
	function mapObject(object, callback, context) {
	  if (!object) {
	    return null;
	  }
	  var result = {};
	  for (var name in object) {
	    if (hasOwnProperty.call(object, name)) {
	      result[name] = callback.call(context, object[name], name, object);
	    }
	  }
	  return result;
	}
	
	module.exports = mapObject;

/***/ },
/* 489 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule memoizeStringOnly
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 *
	 * @param {function} callback
	 * @return {function}
	 */
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 490 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule toArray
	 * @typechecks
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(4);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
	  // old versions of Safari).
	  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ?  false ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;
	
	  !(typeof length === 'number') ?  false ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;
	
	  !(length === 0 || length - 1 in obj) ?  false ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	module.exports = toArray;

/***/ },
/* 491 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 492 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ }
/******/ ]);